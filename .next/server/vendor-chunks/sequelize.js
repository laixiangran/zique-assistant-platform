/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sequelize";
exports.ids = ["vendor-chunks/sequelize"];
exports.modules = {

/***/ "(rsc)/./node_modules/sequelize/lib/associations/base.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { AssociationError } = __webpack_require__(/*! ./../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nclass Association {\n  constructor(source, target, options = {}) {\n    this.source = source;\n    this.target = target;\n    this.options = options;\n    this.scope = options.scope;\n    this.isSelfAssociation = this.source === this.target;\n    this.as = options.as;\n    this.associationType = \"\";\n    if (source.hasAlias(options.as)) {\n      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. Aliased associations must have unique aliases.`);\n    }\n  }\n  toInstanceArray(input) {\n    if (!Array.isArray(input)) {\n      input = [input];\n    }\n    return input.map((element) => {\n      if (element instanceof this.target)\n        return element;\n      const tmpInstance = {};\n      tmpInstance[this.target.primaryKeyAttribute] = element;\n      return this.target.build(tmpInstance, { isNewRecord: false });\n    });\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.as;\n  }\n}\nmodule.exports = Association;\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyx1RUFBYTtBQUNsRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2Jhc2UuanM/NjM0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgQXNzb2NpYXRpb25FcnJvciB9ID0gcmVxdWlyZShcIi4vLi4vZXJyb3JzXCIpO1xuY2xhc3MgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNjb3BlID0gb3B0aW9ucy5zY29wZTtcbiAgICB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID0gdGhpcy5zb3VyY2UgPT09IHRoaXMudGFyZ2V0O1xuICAgIHRoaXMuYXMgPSBvcHRpb25zLmFzO1xuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gXCJcIjtcbiAgICBpZiAoc291cmNlLmhhc0FsaWFzKG9wdGlvbnMuYXMpKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcihgWW91IGhhdmUgdXNlZCB0aGUgYWxpYXMgJHtvcHRpb25zLmFzfSBpbiB0d28gc2VwYXJhdGUgYXNzb2NpYXRpb25zLiBBbGlhc2VkIGFzc29jaWF0aW9ucyBtdXN0IGhhdmUgdW5pcXVlIGFsaWFzZXMuYCk7XG4gICAgfVxuICB9XG4gIHRvSW5zdGFuY2VBcnJheShpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIGlucHV0ID0gW2lucHV0XTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0Lm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiB0aGlzLnRhcmdldClcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0bXBJbnN0YW5jZSA9IHt9O1xuICAgICAgdG1wSW5zdGFuY2VbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBlbGVtZW50O1xuICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0LmJ1aWxkKHRtcEluc3RhbmNlLCB7IGlzTmV3UmVjb3JkOiBmYWxzZSB9KTtcbiAgICB9KTtcbiAgfVxuICBbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcztcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst AssociationError = (__webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\").AssociationError);\nconst EmptyResultError = (__webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\").EmptyResultError);\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n    this.associationType = \"BelongsToMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = __spreadValues({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError(\"'as' must be defined for many-to-many self-associations\");\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    _.each(this.target.associations, (association) => {\n      if (association.associationType !== \"BelongsToMany\")\n        return;\n      if (association.target !== this.source)\n        return;\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n    this._createForeignAndOtherKeys();\n    if (typeof this.through.model === \"string\") {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          paranoid: this.through.paranoid ? this.through.paranoid : false,\n          validate: {}\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      \"timestamps\",\n      \"createdAt\",\n      \"updatedAt\",\n      \"deletedAt\",\n      \"paranoid\"\n    ]));\n    if (this.paired) {\n      let needInjectPaired = false;\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as;\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _createForeignAndOtherKeys() {\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([\n        this.source.options.name.singular,\n        this.sourceKey\n      ].join(\"_\"));\n    }\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([\n        this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n        this.targetKey\n      ].join(\"_\"));\n    }\n  }\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = __spreadValues({ type: sourceKeyType }, this.foreignKeyAttribute);\n    const targetAttribute = __spreadValues({ type: targetKeyType }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === \"string\" && this.options.uniqueKey !== \"\") {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\");\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete)\n        sourceAttribute.onDelete = \"CASCADE\";\n      if (!sourceAttribute.onUpdate)\n        sourceAttribute.onUpdate = \"CASCADE\";\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete)\n        targetAttribute.onDelete = \"CASCADE\";\n      if (!targetAttribute.onUpdate)\n        targetAttribute.onUpdate = \"CASCADE\";\n    }\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n    if (this.options.sequelize.options.dialect === \"db2\" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n    if (this.scope) {\n      scopeWhere = __spreadValues({}, this.scope);\n    }\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, \"paranoid\", true),\n        where: throughWhere\n      });\n    }\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n    return model.findAll(options);\n  }\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn(\"COUNT\", sequelize.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n    options = __spreadProps(__spreadValues({\n      raw: true\n    }, options), {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey)\n    }, this.through.scope);\n    const updateAssociations = (currentRows) => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter((obj) => !currentRows.some((currentRow) => currentRow[foreignIdentifier] === obj.get(targetKey)));\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find((obj) => currentRow[foreignIdentifier] === obj.get(targetKey));\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n      if (obsoleteAssociations.length > 0) {\n        promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n          where: __spreadValues({\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: obsoleteAssociations.map((obsoleteAssociation) => obsoleteAssociation[foreignIdentifier])\n          }, this.through.scope)\n        })));\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey)\n          }), this.through.scope);\n        });\n        promises.push(this.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations([]);\n      throw error;\n    }\n  }\n  async add(sourceInstance, newInstances, options) {\n    if (!newInstances)\n      return Promise.resolve();\n    options = __spreadValues({}, options);\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map((newInstance) => newInstance.get(targetKey))\n    }, association.through.scope);\n    const updateAssociations = (currentRows) => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find((current) => current[foreignIdentifier] === obj.get(targetKey));\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).some((attribute) => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations();\n      throw error;\n    }\n  }\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map((newInstance) => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(__spreadProps(__spreadValues({}, options), { where }));\n  }\n  async create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n    const newAssociatedObject = await association.target.create(values, options);\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [\"fields\"]));\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports[\"default\"] = BelongsToMany;\n//# sourceMappingURL=belongs-to-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrREFBWTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsb0JBQW9CLG1CQUFPLENBQUMsdUVBQVE7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWM7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2xDLHlCQUF5Qiw2R0FBcUM7QUFDOUQseUJBQXlCLDZHQUFxQztBQUM5RCxXQUFXLG1CQUFPLENBQUMscUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxpQkFBaUIsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGNBQWMsa0JBQWtCO0FBQzFIO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtGQUFrRixnQkFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsa0JBQWtCO0FBQ2pJO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYyxPQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnkuanM/ZjM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi8uLi91dGlsc1wiKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvXCIpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoXCIuL2hhcy1tYW55XCIpO1xuY29uc3QgSGFzT25lID0gcmVxdWlyZShcIi4vaGFzLW9uZVwiKTtcbmNvbnN0IEFzc29jaWF0aW9uRXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpLkFzc29jaWF0aW9uRXJyb3I7XG5jb25zdCBFbXB0eVJlc3VsdEVycm9yID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKS5FbXB0eVJlc3VsdEVycm9yO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3JzXCIpO1xuY2xhc3MgQmVsb25nc1RvTWFueSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoID09PSB2b2lkIDAgfHwgdGhpcy5vcHRpb25zLnRocm91Z2ggPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnRocm91Z2ggPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKGAke3NvdXJjZS5uYW1lfS5iZWxvbmdzVG9NYW55KCR7dGFyZ2V0Lm5hbWV9KSByZXF1aXJlcyB0aHJvdWdoIG9wdGlvbiwgcGFzcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSBtb2RlbGApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMudGhyb3VnaCA9IHtcbiAgICAgICAgbW9kZWw6IG9wdGlvbnMudGhyb3VnaFxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSBcIkJlbG9uZ3NUb01hbnlcIjtcbiAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNvdXJjZS5zZXF1ZWxpemU7XG4gICAgdGhpcy50aHJvdWdoID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucy50aHJvdWdoKTtcbiAgICB0aGlzLmlzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5kb3VibGVMaW5rZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuYXMgJiYgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoXCInYXMnIG11c3QgYmUgZGVmaW5lZCBmb3IgbWFueS10by1tYW55IHNlbGYtYXNzb2NpYXRpb25zXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLmFzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMuYXM7XG4gICAgICAgIHRoaXMuYXMgPSB0aGlzLmFzLnBsdXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICAgIHBsdXJhbDogdGhpcy5hcyxcbiAgICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5wbHVyYWw7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG4gICAgdGhpcy5jb21iaW5lZFRhYmxlTmFtZSA9IFV0aWxzLmNvbWJpbmVUYWJsZU5hbWVzKHRoaXMuc291cmNlLnRhYmxlTmFtZSwgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA/IHRoaXMuYXMgfHwgdGhpcy50YXJnZXQudGFibGVOYW1lIDogdGhpcy50YXJnZXQudGFibGVOYW1lKTtcbiAgICBpZiAodGhpcy5pc1NlbGZBc3NvY2lhdGlvbikge1xuICAgICAgdGhpcy50YXJnZXRBc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgfVxuICAgIF8uZWFjaCh0aGlzLnRhcmdldC5hc3NvY2lhdGlvbnMsIChhc3NvY2lhdGlvbikgPT4ge1xuICAgICAgaWYgKGFzc29jaWF0aW9uLmFzc29jaWF0aW9uVHlwZSAhPT0gXCJCZWxvbmdzVG9NYW55XCIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi50YXJnZXQgIT09IHRoaXMuc291cmNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2gubW9kZWwgPT09IGFzc29jaWF0aW9uLm9wdGlvbnMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgICB0aGlzLnBhaXJlZCA9IGFzc29jaWF0aW9uO1xuICAgICAgICBhc3NvY2lhdGlvbi5wYWlyZWQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEtleSkge1xuICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLm9wdGlvbnMudGFyZ2V0S2V5O1xuICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhcmdldEtleURlZmF1bHQgPSB0cnVlO1xuICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIH1cbiAgICB0aGlzLl9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnRocm91Z2gubW9kZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuaXNEZWZpbmVkKHRoaXMudGhyb3VnaC5tb2RlbCkpIHtcbiAgICAgICAgdGhpcy50aHJvdWdoLm1vZGVsID0gdGhpcy5zZXF1ZWxpemUuZGVmaW5lKHRoaXMudGhyb3VnaC5tb2RlbCwge30sIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCB7XG4gICAgICAgICAgdGFibGVOYW1lOiB0aGlzLnRocm91Z2gubW9kZWwsXG4gICAgICAgICAgaW5kZXhlczogW10sXG4gICAgICAgICAgcGFyYW5vaWQ6IHRoaXMudGhyb3VnaC5wYXJhbm9pZCA/IHRoaXMudGhyb3VnaC5wYXJhbm9pZCA6IGZhbHNlLFxuICAgICAgICAgIHZhbGlkYXRlOiB7fVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwgPSB0aGlzLnNlcXVlbGl6ZS5tb2RlbCh0aGlzLnRocm91Z2gubW9kZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgXy5waWNrKHRoaXMudGhyb3VnaC5tb2RlbC5vcHRpb25zLCBbXG4gICAgICBcInRpbWVzdGFtcHNcIixcbiAgICAgIFwiY3JlYXRlZEF0XCIsXG4gICAgICBcInVwZGF0ZWRBdFwiLFxuICAgICAgXCJkZWxldGVkQXRcIixcbiAgICAgIFwicGFyYW5vaWRcIlxuICAgIF0pKTtcbiAgICBpZiAodGhpcy5wYWlyZWQpIHtcbiAgICAgIGxldCBuZWVkSW5qZWN0UGFpcmVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy50YXJnZXRLZXlEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5wYWlyZWQuc291cmNlS2V5O1xuICAgICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy5wYWlyZWQuc291cmNlS2V5RmllbGQ7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBhaXJlZC50YXJnZXRLZXlEZWZhdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnBhaXJlZC50YXJnZXRLZXkgIT09IHRoaXMuc291cmNlS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC50YXJnZXRLZXkgPSB0aGlzLnNvdXJjZUtleTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC50YXJnZXRLZXlGaWVsZCA9IHRoaXMuc291cmNlS2V5RmllbGQ7XG4gICAgICAgICAgdGhpcy5wYWlyZWQuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcbiAgICAgICAgICBuZWVkSW5qZWN0UGFpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMub3RoZXJLZXkgPSB0aGlzLnBhaXJlZC5mb3JlaWduS2V5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpcmVkLm90aGVyS2V5RGVmYXVsdCkge1xuICAgICAgICBpZiAodGhpcy5wYWlyZWQub3RoZXJLZXkgIT09IHRoaXMuZm9yZWlnbktleSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLnBhaXJlZC5vdGhlcktleV07XG4gICAgICAgICAgdGhpcy5wYWlyZWQub3RoZXJLZXkgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgICAgICAgbmVlZEluamVjdFBhaXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZWVkSW5qZWN0UGFpcmVkKSB7XG4gICAgICAgIHRoaXMucGFpcmVkLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnRocm91Z2gpIHtcbiAgICAgIHRoaXMudGhyb3VnaE1vZGVsID0gdGhpcy50aHJvdWdoLm1vZGVsO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMudGFibGVOYW1lID0gdGhpcy5jb21iaW5lZE5hbWUgPSB0aGlzLnRocm91Z2gubW9kZWwgPT09IE9iamVjdCh0aGlzLnRocm91Z2gubW9kZWwpID8gdGhpcy50aHJvdWdoLm1vZGVsLnRhYmxlTmFtZSA6IHRoaXMudGhyb3VnaC5tb2RlbDtcbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIGNvbnN0IHBsdXJhbCA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5wbHVyYWwpO1xuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7cGx1cmFsfWAsXG4gICAgICBzZXQ6IGBzZXQke3BsdXJhbH1gLFxuICAgICAgYWRkTXVsdGlwbGU6IGBhZGQke3BsdXJhbH1gLFxuICAgICAgYWRkOiBgYWRkJHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlOiBgcmVtb3ZlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IGByZW1vdmUke3BsdXJhbH1gLFxuICAgICAgaGFzU2luZ2xlOiBgaGFzJHtzaW5ndWxhcn1gLFxuICAgICAgaGFzQWxsOiBgaGFzJHtwbHVyYWx9YCxcbiAgICAgIGNvdW50OiBgY291bnQke3BsdXJhbH1gXG4gICAgfTtcbiAgfVxuICBfY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpIHtcbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLm5hbWUgfHwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleSB8fCBVdGlscy5jYW1lbGl6ZShbXG4gICAgICAgIHRoaXMuc291cmNlLm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgdGhpcy5zb3VyY2VLZXlcbiAgICAgIF0uam9pbihcIl9cIikpO1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdCh0aGlzLm9wdGlvbnMub3RoZXJLZXkpKSB7XG4gICAgICB0aGlzLm90aGVyS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLm90aGVyS2V5O1xuICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLm90aGVyS2V5QXR0cmlidXRlLmZpZWxkTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3RoZXJLZXkpIHtcbiAgICAgICAgdGhpcy5vdGhlcktleURlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5vdGhlcktleUF0dHJpYnV0ZSA9IHt9O1xuICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMub3B0aW9ucy5vdGhlcktleSB8fCBVdGlscy5jYW1lbGl6ZShbXG4gICAgICAgIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPyBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKSA6IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgdGhpcy50YXJnZXRLZXlcbiAgICAgIF0uam9pbihcIl9cIikpO1xuICAgIH1cbiAgfVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduSWRlbnRpZmllciA9IHRoaXMub3RoZXJLZXk7XG4gICAgXy5lYWNoKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkgPT09IHRydWUgJiYgYXR0cmlidXRlLl9hdXRvR2VuZXJhdGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChbdGhpcy5mb3JlaWduS2V5LCB0aGlzLm90aGVyS2V5XS5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJpbWFyeUtleURlbGV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldO1xuICAgIGNvbnN0IHNvdXJjZUtleVR5cGUgPSBzb3VyY2VLZXkudHlwZTtcbiAgICBjb25zdCBzb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlS2V5RmllbGQ7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV07XG4gICAgY29uc3QgdGFyZ2V0S2V5VHlwZSA9IHRhcmdldEtleS50eXBlO1xuICAgIGNvbnN0IHRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXRLZXlGaWVsZDtcbiAgICBjb25zdCBzb3VyY2VBdHRyaWJ1dGUgPSBfX3NwcmVhZFZhbHVlcyh7IHR5cGU6IHNvdXJjZUtleVR5cGUgfSwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlKTtcbiAgICBjb25zdCB0YXJnZXRBdHRyaWJ1dGUgPSBfX3NwcmVhZFZhbHVlcyh7IHR5cGU6IHRhcmdldEtleVR5cGUgfSwgdGhpcy5vdGhlcktleUF0dHJpYnV0ZSk7XG4gICAgaWYgKHRoaXMucHJpbWFyeUtleURlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5wcmltYXJ5S2V5ID0gc291cmNlQXR0cmlidXRlLnByaW1hcnlLZXkgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy50aHJvdWdoLnVuaXF1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGxldCB1bmlxdWVLZXk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51bmlxdWVLZXkgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5vcHRpb25zLnVuaXF1ZUtleSAhPT0gXCJcIikge1xuICAgICAgICB1bmlxdWVLZXkgPSB0aGlzLm9wdGlvbnMudW5pcXVlS2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gW3RoaXMudGhyb3VnaC5tb2RlbC50YWJsZU5hbWUsIHRoaXMuZm9yZWlnbktleSwgdGhpcy5vdGhlcktleSwgXCJ1bmlxdWVcIl0uam9pbihcIl9cIik7XG4gICAgICB9XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUudW5pcXVlID0gc291cmNlQXR0cmlidXRlLnVuaXF1ZSA9IHVuaXF1ZUtleTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSkge1xuICAgICAgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0gPSB7XG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgc291cmNlQXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLnNvdXJjZS5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiBzb3VyY2VLZXlGaWVsZFxuICAgICAgfTtcbiAgICAgIHNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSA9IHRoaXMub3B0aW9ucy5vbkRlbGV0ZSB8fCB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLm9uRGVsZXRlO1xuICAgICAgc291cmNlQXR0cmlidXRlLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0ub25VcGRhdGU7XG4gICAgICBpZiAoIXNvdXJjZUF0dHJpYnV0ZS5vbkRlbGV0ZSlcbiAgICAgICAgc291cmNlQXR0cmlidXRlLm9uRGVsZXRlID0gXCJDQVNDQURFXCI7XG4gICAgICBpZiAoIXNvdXJjZUF0dHJpYnV0ZS5vblVwZGF0ZSlcbiAgICAgICAgc291cmNlQXR0cmlidXRlLm9uVXBkYXRlID0gXCJDQVNDQURFXCI7XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMudGFyZ2V0LmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IHRhcmdldEtleUZpZWxkXG4gICAgICB9O1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0ub25EZWxldGUgfHwgdGhpcy5vcHRpb25zLm9uRGVsZXRlO1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0ub25VcGRhdGUgfHwgdGhpcy5vcHRpb25zLm9uVXBkYXRlO1xuICAgICAgaWYgKCF0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUpXG4gICAgICAgIHRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiQ0FTQ0FERVwiO1xuICAgICAgaWYgKCF0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUpXG4gICAgICAgIHRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiQ0FTQ0FERVwiO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHNvdXJjZUF0dHJpYnV0ZSk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSwgdGFyZ2V0QXR0cmlidXRlKTtcbiAgICB0aGlzLnRocm91Z2gubW9kZWwucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbklkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLmZpZWxkIHx8IHRoaXMub3RoZXJLZXk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSBcImRiMlwiICYmIHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLnByaW1hcnlLZXkgIT09IHRydWUpIHtcbiAgICAgIHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLnVuaXF1ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhaXJlZCAmJiAhdGhpcy5wYWlyZWQuZm9yZWlnbklkZW50aWZpZXJGaWVsZCkge1xuICAgICAgdGhpcy5wYWlyZWQuZm9yZWlnbklkZW50aWZpZXJGaWVsZCA9IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XS5maWVsZCB8fCB0aGlzLnBhaXJlZC5vdGhlcktleTtcbiAgICB9XG4gICAgdGhpcy50b1NvdXJjZSA9IG5ldyBCZWxvbmdzVG8odGhpcy50aHJvdWdoLm1vZGVsLCB0aGlzLnNvdXJjZSwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5XG4gICAgfSk7XG4gICAgdGhpcy5tYW55RnJvbVNvdXJjZSA9IG5ldyBIYXNNYW55KHRoaXMuc291cmNlLCB0aGlzLnRocm91Z2gubW9kZWwsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMuZm9yZWlnbktleVxuICAgIH0pO1xuICAgIHRoaXMub25lRnJvbVNvdXJjZSA9IG5ldyBIYXNPbmUodGhpcy5zb3VyY2UsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5LFxuICAgICAgc291cmNlS2V5OiB0aGlzLnNvdXJjZUtleSxcbiAgICAgIGFzOiB0aGlzLnRocm91Z2gubW9kZWwubmFtZVxuICAgIH0pO1xuICAgIHRoaXMudG9UYXJnZXQgPSBuZXcgQmVsb25nc1RvKHRoaXMudGhyb3VnaC5tb2RlbCwgdGhpcy50YXJnZXQsIHtcbiAgICAgIGZvcmVpZ25LZXk6IHRoaXMub3RoZXJLZXlcbiAgICB9KTtcbiAgICB0aGlzLm1hbnlGcm9tVGFyZ2V0ID0gbmV3IEhhc01hbnkodGhpcy50YXJnZXQsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleVxuICAgIH0pO1xuICAgIHRoaXMub25lRnJvbVRhcmdldCA9IG5ldyBIYXNPbmUodGhpcy50YXJnZXQsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleSxcbiAgICAgIHNvdXJjZUtleTogdGhpcy50YXJnZXRLZXksXG4gICAgICBhczogdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy5wYWlyZWQgJiYgdGhpcy5wYWlyZWQub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICB0aGlzLnBhaXJlZC50b1RhcmdldCA9IG5ldyBCZWxvbmdzVG8odGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbCwgdGhpcy5wYWlyZWQudGFyZ2V0LCB7XG4gICAgICAgIGZvcmVpZ25LZXk6IHRoaXMucGFpcmVkLm90aGVyS2V5XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFpcmVkLm9uZUZyb21UYXJnZXQgPSBuZXcgSGFzT25lKHRoaXMucGFpcmVkLnRhcmdldCwgdGhpcy5wYWlyZWQudGhyb3VnaC5tb2RlbCwge1xuICAgICAgICBmb3JlaWduS2V5OiB0aGlzLnBhaXJlZC5vdGhlcktleSxcbiAgICAgICAgc291cmNlS2V5OiB0aGlzLnBhaXJlZC50YXJnZXRLZXksXG4gICAgICAgIGFzOiB0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLm5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbXCJnZXRcIiwgXCJjb3VudFwiLCBcImhhc1NpbmdsZVwiLCBcImhhc0FsbFwiLCBcInNldFwiLCBcImFkZFwiLCBcImFkZE11bHRpcGxlXCIsIFwicmVtb3ZlXCIsIFwicmVtb3ZlTXVsdGlwbGVcIiwgXCJjcmVhdGVcIl07XG4gICAgY29uc3QgYWxpYXNlcyA9IHtcbiAgICAgIGhhc1NpbmdsZTogXCJoYXNcIixcbiAgICAgIGhhc0FsbDogXCJoYXNcIixcbiAgICAgIGFkZE11bHRpcGxlOiBcImFkZFwiLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IFwicmVtb3ZlXCJcbiAgICB9O1xuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcywgYWxpYXNlcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcbiAgICBjb25zdCB0aHJvdWdoID0gdGhpcy50aHJvdWdoO1xuICAgIGxldCBzY29wZVdoZXJlO1xuICAgIGxldCB0aHJvdWdoV2hlcmU7XG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIHNjb3BlV2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5zY29wZSk7XG4gICAgfVxuICAgIG9wdGlvbnMud2hlcmUgPSB7XG4gICAgICBbT3AuYW5kXTogW1xuICAgICAgICBzY29wZVdoZXJlLFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcbiAgICBpZiAoT2JqZWN0KHRocm91Z2gubW9kZWwpID09PSB0aHJvdWdoLm1vZGVsKSB7XG4gICAgICB0aHJvdWdoV2hlcmUgPSB7fTtcbiAgICAgIHRocm91Z2hXaGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICAgIGlmICh0aHJvdWdoLnNjb3BlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhyb3VnaFdoZXJlLCB0aHJvdWdoLnNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRocm91Z2ggJiYgb3B0aW9ucy50aHJvdWdoLndoZXJlKSB7XG4gICAgICAgIHRocm91Z2hXaGVyZSA9IHtcbiAgICAgICAgICBbT3AuYW5kXTogW3Rocm91Z2hXaGVyZSwgb3B0aW9ucy50aHJvdWdoLndoZXJlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlIHx8IFtdO1xuICAgICAgb3B0aW9ucy5pbmNsdWRlLnB1c2goe1xuICAgICAgICBhc3NvY2lhdGlvbjogdGhpcy5vbmVGcm9tVGFyZ2V0LFxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zLmpvaW5UYWJsZUF0dHJpYnV0ZXMsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBwYXJhbm9pZDogXy5nZXQob3B0aW9ucy50aHJvdWdoLCBcInBhcmFub2lkXCIsIHRydWUpLFxuICAgICAgICB3aGVyZTogdGhyb3VnaFdoZXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG1vZGVsID0gdGhpcy50YXJnZXQ7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjb3BlXCIpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwgPSBtb2RlbC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjaGVtYVwiKSkge1xuICAgICAgbW9kZWwgPSBtb2RlbC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmZpbmRBbGwob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgY291bnQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXF1ZWxpemUgPSB0aGlzLnRhcmdldC5zZXF1ZWxpemU7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbXG4gICAgICBbc2VxdWVsaXplLmZuKFwiQ09VTlRcIiwgc2VxdWVsaXplLmNvbChbdGhpcy50YXJnZXQubmFtZSwgdGhpcy50YXJnZXRLZXlGaWVsZF0uam9pbihcIi5cIikpKSwgXCJjb3VudFwiXVxuICAgIF07XG4gICAgb3B0aW9ucy5qb2luVGFibGVBdHRyaWJ1dGVzID0gW107XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIG9wdGlvbnMucGxhaW4gPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZ2V0KGluc3RhbmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LmNvdW50LCAxMCk7XG4gIH1cbiAgYXN5bmMgaGFzKHNvdXJjZUluc3RhbmNlLCBpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHJhdzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpLCB7XG4gICAgICBzY29wZTogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVzOiBbdGhpcy50YXJnZXRLZXldLFxuICAgICAgam9pblRhYmxlQXR0cmlidXRlczogW11cbiAgICB9KTtcbiAgICBjb25zdCBpbnN0YW5jZVByaW1hcnlLZXlzID0gaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS53aGVyZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3RoaXMudGFyZ2V0S2V5XTogaW5zdGFuY2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHsgW09wLm9yXTogaW5zdGFuY2VQcmltYXJ5S2V5cyB9LFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcbiAgICBjb25zdCBhc3NvY2lhdGVkT2JqZWN0cyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlV2l0aChpbnN0YW5jZVByaW1hcnlLZXlzLCBhc3NvY2lhdGVkT2JqZWN0cywgKGEsIGIpID0+IF8uaXNFcXVhbChhW3RoaXMudGFyZ2V0S2V5XSwgYlt0aGlzLnRhcmdldEtleV0pKS5sZW5ndGggPT09IDA7XG4gIH1cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBuZXdBc3NvY2lhdGVkT2JqZWN0cywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IHRoaXMuc291cmNlS2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudGFyZ2V0S2V5O1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmlkZW50aWZpZXI7XG4gICAgY29uc3QgZm9yZWlnbklkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25JZGVudGlmaWVyO1xuICAgIGlmIChuZXdBc3NvY2lhdGVkT2JqZWN0cyA9PT0gbnVsbCkge1xuICAgICAgbmV3QXNzb2NpYXRlZE9iamVjdHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXNzb2NpYXRlZE9iamVjdHMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheShuZXdBc3NvY2lhdGVkT2JqZWN0cyk7XG4gICAgfVxuICAgIGNvbnN0IHdoZXJlID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KVxuICAgIH0sIHRoaXMudGhyb3VnaC5zY29wZSk7XG4gICAgY29uc3QgdXBkYXRlQXNzb2NpYXRpb25zID0gKGN1cnJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBvYnNvbGV0ZUFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0gb3B0aW9ucy50aHJvdWdoIHx8IHt9O1xuICAgICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IG5ld0Fzc29jaWF0ZWRPYmplY3RzLmZpbHRlcigob2JqKSA9PiAhY3VycmVudFJvd3Muc29tZSgoY3VycmVudFJvdykgPT4gY3VycmVudFJvd1tmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSkpO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50Um93IG9mIGN1cnJlbnRSb3dzKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IG5ld0Fzc29jaWF0ZWRPYmplY3RzLmZpbmQoKG9iaikgPT4gY3VycmVudFJvd1tmb3JlaWduSWRlbnRpZmllcl0gPT09IG9iai5nZXQodGFyZ2V0S2V5KSk7XG4gICAgICAgIGlmICghbmV3T2JqKSB7XG4gICAgICAgICAgb2Jzb2xldGVBc3NvY2lhdGlvbnMucHVzaChjdXJyZW50Um93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgdGhyb3VnaEF0dHJpYnV0ZXMgPSBuZXdPYmpbdGhpcy50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIGlmICh0aHJvdWdoQXR0cmlidXRlcyBpbnN0YW5jZW9mIHRoaXMudGhyb3VnaC5tb2RlbCkge1xuICAgICAgICAgICAgdGhyb3VnaEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0QXR0cmlidXRlcyksIHRocm91Z2hBdHRyaWJ1dGVzKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGhyb3VnaC5tb2RlbC51cGRhdGUoYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBuZXdPYmouZ2V0KHRhcmdldEtleSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYnNvbGV0ZUFzc29jaWF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy50aHJvdWdoLm1vZGVsLmRlc3Ryb3koX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICB3aGVyZTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG9ic29sZXRlQXNzb2NpYXRpb25zLm1hcCgob2Jzb2xldGVBc3NvY2lhdGlvbikgPT4gb2Jzb2xldGVBc3NvY2lhdGlvbltmb3JlaWduSWRlbnRpZmllcl0pXG4gICAgICAgICAgfSwgdGhpcy50aHJvdWdoLnNjb3BlKVxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBidWxrID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAoKHVuYXNzb2NpYXRlZE9iamVjdCkgPT4ge1xuICAgICAgICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0QXR0cmlidXRlcyksIHVuYXNzb2NpYXRlZE9iamVjdFt0aGlzLnRocm91Z2gubW9kZWwubmFtZV0pLCB7XG4gICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0YXJnZXRLZXkpXG4gICAgICAgICAgfSksIHRoaXMudGhyb3VnaC5zY29wZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMudGhyb3VnaC5tb2RlbC5idWxrQ3JlYXRlKGJ1bGssIF9fc3ByZWFkVmFsdWVzKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0aW9ucykpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFJvd3MgPSBhd2FpdCB0aGlzLnRocm91Z2gubW9kZWwuZmluZEFsbChfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aGVyZSwgcmF3OiB0cnVlIH0pKTtcbiAgICAgIHJldHVybiBhd2FpdCB1cGRhdGVBc3NvY2lhdGlvbnMoY3VycmVudFJvd3MpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFbXB0eVJlc3VsdEVycm9yKVxuICAgICAgICByZXR1cm4gdXBkYXRlQXNzb2NpYXRpb25zKFtdKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGQoc291cmNlSW5zdGFuY2UsIG5ld0luc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGlmICghbmV3SW5zdGFuY2VzKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIGNvbnN0IHNvdXJjZUtleSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleTtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBhc3NvY2lhdGlvbi50YXJnZXRLZXk7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IGFzc29jaWF0aW9uLmlkZW50aWZpZXI7XG4gICAgY29uc3QgZm9yZWlnbklkZW50aWZpZXIgPSBhc3NvY2lhdGlvbi5mb3JlaWduSWRlbnRpZmllcjtcbiAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlcyA9IG9wdGlvbnMudGhyb3VnaCB8fCB7fTtcbiAgICBuZXdJbnN0YW5jZXMgPSBhc3NvY2lhdGlvbi50b0luc3RhbmNlQXJyYXkobmV3SW5zdGFuY2VzKTtcbiAgICBjb25zdCB3aGVyZSA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBuZXdJbnN0YW5jZXMubWFwKChuZXdJbnN0YW5jZSkgPT4gbmV3SW5zdGFuY2UuZ2V0KHRhcmdldEtleSkpXG4gICAgfSwgYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZSk7XG4gICAgY29uc3QgdXBkYXRlQXNzb2NpYXRpb25zID0gKGN1cnJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IFtdO1xuICAgICAgY29uc3QgY2hhbmdlZEFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvYmogb2YgbmV3SW5zdGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQXNzb2NpYXRpb24gPSBjdXJyZW50Um93cyAmJiBjdXJyZW50Um93cy5maW5kKChjdXJyZW50KSA9PiBjdXJyZW50W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKTtcbiAgICAgICAgaWYgKCFleGlzdGluZ0Fzc29jaWF0aW9uKSB7XG4gICAgICAgICAgdW5hc3NvY2lhdGVkT2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGhyb3VnaEF0dHJpYnV0ZXMgPSBvYmpbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgdGhyb3VnaEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5zb21lKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZXNbYXR0cmlidXRlXSAhPT0gZXhpc3RpbmdBc3NvY2lhdGlvblthdHRyaWJ1dGVdKSkge1xuICAgICAgICAgICAgY2hhbmdlZEFzc29jaWF0aW9ucy5wdXNoKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGJ1bGsgPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCgodW5hc3NvY2lhdGVkT2JqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGhyb3VnaEF0dHJpYnV0ZXMgPSB1bmFzc29jaWF0ZWRPYmplY3RbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgdGhyb3VnaEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGF0dHJpYnV0ZXNbaWRlbnRpZmllcl0gPSBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KTtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2ZvcmVpZ25JZGVudGlmaWVyXSA9IHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGFyZ2V0S2V5KTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIGFzc29jaWF0aW9uLnRocm91Z2guc2NvcGUpO1xuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmJ1bGtDcmVhdGUoYnVsaywgX19zcHJlYWRWYWx1ZXMoeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRpb25zKSkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhc3NvYyBvZiBjaGFuZ2VkQXNzb2NpYXRpb25zKSB7XG4gICAgICAgIGxldCB0aHJvdWdoQXR0cmlidXRlcyA9IGFzc29jW2Fzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMpLCB0aHJvdWdoQXR0cmlidXRlcyk7XG4gICAgICAgIGlmICh0aHJvdWdoQXR0cmlidXRlcyBpbnN0YW5jZW9mIGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwpIHtcbiAgICAgICAgICB0aHJvdWdoQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2VzLnB1c2goYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC51cGRhdGUoYXR0cmlidXRlcywgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7IHdoZXJlOiB7XG4gICAgICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiBhc3NvYy5nZXQodGFyZ2V0S2V5KVxuICAgICAgICB9IH0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3dzID0gYXdhaXQgYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5maW5kQWxsKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdoZXJlLCByYXc6IHRydWUgfSkpO1xuICAgICAgY29uc3QgW2Fzc29jaWF0aW9uc10gPSBhd2FpdCB1cGRhdGVBc3NvY2lhdGlvbnMoY3VycmVudFJvd3MpO1xuICAgICAgcmV0dXJuIGFzc29jaWF0aW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRW1wdHlSZXN1bHRFcnJvcilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFzc29jaWF0aW9ucygpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIHJlbW92ZShzb3VyY2VJbnN0YW5jZSwgb2xkQXNzb2NpYXRlZE9iamVjdHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb2xkQXNzb2NpYXRlZE9iamVjdHMgPSBhc3NvY2lhdGlvbi50b0luc3RhbmNlQXJyYXkob2xkQXNzb2NpYXRlZE9iamVjdHMpO1xuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW2Fzc29jaWF0aW9uLmlkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24uc291cmNlS2V5KSxcbiAgICAgIFthc3NvY2lhdGlvbi5mb3JlaWduSWRlbnRpZmllcl06IG9sZEFzc29jaWF0ZWRPYmplY3RzLm1hcCgobmV3SW5zdGFuY2UpID0+IG5ld0luc3RhbmNlLmdldChhc3NvY2lhdGlvbi50YXJnZXRLZXkpKVxuICAgIH07XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuZGVzdHJveShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aGVyZSB9KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBmaWVsZHM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChhc3NvY2lhdGlvbi5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIGFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzLmNvbmNhdChPYmplY3Qua2V5cyhhc3NvY2lhdGlvbi5zY29wZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdBc3NvY2lhdGVkT2JqZWN0ID0gYXdhaXQgYXNzb2NpYXRpb24udGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHNvdXJjZUluc3RhbmNlW2Fzc29jaWF0aW9uLmFjY2Vzc29ycy5hZGRdKG5ld0Fzc29jaWF0ZWRPYmplY3QsIF8ub21pdChvcHRpb25zLCBbXCJmaWVsZHNcIl0pKTtcbiAgICByZXR1cm4gbmV3QXNzb2NpYXRlZE9iamVjdDtcbiAgfVxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMucGx1cmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMucGx1cmFsO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJlbG9uZ3NUb01hbnk7XG5tb2R1bGUuZXhwb3J0cy5CZWxvbmdzVG9NYW55ID0gQmVsb25nc1RvTWFueTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBCZWxvbmdzVG9NYW55O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmVsb25ncy10by1tYW55LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"BelongsTo\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.as,\n        this.target.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? \"SET NULL\" : \"NO ACTION\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false)\n      return;\n    options = __spreadValues({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n    return await sourceInstance.save(options);\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports[\"default\"] = BelongsTo;\n//# sourceMappingURL=belongs-to.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsK0RBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxxRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUIseURBQXlELGlCQUFpQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8uanM/ZDBiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vLi4vdXRpbHNcIik7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3JzXCIpO1xuY2xhc3MgQmVsb25nc1RvIGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9IFwiQmVsb25nc1RvXCI7XG4gICAgdGhpcy5pc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgIHNpbmd1bGFyOiB0aGlzLmFzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoW1xuICAgICAgICB0aGlzLmFzLFxuICAgICAgICB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXG4gICAgICBdLmpvaW4oXCJfXCIpKTtcbiAgICB9XG4gICAgdGhpcy5pZGVudGlmaWVyID0gdGhpcy5mb3JlaWduS2V5O1xuICAgIGlmICh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuaWRlbnRpZmllcl0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmlkZW50aWZpZXJdLmZpZWxkIHx8IHRoaXMuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRLZXkgJiYgIXRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5vcHRpb25zLnRhcmdldEtleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhdHRyaWJ1dGUgXCIke3RoaXMub3B0aW9ucy50YXJnZXRLZXl9XCIgcGFzc2VkIGFzIHRhcmdldEtleSwgZGVmaW5lIHRoaXMgYXR0cmlidXRlIG9uIG1vZGVsIFwiJHt0aGlzLnRhcmdldC5uYW1lfVwiIGZpcnN0YCk7XG4gICAgfVxuICAgIHRoaXMudGFyZ2V0S2V5ID0gdGhpcy5vcHRpb25zLnRhcmdldEtleSB8fCB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS5maWVsZCB8fCB0aGlzLnRhcmdldEtleTtcbiAgICB0aGlzLnRhcmdldEtleUlzUHJpbWFyeSA9IHRoaXMudGFyZ2V0S2V5ID09PSB0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMudGFyZ2V0SWRlbnRpZmllciA9IHRoaXMudGFyZ2V0S2V5O1xuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5vcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy51c2VIb29rcztcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3Npbmd1bGFyfWAsXG4gICAgICBzZXQ6IGBzZXQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWBcbiAgICB9O1xuICB9XG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWVcbiAgICAgIH0sIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgdGhpcy5vcHRpb25zLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8IChzb3VyY2UuYWxsb3dOdWxsID8gXCJTRVQgTlVMTFwiIDogXCJOTyBBQ1RJT05cIik7XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgXCJDQVNDQURFXCI7XG4gICAgfVxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy50YXJnZXQsIHRoaXMuc291cmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMudGFyZ2V0S2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy5zb3VyY2UucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG4gICAgdGhpcy5zb3VyY2UucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gW1wiZ2V0XCIsIFwic2V0XCIsIFwiY3JlYXRlXCJdO1xuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgbGV0IFRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY29wZVwiKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NoZW1hXCIpKSB7XG4gICAgICBUYXJnZXQgPSBUYXJnZXQuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgd2hlcmVbdGhpcy50YXJnZXRLZXldID0ge1xuICAgICAgICBbT3AuaW5dOiBpbnN0YW5jZXMubWFwKChfaW5zdGFuY2UpID0+IF9pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5KSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnRhcmdldEtleUlzUHJpbWFyeSAmJiAhb3B0aW9ucy53aGVyZSkge1xuICAgICAgICByZXR1cm4gVGFyZ2V0LmZpbmRCeVBrKGluc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHdoZXJlW3RoaXMudGFyZ2V0S2V5XSA9IGluc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgICAgb3B0aW9ucy5saW1pdCA9IG51bGw7XG4gICAgfVxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID8geyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDogd2hlcmU7XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFRhcmdldC5maW5kQWxsKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLnRhcmdldEtleSwgeyByYXc6IHRydWUgfSldID0gX2luc3RhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFRhcmdldC5maW5kT25lKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgYXNzb2NpYXRlZEluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdmFsdWUgPSBhc3NvY2lhdGVkSW5zdGFuY2U7XG4gICAgaWYgKGFzc29jaWF0ZWRJbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICB2YWx1ZSA9IGFzc29jaWF0ZWRJbnN0YW5jZVt0aGlzLnRhcmdldEtleV07XG4gICAgfVxuICAgIHNvdXJjZUluc3RhbmNlLnNldCh0aGlzLmZvcmVpZ25LZXksIHZhbHVlKTtcbiAgICBpZiAob3B0aW9ucy5zYXZlID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgZmllbGRzOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgIGFsbG93TnVsbDogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICBhc3NvY2lhdGlvbjogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCBzb3VyY2VJbnN0YW5jZS5zYXZlKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZShzb3VyY2VJbnN0YW5jZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgdmFsdWVzID0gdmFsdWVzIHx8IHt9O1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IG5ld0Fzc29jaWF0ZWRPYmplY3QgPSBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzb3VyY2VJbnN0YW5jZVt0aGlzLmFjY2Vzc29ycy5zZXRdKG5ld0Fzc29jaWF0ZWRPYmplY3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXdBc3NvY2lhdGVkT2JqZWN0O1xuICB9XG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5zaW5ndWxhcikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnNpbmd1bGFyO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJlbG9uZ3NUbztcbm1vZHVsZS5leHBvcnRzLkJlbG9uZ3NUbyA9IEJlbG9uZ3NUbztcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBCZWxvbmdzVG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/has-many.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-many.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.options.through) {\n      throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    }\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.source.options.name.singular,\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    const constraintOptions = __spreadValues({}, this.options);\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      constraintOptions.onUpdate = constraintOptions.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instances, options = {}) {\n    const where = {};\n    let Model = this.target;\n    let instance;\n    let values;\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    options = __spreadValues({}, options);\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    if (instances) {\n      values = instances.map((_instance) => _instance.get(this.sourceKey, { raw: true }));\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n    const results = await Model.findAll(options);\n    if (instance)\n      return results;\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n    return result;\n  }\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [\n        this.sequelize.fn(\"COUNT\", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)),\n        \"count\"\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n    where[Op.or] = targetInstances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return associatedObjects.length === targetInstances.length;\n  }\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n    const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), { scope: false, raw: true }));\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter((old) => !targetInstances.find((obj) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    const unassociatedObjects = targetInstances.filter((obj) => !oldAssociations.find((old) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    let updateWhere;\n    let update;\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map((associatedObject) => associatedObject[this.target.primaryKeyAttribute])\n      };\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map((unassociatedObject) => unassociatedObject[this.target.primaryKeyAttribute]);\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    await Promise.all(promises);\n    return sourceInstance;\n  }\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances)\n      return Promise.resolve();\n    targetInstances = this.toInstanceArray(targetInstances);\n    const update = __spreadValues({\n      [this.foreignKey]: sourceInstance.get(this.sourceKey)\n    }, this.scope);\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map((unassociatedObject) => unassociatedObject.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return sourceInstance;\n  }\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n    targetInstances = this.toInstanceArray(targetInstances);\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map((targetInstance) => targetInstance.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return this;\n  }\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (values === void 0) {\n      values = {};\n    }\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields)\n          options.fields.push(attribute);\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields)\n      options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports[\"default\"] = HasMany;\n//# sourceMappingURL=has-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW1hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLCtEQUFZO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBUTtBQUNwQyxXQUFXLG1CQUFPLENBQUMscUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFdBQVc7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQsV0FBVztBQUN6RTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCLEdBQUcsNEJBQTRCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBGQUEwRixjQUFjLHlCQUF5QjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWMsT0FBTztBQUNwRztBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxPQUFPO0FBQ3BHO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1tYW55LmpzPzBhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vLi4vdXRpbHNcIik7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3JzXCIpO1xuY2xhc3MgSGFzTWFueSBleHRlbmRzIEFzc29jaWF0aW9uIHtcbiAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSBcIkhhc01hbnlcIjtcbiAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNvdXJjZS5zZXF1ZWxpemU7XG4gICAgdGhpcy5pc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTjpNIGFzc29jaWF0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGhhc01hbnkuIFVzZSBiZWxvbmdzVG9NYW55IGluc3RlYWRcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXMpIHtcbiAgICAgIHRoaXMuaXNBbGlhc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5hcykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLmFzO1xuICAgICAgICB0aGlzLmFzID0gdGhpcy5hcy5wbHVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgICBwbHVyYWw6IHRoaXMuYXMsXG4gICAgICAgICAgc2luZ3VsYXI6IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUucGx1cmFsO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoW1xuICAgICAgICB0aGlzLnNvdXJjZS5vcHRpb25zLm5hbWUuc2luZ3VsYXIsXG4gICAgICAgIHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgIF0uam9pbihcIl9cIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgfVxuICAgIHRoaXMuc291cmNlS2V5ID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGlmICh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XSkge1xuICAgICAgdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLnNvdXJjZUtleTtcbiAgICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUgPSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnByaW1hcnlLZXlGaWVsZDtcbiAgICB9XG4gICAgY29uc3QgcGx1cmFsID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnBsdXJhbCk7XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3BsdXJhbH1gLFxuICAgICAgc2V0OiBgc2V0JHtwbHVyYWx9YCxcbiAgICAgIGFkZE11bHRpcGxlOiBgYWRkJHtwbHVyYWx9YCxcbiAgICAgIGFkZDogYGFkZCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZTogYHJlbW92ZSR7c2luZ3VsYXJ9YCxcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBgcmVtb3ZlJHtwbHVyYWx9YCxcbiAgICAgIGhhc1NpbmdsZTogYGhhcyR7c2luZ3VsYXJ9YCxcbiAgICAgIGhhc0FsbDogYGhhcyR7cGx1cmFsfWAsXG4gICAgICBjb3VudDogYGNvdW50JHtwbHVyYWx9YFxuICAgIH07XG4gIH1cbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGVdLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZVxuICAgICAgfSwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlKVxuICAgIH07XG4gICAgY29uc3QgY29uc3RyYWludE9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldIHx8IG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgIGNvbnN0cmFpbnRPcHRpb25zLm9uRGVsZXRlID0gY29uc3RyYWludE9wdGlvbnMub25EZWxldGUgfHwgKHRhcmdldC5hbGxvd051bGwgPyBcIlNFVCBOVUxMXCIgOiBcIkNBU0NBREVcIik7XG4gICAgICBjb25zdHJhaW50T3B0aW9ucy5vblVwZGF0ZSA9IGNvbnN0cmFpbnRPcHRpb25zLm9uVXBkYXRlIHx8IFwiQ0FTQ0FERVwiO1xuICAgIH1cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMuc291cmNlLCB0aGlzLnRhcmdldCwgY29uc3RyYWludE9wdGlvbnMsIHRoaXMuc291cmNlS2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy50YXJnZXQucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG4gICAgdGhpcy50YXJnZXQucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLnNvdXJjZS5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25LZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtcImdldFwiLCBcImNvdW50XCIsIFwiaGFzU2luZ2xlXCIsIFwiaGFzQWxsXCIsIFwic2V0XCIsIFwiYWRkXCIsIFwiYWRkTXVsdGlwbGVcIiwgXCJyZW1vdmVcIiwgXCJyZW1vdmVNdWx0aXBsZVwiLCBcImNyZWF0ZVwiXTtcbiAgICBjb25zdCBhbGlhc2VzID0ge1xuICAgICAgaGFzU2luZ2xlOiBcImhhc1wiLFxuICAgICAgaGFzQWxsOiBcImhhc1wiLFxuICAgICAgYWRkTXVsdGlwbGU6IFwiYWRkXCIsXG4gICAgICByZW1vdmVNdWx0aXBsZTogXCJyZW1vdmVcIlxuICAgIH07XG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzLCBhbGlhc2VzKTtcbiAgfVxuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGxldCBNb2RlbCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih3aGVyZSwgdGhpcy5zY29wZSk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHZhbHVlcyA9IGluc3RhbmNlcy5tYXAoKF9pbnN0YW5jZSkgPT4gX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSwgeyByYXc6IHRydWUgfSkpO1xuICAgICAgaWYgKG9wdGlvbnMubGltaXQgJiYgaW5zdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgb3B0aW9ucy5ncm91cGVkTGltaXQgPSB7XG4gICAgICAgICAgbGltaXQ6IG9wdGlvbnMubGltaXQsXG4gICAgICAgICAgb246IHRoaXMsXG4gICAgICAgICAgdmFsdWVzXG4gICAgICAgIH07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmxpbWl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgICBbT3AuaW5dOiB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZ3JvdXBlZExpbWl0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgPyB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOiB3aGVyZTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NvcGVcIikpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBNb2RlbCA9IE1vZGVsLnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNb2RlbCA9IE1vZGVsLnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NoZW1hXCIpKSB7XG4gICAgICBNb2RlbCA9IE1vZGVsLnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgTW9kZWwuZmluZEFsbChvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UpXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5mb3JlaWduS2V5LCB7IHJhdzogdHJ1ZSB9KV0ucHVzaChfaW5zdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvdW50KGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBbXG4gICAgICBbXG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmZuKFwiQ09VTlRcIiwgdGhpcy5zZXF1ZWxpemUuY29sKGAke3RoaXMudGFyZ2V0Lm5hbWV9LiR7dGhpcy50YXJnZXQucHJpbWFyeUtleUZpZWxkfWApKSxcbiAgICAgICAgXCJjb3VudFwiXG4gICAgICBdXG4gICAgXTtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoaW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQuY291bnQsIDEwKTtcbiAgfVxuICBhc3luYyBoYXMoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldEluc3RhbmNlcykpIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IFt0YXJnZXRJbnN0YW5jZXNdO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHNjb3BlOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSxcbiAgICAgIHJhdzogdHJ1ZVxuICAgIH0pO1xuICAgIHdoZXJlW09wLm9yXSA9IHRhcmdldEluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uud2hlcmUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogaW5zdGFuY2VcbiAgICAgIH07XG4gICAgfSk7XG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHdoZXJlLFxuICAgICAgICBvcHRpb25zLndoZXJlXG4gICAgICBdXG4gICAgfTtcbiAgICBjb25zdCBhc3NvY2lhdGVkT2JqZWN0cyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID09PSB0YXJnZXRJbnN0YW5jZXMubGVuZ3RoO1xuICB9XG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldEluc3RhbmNlcyA9PT0gbnVsbCkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IG9sZEFzc29jaWF0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0KHNvdXJjZUluc3RhbmNlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBzY29wZTogZmFsc2UsIHJhdzogdHJ1ZSB9KSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCBvYnNvbGV0ZUFzc29jaWF0aW9ucyA9IG9sZEFzc29jaWF0aW9ucy5maWx0ZXIoKG9sZCkgPT4gIXRhcmdldEluc3RhbmNlcy5maW5kKChvYmopID0+IG9ialt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gb2xkW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdKSk7XG4gICAgY29uc3QgdW5hc3NvY2lhdGVkT2JqZWN0cyA9IHRhcmdldEluc3RhbmNlcy5maWx0ZXIoKG9iaikgPT4gIW9sZEFzc29jaWF0aW9ucy5maW5kKChvbGQpID0+IG9ialt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gb2xkW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdKSk7XG4gICAgbGV0IHVwZGF0ZVdoZXJlO1xuICAgIGxldCB1cGRhdGU7XG4gICAgaWYgKG9ic29sZXRlQXNzb2NpYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHVwZGF0ZSA9IHt9O1xuICAgICAgdXBkYXRlW3RoaXMuZm9yZWlnbktleV0gPSBudWxsO1xuICAgICAgdXBkYXRlV2hlcmUgPSB7XG4gICAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogb2Jzb2xldGVBc3NvY2lhdGlvbnMubWFwKChhc3NvY2lhdGVkT2JqZWN0KSA9PiBhc3NvY2lhdGVkT2JqZWN0W3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdKVxuICAgICAgfTtcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICB3aGVyZTogdXBkYXRlV2hlcmVcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVwZGF0ZVdoZXJlID0ge307XG4gICAgICB1cGRhdGUgPSB7fTtcbiAgICAgIHVwZGF0ZVt0aGlzLmZvcmVpZ25LZXldID0gc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICAgIE9iamVjdC5hc3NpZ24odXBkYXRlLCB0aGlzLnNjb3BlKTtcbiAgICAgIHVwZGF0ZVdoZXJlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gdW5hc3NvY2lhdGVkT2JqZWN0cy5tYXAoKHVuYXNzb2NpYXRlZE9iamVjdCkgPT4gdW5hc3NvY2lhdGVkT2JqZWN0W3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdKTtcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICB3aGVyZTogdXBkYXRlV2hlcmVcbiAgICAgIH0pKSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICByZXR1cm4gc291cmNlSW5zdGFuY2U7XG4gIH1cbiAgYXN5bmMgYWRkKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGFyZ2V0SW5zdGFuY2VzKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRhcmdldEluc3RhbmNlcyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KHRhcmdldEluc3RhbmNlcyk7XG4gICAgY29uc3QgdXBkYXRlID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSlcbiAgICB9LCB0aGlzLnNjb3BlKTtcbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXTogdGFyZ2V0SW5zdGFuY2VzLm1hcCgodW5hc3NvY2lhdGVkT2JqZWN0KSA9PiB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGUpKVxuICAgIH07XG4gICAgYXdhaXQgdGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aGVyZSB9KSk7XG4gICAgcmV0dXJuIHNvdXJjZUluc3RhbmNlO1xuICB9XG4gIGFzeW5jIHJlbW92ZShzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogbnVsbFxuICAgIH07XG4gICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcbiAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpLFxuICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiB0YXJnZXRJbnN0YW5jZXMubWFwKCh0YXJnZXRJbnN0YW5jZSkgPT4gdGFyZ2V0SW5zdGFuY2UuZ2V0KHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGUpKVxuICAgIH07XG4gICAgYXdhaXQgdGhpcy50YXJnZXQudW5zY29wZWQoKS51cGRhdGUodXBkYXRlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB3aGVyZSB9KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBmaWVsZHM6IG9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWVzID0ge307XG4gICAgfVxuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyh0aGlzLnNjb3BlKSkge1xuICAgICAgICB2YWx1ZXNbYXR0cmlidXRlXSA9IHRoaXMuc2NvcGVbYXR0cmlidXRlXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKVxuICAgICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcylcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godGhpcy5mb3JlaWduS2V5KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnBsdXJhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzLnBsdXJhbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBIYXNNYW55O1xubW9kdWxlLmV4cG9ydHMuSGFzTWFueSA9IEhhc01hbnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gSGFzTWFueTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhcy1tYW55LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/has-many.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/has-one.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-one.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasOne\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        Utils.singularize(this.options.as || this.source.name),\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.sourceKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.foreignKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options) {\n    options = __spreadProps(__spreadValues({}, options), { scope: false });\n    const oldInstance = await sourceInstance[this.accessors.get](options);\n    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every((attribute) => oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance));\n    if (oldInstance && !alreadyAssociated) {\n      oldInstance[this.foreignKey] = null;\n      await oldInstance.save(__spreadProps(__spreadValues({}, options), {\n        fields: [this.foreignKey],\n        allowNull: [this.foreignKey],\n        association: true\n      }));\n    }\n    if (associatedInstance && !alreadyAssociated) {\n      if (!(associatedInstance instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n        associatedInstance = this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n      Object.assign(associatedInstance, this.scope);\n      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n      return associatedInstance.save(options);\n    }\n    return null;\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasOne;\n//# sourceMappingURL=has-one.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsK0RBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxxRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCLHlEQUF5RCxpQkFBaUI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixTQUFTO0FBQzFCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsY0FBYztBQUN6RTtBQUNBLHNKQUFzSixXQUFXLG9FQUFvRSxXQUFXO0FBQ2hQO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9oYXMtb25lLmpzPzAwMWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vLi4vdXRpbHNcIik7XG5jb25zdCBIZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3JzXCIpO1xuY2xhc3MgSGFzT25lIGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9IFwiSGFzT25lXCI7XG4gICAgdGhpcy5pc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgIHNpbmd1bGFyOiB0aGlzLmFzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyO1xuICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWU7XG4gICAgfVxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5O1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gVXRpbHMuY2FtZWxpemUoW1xuICAgICAgICBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLm9wdGlvbnMuYXMgfHwgdGhpcy5zb3VyY2UubmFtZSksXG4gICAgICAgIHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgIF0uam9pbihcIl9cIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNvdXJjZUtleSAmJiAhdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLm9wdGlvbnMuc291cmNlS2V5XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBcIiR7dGhpcy5vcHRpb25zLnNvdXJjZUtleX1cIiBwYXNzZWQgYXMgc291cmNlS2V5LCBkZWZpbmUgdGhpcyBhdHRyaWJ1dGUgb24gbW9kZWwgXCIke3RoaXMuc291cmNlLm5hbWV9XCIgZmlyc3RgKTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VLZXkgfHwgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgdGhpcy5zb3VyY2VLZXlJc1ByaW1hcnkgPSB0aGlzLnNvdXJjZUtleSA9PT0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB0aGlzLmFzc29jaWF0aW9uQWNjZXNzb3IgPSB0aGlzLmFzO1xuICAgIHRoaXMub3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMudXNlSG9va3M7XG4gICAgaWYgKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIH1cbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSB7XG4gICAgICBnZXQ6IGBnZXQke3Npbmd1bGFyfWAsXG4gICAgICBzZXQ6IGBzZXQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWBcbiAgICB9O1xuICB9XG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMua2V5VHlwZSB8fCB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS50eXBlLFxuICAgICAgICBhbGxvd051bGw6IHRydWVcbiAgICAgIH0sIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgdGhpcy5vcHRpb25zLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8ICh0YXJnZXQuYWxsb3dOdWxsID8gXCJTRVQgTlVMTFwiIDogXCJDQVNDQURFXCIpO1xuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlID0gdGhpcy5vcHRpb25zLm9uVXBkYXRlIHx8IFwiQ0FTQ0FERVwiO1xuICAgIH1cbiAgICBIZWxwZXJzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0sIHRoaXMuc291cmNlLCB0aGlzLnRhcmdldCwgdGhpcy5vcHRpb25zLCB0aGlzLnNvdXJjZUtleUZpZWxkKTtcbiAgICBVdGlscy5tZXJnZURlZmF1bHRzKHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXMsIG5ld0F0dHJpYnV0ZXMpO1xuICAgIHRoaXMudGFyZ2V0LnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtcImdldFwiLCBcInNldFwiLCBcImNyZWF0ZVwiXTtcbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMpO1xuICB9XG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGxldCBUYXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NvcGVcIikpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC5zY29wZShvcHRpb25zLnNjb3BlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjaGVtYVwiKSkge1xuICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXM7XG4gICAgICBpbnN0YW5jZXMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgIFtPcC5pbl06IGluc3RhbmNlcy5tYXAoKF9pbnN0YW5jZSkgPT4gX2luc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSkpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24od2hlcmUsIHRoaXMuc2NvcGUpO1xuICAgIH1cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/IHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6IHdoZXJlO1xuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBUYXJnZXQuZmluZEFsbChvcHRpb25zKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXSA9IF9pbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBUYXJnZXQuZmluZE9uZShvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIGFzc29jaWF0ZWRJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBzY29wZTogZmFsc2UgfSk7XG4gICAgY29uc3Qgb2xkSW5zdGFuY2UgPSBhd2FpdCBzb3VyY2VJbnN0YW5jZVt0aGlzLmFjY2Vzc29ycy5nZXRdKG9wdGlvbnMpO1xuICAgIGNvbnN0IGFscmVhZHlBc3NvY2lhdGVkID0gb2xkSW5zdGFuY2UgJiYgYXNzb2NpYXRlZEluc3RhbmNlICYmIHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVzLmV2ZXJ5KChhdHRyaWJ1dGUpID0+IG9sZEluc3RhbmNlLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSAoYXNzb2NpYXRlZEluc3RhbmNlLmdldCA/IGFzc29jaWF0ZWRJbnN0YW5jZS5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA6IGFzc29jaWF0ZWRJbnN0YW5jZSkpO1xuICAgIGlmIChvbGRJbnN0YW5jZSAmJiAhYWxyZWFkeUFzc29jaWF0ZWQpIHtcbiAgICAgIG9sZEluc3RhbmNlW3RoaXMuZm9yZWlnbktleV0gPSBudWxsO1xuICAgICAgYXdhaXQgb2xkSW5zdGFuY2Uuc2F2ZShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICBmaWVsZHM6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgICBhbGxvd051bGw6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgICBhc3NvY2lhdGlvbjogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoYXNzb2NpYXRlZEluc3RhbmNlICYmICFhbHJlYWR5QXNzb2NpYXRlZCkge1xuICAgICAgaWYgKCEoYXNzb2NpYXRlZEluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpKSB7XG4gICAgICAgIGNvbnN0IHRtcEluc3RhbmNlID0ge307XG4gICAgICAgIHRtcEluc3RhbmNlW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gYXNzb2NpYXRlZEluc3RhbmNlO1xuICAgICAgICBhc3NvY2lhdGVkSW5zdGFuY2UgPSB0aGlzLnRhcmdldC5idWlsZCh0bXBJbnN0YW5jZSwge1xuICAgICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24oYXNzb2NpYXRlZEluc3RhbmNlLCB0aGlzLnNjb3BlKTtcbiAgICAgIGFzc29jaWF0ZWRJbnN0YW5jZS5zZXQodGhpcy5mb3JlaWduS2V5LCBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUpKTtcbiAgICAgIHJldHVybiBhc3NvY2lhdGVkSW5zdGFuY2Uuc2F2ZShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKHRoaXMuc2NvcGUpKSB7XG4gICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gdGhpcy5zY29wZVthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAob3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXlBdHRyaWJ1dGUpO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnNpbmd1bGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMuc2luZ3VsYXI7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gSGFzT25lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLW9uZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/has-one.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    const primaryKeys = Object.keys(source.primaryKeys).map((primaryKeyAttribute) => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n  for (const method of methods) {\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSwyREFBMkQsZUFBZSxxQkFBcUIsZUFBZSxhQUFhLHdCQUF3QjtBQUNuSjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcz9hZTc4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gY2hlY2tOYW1pbmdDb2xsaXNpb24oYXNzb2NpYXRpb24pIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhc3NvY2lhdGlvbi5zb3VyY2UucmF3QXR0cmlidXRlcywgYXNzb2NpYXRpb24uYXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOYW1pbmcgY29sbGlzaW9uIGJldHdlZW4gYXR0cmlidXRlICcke2Fzc29jaWF0aW9uLmFzfScgYW5kIGFzc29jaWF0aW9uICcke2Fzc29jaWF0aW9uLmFzfScgb24gbW9kZWwgJHthc3NvY2lhdGlvbi5zb3VyY2UubmFtZX0uIFRvIHJlbWVkeSB0aGlzLCBjaGFuZ2UgZWl0aGVyIGZvcmVpZ25LZXkgb3IgYXMgaW4geW91ciBhc3NvY2lhdGlvbiBkZWZpbml0aW9uYCk7XG4gIH1cbn1cbmV4cG9ydHMuY2hlY2tOYW1pbmdDb2xsaXNpb24gPSBjaGVja05hbWluZ0NvbGxpc2lvbjtcbmZ1bmN0aW9uIGFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyhuZXdBdHRyaWJ1dGUsIHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zLCBrZXkpIHtcbiAgaWYgKG9wdGlvbnMuZm9yZWlnbktleUNvbnN0cmFpbnQgfHwgb3B0aW9ucy5vbkRlbGV0ZSB8fCBvcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UucHJpbWFyeUtleXMpLm1hcCgocHJpbWFyeUtleUF0dHJpYnV0ZSkgPT4gc291cmNlLnJhd0F0dHJpYnV0ZXNbcHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgfHwgcHJpbWFyeUtleUF0dHJpYnV0ZSk7XG4gICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCA9PT0gMSB8fCAhcHJpbWFyeUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgbmV3QXR0cmlidXRlLnJlZmVyZW5jZXMgPSB7XG4gICAgICAgIG1vZGVsOiBzb3VyY2UuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleToga2V5IHx8IHByaW1hcnlLZXlzWzBdXG4gICAgICB9O1xuICAgICAgbmV3QXR0cmlidXRlLm9uRGVsZXRlID0gb3B0aW9ucy5vbkRlbGV0ZTtcbiAgICAgIG5ld0F0dHJpYnV0ZS5vblVwZGF0ZSA9IG9wdGlvbnMub25VcGRhdGU7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLmFkZEZvcmVpZ25LZXlDb25zdHJhaW50cyA9IGFkZEZvcmVpZ25LZXlDb25zdHJhaW50cztcbmZ1bmN0aW9uIG1peGluTWV0aG9kcyhhc3NvY2lhdGlvbiwgb2JqLCBtZXRob2RzLCBhbGlhc2VzKSB7XG4gIGFsaWFzZXMgPSBhbGlhc2VzIHx8IHt9O1xuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBhc3NvY2lhdGlvbi5hY2Nlc3NvcnNbbWV0aG9kXSkpIHtcbiAgICAgIGNvbnN0IHJlYWxNZXRob2QgPSBhbGlhc2VzW21ldGhvZF0gfHwgbWV0aG9kO1xuICAgICAgb2JqW2Fzc29jaWF0aW9uLmFjY2Vzc29yc1ttZXRob2RdXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYXNzb2NpYXRpb25bcmVhbE1ldGhvZF0odGhpcywgLi4uQXJyYXkuZnJvbShhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5leHBvcnRzLm1peGluTWV0aG9kcyA9IG1peGluTWV0aG9kcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nAssociation.BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nAssociation.HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nAssociation.HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nAssociation.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nmodule.exports = Association;\nmodule.exports[\"default\"] = Association;\nmodule.exports.Association = Association;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBUTtBQUNwQyx3QkFBd0IsbUJBQU8sQ0FBQyxtRkFBYztBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBVztBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBWTtBQUMxQyw0QkFBNEIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDdkQ7QUFDQSx5QkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2luZGV4LmpzP2VmMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5Bc3NvY2lhdGlvbi5CZWxvbmdzVG8gPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvXCIpO1xuQXNzb2NpYXRpb24uSGFzT25lID0gcmVxdWlyZShcIi4vaGFzLW9uZVwiKTtcbkFzc29jaWF0aW9uLkhhc01hbnkgPSByZXF1aXJlKFwiLi9oYXMtbWFueVwiKTtcbkFzc29jaWF0aW9uLkJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvLW1hbnlcIik7XG5tb2R1bGUuZXhwb3J0cyA9IEFzc29jaWF0aW9uO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFzc29jaWF0aW9uO1xubW9kdWxlLmV4cG9ydHMuQXNzb2NpYXRpb24gPSBBc3NvY2lhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/mixin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, [\"hooks\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: HasMany }, options);\n    }\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: HasMany, association }, options);\n    }\n    return association;\n  },\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, [\"hooks\", \"timestamps\", \"scopes\", \"defaultScope\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: BelongsToMany }, options);\n    }\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: BelongsToMany, association }, options);\n    }\n    return association;\n  },\n  getAssociations(target) {\n    return Object.values(this.associations).filter((association) => association.target.name === target.name);\n  },\n  getAssociationForAlias(target, alias) {\n    return this.getAssociations(target).find((association) => association.verifyAssociationAlias(alias)) || null;\n  }\n};\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    if (options.useHooks) {\n      source.runHooks(\"beforeAssociate\", { source, target, type: Type }, options);\n    }\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      source.runHooks(\"afterAssociate\", { source, target, type: Type, association }, options);\n    }\n    return association;\n  };\n}\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports[\"default\"] = Mixin;\n//# sourceMappingURL=mixin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvbWl4aW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3BDLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRDQUE0QztBQUNwRjtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQztBQUNwQztBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFDQUFxQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0RBQWtEO0FBQzFGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvbWl4aW4uanM/OGExZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgSGFzT25lID0gcmVxdWlyZShcIi4vaGFzLW9uZVwiKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKFwiLi9oYXMtbWFueVwiKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvLW1hbnlcIik7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKFwiLi9iZWxvbmdzLXRvXCIpO1xuZnVuY3Rpb24gaXNNb2RlbChtb2RlbCwgc2VxdWVsaXplKSB7XG4gIHJldHVybiBtb2RlbCAmJiBtb2RlbC5wcm90b3R5cGUgJiYgbW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2Ygc2VxdWVsaXplLlNlcXVlbGl6ZS5Nb2RlbDtcbn1cbmNvbnN0IE1peGluID0ge1xuICBoYXNNYW55KHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFpc01vZGVsKHRhcmdldCwgdGhpcy5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfS5oYXNNYW55IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXM7XG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHZvaWQgMCA/IGZhbHNlIDogQm9vbGVhbihvcHRpb25zLmhvb2tzKTtcbiAgICBvcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy5ob29rcztcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIF8ub21pdChzb3VyY2Uub3B0aW9ucywgW1wiaG9va3NcIl0pKTtcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBIYXNNYW55IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBIYXNNYW55KHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcyhcImFmdGVyQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEhhc01hbnksIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH0sXG4gIGJlbG9uZ3NUb01hbnkodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCB0aGlzLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9LmJlbG9uZ3NUb01hbnkgY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuICAgIG9wdGlvbnMudGltZXN0YW1wcyA9IG9wdGlvbnMudGltZXN0YW1wcyA9PT0gdm9pZCAwID8gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lc3RhbXBzIDogb3B0aW9ucy50aW1lc3RhbXBzO1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgXy5vbWl0KHNvdXJjZS5vcHRpb25zLCBbXCJob29rc1wiLCBcInRpbWVzdGFtcHNcIiwgXCJzY29wZXNcIiwgXCJkZWZhdWx0U2NvcGVcIl0pKTtcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBCZWxvbmdzVG9NYW55IH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBCZWxvbmdzVG9NYW55KHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICBzb3VyY2UuYXNzb2NpYXRpb25zW2Fzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3JdID0gYXNzb2NpYXRpb247XG4gICAgYXNzb2NpYXRpb24uX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICBhc3NvY2lhdGlvbi5taXhpbihzb3VyY2UucHJvdG90eXBlKTtcbiAgICBpZiAob3B0aW9ucy51c2VIb29rcykge1xuICAgICAgdGhpcy5ydW5Ib29rcyhcImFmdGVyQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEJlbG9uZ3NUb01hbnksIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH0sXG4gIGdldEFzc29jaWF0aW9ucyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLmFzc29jaWF0aW9ucykuZmlsdGVyKChhc3NvY2lhdGlvbikgPT4gYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IHRhcmdldC5uYW1lKTtcbiAgfSxcbiAgZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXQsIGFsaWFzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldCkuZmluZCgoYXNzb2NpYXRpb24pID0+IGFzc29jaWF0aW9uLnZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpKSB8fCBudWxsO1xuICB9XG59O1xuZnVuY3Rpb24gc2luZ2xlTGlua2VkKFR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCBzb3VyY2Uuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3NvdXJjZS5uYW1lfS4ke18ubG93ZXJGaXJzdChUeXBlLm5hbWUpfSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICBzb3VyY2UucnVuSG9va3MoXCJiZWZvcmVBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogVHlwZSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBuZXcgVHlwZShzb3VyY2UsIHRhcmdldCwgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBzb3VyY2Uub3B0aW9ucykpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICBzb3VyY2UucnVuSG9va3MoXCJhZnRlckFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBUeXBlLCBhc3NvY2lhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICB9O1xufVxuTWl4aW4uaGFzT25lID0gc2luZ2xlTGlua2VkKEhhc09uZSk7XG5NaXhpbi5iZWxvbmdzVG8gPSBzaW5nbGVMaW5rZWQoQmVsb25nc1RvKTtcbm1vZHVsZS5leHBvcnRzID0gTWl4aW47XG5tb2R1bGUuZXhwb3J0cy5NaXhpbiA9IE1peGluO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IE1peGluO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWl4aW4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/mixin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/data-types.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/data-types.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst warnings = {};\nconst { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ \"(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\");\nconst { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\");\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\nABSTRACT.prototype.dialectTypes = \"\";\nclass STRING extends ABSTRACT {\n  constructor(length, binary) {\n    super();\n    const options = typeof length === \"object\" && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === \"number\") {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\nclass CHAR extends STRING {\n  constructor(length, binary) {\n    super(typeof length === \"object\" && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n}\nclass TEXT extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n      case \"long\":\n        return \"LONGTEXT\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return \"CITEXT\";\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass NUMBER extends ABSTRACT {\n  constructor(options = {}) {\n    super();\n    if (typeof options === \"number\") {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === \"number\") {\n        result += `,${this._decimals}`;\n      }\n      result += \")\";\n    }\n    if (this._unsigned) {\n      result += \" UNSIGNED\";\n    }\n    if (this._zerofill) {\n      result += \" ZEROFILL\";\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === \"number\" || typeof number === \"bigint\" || typeof number === \"boolean\" || number === null || number === void 0) {\n      return number;\n    }\n    if (typeof number.toString === \"function\") {\n      return number.toString();\n    }\n    return number;\n  }\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\nclass TINYINT extends INTEGER {\n}\nclass SMALLINT extends INTEGER {\n}\nclass MEDIUMINT extends INTEGER {\n}\nclass BIGINT extends INTEGER {\n}\nclass FLOAT extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid float\", value));\n    }\n    return true;\n  }\n}\nclass REAL extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DOUBLE extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DECIMAL extends NUMBER {\n  constructor(precision, scale) {\n    super(typeof precision === \"object\" && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(\",\")})`;\n    }\n    return \"DECIMAL\";\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid decimal\", value));\n    }\n    return true;\n  }\n}\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return \"NaN\";\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? \"-\" : \"\";\n      return `${sign}Infinity`;\n    }\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid boolean\", value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== void 0) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === \"string\") {\n        return value === \"true\" ? true : value === \"false\" ? false : value;\n      }\n      if (type === \"number\") {\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\nclass TIME extends ABSTRACT {\n  toSql() {\n    return \"TIME\";\n  }\n}\nclass DATE extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    return \"DATETIME\";\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid date\", value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    return date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n}\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return \"DATE\";\n  }\n  _stringify(date) {\n    return moment(date).format(\"YYYY-MM-DD\");\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid hstore\", value));\n    }\n    return true;\n  }\n}\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\nclass JSONB extends JSONTYPE {\n}\nclass NOW extends ABSTRACT {\n}\nclass BLOB extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n      case \"long\":\n        return \"LONGBLOB\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid blob\", value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString(\"hex\");\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\nBLOB.prototype.escape = false;\nclass RANGE extends ABSTRACT {\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === \"function\") {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid range\", value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError(\"A range must be an array with two elements\");\n    }\n    return true;\n  }\n}\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuidv4\", value));\n    }\n    return true;\n  }\n}\nclass VIRTUAL extends ABSTRACT {\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === \"function\")\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\nclass ENUM extends ABSTRACT {\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === \"object\" && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid choice in %j\", value, this.values));\n    }\n    return true;\n  }\n}\nclass ARRAY extends ABSTRACT {\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === \"function\" ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid array\", value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\nclass GEOMETRY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOMETRY.prototype.escape = false;\nclass GEOGRAPHY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOGRAPHY.prototype.escape = false;\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid CIDR\", value));\n    }\n    return true;\n  }\n}\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid INET\", value));\n    }\n    return true;\n  }\n}\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid MACADDR\", value));\n    }\n    return true;\n  }\n}\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  \"DOUBLE PRECISION\": DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n_.each(DataTypes, (dataType, name) => {\n  if (!Object.prototype.hasOwnProperty.call(dataType, \"key\")) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\nconst dialectMap = {};\ndialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js\")(DataTypes);\ndialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js\")(DataTypes);\ndialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js\")(DataTypes);\ndialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js\")(DataTypes);\ndialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js\")(DataTypes);\ndialectMap.db2 = __webpack_require__(/*! ./dialects/db2/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js\")(DataTypes);\ndialectMap.snowflake = __webpack_require__(/*! ./dialects/snowflake/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js\")(DataTypes);\ndialectMap.oracle = __webpack_require__(/*! ./dialects/oracle/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js\")(DataTypes);\nconst dialectList = Object.values(dialectMap);\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\nObject.assign(DataTypes, dialectMap);\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixZQUFZLG1CQUFPLENBQUMsZ0RBQUs7QUFDekIsd0JBQXdCLG1CQUFPLENBQUMsb0VBQVU7QUFDMUMsa0JBQWtCLCtIQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzNDO0FBQ0EsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLGtHQUE0QjtBQUNqRSxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsa0dBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBNEQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBeUQ7QUFDdkY7QUFDQTtBQUNBLDhCQUE4Qiw0REFBNEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQXlEO0FBQ3ZGO0FBQ0E7QUFDQSw4QkFBOEIsNERBQTREO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsd0dBQStCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHNHQUE4QjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLDRHQUFpQztBQUNoRSxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RhdGEtdHlwZXMuanM/YThjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3Qgd2t4ID0gcmVxdWlyZShcIndreFwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXNcIikudmFsaWRhdG9yO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCB3YXJuaW5ncyA9IHt9O1xuY29uc3QgeyBjbGFzc1RvSW52b2thYmxlIH0gPSByZXF1aXJlKFwiLi91dGlscy9jbGFzcy10by1pbnZva2FibGVcIik7XG5jb25zdCB7IGpvaW5TUUxGcmFnbWVudHMgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50c1wiKTtcbmNsYXNzIEFCU1RSQUNUIHtcbiAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvU3FsKG9wdGlvbnMpO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiB0aGlzLmtleTtcbiAgfVxuICBzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5naWZ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGJpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9iaW5kUGFyYW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICBzdGF0aWMgd2FybihsaW5rLCB0ZXh0KSB7XG4gICAgaWYgKCF3YXJuaW5nc1t0ZXh0XSkge1xuICAgICAgd2FybmluZ3NbdGV4dF0gPSB0cnVlO1xuICAgICAgbG9nZ2VyLndhcm4oYCR7dGV4dH0gXG4+PiBDaGVjazogJHtsaW5rfWApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZXh0ZW5kKG9sZFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob2xkVHlwZS5vcHRpb25zKTtcbiAgfVxufVxuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9IFwiXCI7XG5jbGFzcyBTVFJJTkcgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgYmluYXJ5KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGJpbmFyeSB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYmluYXJ5ID0gb3B0aW9ucy5iaW5hcnk7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgMjU1O1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBWQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgLFxuICAgICAgdGhpcy5fYmluYXJ5ICYmIFwiQklOQVJZXCJcbiAgICBdKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSBcIltvYmplY3QgU3RyaW5nXVwiKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmJpbmFyeSAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCBCSU5BUlkoKSB7XG4gICAgdGhpcy5fYmluYXJ5ID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMuYmluYXJ5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgZ2V0IEJJTkFSWSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5CSU5BUlk7XG4gIH1cbn1cbmNsYXNzIENIQVIgZXh0ZW5kcyBTVFJJTkcge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGJpbmFyeSkge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBiaW5hcnkgfSk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYENIQVIoJHt0aGlzLl9sZW5ndGh9KWAsXG4gICAgICB0aGlzLl9iaW5hcnkgJiYgXCJCSU5BUllcIlxuICAgIF0pO1xuICB9XG59XG5jbGFzcyBURVhUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgXCJcIjtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwidGlueVwiOlxuICAgICAgICByZXR1cm4gXCJUSU5ZVEVYVFwiO1xuICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICByZXR1cm4gXCJNRURJVU1URVhUXCI7XG4gICAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgICByZXR1cm4gXCJMT05HVEVYVFwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBDSVRFWFQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIkNJVEVYVFwiO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBzdHJpbmdcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIE5VTUJFUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGxlbmd0aDogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aDtcbiAgICB0aGlzLl96ZXJvZmlsbCA9IG9wdGlvbnMuemVyb2ZpbGw7XG4gICAgdGhpcy5fZGVjaW1hbHMgPSBvcHRpb25zLmRlY2ltYWxzO1xuICAgIHRoaXMuX3ByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgIHRoaXMuX3NjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB0aGlzLl91bnNpZ25lZCA9IG9wdGlvbnMudW5zaWduZWQ7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy5fbGVuZ3RofWA7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2RlY2ltYWxzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fZGVjaW1hbHN9YDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICByZXN1bHQgKz0gXCIgVU5TSUdORURcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICByZXN1bHQgKz0gXCIgWkVST0ZJTExcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRmxvYXQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KGAlaiBpcyBub3QgYSB2YWxpZCAke3RoaXMua2V5LnRvTG93ZXJDYXNlKCl9YCwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0cmluZ2lmeShudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbnVtYmVyID09PSBcImJpZ2ludFwiIHx8IHR5cGVvZiBudW1iZXIgPT09IFwiYm9vbGVhblwiIHx8IG51bWJlciA9PT0gbnVsbCB8fCBudW1iZXIgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBudW1iZXIudG9TdHJpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIG51bWJlci50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG4gIGdldCBVTlNJR05FRCgpIHtcbiAgICB0aGlzLl91bnNpZ25lZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgWkVST0ZJTEwoKSB7XG4gICAgdGhpcy5femVyb2ZpbGwgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy56ZXJvZmlsbCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGdldCBVTlNJR05FRCgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoKS5VTlNJR05FRDtcbiAgfVxuICBzdGF0aWMgZ2V0IFpFUk9GSUxMKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLlpFUk9GSUxMO1xuICB9XG59XG5jbGFzcyBJTlRFR0VSIGV4dGVuZHMgTlVNQkVSIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0ludChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoYCVqIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5rZXkudG9Mb3dlckNhc2UoKX1gLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVElOWUlOVCBleHRlbmRzIElOVEVHRVIge1xufVxuY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cbmNsYXNzIE1FRElVTUlOVCBleHRlbmRzIElOVEVHRVIge1xufVxuY2xhc3MgQklHSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5jbGFzcyBGTE9BVCBleHRlbmRzIE5VTUJFUiB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICBzdXBlcih0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgZGVjaW1hbHMgfSk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Zsb2F0KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGZsb2F0XCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBSRUFMIGV4dGVuZHMgTlVNQkVSIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxufVxuY2xhc3MgRE9VQkxFIGV4dGVuZHMgTlVNQkVSIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxufVxuY2xhc3MgREVDSU1BTCBleHRlbmRzIE5VTUJFUiB7XG4gIGNvbnN0cnVjdG9yKHByZWNpc2lvbiwgc2NhbGUpIHtcbiAgICBzdXBlcih0eXBlb2YgcHJlY2lzaW9uID09PSBcIm9iamVjdFwiICYmIHByZWNpc2lvbiB8fCB7IHByZWNpc2lvbiwgc2NhbGUgfSk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgaWYgKHRoaXMuX3ByZWNpc2lvbiB8fCB0aGlzLl9zY2FsZSkge1xuICAgICAgcmV0dXJuIGBERUNJTUFMKCR7W3RoaXMuX3ByZWNpc2lvbiwgdGhpcy5fc2NhbGVdLmZpbHRlcihfLmlkZW50aXR5KS5qb2luKFwiLFwiKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIFwiREVDSU1BTFwiO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNEZWNpbWFsKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWxcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNvbnN0IHByb3RvRXh0ZW5zaW9ucyA9IHtcbiAgZXNjYXBlOiBmYWxzZSxcbiAgX3ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICBjb25zdCBzaWduID0gdmFsdWUgPCAwID8gXCItXCIgOiBcIlwiO1xuICAgICAgcmV0dXJuIGAke3NpZ259SW5maW5pdHlgO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gYCcke3RoaXMuX3ZhbHVlKHZhbHVlKX0nYDtcbiAgfSxcbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZSkpO1xuICB9XG59O1xuZm9yIChjb25zdCBmbG9hdGluZyBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTF0pIHtcbiAgT2JqZWN0LmFzc2lnbihmbG9hdGluZy5wcm90b3R5cGUsIHByb3RvRXh0ZW5zaW9ucyk7XG59XG5jbGFzcyBCT09MRUFOIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJUSU5ZSU5UKDEpXCI7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0Jvb2xlYW4oU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgYm9vbGVhblwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMSA/IHRydWUgOiB2YWx1ZSA9PT0gMCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuQk9PTEVBTi5wYXJzZSA9IEJPT0xFQU4ucHJvdG90eXBlLl9zYW5pdGl6ZTtcbmNsYXNzIFRJTUUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIlRJTUVcIjtcbiAgfVxufVxuY2xhc3MgREFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGggfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoIHx8IFwiXCI7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiREFURVRJTUVcIjtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRGF0ZShTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBkYXRlXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX2lzQ2hhbmdlZCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkge1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICYmICEhdmFsdWUgJiYgKHZhbHVlID09PSBvcmlnaW5hbFZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiBvcmlnaW5hbFZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZS5nZXRUaW1lKCkgPT09IG9yaWdpbmFsVmFsdWUuZ2V0VGltZSgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW9yaWdpbmFsVmFsdWUgJiYgIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy50aW1lem9uZSkge1xuICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudFR6KGRhdGUpLnR6KG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUgPSBtb21lbnQoZGF0ZSkudXRjT2Zmc2V0KG9wdGlvbnMudGltZXpvbmUpO1xuICAgIH1cbiAgICByZXR1cm4gbW9tZW50VHooZGF0ZSk7XG4gIH1cbiAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBaXCIpO1xuICB9XG59XG5jbGFzcyBEQVRFT05MWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiREFURVwiO1xuICB9XG4gIF9zdHJpbmdpZnkoZGF0ZSkge1xuICAgIHJldHVybiBtb21lbnQoZGF0ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgfVxuICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiAhIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgX2lzQ2hhbmdlZCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkge1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICYmICEhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFvcmlnaW5hbFZhbHVlICYmICF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgSFNUT1JFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBoc3RvcmVcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuY2xhc3MgSlNPTkIgZXh0ZW5kcyBKU09OVFlQRSB7XG59XG5jbGFzcyBOT1cgZXh0ZW5kcyBBQlNUUkFDVCB7XG59XG5jbGFzcyBCTE9CIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgXCJcIjtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwidGlueVwiOlxuICAgICAgICByZXR1cm4gXCJUSU5ZQkxPQlwiO1xuICAgICAgY2FzZSBcIm1lZGl1bVwiOlxuICAgICAgICByZXR1cm4gXCJNRURJVU1CTE9CXCI7XG4gICAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgICByZXR1cm4gXCJMT05HQkxPQlwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgYmxvYlwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZXggPSB2YWx1ZS50b1N0cmluZyhcImhleFwiKTtcbiAgICByZXR1cm4gdGhpcy5faGV4aWZ5KGhleCk7XG4gIH1cbiAgX2hleGlmeShoZXgpIHtcbiAgICByZXR1cm4gYFgnJHtoZXh9J2A7XG4gIH1cbiAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgfVxufVxuQkxPQi5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5jbGFzcyBSQU5HRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3Ioc3VidHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdChzdWJ0eXBlKSA/IHN1YnR5cGUgOiB7IHN1YnR5cGUgfTtcbiAgICBpZiAoIW9wdGlvbnMuc3VidHlwZSlcbiAgICAgIG9wdGlvbnMuc3VidHlwZSA9IG5ldyBJTlRFR0VSKCk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnN1YnR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb3B0aW9ucy5zdWJ0eXBlID0gbmV3IG9wdGlvbnMuc3VidHlwZSgpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJ0eXBlID0gb3B0aW9ucy5zdWJ0eXBlLmtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCByYW5nZVwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcihcIkEgcmFuZ2UgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBlbGVtZW50c1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFVVSUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHV1aWRcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFVVSURWMSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlKSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgdXVpZFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVVVJRFY0IGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUsIDQpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCB1dWlkdjRcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFZJUlRVQUwgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKFJldHVyblR5cGUsIGZpZWxkcykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBSZXR1cm5UeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBSZXR1cm5UeXBlID0gbmV3IFJldHVyblR5cGUoKTtcbiAgICB0aGlzLnJldHVyblR5cGUgPSBSZXR1cm5UeXBlO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICB9XG59XG5jbGFzcyBFTlVNIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbMF07XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUgfHwge1xuICAgICAgdmFsdWVzOiBhcmdzLnJlZHVjZSgocmVzdWx0LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KEFycmF5LmlzQXJyYXkoZWxlbWVudCkgPyBlbGVtZW50IDogW2VsZW1lbnRdKTtcbiAgICAgIH0sIFtdKVxuICAgIH07XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgY2hvaWNlIGluICVqXCIsIHZhbHVlLCB0aGlzLnZhbHVlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgQVJSQVkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSB0eXBlb2Ygb3B0aW9ucy50eXBlID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgb3B0aW9ucy50eXBlKCkgOiBvcHRpb25zLnR5cGU7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudHlwZS50b1NxbCgpfVtdYDtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgYXJyYXlcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RhdGljIGlzKG9iaiwgdHlwZSkge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBBUlJBWSAmJiBvYmoudHlwZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbn1cbmNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSwgc3JpZCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuc3JpZCA9IG9wdGlvbnMuc3JpZDtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBTVF9HZW9tRnJvbVRleHQoJHtvcHRpb25zLmVzY2FwZSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBTVF9HZW9tRnJvbVRleHQoJHtvcHRpb25zLmJpbmRQYXJhbSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxufVxuR0VPTUVUUlkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuY2xhc3MgR0VPR1JBUEhZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHR5cGUpID8gdHlwZSA6IHsgdHlwZSwgc3JpZCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIHRoaXMuc3JpZCA9IG9wdGlvbnMuc3JpZDtcbiAgfVxuICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBTVF9HZW9tRnJvbVRleHQoJHtvcHRpb25zLmVzY2FwZSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGBTVF9HZW9tRnJvbVRleHQoJHtvcHRpb25zLmJpbmRQYXJhbSh3a3guR2VvbWV0cnkucGFyc2VHZW9KU09OKHZhbHVlKS50b1drdCgpKX0pYDtcbiAgfVxufVxuR0VPR1JBUEhZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbmNsYXNzIENJRFIgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzSVBSYW5nZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgQ0lEUlwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgSU5FVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNJUCh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgSU5FVFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgTUFDQUREUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNNQUNBZGRyZXNzKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBNQUNBRERSXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBUU1ZFQ1RPUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZ1wiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgRGF0YVR5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCU1RSQUNULFxuICBTVFJJTkcsXG4gIENIQVIsXG4gIFRFWFQsXG4gIE5VTUJFUixcbiAgVElOWUlOVCxcbiAgU01BTExJTlQsXG4gIE1FRElVTUlOVCxcbiAgSU5URUdFUixcbiAgQklHSU5ULFxuICBGTE9BVCxcbiAgVElNRSxcbiAgREFURSxcbiAgREFURU9OTFksXG4gIEJPT0xFQU4sXG4gIE5PVyxcbiAgQkxPQixcbiAgREVDSU1BTCxcbiAgTlVNRVJJQzogREVDSU1BTCxcbiAgVVVJRCxcbiAgVVVJRFYxLFxuICBVVUlEVjQsXG4gIEhTVE9SRSxcbiAgSlNPTjogSlNPTlRZUEUsXG4gIEpTT05CLFxuICBWSVJUVUFMLFxuICBBUlJBWSxcbiAgRU5VTSxcbiAgUkFOR0UsXG4gIFJFQUwsXG4gIFwiRE9VQkxFIFBSRUNJU0lPTlwiOiBET1VCTEUsXG4gIERPVUJMRSxcbiAgR0VPTUVUUlksXG4gIEdFT0dSQVBIWSxcbiAgQ0lEUixcbiAgSU5FVCxcbiAgTUFDQUREUixcbiAgQ0lURVhULFxuICBUU1ZFQ1RPUlxufTtcbl8uZWFjaChEYXRhVHlwZXMsIChkYXRhVHlwZSwgbmFtZSkgPT4ge1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgXCJrZXlcIikpIHtcbiAgICBkYXRhVHlwZS50eXBlcyA9IHt9O1xuICAgIGRhdGFUeXBlLmtleSA9IGRhdGFUeXBlLnByb3RvdHlwZS5rZXkgPSBuYW1lO1xuICB9XG59KTtcbmNvbnN0IGRpYWxlY3RNYXAgPSB7fTtcbmRpYWxlY3RNYXAucG9zdGdyZXMgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm15c3FsID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5tYXJpYWRiID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbWFyaWFkYi9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLnNxbGl0ZSA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3NxbGl0ZS9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm1zc3FsID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbXNzcWwvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5kYjIgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9kYjIvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5zbm93Zmxha2UgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9zbm93Zmxha2UvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuZGlhbGVjdE1hcC5vcmFjbGUgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9vcmFjbGUvZGF0YS10eXBlc1wiKShEYXRhVHlwZXMpO1xuY29uc3QgZGlhbGVjdExpc3QgPSBPYmplY3QudmFsdWVzKGRpYWxlY3RNYXApO1xuZm9yIChjb25zdCBkYXRhVHlwZXMgb2YgZGlhbGVjdExpc3QpIHtcbiAgXy5lYWNoKGRhdGFUeXBlcywgKERhdGFUeXBlLCBrZXkpID0+IHtcbiAgICBpZiAoIURhdGFUeXBlLmtleSkge1xuICAgICAgRGF0YVR5cGUua2V5ID0gRGF0YVR5cGUucHJvdG90eXBlLmtleSA9IGtleTtcbiAgICB9XG4gIH0pO1xufVxuZm9yIChjb25zdCBkYXRhVHlwZXMgb2YgW0RhdGFUeXBlcywgLi4uZGlhbGVjdExpc3RdKSB7XG4gIF8uZWFjaChkYXRhVHlwZXMsIChEYXRhVHlwZSwga2V5KSA9PiB7XG4gICAgZGF0YVR5cGVzW2tleV0gPSBjbGFzc1RvSW52b2thYmxlKERhdGFUeXBlKTtcbiAgfSk7XG59XG5PYmplY3QuYXNzaWduKERhdGFUeXBlcywgZGlhbGVjdE1hcCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/deferrable.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/deferrable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { classToInvokable } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass ABSTRACT {\n  static toString(...args) {\n    return new this().toString(...args);\n  }\n  toString(...args) {\n    return this.toSql(...args);\n  }\n  toSql() {\n    throw new Error(\"toSql implementation missing\");\n  }\n}\nclass INITIALLY_DEFERRED extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY DEFERRED\";\n  }\n}\nclass INITIALLY_IMMEDIATE extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY IMMEDIATE\";\n  }\n}\nclass NOT extends ABSTRACT {\n  toSql() {\n    return \"NOT DEFERRABLE\";\n  }\n}\nclass SET_DEFERRED extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setDeferredQuery(this.constraints);\n  }\n}\nclass SET_IMMEDIATE extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setImmediateQuery(this.constraints);\n  }\n}\nconst Deferrable = {\n  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),\n  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),\n  NOT: classToInvokable(NOT),\n  SET_DEFERRED: classToInvokable(SET_DEFERRED),\n  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)\n};\nmodule.exports = Deferrable;\n//# sourceMappingURL=deferrable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDREQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzP2E0ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IGNsYXNzVG9JbnZva2FibGUgfSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY2xhc3MgQUJTVFJBQ1Qge1xuICBzdGF0aWMgdG9TdHJpbmcoLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgdGhpcygpLnRvU3RyaW5nKC4uLmFyZ3MpO1xuICB9XG4gIHRvU3RyaW5nKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy50b1NxbCguLi5hcmdzKTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b1NxbCBpbXBsZW1lbnRhdGlvbiBtaXNzaW5nXCIpO1xuICB9XG59XG5jbGFzcyBJTklUSUFMTFlfREVGRVJSRUQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIkRFRkVSUkFCTEUgSU5JVElBTExZIERFRkVSUkVEXCI7XG4gIH1cbn1cbmNsYXNzIElOSVRJQUxMWV9JTU1FRElBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIkRFRkVSUkFCTEUgSU5JVElBTExZIElNTUVESUFURVwiO1xuICB9XG59XG5jbGFzcyBOT1QgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIk5PVCBERUZFUlJBQkxFXCI7XG4gIH1cbn1cbmNsYXNzIFNFVF9ERUZFUlJFRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoY29uc3RyYWludHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBjb25zdHJhaW50cztcbiAgfVxuICB0b1NxbChxdWVyeUdlbmVyYXRvcikge1xuICAgIHJldHVybiBxdWVyeUdlbmVyYXRvci5zZXREZWZlcnJlZFF1ZXJ5KHRoaXMuY29uc3RyYWludHMpO1xuICB9XG59XG5jbGFzcyBTRVRfSU1NRURJQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICB9XG4gIHRvU3FsKHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIHF1ZXJ5R2VuZXJhdG9yLnNldEltbWVkaWF0ZVF1ZXJ5KHRoaXMuY29uc3RyYWludHMpO1xuICB9XG59XG5jb25zdCBEZWZlcnJhYmxlID0ge1xuICBJTklUSUFMTFlfREVGRVJSRUQ6IGNsYXNzVG9JbnZva2FibGUoSU5JVElBTExZX0RFRkVSUkVEKSxcbiAgSU5JVElBTExZX0lNTUVESUFURTogY2xhc3NUb0ludm9rYWJsZShJTklUSUFMTFlfSU1NRURJQVRFKSxcbiAgTk9UOiBjbGFzc1RvSW52b2thYmxlKE5PVCksXG4gIFNFVF9ERUZFUlJFRDogY2xhc3NUb0ludm9rYWJsZShTRVRfREVGRVJSRUQpLFxuICBTRVRfSU1NRURJQVRFOiBjbGFzc1RvSW52b2thYmxlKFNFVF9JTU1FRElBVEUpXG59O1xubW9kdWxlLmV4cG9ydHMgPSBEZWZlcnJhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXJyYWJsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/deferrable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ \"(rsc)/./node_modules/sequelize-pool/lib/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst debug = logger.debugContext(\"pool\");\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n    if (config.pool === false) {\n      throw new Error(\"Support for pool:false was removed in v4.0\");\n    }\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, (dataType) => {\n      if (Object.prototype.hasOwnProperty.call(dataType, \"parse\")) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return __webpack_require__(\"(rsc)/./node_modules/sequelize/lib/dialects/abstract sync recursive\")(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return __webpack_require__(\"(rsc)/./node_modules/sequelize/lib/dialects/abstract sync recursive\")(moduleName);\n    } catch (err) {\n      if (err.code === \"MODULE_NOT_FOUND\") {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n      throw err;\n    }\n  }\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n    await this.pool.drain();\n    debug(\"connection drain due to process exit\");\n    return await this.pool.destroyAllNow();\n  }\n  async close() {\n    this.getConnection = async function getConnection() {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    };\n    return await this._onProcessExit();\n  }\n  initPools() {\n    const config = this.config;\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: \"sequelize\",\n        create: () => this._connect(config),\n        destroy: async (connection) => {\n          const result = await this._disconnect(connection);\n          debug(\"connection destroy\");\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, \"replication\"));\n    config.replication.read = config.replication.read.map((readConfig) => _.defaults(readConfig, _.omit(this.config, \"replication\")));\n    let reads = 0;\n    this.pool = {\n      release: (client) => {\n        if (client.queryType === \"read\") {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === void 0 ? false : useMaster;\n        if (queryType === \"SELECT\" && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: (connection) => {\n        this.pool[connection.queryType].destroy(connection);\n        debug(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n        debug(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: \"sequelize:read\",\n        create: async () => {\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = \"read\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: \"sequelize:write\",\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = \"write\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  async getConnection(options) {\n    options = options || {};\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = { connection };\n            _options.logging = () => {\n            };\n            _options.logging.__testLoggingFn = true;\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), \"version\") || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n    let result;\n    try {\n      await this.sequelize.runHooks(\"beforePoolAcquire\", options);\n      result = await this.pool.acquire(options.type, options.useMaster);\n      await this.sequelize.runHooks(\"afterPoolAcquire\", result, options);\n    } catch (error) {\n      if (error instanceof TimeoutError)\n        throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n    debug(\"connection acquired\");\n    return result;\n  }\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug(\"connection released\");\n  }\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n  async _connect(config) {\n    await this.sequelize.runHooks(\"beforeConnect\", config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks(\"afterConnect\", connection, config);\n    return connection;\n  }\n  async _disconnect(connection) {\n    await this.sequelize.runHooks(\"beforeDisconnect\", connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks(\"afterDisconnect\", connection);\n  }\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZELFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3JDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1FQUFtRSxjQUFjLGFBQWEsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJGQUFRLHVDQUF1QyxDQUFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyRkFBUSxVQUFVLENBQUM7QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLGdCQUFnQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlci5qcz9mMGI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBQb29sLCBUaW1lb3V0RXJyb3IgfSA9IHJlcXVpcmUoXCJzZXF1ZWxpemUtcG9vbFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IGVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbnNcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJwb29sXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBjb25zdCBjb25maWcgPSBfLmNsb25lRGVlcChzZXF1ZWxpemUuY29uZmlnKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLmRpYWxlY3QgPSBkaWFsZWN0O1xuICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuZGlhbGVjdE5hbWUgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3Q7XG4gICAgaWYgKGNvbmZpZy5wb29sID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcG9ydCBmb3IgcG9vbDpmYWxzZSB3YXMgcmVtb3ZlZCBpbiB2NC4wXCIpO1xuICAgIH1cbiAgICBjb25maWcucG9vbCA9IF8uZGVmYXVsdHMoY29uZmlnLnBvb2wgfHwge30sIHtcbiAgICAgIG1heDogNSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGlkbGU6IDFlNCxcbiAgICAgIGFjcXVpcmU6IDZlNCxcbiAgICAgIGV2aWN0OiAxZTMsXG4gICAgICB2YWxpZGF0ZTogdGhpcy5fdmFsaWRhdGUuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuaW5pdFBvb2xzKCk7XG4gIH1cbiAgcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzKSB7XG4gICAgXy5lYWNoKGRhdGFUeXBlcywgKGRhdGFUeXBlKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCBcInBhcnNlXCIpKSB7XG4gICAgICAgIGlmIChkYXRhVHlwZS50eXBlc1t0aGlzLmRpYWxlY3ROYW1lXSkge1xuICAgICAgICAgIHRoaXMuX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnNlIGZ1bmN0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJHtkYXRhVHlwZS5rZXl9IGluIGRpYWxlY3QgJHt0aGlzLmRpYWxlY3ROYW1lfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2xvYWREaWFsZWN0TW9kdWxlKG1vZHVsZU5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXF1aXJlKG1vZHVsZU5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBcIk1PRFVMRV9OT1RfRk9VTkRcIikge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBkaWFsZWN0IGF0ICR7dGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGxlYXNlIGluc3RhbGwgJHttb2R1bGVOYW1lfSBwYWNrYWdlIG1hbnVhbGx5YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9vblByb2Nlc3NFeGl0KCkge1xuICAgIGlmICghdGhpcy5wb29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMucG9vbC5kcmFpbigpO1xuICAgIGRlYnVnKFwiY29ubmVjdGlvbiBkcmFpbiBkdWUgdG8gcHJvY2VzcyBleGl0XCIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnBvb2wuZGVzdHJveUFsbE5vdygpO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHRoaXMuZ2V0Q29ubmVjdGlvbiA9IGFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uIHdhcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gbWFuYWdlciB3YXMgY2xvc2VkIVwiKTtcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9vblByb2Nlc3NFeGl0KCk7XG4gIH1cbiAgaW5pdFBvb2xzKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghY29uZmlnLnJlcGxpY2F0aW9uKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6IFwic2VxdWVsaXplXCIsXG4gICAgICAgIGNyZWF0ZTogKCkgPT4gdGhpcy5fY29ubmVjdChjb25maWcpLFxuICAgICAgICBkZXN0cm95OiBhc3luYyAoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGRlc3Ryb3lcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSk7XG4gICAgICBkZWJ1ZyhgcG9vbCBjcmVhdGVkIHdpdGggbWF4L21pbjogJHtjb25maWcucG9vbC5tYXh9LyR7Y29uZmlnLnBvb2wubWlufSwgbm8gcmVwbGljYXRpb25gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkKSkge1xuICAgICAgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQgPSBbY29uZmlnLnJlcGxpY2F0aW9uLnJlYWRdO1xuICAgIH1cbiAgICBjb25maWcucmVwbGljYXRpb24ud3JpdGUgPSBfLmRlZmF1bHRzKGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSwgXy5vbWl0KGNvbmZpZywgXCJyZXBsaWNhdGlvblwiKSk7XG4gICAgY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQgPSBjb25maWcucmVwbGljYXRpb24ucmVhZC5tYXAoKHJlYWRDb25maWcpID0+IF8uZGVmYXVsdHMocmVhZENvbmZpZywgXy5vbWl0KHRoaXMuY29uZmlnLCBcInJlcGxpY2F0aW9uXCIpKSk7XG4gICAgbGV0IHJlYWRzID0gMDtcbiAgICB0aGlzLnBvb2wgPSB7XG4gICAgICByZWxlYXNlOiAoY2xpZW50KSA9PiB7XG4gICAgICAgIGlmIChjbGllbnQucXVlcnlUeXBlID09PSBcInJlYWRcIikge1xuICAgICAgICAgIHRoaXMucG9vbC5yZWFkLnJlbGVhc2UoY2xpZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBvb2wud3JpdGUucmVsZWFzZShjbGllbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWNxdWlyZTogKHF1ZXJ5VHlwZSwgdXNlTWFzdGVyKSA9PiB7XG4gICAgICAgIHVzZU1hc3RlciA9IHVzZU1hc3RlciA9PT0gdm9pZCAwID8gZmFsc2UgOiB1c2VNYXN0ZXI7XG4gICAgICAgIGlmIChxdWVyeVR5cGUgPT09IFwiU0VMRUNUXCIgJiYgIXVzZU1hc3Rlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBvb2wucmVhZC5hY3F1aXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbC53cml0ZS5hY3F1aXJlKCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogKGNvbm5lY3Rpb24pID0+IHtcbiAgICAgICAgdGhpcy5wb29sW2Nvbm5lY3Rpb24ucXVlcnlUeXBlXS5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gZGVzdHJveVwiKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95QWxsTm93OiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICB0aGlzLnBvb2wucmVhZC5kZXN0cm95QWxsTm93KCksXG4gICAgICAgICAgdGhpcy5wb29sLndyaXRlLmRlc3Ryb3lBbGxOb3coKVxuICAgICAgICBdKTtcbiAgICAgICAgZGVidWcoXCJhbGwgY29ubmVjdGlvbnMgZGVzdHJveWVkXCIpO1xuICAgICAgfSxcbiAgICAgIGRyYWluOiBhc3luYyAoKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucG9vbC53cml0ZS5kcmFpbigpLFxuICAgICAgICB0aGlzLnBvb2wucmVhZC5kcmFpbigpXG4gICAgICBdKSxcbiAgICAgIHJlYWQ6IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogXCJzZXF1ZWxpemU6cmVhZFwiLFxuICAgICAgICBjcmVhdGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXh0UmVhZCA9IHJlYWRzKysgJSBjb25maWcucmVwbGljYXRpb24ucmVhZC5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QoY29uZmlnLnJlcGxpY2F0aW9uLnJlYWRbbmV4dFJlYWRdKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5VHlwZSA9IFwicmVhZFwiO1xuICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoY29ubmVjdGlvbikgPT4gdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSksXG4gICAgICB3cml0ZTogbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiBcInNlcXVlbGl6ZTp3cml0ZVwiLFxuICAgICAgICBjcmVhdGU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdChjb25maWcucmVwbGljYXRpb24ud3JpdGUpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnlUeXBlID0gXCJ3cml0ZVwiO1xuICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoY29ubmVjdGlvbikgPT4gdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKSxcbiAgICAgICAgdmFsaWRhdGU6IGNvbmZpZy5wb29sLnZhbGlkYXRlLFxuICAgICAgICBtYXg6IGNvbmZpZy5wb29sLm1heCxcbiAgICAgICAgbWluOiBjb25maWcucG9vbC5taW4sXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5hY3F1aXJlLFxuICAgICAgICBpZGxlVGltZW91dE1pbGxpczogY29uZmlnLnBvb2wuaWRsZSxcbiAgICAgICAgcmVhcEludGVydmFsTWlsbGlzOiBjb25maWcucG9vbC5ldmljdCxcbiAgICAgICAgbWF4VXNlczogY29uZmlnLnBvb2wubWF4VXNlc1xuICAgICAgfSlcbiAgICB9O1xuICAgIGRlYnVnKGBwb29sIGNyZWF0ZWQgd2l0aCBtYXgvbWluOiAke2NvbmZpZy5wb29sLm1heH0vJHtjb25maWcucG9vbC5taW59LCB3aXRoIHJlcGxpY2F0aW9uYCk7XG4gIH1cbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMudmVyc2lvblByb21pc2UpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KHRoaXMuY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlIHx8IHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IF9vcHRpb25zID0ge307XG4gICAgICAgICAgICBfb3B0aW9ucy50cmFuc2FjdGlvbiA9IHsgY29ubmVjdGlvbiB9O1xuICAgICAgICAgICAgX29wdGlvbnMubG9nZ2luZyA9ICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfb3B0aW9ucy5sb2dnaW5nLl9fdGVzdExvZ2dpbmdGbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLmRhdGFiYXNlVmVyc2lvbihfb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZlcnNpb24gPSBfLmdldChzZW12ZXIuY29lcmNlKHZlcnNpb24pLCBcInZlcnNpb25cIikgfHwgdmVyc2lvbjtcbiAgICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIudmFsaWQocGFyc2VkVmVyc2lvbikgPyBwYXJzZWRWZXJzaW9uIDogdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbXZlci5sdCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiwgdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uKSkge1xuICAgICAgICAgICAgICBkZXByZWNhdGlvbnMudW5zdXBwb3J0ZWRFbmdpbmUoKTtcbiAgICAgICAgICAgICAgZGVidWcoYFVuc3VwcG9ydGVkIGRhdGFiYXNlIGVuZ2luZSB2ZXJzaW9uICR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy52ZXJzaW9uUHJvbWlzZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJiZWZvcmVQb29sQWNxdWlyZVwiLCBvcHRpb25zKTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucG9vbC5hY3F1aXJlKG9wdGlvbnMudHlwZSwgb3B0aW9ucy51c2VNYXN0ZXIpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJhZnRlclBvb2xBY3F1aXJlXCIsIHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFRpbWVvdXRFcnJvcilcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5Db25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvcihlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgIHRoaXMucG9vbC5yZWxlYXNlKGNvbm5lY3Rpb24pO1xuICAgIGRlYnVnKFwiY29ubmVjdGlvbiByZWxlYXNlZFwiKTtcbiAgfVxuICBhc3luYyBkZXN0cm95Q29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgYXdhaXQgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgZGVidWcoYGNvbm5lY3Rpb24gJHtjb25uZWN0aW9uLnV1aWR9IGRlc3Ryb3llZGApO1xuICB9XG4gIGFzeW5jIF9jb25uZWN0KGNvbmZpZykge1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYmVmb3JlQ29ubmVjdFwiLCBjb25maWcpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdChjb25maWcpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYWZ0ZXJDb25uZWN0XCIsIGNvbm5lY3Rpb24sIGNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cbiAgYXN5bmMgX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYmVmb3JlRGlzY29ubmVjdFwiLCBjb25uZWN0aW9uKTtcbiAgICBhd2FpdCB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJhZnRlckRpc2Nvbm5lY3RcIiwgY29ubmVjdGlvbik7XG4gIH1cbiAgX3ZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci52YWxpZGF0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpYWxlY3QuY29ubmVjdGlvbk1hbmFnZXIudmFsaWRhdGUoY29ubmVjdGlvbik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass AbstractDialect {\n  canBackslashEscape() {\n    return false;\n  }\n}\nAbstractDialect.prototype.supports = {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ON DUPLICATE KEY\": true,\n  \"ORDER NULLS\": false,\n  \"UNION\": true,\n  \"UNION ALL\": true,\n  \"RIGHT JOIN\": true,\n  returnValues: false,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: true,\n    update: true\n  },\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: \"\",\n    updateOnDuplicate: false,\n    onConflictDoNothing: \"\",\n    onConflictWhere: false,\n    conflictFields: false\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false,\n    operator: false\n  },\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false,\n  escapeStringConstants: false\n};\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports[\"default\"] = AbstractDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9pbmRleC5qcz9hMjk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY2xhc3MgQWJzdHJhY3REaWFsZWN0IHtcbiAgY2FuQmFja3NsYXNoRXNjYXBlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IHtcbiAgXCJERUZBVUxUXCI6IHRydWUsXG4gIFwiREVGQVVMVCBWQUxVRVNcIjogZmFsc2UsXG4gIFwiVkFMVUVTICgpXCI6IGZhbHNlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiBmYWxzZSxcbiAgXCJPTiBEVVBMSUNBVEUgS0VZXCI6IHRydWUsXG4gIFwiT1JERVIgTlVMTFNcIjogZmFsc2UsXG4gIFwiVU5JT05cIjogdHJ1ZSxcbiAgXCJVTklPTiBBTExcIjogdHJ1ZSxcbiAgXCJSSUdIVCBKT0lOXCI6IHRydWUsXG4gIHJldHVyblZhbHVlczogZmFsc2UsXG4gIGF1dG9JbmNyZW1lbnQ6IHtcbiAgICBpZGVudGl0eUluc2VydDogZmFsc2UsXG4gICAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICAgIHVwZGF0ZTogdHJ1ZVxuICB9LFxuICBidWxrRGVmYXVsdDogZmFsc2UsXG4gIHNjaGVtYXM6IGZhbHNlLFxuICB0cmFuc2FjdGlvbnM6IHRydWUsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiB0cnVlLFxuICB0cmFuc2FjdGlvbk9wdGlvbnM6IHtcbiAgICB0eXBlOiBmYWxzZVxuICB9LFxuICBtaWdyYXRpb25zOiB0cnVlLFxuICB1cHNlcnRzOiB0cnVlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogXCJcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogZmFsc2UsXG4gICAgb25Db25mbGljdERvTm90aGluZzogXCJcIixcbiAgICBvbkNvbmZsaWN0V2hlcmU6IGZhbHNlLFxuICAgIGNvbmZsaWN0RmllbGRzOiBmYWxzZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiB0cnVlLFxuICAgIGFkZENvbnN0cmFpbnQ6IHRydWUsXG4gICAgZHJvcENvbnN0cmFpbnQ6IHRydWUsXG4gICAgdW5pcXVlOiB0cnVlLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIGNoZWNrOiB0cnVlLFxuICAgIGZvcmVpZ25LZXk6IHRydWUsXG4gICAgcHJpbWFyeUtleTogdHJ1ZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IHRydWUsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIGNvbmN1cnJlbnRseTogZmFsc2UsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgdXNpbmc6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogZmFsc2UsXG4gICAgb3BlcmF0b3I6IGZhbHNlXG4gIH0sXG4gIGdyb3VwZWRMaW1pdDogdHJ1ZSxcbiAgaW5kZXhWaWFBbHRlcjogZmFsc2UsXG4gIEpTT046IGZhbHNlLFxuICBkZWZlcnJhYmxlQ29uc3RyYWludHM6IGZhbHNlLFxuICBlc2NhcGVTdHJpbmdDb25zdGFudHM6IGZhbHNlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdERpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5BYnN0cmFjdERpYWxlY3QgPSBBYnN0cmFjdERpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3REaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Model = __webpack_require__(/*! ../../model */ \"(rsc)/./node_modules/sequelize/lib/model.js\");\nconst Association = __webpack_require__(/*! ../../associations/base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst HasMany = __webpack_require__(/*! ../../associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst sequelizeError = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst IndexHints = __webpack_require__(/*! ../../index-hints */ \"(rsc)/./node_modules/sequelize/lib/index-hints.js\");\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize)\n      throw new Error(\"QueryGenerator initialized without options.sequelize\");\n    if (!options._dialect)\n      throw new Error(\"QueryGenerator initialized without options._dialect\");\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n    this._initQuoteIdentifier();\n  }\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || this.options.schema || \"public\",\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || \".\"\n    };\n  }\n  addSchema(param) {\n    if (!param._schema)\n      return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || \".\",\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `DESCRIBE ${table};`;\n  }\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n  populateInsertQueryReturnIntoBinds() {\n  }\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n    const modelAttributeMap = {};\n    const bind = options.bind || [];\n    const fields = [];\n    const returningModelAttributes = [];\n    const returnTypes = [];\n    const values = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    const returnAttributes = [];\n    let query;\n    let valueQuery = \"\";\n    let emptyQuery = \"\";\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let identityWrapperRequired = false;\n    let tmpTable = \"\";\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    if (this._dialect.supports[\"DEFAULT VALUES\"]) {\n      emptyQuery += \" DEFAULT VALUES\";\n    } else if (this._dialect.supports[\"VALUES ()\"]) {\n      emptyQuery += \" VALUES ()\";\n    }\n    if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n      returningModelAttributes.push(...returnValues.returnFields);\n      if (this._dialect.supports.returnIntoValues) {\n        returnTypes.push(...returnValues.returnTypes);\n      }\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n    }\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      options.bindParam = false;\n    }\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push(\"DEFAULT\");\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }, bindParam));\n          }\n        }\n      }\n    }\n    let onDuplicateKeyUpdate = \"\";\n    if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {\n      throw new Error(\"missing dialect support for conflictWhere option\");\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        const fragments = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\"\n        ];\n        if (!_.isEmpty(options.conflictWhere)) {\n          fragments.push(this.whereQuery(options.conflictWhere, options));\n        }\n        if (_.isEmpty(updateKeys)) {\n          fragments.push(\"DO NOTHING\");\n        } else {\n          fragments.push(\"DO UPDATE SET\", updateKeys.join(\",\"));\n        }\n        onDuplicateKeyUpdate = ` ${Utils.joinSQLFragments(fragments)}`;\n      } else {\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        if (_.isEmpty(valueKeys) && options.upsertKeys) {\n          valueKeys.push(...options.upsertKeys.map((attr) => `${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));\n        }\n        if (_.isEmpty(valueKeys)) {\n          throw new Error(\"No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.\");\n        }\n        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\",\n      attributes: fields.join(\",\"),\n      output: outputFragment,\n      values: values.join(\",\"),\n      tmpTable\n    };\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = \"DROP FUNCTION IF EXISTS pg_temp.testfunc()\";\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push(\"*\");\n      }\n      const delimiter = `$func_${uuidv4().replace(/-/g, \"\")}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(\", (testfunc.response).\")}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n      options.exception = \"WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;\";\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n    if (this._dialect.supports.returnIntoValues && options.returning) {\n      this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);\n    }\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery}${returnAttributes.join(\",\")};`;\n    if (this._dialect.supports.finalTable) {\n      query = `SELECT * FROM FINAL TABLE(${replacements.attributes.length ? valueQuery : emptyQuery});`;\n    }\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = \"\";\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {\n          serials[key] = true;\n        }\n      });\n    }\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map((key) => {\n        if (this._dialect.supports.bulkDefault && serials[key] === true) {\n          return fieldValueHash[key] != null ? fieldValueHash[key] : \"DEFAULT\";\n        }\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" });\n      });\n      tuples.push(`(${values.join(\",\")})`);\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        let whereClause = false;\n        if (options.conflictWhere) {\n          if (!this._dialect.supports.inserts.onConflictWhere) {\n            throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n          }\n          whereClause = this.whereQuery(options.conflictWhere, options);\n        }\n        onDuplicateKeyUpdate = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\",\n          whereClause,\n          \"DO UPDATE SET\",\n          updateKeys.join(\",\")\n        ];\n      } else {\n        if (options.conflictWhere) {\n          throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n        }\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\";\n    const attributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\";\n    let returning = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n      returning += returnValues.returningFragment;\n    }\n    return Utils.joinSQLFragments([\n      \"INSERT\",\n      ignoreDuplicates,\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      \"VALUES\",\n      tuples.join(\",\"),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      \";\"\n    ]);\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = \"\";\n    let tmpTable = \"\";\n    let suffix = \"\";\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    if (this._dialect.supports[\"LIMIT ON UPDATE\"] && options.limit) {\n      if (![\"mssql\", \"db2\", \"oracle\"].includes(this.dialect)) {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      } else if (this.dialect === \"oracle\") {\n        if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {\n          suffix += \" AND \";\n        } else {\n          suffix += \" WHERE \";\n        }\n        suffix += `rownum <= ${this.escape(options.limit)} `;\n      }\n    }\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n      if (!this._dialect.supports.returnValues.output && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {\n        continue;\n      }\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (values.length === 0) {\n      return \"\";\n    }\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n    return Utils.joinSQLFragments([\n      \"UPDATE\",\n      this.quoteTable(tableName),\n      \"SET\",\n      updateSetSqlFragments.join(\",\"),\n      outputFragment,\n      this.whereQuery(where),\n      returningFragment\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = void 0;\n    } else {\n      options.fields = attributes;\n    }\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === \"string\") {\n      options.prefix = options.prefix.replace(/\\./g, \"_\");\n      options.prefix = options.prefix.replace(/(\"|')/g, \"\");\n    }\n    const fieldsSql = options.fields.map((field) => {\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (typeof field === \"string\") {\n        field = {\n          name: field\n        };\n      }\n      let result = \"\";\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n      result += this.quoteIdentifier(field.name);\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n      if (this._dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n      return result;\n    });\n    if (!options.name) {\n      options = Utils.nameIndex(options, options.prefix);\n    }\n    options = Model._conformIndex(options);\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? \"CONCURRENTLY\" : void 0;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        \"ALTER TABLE\",\n        tableName,\n        concurrently,\n        \"ADD\"\n      ];\n    } else {\n      ind = [\"CREATE\"];\n    }\n    ind = ind.concat(options.unique ? \"UNIQUE\" : \"\", options.type, \"INDEX\", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : \"\", !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : void 0, this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : \"\", `(${fieldsSql.join(\", \")})`, this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);\n    return _.compact(ind).join(\" \");\n  }\n  addConstraintQuery(tableName, options) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"ADD\",\n      this.getConstraintSnippet(tableName, options || {}),\n      \";\"\n    ]);\n  }\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n    const fieldsSql = options.fields.map((field) => {\n      if (typeof field === \"string\") {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n      return this.quoteIdentifier(field.name);\n    });\n    const fieldsSqlQuotedString = fieldsSql.join(\", \");\n    const fieldsSqlString = fieldsSql.join(\"_\");\n    switch (options.type.toUpperCase()) {\n      case \"UNIQUE\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case \"CHECK\":\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case \"DEFAULT\":\n        if (options.defaultValue === void 0) {\n          throw new Error(\"Default value must be specified for DEFAULT CONSTRAINT\");\n        }\n        if (this._dialect.name !== \"mssql\") {\n          throw new Error(\"Default constraints are supported only for MSSQL dialect.\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case \"PRIMARY KEY\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case \"FOREIGN KEY\":\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error(\"references object with table and field must be specified\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences = typeof references.field !== \"undefined\" ? this.quoteIdentifier(references.field) : references.fields.map((f) => this.quoteIdentifier(f)).join(\", \");\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default:\n        throw new Error(`${options.type} is invalid.`);\n    }\n    if (options.deferrable && [\"UNIQUE\", \"PRIMARY KEY\", \"FOREIGN KEY\"].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n    return constraintSnippet;\n  }\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifiers(constraintName)\n    ]);\n  }\n  quote(collection, parent, connector) {\n    const validOrderOptions = [\n      \"ASC\",\n      \"DESC\",\n      \"ASC NULLS LAST\",\n      \"DESC NULLS LAST\",\n      \"ASC NULLS FIRST\",\n      \"DESC NULLS FIRST\",\n      \"NULLS FIRST\",\n      \"NULLS LAST\"\n    ];\n    connector = connector || \".\";\n    if (typeof collection === \"string\") {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      collection.forEach((item2, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n        if (!previous && parent !== void 0) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n          if (typeof item2 === \"function\" && item2.prototype instanceof Model) {\n            model = item2;\n          } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {\n            model = item2.model;\n            as = item2.as;\n          }\n          if (model) {\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              item2 = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              item2 = previousModel.getAssociationForAlias(model, as);\n              if (!item2) {\n                item2 = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n            if (!(item2 instanceof Association)) {\n              throw new Error(util.format(\"Unable to find a valid association for model, '%s'\", model.name));\n            }\n          }\n        }\n        if (typeof item2 === \"string\") {\n          const orderIndex = validOrderOptions.indexOf(item2.toUpperCase());\n          if (index > 0 && orderIndex !== -1) {\n            item2 = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            if (previousModel.associations !== void 0 && previousModel.associations[item2]) {\n              item2 = previousModel.associations[item2];\n            } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {\n              item2 = previousModel.rawAttributes[item2].field;\n            } else if (item2.includes(\".\") && previousModel.rawAttributes !== void 0) {\n              const itemSplit = item2.split(\".\");\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n                const path = itemSplit.slice(1);\n                item2 = this.jsonPathExtractionQuery(identifier, path);\n                item2 = this.sequelize.literal(item2);\n              }\n            }\n          }\n        }\n        collection[index] = item2;\n      }, this);\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === \"string\" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n      let sql = \"\";\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === \"string\" && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n      collection.slice(i).forEach((collectionItem) => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n  _initQuoteIdentifier() {\n    this._quoteIdentifier = this.quoteIdentifier;\n    this.quoteIdentifier = function(identifier, force) {\n      if (identifier === \"*\")\n        return identifier;\n      return this._quoteIdentifier(identifier, force);\n    };\n  }\n  quoteIdentifier(identifier, force) {\n    throw new Error(`quoteIdentifier for Dialect \"${this.dialect}\" is not implemented`);\n  }\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes(\".\")) {\n      identifiers = identifiers.split(\".\");\n      const head = identifiers.slice(0, identifiers.length - 1).join(\"->\");\n      const tail = identifiers[identifiers.length - 1];\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n    return this.quoteIdentifier(identifiers);\n  }\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n  getAliasToken() {\n    return \"AS\";\n  }\n  quoteTable(param, alias) {\n    let table = \"\";\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || \".\");\n        }\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n    if (alias) {\n      table += ` ${this.getAliasToken()} ${this.quoteIdentifier(alias)}`;\n    }\n    return table;\n  }\n  escape(value, field, options) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        if (field.type instanceof DataTypes.STRING && [\"mysql\", \"mariadb\"].includes(this.dialect) && [\"number\", \"boolean\"].includes(typeof value)) {\n          value = String(Number(value));\n        }\n        this.validate(value, field, options);\n        if (field.type.stringify) {\n          const simpleEscape = (escVal) => SqlString.escape(escVal, this.options.timezone, this.dialect);\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n          if (field.type.escape === false) {\n            return value;\n          }\n        }\n      }\n    }\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n  bindParam(bind) {\n    return (value) => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n  format(value, field, options, bindParam) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error(\"Cannot pass SequelizeMethod as a bind parameter - use escape instead\");\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n    return bindParam(value);\n  }\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(error.message, \"Validation error\", field.fieldName, value, null, `${field.type.key} validator`));\n        }\n        throw error;\n      }\n    }\n  }\n  isIdentifierQuoted(identifier) {\n    return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n  }\n  jsonPathExtractionQuery(column, path, isJson) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    switch (this.dialect) {\n      case \"mysql\":\n      case \"mariadb\":\n      case \"sqlite\":\n        if (this.dialect === \"mysql\") {\n          paths = paths.map((subPath) => {\n            return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n          });\n        }\n        pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n        if (this.dialect === \"sqlite\") {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n      case \"postgres\":\n        const join = isJson ? \"#>\" : \"#>>\";\n        pathStr = this.escape(`{${paths.join(\",\")}}`);\n        return `(${quotedColumn}${join}${pathStr})`;\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = /* @__PURE__ */ new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = /* @__PURE__ */ new Map();\n    }\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map((t) => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(\", \");\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        if (!attributes.main.some((attr) => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : [\"*\"]);\n    if (subQuery || options.groupedLimit) {\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(\"\"));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = __spreadValues({}, options.where);\n        let groupedLimitOrder, whereKey, include, groupedTableName = mainTable.as;\n        if (typeof options.groupedLimit.on === \"string\") {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false,\n              required: true,\n              where: __spreadValues({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n          if (Array.isArray(options.order)) {\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n              alias = this.sequelize.literal(this.quote(alias));\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          groupedLimitOrder = options.order;\n          if (!this._dialect.supports.topLevelOrderByRequired) {\n            delete options.order;\n          }\n          where[Op.placeholder] = true;\n        }\n        const baseQuery = `SELECT * FROM (${this.selectQuery(tableName, {\n          attributes: options.attributes,\n          offset: options.offset,\n          limit: options.groupedLimit.limit,\n          order: groupedLimitOrder,\n          aliasesMapping: options.aliasesMapping,\n          aliasesByTable: options.aliasesByTable,\n          where,\n          include,\n          model\n        }, model).replace(/;$/, \"\")}) ${this.getAliasToken()} sub`;\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${options.groupedLimit.values.map((value) => {\n          let groupWhere;\n          if (whereKey) {\n            groupWhere = {\n              [whereKey]: value\n            };\n          }\n          if (include) {\n            groupWhere = {\n              [options.groupedLimit.on.foreignIdentifierField]: value\n            };\n          }\n          return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n        }).join(this._dialect.supports[\"UNION ALL\"] ? \" UNION ALL \" : \" UNION \")})`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n      mainQueryItems.push(mainJoinQueries.join(\"\"));\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"where\") && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith(\"SELECT\")) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map((t) => this.aliasGrouping(t, model, mainTable.as, options)).join(\", \") : this.aliasGrouping(options.group, model, mainTable.as, options);\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"having\")) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(\", \")}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(\", \")}`);\n      }\n    }\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });\n      query = `SELECT ${attributes.main.join(\", \")} FROM (${subQueryItems.join(\"\")}) ${this.getAliasToken()} ${mainTable.as}${mainJoinQueries.join(\"\")}${mainQueryItems.join(\"\")}`;\n    } else {\n      query = mainQueryItems.join(\"\");\n    }\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === \"object\") {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && [\"KEY SHARE\", \"NO KEY UPDATE\"].includes(lock)) {\n        query += ` FOR ${lock}`;\n      } else if (lock === \"SHARE\") {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += \" FOR UPDATE\";\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += \" SKIP LOCKED\";\n      }\n    }\n    return `${query};`;\n  }\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map((attr) => {\n      let addTable = true;\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (this.options.attributeBehavior === \"escape\" || !attr[0].includes(\"(\") && !attr[0].includes(\")\")) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else if (this.options.attributeBehavior !== \"unsafe-legacy\") {\n          throw new Error(`Attributes cannot include parentheses in Sequelize 6:\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\nSequelize 7 escapes all attributes, even if they include parentheses.\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\n\nHere is what you can do to fix this error:\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\n- Set the \"attributeBehavior\" sequelize option to \"escape\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\n- Set the \"attributeBehavior\" sequelize option to \"unsafe-legacy\" to make Sequelize escape the attribute, like in Sequelize v5.\n\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\nhttps://github.com/sequelize/sequelize/discussions/15694`);\n        }\n        let alias = attr[1];\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n        attr = [attr[0], this.quoteIdentifier(alias)].join(\" AS \");\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"') ? this.quoteAttribute(attr, options.model) : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && (!attr.includes(\".\") || options.dotNotation) && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n      return attr;\n    });\n  }\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n    topLevelInfo.options.keysEscaped = true;\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n      const includeAttributes = include.attributes.map((attr) => {\n        let attrAs = attr;\n        let verbatim = false;\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {\n            verbatim = true;\n          }\n          attr = attr.map((attr2) => attr2 instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr2) : attr2);\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val;\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\"Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance\");\n        }\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, \"\")})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else if (/json_value\\(/.test(attr)) {\n          prefix = attr.replace(/json_value\\(/i, `json_value(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n        return Utils.joinSQLFragments([\n          prefix,\n          \"AS\",\n          this.quoteIdentifier(alias, true)\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n    }\n    return {\n      mainQuery: joinQueries.mainQuery.join(\"\"),\n      subQuery: joinQueries.subQuery.join(\"\"),\n      attributes\n    };\n  }\n  _getMinifiedAlias(alias, tableName, options) {\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n    return minifiedAlias;\n  }\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;\n    let asRight = include.as;\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n    if (!asLeft)\n      asLeft = parent.as || parent.model.name;\n    else\n      asRight = `${asLeft}->${asRight}`;\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, \".\")}.${attrLeft}`;\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n    this.aliasAs(asRight, topLevelInfo);\n    return {\n      join: include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\",\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let tmpTable = \"\";\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map((field) => this.quoteIdentifier(field)));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, (attribute) => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n    if (_.isEmpty(returnFields)) {\n      returnFields.push(\"*\");\n    }\n    if (this._dialect.supports.returnValues.returning) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")}`;\n    } else if (this._dialect.supports.returnIntoValues) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")} INTO `;\n    } else if (this._dialect.supports.returnValues.output) {\n      outputFragment = ` OUTPUT ${returnFields.map((field) => `INSERTED.${field}`).join(\",\")}`;\n      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(\",\")}); `;\n        outputFragment += \" INTO @tmp\";\n        returningFragment = \"; SELECT * FROM @tmp\";\n      }\n    }\n    return { outputFragment, returnFields, returnTypes, returningFragment, tmpTable };\n  }\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map((attr) => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n      return Utils.joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        \"AS\",\n        this.quoteIdentifier(alias)\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n    const joinType = include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\";\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n    this.aliasAs(includeAs.internalAs, topLevelInfo);\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n    joinBody += \")\";\n    joinCondition = sourceJoinOn;\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n  aliasAs(as, topLevelInfo) {\n    if (this.options.minifyAliases && as.length >= 64) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n      topLevelInfo.options.includeAliases.set(alias, as);\n    }\n  }\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n    while (parent = parent.parent) {\n      if (parent.parent && !parent.required) {\n        return;\n      }\n      if (parent.subQueryFilter) {\n        return;\n      }\n      nestedIncludes = [__spreadProps(__spreadValues({}, child), { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = void 0;\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(\" = \")),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === \"BelongsTo\";\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(\" = \");\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      \"(\",\n      query.replace(/;$/, \"\"),\n      \")\",\n      \"IS NOT NULL\"\n    ].join(\" \"));\n  }\n  _getRequiredClosure(include) {\n    const copy = __spreadProps(__spreadValues({}, include), { attributes: [], include: [] });\n    if (Array.isArray(include.include)) {\n      copy.include = include.include.filter((i) => i.required).map((inc) => this._getRequiredClosure(inc));\n    }\n    return copy;\n  }\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n        if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === \"function\" && order[0].prototype instanceof Model) && !(typeof order[0].model === \"function\" && order[0].model.prototype instanceof Model) && !(typeof order[0] === \"string\" && model && model.associations !== void 0 && model.associations[order[0]])) {\n          const field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];\n          const subQueryAlias = this._getAliasForField(this.quoteIdentifier(model.name), field, options);\n          let parent = null;\n          let orderToQuote = [];\n          if (subQueryAlias === null) {\n            orderToQuote = order;\n            parent = model;\n          } else {\n            orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : \"ASC\"];\n            parent = null;\n          }\n          subQueryOrder.push(this.quote(orderToQuote, parent, \"->\"));\n        }\n        if (options.attributes && model) {\n          const aliasedAttribute = options.attributes.find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]));\n          if (aliasedAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n            const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n            order[0] = new Utils.Col(alias || aliasedAttribute[1]);\n          }\n        }\n        mainQueryOrder.push(this.quote(order, model, \"->\"));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, \"->\");\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error(\"Order must be type of array or instance of a valid sequelize method.\");\n    }\n    return { mainQueryOrder, subQueryOrder };\n  }\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0)\n      return;\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || \"\";\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || \"\";\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, \" \"));\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    let fragment = `SELECT ${attributes.join(\", \")} FROM ${tables}`;\n    if (mainTableAs) {\n      fragment += ` ${this.getAliasToken()} ${mainTableAs}`;\n    }\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map((indexName) => this.quoteIdentifiers(indexName)).join(\",\")})`;\n        }\n      }\n    }\n    return fragment;\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.offset != null && options.limit == null) {\n      fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + 1e13;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + this.escape(options.limit);\n      } else {\n        fragment += \" LIMIT \" + this.escape(options.limit);\n      }\n    }\n    return fragment;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n        if (value === \"NULL\") {\n          if (smth.comparator === \"=\") {\n            smth.comparator = \"IS\";\n          }\n          if (smth.comparator === \"!=\") {\n            smth.comparator = \"IS NOT\";\n          }\n        }\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;\n      } else if (typeof value === \"boolean\") {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n      if (value === \"NULL\") {\n        if (smth.comparator === \"=\") {\n          smth.comparator = \"IS\";\n        }\n        if (smth.comparator === \"!=\") {\n          smth.comparator = \"IS NOT\";\n        }\n      }\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map((arg) => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(typeof arg === \"string\" ? arg.replace(/\\$/g, \"$$$\") : arg);\n      }).join(\", \")})`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error(\"Cannot call Sequelize.col() with array outside of order / group clause\");\n      }\n      if (smth.col.startsWith(\"*\")) {\n        return \"*\";\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return \"\";\n  }\n  whereItemsQuery(where, options, binding) {\n    if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {\n      return \"\";\n    }\n    if (typeof where === \"string\") {\n      throw new Error(\"Support for `{where: 'raw query'}` has been removed.\");\n    }\n    const items = [];\n    binding = binding || \"AND\";\n    if (binding[0] !== \" \")\n      binding = ` ${binding} `;\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach((prop) => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(void 0, where, options));\n    }\n    return items.length && items.filter((item) => item && item.length).join(binding) || \"\";\n  }\n  whereItemQuery(key, value, options = {}) {\n    if (value === void 0) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n    if (typeof key === \"string\" && key.includes(\".\") && options.model) {\n      const keyParts = key.split(\".\");\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field2 = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({ field: field2 }, options));\n      }\n    }\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n    if (key === void 0) {\n      if (typeof value === \"string\") {\n        return value;\n      }\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n    if (value === null) {\n      const opValue2 = options.bindParam ? \"NULL\" : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);\n    }\n    if (!value) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n    if (key === void 0 && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n      }\n    }\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n    if (key === Op.placeholder) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? \"NOT \" : \"\";\n    if (Array.isArray(value)) {\n      value = value.map((item) => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter((item) => item && item.length);\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    if ((key === Op.or || key === Op.not) && !value) {\n      return \"0 = 1\";\n    }\n    return value ? `${outerBinding}(${value})` : void 0;\n  }\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map((prop) => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map((item) => this.whereItemQuery(key, item, options));\n    }\n    value = value.filter((item) => item && item.length);\n    return value.length ? `(${value.join(binding)})` : void 0;\n  }\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n    Utils.getOperators(value).forEach((op) => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), { json: false })));\n    });\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n    if (path[path.length - 1].includes(\"::\")) {\n      const tmp = path[path.length - 1].split(\"::\");\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n    let pathKey = this.jsonPathExtractionQuery(baseKey, path);\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach((op) => {\n        const value = this._toJSONValue(item[op]);\n        let isJson = false;\n        if (typeof value === \"string\" && op === Op.contains) {\n          try {\n            JSON.stringify(value);\n            isJson = true;\n          } catch (e) {\n          }\n        }\n        pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n      return;\n    }\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n  _toJSONValue(value) {\n    return value;\n  }\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n    return new Utils.Literal(key);\n  }\n  _getJsonCast(value) {\n    if (typeof value === \"number\") {\n      return \"double precision\";\n    }\n    if (value instanceof Date) {\n      return \"timestamptz\";\n    }\n    if (typeof value === \"boolean\") {\n      return \"boolean\";\n    }\n    return;\n  }\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === void 0) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split(\".\");\n      if (key.length > 2) {\n        key = [\n          key.slice(0, -1).join(\"->\"),\n          key[key.length - 1]\n        ];\n      }\n      return key.map((identifier) => this.quoteIdentifier(identifier)).join(\".\");\n    }\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join(\".\");\n      }\n      return [this.quoteTable(prefix), key].join(\".\");\n    }\n    return key;\n  }\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map((item) => this.escape(item, field)).join(\", \")})`, comparator, options.prefix);\n        }\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, \"(NULL)\", comparator, options.prefix);\n        }\n        return \"\";\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map((item) => `(${this.escape(item)})`).join(\", \")})`, comparator, options.prefix);\n        }\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error(\"The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.\");\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split(\".\");\n        if (value.length > 2) {\n          value = [\n            value.slice(0, -1).join(\"->\"),\n            value[value.length - 1]\n          ];\n        }\n        return this._joinKeyValue(key, value.map((identifier) => this.quoteIdentifier(identifier)).join(\".\"), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        if (value instanceof Utils.Literal) {\n          value = value.val;\n        }\n        let pattern = `${value}%`;\n        if (prop === Op.endsWith)\n          pattern = `%${value}`;\n        if (prop === Op.substring)\n          pattern = `%${value}%`;\n        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n    }\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n    options = options || {};\n    if (prepend === void 0) {\n      prepend = true;\n    }\n    if (smth && smth instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === \"number\" || typeof smth === \"bigint\") {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n      if (primaryKeys.length > 0) {\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = \"id\";\n      }\n      where[primaryKeys] = smth;\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === \"string\") {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0)\n        return \"1=1\";\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n    }\n    if (smth == null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    throw new Error(`Unsupported where option value: ${util.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);\n  }\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key)));\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n  booleanValue(value) {\n    return value;\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result\";\n  }\n}\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\"));\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\"));\nmodule.exports = QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixlQUFlLHdGQUFrQjtBQUNqQyxjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDBFQUFrQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBK0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsOEdBQW9DO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLGdHQUE2QjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFjO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCLFlBQVksd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csbUJBQW1CO0FBQ3ZILFlBQVk7QUFDWixvR0FBb0csbUJBQW1CO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkJBQTJCLFlBQVksMkJBQTJCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsUUFBUTtBQUNSLHFFQUFxRSwyQkFBMkIsVUFBVSwyQkFBMkI7QUFDckk7QUFDQSxnRUFBZ0UsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFrRCxFQUFFLG9CQUFvQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFFBQVEsK0JBQStCLE9BQU8sYUFBYSxHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixVQUFVLG9CQUFvQixHQUFHLHFCQUFxQixFQUFFLGlDQUFpQyxFQUFFLFdBQVc7QUFDalAsb0JBQW9CLFNBQVMsUUFBUSwrQkFBK0IsT0FBTyxZQUFZLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUsaUNBQWlDLEVBQUUsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3REFBd0Qsd0RBQXdELDhEQUE4RDtBQUM5SywrSEFBK0g7QUFDL0gsK0VBQStFLFlBQVksMkRBQTJELFdBQVcsUUFBUSxZQUFZLDJCQUEyQixZQUFZLG1CQUFtQixNQUFNLFdBQVcsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDaFQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQXlELEVBQUUsNEJBQTRCO0FBQ3RHO0FBQ0EsMkNBQTJDLHlEQUF5RCxFQUFFO0FBQ3RHO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYSxJQUFJLEVBQUUsT0FBTyxzQkFBc0IsYUFBYSxJQUFJO0FBQ3RHO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG1CQUFtQjtBQUNqRyxPQUFPO0FBQ1Asc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQkFBMkIsWUFBWSwyQkFBMkI7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG1CQUFtQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGO0FBQ0EscUVBQXFFLDJCQUEyQixVQUFVLDJCQUEyQjtBQUNySSxrQ0FBa0Msa0RBQWtELEVBQUUsb0JBQW9CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsU0FBUyw0QkFBNEIsTUFBTSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxxQ0FBcUMsRUFBRSxPQUFPO0FBQzVKLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxHQUFHLFlBQVksRUFBRSxVQUFVLEVBQUUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVksR0FBRyxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxUEFBcVAsY0FBYyxzREFBc0QsVUFBVSxpRkFBaUYsY0FBYyxZQUFZLHFCQUFxQiwyRUFBMkUsZUFBZTtBQUM3aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFVBQVUsc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLEdBQUcsZ0JBQWdCO0FBQzlGLDBDQUEwQyxnQkFBZ0IsU0FBUyxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFdBQVcsa0NBQWtDLFFBQVEsYUFBYTtBQUM1SDtBQUNBO0FBQ0EsaUVBQWlFLFVBQVUsR0FBRyxnQkFBZ0I7QUFDOUYsMENBQTBDLGdCQUFnQixlQUFlLHNCQUFzQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQjtBQUNsSDtBQUNBLHFDQUFxQyxtQ0FBbUMsR0FBRyxpQkFBaUI7QUFDNUYsMENBQTBDLGdCQUFnQjtBQUMxRCw2Q0FBNkMsc0JBQXNCLGVBQWUsa0JBQWtCO0FBQ3BHO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CLEdBQUcsZ0RBQWdEO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRSxRQUFRO0FBQ1Isa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QyxHQUFHLDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLEVBQUUsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRGQUE0RjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxR0FBcUc7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1SUFBdUksZ0JBQWdCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLCtHQUErRyxNQUFNO0FBQ3JIO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRyxRQUFRO0FBQ3pEO0FBQ0EsNENBQTRDLGFBQWEsR0FBRyxRQUFRO0FBQ3BFO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxpQkFBaUI7QUFDbkQsbUJBQW1CLGFBQWEsRUFBRSxLQUFLLEVBQUUsUUFBUTtBQUNqRDtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9EQUFvRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CLFFBQVEsSUFBSSxzQkFBc0I7QUFDOUQsd0VBQXdFLE9BQU87QUFDL0U7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3RUFBd0U7QUFDakYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRCxVQUFVO0FBQ1Ysd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsUUFBUTtBQUNSLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELFVBQVU7QUFDVix5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrREFBa0Q7QUFDeEcsd0JBQXdCLDRCQUE0QixRQUFRLHVCQUF1QixJQUFJLHNCQUFzQixFQUFFLGFBQWEsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0I7QUFDakwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QixRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQztBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxHQUFHLEtBQUs7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixJQUFJLFdBQVc7QUFDMUUsZ0NBQWdDLDJCQUEyQixHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDaEcsVUFBVTtBQUNWLG1FQUFtRSwyQ0FBMkM7QUFDOUcsVUFBVTtBQUNWLCtEQUErRCwyQ0FBMkM7QUFDMUcsVUFBVTtBQUNWLHNCQUFzQiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDL0Y7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixJQUFJLGVBQWUsRUFBRSwyQkFBMkIsT0FBTyxvQkFBb0I7QUFDakksUUFBUTtBQUNSLHNDQUFzQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsS0FBSyxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVDQUF1QyxnQkFBZ0IsSUFBSSxlQUFlLEVBQUUsNEJBQTRCLE9BQU8sb0JBQW9CO0FBQ25JLFFBQVE7QUFDUix1Q0FBdUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEtBQUssb0JBQW9CO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsRUFBRSxNQUFNO0FBQ3BELHVDQUF1QyxVQUFVLEVBQUUsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxFQUFFLE1BQU07QUFDdEQseUNBQXlDLFVBQVUsRUFBRSxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxJQUFJLE9BQU87QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPLElBQUksUUFBUTtBQUN0QyxvQkFBb0Isd0JBQXdCLEdBQUcsZ0NBQWdDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFVBQVUsR0FBRywrQkFBK0I7QUFDckk7QUFDQSxrQ0FBa0MsVUFBVSxHQUFHLGdDQUFnQztBQUMvRSwrREFBK0QsY0FBYyxLQUFLLCtCQUErQjtBQUNqSDtBQUNBLFFBQVE7QUFDUiw4QkFBOEIsMkJBQTJCLEdBQUcsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCLEdBQUcsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLFVBQVU7QUFDViw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELE1BQU07QUFDTix3Q0FBd0Msd0JBQXdCO0FBQ2hFLE1BQU07QUFDTixrQ0FBa0Msd0NBQXdDLE1BQU0sYUFBYTtBQUM3RjtBQUNBLDZEQUE2RCxPQUFPLEVBQUUsdUJBQXVCO0FBQzdGLDBDQUEwQyxxQkFBcUIsR0FBRztBQUNsRTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixJQUFJLFdBQVc7QUFDN0QsaUNBQWlDLHFCQUFxQixHQUFHLFdBQVc7QUFDcEU7QUFDQSxxQkFBcUIsa0JBQWtCLEdBQUcscUNBQXFDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0MsR0FBRywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVksR0FBRyxXQUFXLCtCQUErQixZQUFZLEdBQUcsV0FBVztBQUNuSix3QkFBd0Isa0NBQWtDO0FBQzFELE1BQU07QUFDTjtBQUNBLHdCQUF3Qiw2QkFBNkIsR0FBRyxxQ0FBcUM7QUFDN0Y7QUFDQSx1QkFBdUIsZ0NBQWdDLEdBQUcsa0NBQWtDO0FBQzVGLHNCQUFzQixrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDN0YsdUJBQXVCLGdDQUFnQyxHQUFHLGtDQUFrQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEMsYUFBYSxxRUFBcUUsS0FBSyxhQUFhO0FBQ2xLO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVkseUNBQXlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0MsR0FBRyxzREFBc0Q7QUFDaEgsaUJBQWlCLG9EQUFvRCxHQUFHLHFEQUFxRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxHQUFHLGtDQUFrQztBQUNwRixXQUFXLHNEQUFzRCxHQUFHLGtDQUFrQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLDZCQUE2QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsMERBQTBELG9CQUFvQjtBQUM5RSxnREFBZ0QsVUFBVSxFQUFFLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlEQUFpRDtBQUNoRyw2QkFBNkIsdUJBQXVCLE9BQU8sT0FBTztBQUNsRTtBQUNBLHNCQUFzQixzQkFBc0IsRUFBRSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QixTQUFTLDJFQUEyRTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUJBQWlCLDJDQUEyQyxHQUFHLHVFQUF1RTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QixNQUFNLHNCQUFzQjtBQUN0RSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxLQUFLLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYSxHQUFHLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hELE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLEdBQUcsUUFBUTtBQUMzRSxRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQyxHQUFHLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWMsYUFBYTtBQUMzRyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0YsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxNQUFNLE9BQU87QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseURBQXlEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QixFQUFFLFdBQVc7QUFDOUQ7QUFDQSxvREFBb0QsbUNBQW1DLGtCQUFrQixlQUFlO0FBQ3hIO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QixNQUFNLDZCQUE2QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLHNIQUE2QjtBQUM3RSx3Q0FBd0MsbUJBQU8sQ0FBQywwSEFBK0I7QUFDL0U7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci5qcz82YjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoXCJ1dWlkXCIpLnY0O1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zXCIpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZShcIi4uLy4uL3NxbC1zdHJpbmdcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZShcIi4uLy4uL21vZGVsXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL2Jhc2VcIik7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG9cIik7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9iZWxvbmdzLXRvLW1hbnlcIik7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZShcIi4uLy4uL2Fzc29jaWF0aW9ucy9oYXMtbWFueVwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9yID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IEluZGV4SGludHMgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXgtaGludHNcIik7XG5jbGFzcyBRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2VxdWVsaXplKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnlHZW5lcmF0b3IgaW5pdGlhbGl6ZWQgd2l0aG91dCBvcHRpb25zLnNlcXVlbGl6ZVwiKTtcbiAgICBpZiAoIW9wdGlvbnMuX2RpYWxlY3QpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeUdlbmVyYXRvciBpbml0aWFsaXplZCB3aXRob3V0IG9wdGlvbnMuX2RpYWxlY3RcIik7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBvcHRpb25zLnNlcXVlbGl6ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNlcXVlbGl6ZS5vcHRpb25zO1xuICAgIHRoaXMuZGlhbGVjdCA9IG9wdGlvbnMuX2RpYWxlY3QubmFtZTtcbiAgICB0aGlzLl9kaWFsZWN0ID0gb3B0aW9ucy5fZGlhbGVjdDtcbiAgICB0aGlzLl9pbml0UXVvdGVJZGVudGlmaWVyKCk7XG4gIH1cbiAgZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYSB8fCBvcHRpb25zLnNjaGVtYSB8fCB0aGlzLm9wdGlvbnMuc2NoZW1hIHx8IFwicHVibGljXCIsXG4gICAgICB0YWJsZU5hbWU6IF8uaXNQbGFpbk9iamVjdCh0YWJsZU5hbWUpID8gdGFibGVOYW1lLnRhYmxlTmFtZSA6IHRhYmxlTmFtZSxcbiAgICAgIGRlbGltaXRlcjogdGFibGVOYW1lLmRlbGltaXRlciB8fCBvcHRpb25zLmRlbGltaXRlciB8fCBcIi5cIlxuICAgIH07XG4gIH1cbiAgYWRkU2NoZW1hKHBhcmFtKSB7XG4gICAgaWYgKCFwYXJhbS5fc2NoZW1hKVxuICAgICAgcmV0dXJuIHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGVOYW1lOiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW0sXG4gICAgICB0YWJsZTogcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtLFxuICAgICAgbmFtZTogcGFyYW0ubmFtZSB8fCBwYXJhbSxcbiAgICAgIHNjaGVtYTogcGFyYW0uX3NjaGVtYSxcbiAgICAgIGRlbGltaXRlcjogcGFyYW0uX3NjaGVtYURlbGltaXRlciB8fCBcIi5cIixcbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5xdW90ZVRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZHJvcFNjaGVtYSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5kcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEoe1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyXG4gICAgfSkpO1xuICAgIHJldHVybiBgREVTQ1JJQkUgJHt0YWJsZX07YDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9O2A7XG4gIH1cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZShiZWZvcmUpfSBSRU5BTUUgVE8gJHt0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpfTtgO1xuICB9XG4gIHBvcHVsYXRlSW5zZXJ0UXVlcnlSZXR1cm5JbnRvQmluZHMoKSB7XG4gIH1cbiAgaW5zZXJ0UXVlcnkodGFibGUsIHZhbHVlSGFzaCwgbW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgYmluZCA9IG9wdGlvbnMuYmluZCB8fCBbXTtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBjb25zdCByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBjb25zdCByZXR1cm5UeXBlcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlKTtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdm9pZCAwID8gdGhpcy5iaW5kUGFyYW0oYmluZCkgOiBvcHRpb25zLmJpbmRQYXJhbTtcbiAgICBjb25zdCByZXR1cm5BdHRyaWJ1dGVzID0gW107XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGxldCB2YWx1ZVF1ZXJ5ID0gXCJcIjtcbiAgICBsZXQgZW1wdHlRdWVyeSA9IFwiXCI7XG4gICAgbGV0IG91dHB1dEZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgcmV0dXJuaW5nRnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCBpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGxldCB0bXBUYWJsZSA9IFwiXCI7XG4gICAgaWYgKG1vZGVsQXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKG1vZGVsQXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJERUZBVUxUIFZBTFVFU1wiXSkge1xuICAgICAgZW1wdHlRdWVyeSArPSBcIiBERUZBVUxUIFZBTFVFU1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1tcIlZBTFVFUyAoKVwiXSkge1xuICAgICAgZW1wdHlRdWVyeSArPSBcIiBWQUxVRVMgKClcIjtcbiAgICB9XG4gICAgaWYgKCh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyB8fCB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVybkludG9WYWx1ZXMpICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKG1vZGVsQXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMucHVzaCguLi5yZXR1cm5WYWx1ZXMucmV0dXJuRmllbGRzKTtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVybkludG9WYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuVHlwZXMucHVzaCguLi5yZXR1cm5WYWx1ZXMucmV0dXJuVHlwZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICB0bXBUYWJsZSA9IHJldHVyblZhbHVlcy50bXBUYWJsZSB8fCBcIlwiO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQgfHwgXCJcIjtcbiAgICB9XG4gICAgaWYgKF8uZ2V0KHRoaXMsIFtcInNlcXVlbGl6ZVwiLCBcIm9wdGlvbnNcIiwgXCJkaWFsZWN0T3B0aW9uc1wiLCBcInByZXBlbmRTZWFyY2hQYXRoXCJdKSB8fCBvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkVYQ0VQVElPTiAmJiBvcHRpb25zLmV4Y2VwdGlvbikge1xuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG4gICAgdmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKHZhbHVlSGFzaCwgdGhpcy5vcHRpb25zLm9taXROdWxsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZUhhc2gpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVIYXNoLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVIYXNoW2tleV07XG4gICAgICAgIGZpZWxkcy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUgJiYgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgZmllbGRzLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkRFRkFVTFQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFwiREVGQVVMVFwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5lc2NhcGUobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlkZW50aXR5V3JhcHBlclJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJJTlNFUlRcIiB9LCBiaW5kUGFyYW0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG9uRHVwbGljYXRlS2V5VXBkYXRlID0gXCJcIjtcbiAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmNvbmZsaWN0V2hlcmUpICYmICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdFdoZXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIGRpYWxlY3Qgc3VwcG9ydCBmb3IgY29uZmxpY3RXaGVyZSBvcHRpb25cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgJiYgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSA9PSBcIiBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUXCIpIHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RLZXlzID0gb3B0aW9ucy51cHNlcnRLZXlzLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpO1xuICAgICAgICBjb25zdCB1cGRhdGVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoKGF0dHIpID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1FWENMVURFRC4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWApO1xuICAgICAgICBjb25zdCBmcmFnbWVudHMgPSBbXG4gICAgICAgICAgXCJPTiBDT05GTElDVFwiLFxuICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgIGNvbmZsaWN0S2V5cy5qb2luKFwiLFwiKSxcbiAgICAgICAgICBcIilcIlxuICAgICAgICBdO1xuICAgICAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmNvbmZsaWN0V2hlcmUpKSB7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2godGhpcy53aGVyZVF1ZXJ5KG9wdGlvbnMuY29uZmxpY3RXaGVyZSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLmlzRW1wdHkodXBkYXRlS2V5cykpIHtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChcIkRPIE5PVEhJTkdcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJhZ21lbnRzLnB1c2goXCJETyBVUERBVEUgU0VUXCIsIHVwZGF0ZUtleXMuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gYCAke1V0aWxzLmpvaW5TUUxGcmFnbWVudHMoZnJhZ21lbnRzKX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsdWVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoKGF0dHIpID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1WQUxVRVMoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0pYCk7XG4gICAgICAgIGlmIChfLmlzRW1wdHkodmFsdWVLZXlzKSAmJiBvcHRpb25zLnVwc2VydEtleXMpIHtcbiAgICAgICAgICB2YWx1ZUtleXMucHVzaCguLi5vcHRpb25zLnVwc2VydEtleXMubWFwKChhdHRyKSA9PiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX09JHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNFbXB0eSh2YWx1ZUtleXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXBkYXRlIHZhbHVlcyBmb3VuZCBmb3IgT04gRFVQTElDQVRFIEtFWSBVUERBVEUgY2xhdXNlLCBhbmQgbm8gaWRlbnRpZmllciBmaWVsZHMgY291bGQgYmUgZm91bmQgdG8gdXNlIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlICs9IGAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZX0gJHt2YWx1ZUtleXMuam9pbihcIixcIil9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuICAgICAgaWdub3JlRHVwbGljYXRlczogb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLmlnbm9yZUR1cGxpY2F0ZXMgOiBcIlwiLFxuICAgICAgb25Db25mbGljdERvTm90aGluZzogb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3REb05vdGhpbmcgOiBcIlwiLFxuICAgICAgYXR0cmlidXRlczogZmllbGRzLmpvaW4oXCIsXCIpLFxuICAgICAgb3V0cHV0OiBvdXRwdXRGcmFnbWVudCxcbiAgICAgIHZhbHVlczogdmFsdWVzLmpvaW4oXCIsXCIpLFxuICAgICAgdG1wVGFibGVcbiAgICB9O1xuICAgIHZhbHVlUXVlcnkgPSBgJHt0bXBUYWJsZX1JTlNFUlQke3JlcGxhY2VtZW50cy5pZ25vcmVEdXBsaWNhdGVzfSBJTlRPICR7cXVvdGVkVGFibGV9ICgke3JlcGxhY2VtZW50cy5hdHRyaWJ1dGVzfSkke3JlcGxhY2VtZW50cy5vdXRwdXR9IFZBTFVFUyAoJHtyZXBsYWNlbWVudHMudmFsdWVzfSkke29uRHVwbGljYXRlS2V5VXBkYXRlfSR7cmVwbGFjZW1lbnRzLm9uQ29uZmxpY3REb05vdGhpbmd9JHt2YWx1ZVF1ZXJ5fWA7XG4gICAgZW1wdHlRdWVyeSA9IGAke3RtcFRhYmxlfUlOU0VSVCR7cmVwbGFjZW1lbnRzLmlnbm9yZUR1cGxpY2F0ZXN9IElOVE8gJHtxdW90ZWRUYWJsZX0ke3JlcGxhY2VtZW50cy5vdXRwdXR9JHtvbkR1cGxpY2F0ZUtleVVwZGF0ZX0ke3JlcGxhY2VtZW50cy5vbkNvbmZsaWN0RG9Ob3RoaW5nfSR7ZW1wdHlRdWVyeX1gO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLkVYQ0VQVElPTiAmJiBvcHRpb25zLmV4Y2VwdGlvbikge1xuICAgICAgY29uc3QgZHJvcEZ1bmN0aW9uID0gXCJEUk9QIEZVTkNUSU9OIElGIEVYSVNUUyBwZ190ZW1wLnRlc3RmdW5jKClcIjtcbiAgICAgIGlmIChyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5wdXNoKFwiKlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGltaXRlciA9IGAkZnVuY18ke3V1aWR2NCgpLnJlcGxhY2UoLy0vZywgXCJcIil9JGA7XG4gICAgICBjb25zdCBzZWxlY3RRdWVyeSA9IGBTRUxFQ1QgKHRlc3RmdW5jLnJlc3BvbnNlKS4ke3JldHVybmluZ01vZGVsQXR0cmlidXRlcy5qb2luKFwiLCAodGVzdGZ1bmMucmVzcG9uc2UpLlwiKX0sIHRlc3RmdW5jLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uIEZST00gcGdfdGVtcC50ZXN0ZnVuYygpO2A7XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbiA9IFwiV0hFTiB1bmlxdWVfdmlvbGF0aW9uIFRIRU4gR0VUIFNUQUNLRUQgRElBR05PU1RJQ1Mgc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gPSBQR19FWENFUFRJT05fREVUQUlMO1wiO1xuICAgICAgdmFsdWVRdWVyeSA9IGBDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTiBwZ190ZW1wLnRlc3RmdW5jKE9VVCByZXNwb25zZSAke3F1b3RlZFRhYmxlfSwgT1VUIHNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uIHRleHQpIFJFVFVSTlMgUkVDT1JEIEFTICR7ZGVsaW1pdGVyfSBCRUdJTiAke3ZhbHVlUXVlcnl9IFJFVFVSTklORyAqIElOVE8gcmVzcG9uc2U7IEVYQ0VQVElPTiAke29wdGlvbnMuZXhjZXB0aW9ufSBFTkQgJHtkZWxpbWl0ZXJ9IExBTkdVQUdFIHBscGdzcWw7ICR7c2VsZWN0UXVlcnl9ICR7ZHJvcEZ1bmN0aW9ufWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlUXVlcnkgKz0gcmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICBlbXB0eVF1ZXJ5ICs9IHJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5JbnRvVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlSW5zZXJ0UXVlcnlSZXR1cm5JbnRvQmluZHMocmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLCByZXR1cm5UeXBlcywgYmluZC5sZW5ndGgsIHJldHVybkF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBxdWVyeSA9IGAke3JlcGxhY2VtZW50cy5hdHRyaWJ1dGVzLmxlbmd0aCA/IHZhbHVlUXVlcnkgOiBlbXB0eVF1ZXJ5fSR7cmV0dXJuQXR0cmlidXRlcy5qb2luKFwiLFwiKX07YDtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5maW5hbFRhYmxlKSB7XG4gICAgICBxdWVyeSA9IGBTRUxFQ1QgKiBGUk9NIEZJTkFMIFRBQkxFKCR7cmVwbGFjZW1lbnRzLmF0dHJpYnV0ZXMubGVuZ3RoID8gdmFsdWVRdWVyeSA6IGVtcHR5UXVlcnl9KTtgO1xuICAgIH1cbiAgICBpZiAoaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5hdXRvSW5jcmVtZW50LmlkZW50aXR5SW5zZXJ0KSB7XG4gICAgICBxdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9OOyAke3F1ZXJ5fSBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9GRjtgO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgaWYgKG9wdGlvbnMuYmluZFBhcmFtICE9PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmJpbmQgPSBiaW5kO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGZpZWxkTWFwcGVkQXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IGZpZWxkTWFwcGVkQXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBzZXJpYWxzID0ge307XG4gICAgY29uc3QgYWxsQXR0cmlidXRlcyA9IFtdO1xuICAgIGxldCBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBfLmZvck93bihmaWVsZFZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKCFhbGxBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0gJiYgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNlcmlhbHNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYnVsa0RlZmF1bHQgJiYgc2VyaWFsc1trZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWVIYXNoW2tleV0gIT0gbnVsbCA/IGZpZWxkVmFsdWVIYXNoW2tleV0gOiBcIkRFRkFVTFRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUoZmllbGRWYWx1ZUhhc2hba2V5XSwgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0sIHsgY29udGV4dDogXCJJTlNFUlRcIiB9KTtcbiAgICAgIH0pO1xuICAgICAgdHVwbGVzLnB1c2goYCgke3ZhbHVlcy5qb2luKFwiLFwiKX0pYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGUgJiYgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSA9PSBcIiBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUXCIpIHtcbiAgICAgICAgY29uc3QgY29uZmxpY3RLZXlzID0gb3B0aW9ucy51cHNlcnRLZXlzLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpO1xuICAgICAgICBjb25zdCB1cGRhdGVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoKGF0dHIpID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1FWENMVURFRC4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWApO1xuICAgICAgICBsZXQgd2hlcmVDbGF1c2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29uZmxpY3RXaGVyZSkge1xuICAgICAgICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3RXaGVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdFdoZXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGRpYWxlY3QgJHt0aGlzLl9kaWFsZWN0Lm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoZXJlQ2xhdXNlID0gdGhpcy53aGVyZVF1ZXJ5KG9wdGlvbnMuY29uZmxpY3RXaGVyZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBbXG4gICAgICAgICAgXCJPTiBDT05GTElDVFwiLFxuICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgIGNvbmZsaWN0S2V5cy5qb2luKFwiLFwiKSxcbiAgICAgICAgICBcIilcIixcbiAgICAgICAgICB3aGVyZUNsYXVzZSxcbiAgICAgICAgICBcIkRPIFVQREFURSBTRVRcIixcbiAgICAgICAgICB1cGRhdGVLZXlzLmpvaW4oXCIsXCIpXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5jb25mbGljdFdoZXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25mbGljdFdoZXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGRpYWxlY3QgJHt0aGlzLl9kaWFsZWN0Lm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVLZXlzID0gb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoKGF0dHIpID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT1WQUxVRVMoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0pYCk7XG4gICAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlID0gYCR7dGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlfSAke3ZhbHVlS2V5cy5qb2luKFwiLFwiKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpZ25vcmVEdXBsaWNhdGVzID0gb3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzID8gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLmlnbm9yZUR1cGxpY2F0ZXMgOiBcIlwiO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IG9uQ29uZmxpY3REb05vdGhpbmcgPSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdERvTm90aGluZyA6IFwiXCI7XG4gICAgbGV0IHJldHVybmluZyA9IFwiXCI7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGZpZWxkTWFwcGVkQXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm5pbmcgKz0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIklOU0VSVFwiLFxuICAgICAgaWdub3JlRHVwbGljYXRlcyxcbiAgICAgIFwiSU5UT1wiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBgKCR7YXR0cmlidXRlc30pYCxcbiAgICAgIFwiVkFMVUVTXCIsXG4gICAgICB0dXBsZXMuam9pbihcIixcIiksXG4gICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSxcbiAgICAgIG9uQ29uZmxpY3REb05vdGhpbmcsXG4gICAgICByZXR1cm5pbmcsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgYXR0clZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChhdHRyVmFsdWVIYXNoLCBvcHRpb25zLm9taXROdWxsLCBvcHRpb25zKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBiaW5kID0gW107XG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCB0bXBUYWJsZSA9IFwiXCI7XG4gICAgbGV0IHN1ZmZpeCA9IFwiXCI7XG4gICAgaWYgKF8uZ2V0KHRoaXMsIFtcInNlcXVlbGl6ZVwiLCBcIm9wdGlvbnNcIiwgXCJkaWFsZWN0T3B0aW9uc1wiLCBcInByZXBlbmRTZWFyY2hQYXRoXCJdKSB8fCBvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIG9wdGlvbnMuYmluZFBhcmFtID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtID09PSB2b2lkIDAgPyB0aGlzLmJpbmRQYXJhbShiaW5kKSA6IG9wdGlvbnMuYmluZFBhcmFtO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiTElNSVQgT04gVVBEQVRFXCJdICYmIG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGlmICghW1wibXNzcWxcIiwgXCJkYjJcIiwgXCJvcmFjbGVcIl0uaW5jbHVkZXModGhpcy5kaWFsZWN0KSkge1xuICAgICAgICBzdWZmaXggPSBgIExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IGA7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGlhbGVjdCA9PT0gXCJvcmFjbGVcIikge1xuICAgICAgICBpZiAod2hlcmUgJiYgKHdoZXJlLmxlbmd0aCAmJiB3aGVyZS5sZW5ndGggPiAwIHx8IE9iamVjdC5rZXlzKHdoZXJlKS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgIHN1ZmZpeCArPSBcIiBBTkQgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4ICs9IFwiIFdIRVJFIFwiO1xuICAgICAgICB9XG4gICAgICAgIHN1ZmZpeCArPSBgcm93bnVtIDw9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcyAmJiBvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgIHN1ZmZpeCArPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgICB0bXBUYWJsZSA9IHJldHVyblZhbHVlcy50bXBUYWJsZSB8fCBcIlwiO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQgfHwgXCJcIjtcbiAgICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMub3V0cHV0ICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIG9wdGlvbnMubWFwVG9Nb2RlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2goYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0clZhbHVlSGFzaCkge1xuICAgICAgaWYgKG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlICYmICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQudXBkYXRlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWVIYXNoW2tleV07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0sIGJpbmRQYXJhbSl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdoZXJlT3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGJpbmRQYXJhbSB9KTtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gYCR7dG1wVGFibGV9VVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKFwiLFwiKX0ke291dHB1dEZyYWdtZW50fSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX0ke3N1ZmZpeH1gLnRyaW0oKTtcbiAgICBjb25zdCByZXN1bHQgPSB7IHF1ZXJ5IH07XG4gICAgaWYgKG9wdGlvbnMuYmluZFBhcmFtICE9PSBmYWxzZSkge1xuICAgICAgcmVzdWx0LmJpbmQgPSBiaW5kO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFyaXRobWV0aWNRdWVyeShvcGVyYXRvciwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB7IHJldHVybmluZzogdHJ1ZSB9KTtcbiAgICBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgdGhpcy5vcHRpb25zLm9taXROdWxsKTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKG51bGwsIG9wdGlvbnMpO1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSByZXR1cm5WYWx1ZXMub3V0cHV0RnJhZ21lbnQ7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlU2V0U3FsRnJhZ21lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCkge1xuICAgICAgY29uc3QgaW5jcmVtZW50QW1vdW50ID0gaW5jcmVtZW50QW1vdW50c0J5RmllbGRbZmllbGRdO1xuICAgICAgY29uc3QgcXVvdGVkRmllbGQgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICBjb25zdCBlc2NhcGVkQW1vdW50ID0gdGhpcy5lc2NhcGUoaW5jcmVtZW50QW1vdW50KTtcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5wdXNoKGAke3F1b3RlZEZpZWxkfT0ke3F1b3RlZEZpZWxkfSR7b3BlcmF0b3J9ICR7ZXNjYXBlZEFtb3VudH1gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCkge1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZFtmaWVsZF07XG4gICAgICBjb25zdCBxdW90ZWRGaWVsZCA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIGNvbnN0IGVzY2FwZWRWYWx1ZSA9IHRoaXMuZXNjYXBlKG5ld1ZhbHVlKTtcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5wdXNoKGAke3F1b3RlZEZpZWxkfT0ke2VzY2FwZWRWYWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJVUERBVEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJTRVRcIixcbiAgICAgIHVwZGF0ZVNldFNxbEZyYWdtZW50cy5qb2luKFwiLFwiKSxcbiAgICAgIG91dHB1dEZyYWdtZW50LFxuICAgICAgdGhpcy53aGVyZVF1ZXJ5KHdoZXJlKSxcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50XG4gICAgXSk7XG4gIH1cbiAgYWRkSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgb3B0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgICBhdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXggfHwgcmF3VGFibGVuYW1lIHx8IHRhYmxlTmFtZTtcbiAgICBpZiAob3B0aW9ucy5wcmVmaXggJiYgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4LnJlcGxhY2UoL1xcLi9nLCBcIl9cIik7XG4gICAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4LnJlcGxhY2UoLyhcInwnKS9nLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZmllbGRzU3FsID0gb3B0aW9ucy5maWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZpZWxkID0ge1xuICAgICAgICAgIG5hbWU6IGZpZWxkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGlmIChmaWVsZC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgZmllbGQubmFtZSA9IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZmllbGQubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgaW5kZXggZmllbGQgaGFzIG5vIG5hbWU6ICR7dXRpbC5pbnNwZWN0KGZpZWxkKX1gKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5uYW1lKTtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LmNvbGxhdGUgJiYgZmllbGQuY29sbGF0ZSkge1xuICAgICAgICByZXN1bHQgKz0gYCBDT0xMQVRFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQuY29sbGF0ZSl9YDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4Lm9wZXJhdG9yKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yID0gZmllbGQub3BlcmF0b3IgfHwgb3B0aW9ucy5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAgJHtvcGVyYXRvcn1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5sZW5ndGggJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7ZmllbGQubGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkLm9yZGVyKSB7XG4gICAgICAgIHJlc3VsdCArPSBgICR7ZmllbGQub3JkZXJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgIG9wdGlvbnMgPSBVdGlscy5uYW1lSW5kZXgob3B0aW9ucywgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICBvcHRpb25zID0gTW9kZWwuX2NvbmZvcm1JbmRleChvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudHlwZSkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMudHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLndoZXJlUXVlcnkob3B0aW9ucy53aGVyZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmN1cnJlbnRseSA9IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXguY29uY3VycmVudGx5ICYmIG9wdGlvbnMuY29uY3VycmVudGx5ID8gXCJDT05DVVJSRU5UTFlcIiA6IHZvaWQgMDtcbiAgICBsZXQgaW5kO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIpIHtcbiAgICAgIGluZCA9IFtcbiAgICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIGNvbmN1cnJlbnRseSxcbiAgICAgICAgXCJBRERcIlxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kID0gW1wiQ1JFQVRFXCJdO1xuICAgIH1cbiAgICBpbmQgPSBpbmQuY29uY2F0KG9wdGlvbnMudW5pcXVlID8gXCJVTklRVUVcIiA6IFwiXCIsIG9wdGlvbnMudHlwZSwgXCJJTkRFWFwiLCAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyID8gY29uY3VycmVudGx5IDogdm9pZCAwLCB0aGlzLnF1b3RlSWRlbnRpZmllcnMob3B0aW9ucy5uYW1lKSwgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC51c2luZyA9PT0gMSAmJiBvcHRpb25zLnVzaW5nID8gYFVTSU5HICR7b3B0aW9ucy51c2luZ31gIDogXCJcIiwgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlciA/IGBPTiAke3RhYmxlTmFtZX1gIDogdm9pZCAwLCB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnVzaW5nID09PSAyICYmIG9wdGlvbnMudXNpbmcgPyBgVVNJTkcgJHtvcHRpb25zLnVzaW5nfWAgOiBcIlwiLCBgKCR7ZmllbGRzU3FsLmpvaW4oXCIsIFwiKX0pYCwgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5wYXJzZXIgJiYgb3B0aW9ucy5wYXJzZXIgPyBgV0lUSCBQQVJTRVIgJHtvcHRpb25zLnBhcnNlcn1gIDogdm9pZCAwLCB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LndoZXJlICYmIG9wdGlvbnMud2hlcmUgPyBvcHRpb25zLndoZXJlIDogdm9pZCAwKTtcbiAgICByZXR1cm4gXy5jb21wYWN0KGluZCkuam9pbihcIiBcIik7XG4gIH1cbiAgYWRkQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIFwiQUREXCIsXG4gICAgICB0aGlzLmdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucyB8fCB7fSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGdldENvbnN0cmFpbnRTbmlwcGV0KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjb25zdHJhaW50U25pcHBldCwgY29uc3RyYWludE5hbWU7XG4gICAgY29uc3QgZmllbGRzU3FsID0gb3B0aW9ucy5maWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQuYXR0cmlidXRlKSB7XG4gICAgICAgIGZpZWxkLm5hbWUgPSBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgICBpZiAoIWZpZWxkLm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIGluZGV4IGZpZWxkIGhhcyBubyBuYW1lOiAke2ZpZWxkfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLm5hbWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpZWxkc1NxbFF1b3RlZFN0cmluZyA9IGZpZWxkc1NxbC5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgZmllbGRzU3FsU3RyaW5nID0gZmllbGRzU3FsLmpvaW4oXCJfXCIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJVTklRVUVcIjpcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fdWtgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBVTklRVUUgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJDSEVDS1wiOlxuICAgICAgICBvcHRpb25zLndoZXJlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkob3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X2NrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gQ0hFQ0sgKCR7b3B0aW9ucy53aGVyZX0pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiREVGQVVMVFwiOlxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgdmFsdWUgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIERFRkFVTFQgQ09OU1RSQUlOVFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGlhbGVjdC5uYW1lICE9PSBcIm1zc3FsXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGNvbnN0cmFpbnRzIGFyZSBzdXBwb3J0ZWQgb25seSBmb3IgTVNTUUwgZGlhbGVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fZGZgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBERUZBVUxUICgke3RoaXMuZXNjYXBlKG9wdGlvbnMuZGVmYXVsdFZhbHVlKX0pIEZPUiAke2ZpZWxkc1NxbFswXX1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQUklNQVJZIEtFWVwiOlxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9wa2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFBSSU1BUlkgS0VZICgke2ZpZWxkc1NxbFF1b3RlZFN0cmluZ30pYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRk9SRUlHTiBLRVlcIjpcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IG9wdGlvbnMucmVmZXJlbmNlcztcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VzIHx8ICFyZWZlcmVuY2VzLnRhYmxlIHx8ICEocmVmZXJlbmNlcy5maWVsZCB8fCByZWZlcmVuY2VzLmZpZWxkcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWZlcmVuY2VzIG9iamVjdCB3aXRoIHRhYmxlIGFuZCBmaWVsZCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV8ke3JlZmVyZW5jZXMudGFibGV9X2ZrYCk7XG4gICAgICAgIGNvbnN0IHF1b3RlZFJlZmVyZW5jZXMgPSB0eXBlb2YgcmVmZXJlbmNlcy5maWVsZCAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMucXVvdGVJZGVudGlmaWVyKHJlZmVyZW5jZXMuZmllbGQpIDogcmVmZXJlbmNlcy5maWVsZHMubWFwKChmKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmKSkuam9pbihcIiwgXCIpO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzU25pcHBldCA9IGAke3RoaXMucXVvdGVUYWJsZShyZWZlcmVuY2VzLnRhYmxlKX0gKCR7cXVvdGVkUmVmZXJlbmNlc30pYDtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBgO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgRk9SRUlHTiBLRVkgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSkgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNTbmlwcGV0fWA7XG4gICAgICAgIGlmIChvcHRpb25zLm9uVXBkYXRlKSB7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBVUERBVEUgJHtvcHRpb25zLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vbkRlbGV0ZSkge1xuICAgICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gREVMRVRFICR7b3B0aW9ucy5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy50eXBlfSBpcyBpbnZhbGlkLmApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kZWZlcnJhYmxlICYmIFtcIlVOSVFVRVwiLCBcIlBSSU1BUlkgS0VZXCIsIFwiRk9SRUlHTiBLRVlcIl0uaW5jbHVkZXMob3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgICR7dGhpcy5kZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRTbmlwcGV0O1xuICB9XG4gIHJlbW92ZUNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGFibGVOYW1lLFxuICAgICAgXCJEUk9QIENPTlNUUkFJTlRcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVycyhjb25zdHJhaW50TmFtZSlcbiAgICBdKTtcbiAgfVxuICBxdW90ZShjb2xsZWN0aW9uLCBwYXJlbnQsIGNvbm5lY3Rvcikge1xuICAgIGNvbnN0IHZhbGlkT3JkZXJPcHRpb25zID0gW1xuICAgICAgXCJBU0NcIixcbiAgICAgIFwiREVTQ1wiLFxuICAgICAgXCJBU0MgTlVMTFMgTEFTVFwiLFxuICAgICAgXCJERVNDIE5VTExTIExBU1RcIixcbiAgICAgIFwiQVNDIE5VTExTIEZJUlNUXCIsXG4gICAgICBcIkRFU0MgTlVMTFMgRklSU1RcIixcbiAgICAgIFwiTlVMTFMgRklSU1RcIixcbiAgICAgIFwiTlVMTFMgTEFTVFwiXG4gICAgXTtcbiAgICBjb25uZWN0b3IgPSBjb25uZWN0b3IgfHwgXCIuXCI7XG4gICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKChpdGVtMiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSBjb2xsZWN0aW9uW2luZGV4IC0gMV07XG4gICAgICAgIGxldCBwcmV2aW91c0Fzc29jaWF0aW9uO1xuICAgICAgICBsZXQgcHJldmlvdXNNb2RlbDtcbiAgICAgICAgaWYgKCFwcmV2aW91cyAmJiBwYXJlbnQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHByZXZpb3VzTW9kZWwgPSBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgJiYgcHJldmlvdXMgaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikge1xuICAgICAgICAgIHByZXZpb3VzQXNzb2NpYXRpb24gPSBwcmV2aW91cztcbiAgICAgICAgICBwcmV2aW91c01vZGVsID0gcHJldmlvdXMudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aW91c01vZGVsICYmIHByZXZpb3VzTW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgICAgbGV0IGFzO1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbTIgPT09IFwiZnVuY3Rpb25cIiAmJiBpdGVtMi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwgPSBpdGVtMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtMikgJiYgaXRlbTIubW9kZWwgJiYgaXRlbTIubW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIG1vZGVsID0gaXRlbTIubW9kZWw7XG4gICAgICAgICAgICBhcyA9IGl0ZW0yLmFzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIGlmICghYXMgJiYgcHJldmlvdXNBc3NvY2lhdGlvbiAmJiBwcmV2aW91c0Fzc29jaWF0aW9uIGluc3RhbmNlb2YgQXNzb2NpYXRpb24gJiYgcHJldmlvdXNBc3NvY2lhdGlvbi50aHJvdWdoICYmIHByZXZpb3VzQXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCA9PT0gbW9kZWwpIHtcbiAgICAgICAgICAgICAgaXRlbTIgPSBuZXcgQXNzb2NpYXRpb24ocHJldmlvdXNNb2RlbCwgbW9kZWwsIHtcbiAgICAgICAgICAgICAgICBhczogbW9kZWwubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW0yID0gcHJldmlvdXNNb2RlbC5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKG1vZGVsLCBhcyk7XG4gICAgICAgICAgICAgIGlmICghaXRlbTIpIHtcbiAgICAgICAgICAgICAgICBpdGVtMiA9IHByZXZpb3VzTW9kZWwuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyhtb2RlbCwgbW9kZWwubmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGl0ZW0yIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdChcIlVuYWJsZSB0byBmaW5kIGEgdmFsaWQgYXNzb2NpYXRpb24gZm9yIG1vZGVsLCAnJXMnXCIsIG1vZGVsLm5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IG9yZGVySW5kZXggPSB2YWxpZE9yZGVyT3B0aW9ucy5pbmRleE9mKGl0ZW0yLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgb3JkZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGl0ZW0yID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChgICR7dmFsaWRPcmRlck9wdGlvbnNbb3JkZXJJbmRleF19YCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c01vZGVsICYmIHByZXZpb3VzTW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGVsLmFzc29jaWF0aW9ucyAhPT0gdm9pZCAwICYmIHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zW2l0ZW0yXSkge1xuICAgICAgICAgICAgICBpdGVtMiA9IHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zW2l0ZW0yXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzICE9PSB2b2lkIDAgJiYgcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW0yXSAmJiBpdGVtMiAhPT0gcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW0yXS5maWVsZCkge1xuICAgICAgICAgICAgICBpdGVtMiA9IHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtMl0uZmllbGQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0yLmluY2x1ZGVzKFwiLlwiKSAmJiBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtU3BsaXQgPSBpdGVtMi5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbVNwbGl0WzBdXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGAke3ByZXZpb3VzTW9kZWwubmFtZX0uJHtwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbVNwbGl0WzBdXS5maWVsZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gaXRlbVNwbGl0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGl0ZW0yID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShpZGVudGlmaWVyLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpdGVtMiA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoaXRlbTIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3Rpb25baW5kZXhdID0gaXRlbTI7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIGNvbnN0IGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBbXTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbGxlY3Rpb25MZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IGNvbGxlY3Rpb25baV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiB8fCBpdGVtLl9tb2RlbEF0dHJpYnV0ZSB8fCBpdGVtIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgdGFibGVOYW1lc1tpXSA9IGl0ZW0uYXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBzcWwgPSBcIlwiO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHNxbCArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZU5hbWVzLmpvaW4oY29ubmVjdG9yKSl9LmA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2xsZWN0aW9uWzBdID09PSBcInN0cmluZ1wiICYmIHBhcmVudCkge1xuICAgICAgICBzcWwgKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIocGFyZW50Lm5hbWUpfS5gO1xuICAgICAgfVxuICAgICAgY29sbGVjdGlvbi5zbGljZShpKS5mb3JFYWNoKChjb2xsZWN0aW9uSXRlbSkgPT4ge1xuICAgICAgICBzcWwgKz0gdGhpcy5xdW90ZShjb2xsZWN0aW9uSXRlbSwgcGFyZW50LCBjb25uZWN0b3IpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgICByZXR1cm4gc3FsO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbi5fbW9kZWxBdHRyaWJ1dGUpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLnF1b3RlVGFibGUoY29sbGVjdGlvbi5Nb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihjb2xsZWN0aW9uLmZpZWxkTmFtZSl9YDtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChjb2xsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChjb2xsZWN0aW9uKSAmJiBjb2xsZWN0aW9uLnJhdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHtyYXc6IFwiLi4uXCJ9YCBzeW50YXggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gIFVzZSBgc2VxdWVsaXplLmxpdGVyYWxgIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJ1Y3R1cmUgcGFzc2VkIHRvIG9yZGVyIC8gZ3JvdXA6ICR7dXRpbC5pbnNwZWN0KGNvbGxlY3Rpb24pfWApO1xuICB9XG4gIF9pbml0UXVvdGVJZGVudGlmaWVyKCkge1xuICAgIHRoaXMuX3F1b3RlSWRlbnRpZmllciA9IHRoaXMucXVvdGVJZGVudGlmaWVyO1xuICAgIHRoaXMucXVvdGVJZGVudGlmaWVyID0gZnVuY3Rpb24oaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICAgIGlmIChpZGVudGlmaWVyID09PSBcIipcIilcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICByZXR1cm4gdGhpcy5fcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKTtcbiAgICB9O1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcXVvdGVJZGVudGlmaWVyIGZvciBEaWFsZWN0IFwiJHt0aGlzLmRpYWxlY3R9XCIgaXMgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVycyhpZGVudGlmaWVycykge1xuICAgIGlmIChpZGVudGlmaWVycy5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgIGlkZW50aWZpZXJzID0gaWRlbnRpZmllcnMuc3BsaXQoXCIuXCIpO1xuICAgICAgY29uc3QgaGVhZCA9IGlkZW50aWZpZXJzLnNsaWNlKDAsIGlkZW50aWZpZXJzLmxlbmd0aCAtIDEpLmpvaW4oXCItPlwiKTtcbiAgICAgIGNvbnN0IHRhaWwgPSBpZGVudGlmaWVyc1tpZGVudGlmaWVycy5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihoZWFkKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWlsKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcnMpO1xuICB9XG4gIHF1b3RlQXR0cmlidXRlKGF0dHJpYnV0ZSwgbW9kZWwpIHtcbiAgICBpZiAobW9kZWwgJiYgYXR0cmlidXRlIGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGF0dHJpYnV0ZSk7XG4gIH1cbiAgZ2V0QWxpYXNUb2tlbigpIHtcbiAgICByZXR1cm4gXCJBU1wiO1xuICB9XG4gIHF1b3RlVGFibGUocGFyYW0sIGFsaWFzKSB7XG4gICAgbGV0IHRhYmxlID0gXCJcIjtcbiAgICBpZiAoYWxpYXMgPT09IHRydWUpIHtcbiAgICAgIGFsaWFzID0gcGFyYW0uYXMgfHwgcGFyYW0ubmFtZSB8fCBwYXJhbTtcbiAgICB9XG4gICAgaWYgKF8uaXNPYmplY3QocGFyYW0pKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5zY2hlbWFzKSB7XG4gICAgICAgIGlmIChwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgICB0YWJsZSArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbS5zY2hlbWEpfS5gO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlICs9IHRoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtLnRhYmxlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGFyYW0uc2NoZW1hKSB7XG4gICAgICAgICAgdGFibGUgKz0gcGFyYW0uc2NoZW1hICsgKHBhcmFtLmRlbGltaXRlciB8fCBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgKz0gcGFyYW0udGFibGVOYW1lO1xuICAgICAgICB0YWJsZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJhbSk7XG4gICAgfVxuICAgIGlmIChhbGlhcykge1xuICAgICAgdGFibGUgKz0gYCAke3RoaXMuZ2V0QWxpYXNUb2tlbigpfSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgZXNjYXBlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC50eXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlNUUklORyAmJiBbXCJteXNxbFwiLCBcIm1hcmlhZGJcIl0uaW5jbHVkZXModGhpcy5kaWFsZWN0KSAmJiBbXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IFN0cmluZyhOdW1iZXIodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChmaWVsZC50eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICAgIGNvbnN0IHNpbXBsZUVzY2FwZSA9IChlc2NWYWwpID0+IFNxbFN0cmluZy5lc2NhcGUoZXNjVmFsLCB0aGlzLm9wdGlvbnMudGltZXpvbmUsIHRoaXMuZGlhbGVjdCk7XG4gICAgICAgICAgdmFsdWUgPSBmaWVsZC50eXBlLnN0cmluZ2lmeSh2YWx1ZSwgeyBlc2NhcGU6IHNpbXBsZUVzY2FwZSwgZmllbGQsIHRpbWV6b25lOiB0aGlzLm9wdGlvbnMudGltZXpvbmUsIG9wZXJhdGlvbjogb3B0aW9ucy5vcGVyYXRpb24gfSk7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUuZXNjYXBlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU3FsU3RyaW5nLmVzY2FwZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnRpbWV6b25lLCB0aGlzLmRpYWxlY3QpO1xuICB9XG4gIGJpbmRQYXJhbShiaW5kKSB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgYmluZC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBgJCR7YmluZC5sZW5ndGh9YDtcbiAgICB9O1xuICB9XG4gIGZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIGJpbmRQYXJhbSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhc3MgU2VxdWVsaXplTWV0aG9kIGFzIGEgYmluZCBwYXJhbWV0ZXIgLSB1c2UgZXNjYXBlIGluc3RlYWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgJiYgZmllbGQudHlwZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChmaWVsZC50eXBlLmJpbmRQYXJhbSkge1xuICAgICAgICAgIHJldHVybiBmaWVsZC50eXBlLmJpbmRQYXJhbSh2YWx1ZSwgeyBlc2NhcGU6IF8uaWRlbnRpdHksIGZpZWxkLCB0aW1lem9uZTogdGhpcy5vcHRpb25zLnRpbWV6b25lLCBvcGVyYXRpb246IG9wdGlvbnMub3BlcmF0aW9uLCBiaW5kUGFyYW0gfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJpbmRQYXJhbSh2YWx1ZSk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMudHlwZVZhbGlkYXRpb24gJiYgZmllbGQudHlwZS52YWxpZGF0ZSAmJiB2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNMaXN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBmaWVsZC50eXBlLnZhbGlkYXRlKGl0ZW0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZC50eXBlLnZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oZXJyb3IubWVzc2FnZSwgXCJWYWxpZGF0aW9uIGVycm9yXCIsIGZpZWxkLmZpZWxkTmFtZSwgdmFsdWUsIG51bGwsIGAke2ZpZWxkLnR5cGUua2V5fSB2YWxpZGF0b3JgKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSWRlbnRpZmllclF1b3RlZChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIC9eXFxzKig/OihbYFwiJ10pKD86KD8hXFwxKS58XFwxezJ9KSpcXDFcXC4/KStcXHMqJC9pLnRlc3QoaWRlbnRpZmllcik7XG4gIH1cbiAganNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRoLCBpc0pzb24pIHtcbiAgICBsZXQgcGF0aHMgPSBfLnRvUGF0aChwYXRoKTtcbiAgICBsZXQgcGF0aFN0cjtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW4gPSB0aGlzLmlzSWRlbnRpZmllclF1b3RlZChjb2x1bW4pID8gY29sdW1uIDogdGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGlhbGVjdCkge1xuICAgICAgY2FzZSBcIm15c3FsXCI6XG4gICAgICBjYXNlIFwibWFyaWFkYlwiOlxuICAgICAgY2FzZSBcInNxbGl0ZVwiOlxuICAgICAgICBpZiAodGhpcy5kaWFsZWN0ID09PSBcIm15c3FsXCIpIHtcbiAgICAgICAgICBwYXRocyA9IHBhdGhzLm1hcCgoc3ViUGF0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIC9cXEQvLnRlc3Qoc3ViUGF0aCkgPyBVdGlscy5hZGRUaWNrcyhzdWJQYXRoLCAnXCInKSA6IHN1YlBhdGg7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aFN0ciA9IHRoaXMuZXNjYXBlKFtcIiRcIl0uY29uY2F0KHBhdGhzKS5qb2luKFwiLlwiKS5yZXBsYWNlKC9cXC4oXFxkKykoPzooPz1cXC4pfCQpL2csIChfXywgZGlnaXQpID0+IGBbJHtkaWdpdH1dYCkpO1xuICAgICAgICBpZiAodGhpcy5kaWFsZWN0ID09PSBcInNxbGl0ZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGBqc29uX2V4dHJhY3QoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGpzb25fdW5xdW90ZShqc29uX2V4dHJhY3QoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pKWA7XG4gICAgICBjYXNlIFwicG9zdGdyZXNcIjpcbiAgICAgICAgY29uc3Qgam9pbiA9IGlzSnNvbiA/IFwiIz5cIiA6IFwiIz4+XCI7XG4gICAgICAgIHBhdGhTdHIgPSB0aGlzLmVzY2FwZShgeyR7cGF0aHMuam9pbihcIixcIil9fWApO1xuICAgICAgICByZXR1cm4gYCgke3F1b3RlZENvbHVtbn0ke2pvaW59JHtwYXRoU3RyfSlgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCAke3RoaXMuZGlhbGVjdH0gZm9yIEpTT04gb3BlcmF0aW9uc2ApO1xuICAgIH1cbiAgfVxuICBzZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0O1xuICAgIGNvbnN0IG1haW5RdWVyeUl0ZW1zID0gW107XG4gICAgY29uc3Qgc3ViUXVlcnlJdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5ID0gb3B0aW9ucy5zdWJRdWVyeSA9PT0gdm9pZCAwID8gbGltaXQgJiYgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uIDogb3B0aW9ucy5zdWJRdWVyeTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogb3B0aW9ucy5hdHRyaWJ1dGVzICYmIG9wdGlvbnMuYXR0cmlidXRlcy5zbGljZSgpLFxuICAgICAgc3ViUXVlcnk6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IG1haW5UYWJsZSA9IHtcbiAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgIHF1b3RlZE5hbWU6IG51bGwsXG4gICAgICBhczogbnVsbCxcbiAgICAgIG1vZGVsXG4gICAgfTtcbiAgICBjb25zdCB0b3BMZXZlbEluZm8gPSB7XG4gICAgICBuYW1lczogbWFpblRhYmxlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHN1YlF1ZXJ5XG4gICAgfTtcbiAgICBsZXQgbWFpbkpvaW5RdWVyaWVzID0gW107XG4gICAgbGV0IHN1YkpvaW5RdWVyaWVzID0gW107XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiAhb3B0aW9ucy5hbGlhc2VzTWFwcGluZykge1xuICAgICAgb3B0aW9ucy5hbGlhc2VzTWFwcGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBvcHRpb25zLmFsaWFzZXNCeVRhYmxlID0ge307XG4gICAgICBvcHRpb25zLmluY2x1ZGVBbGlhc2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGFibGVBcykge1xuICAgICAgbWFpblRhYmxlLmFzID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy50YWJsZUFzKTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1haW5UYWJsZS5uYW1lKSAmJiBtYWluVGFibGUubW9kZWwpIHtcbiAgICAgIG1haW5UYWJsZS5hcyA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG1haW5UYWJsZS5tb2RlbC5uYW1lKTtcbiAgICB9XG4gICAgbWFpblRhYmxlLnF1b3RlZE5hbWUgPSAhQXJyYXkuaXNBcnJheShtYWluVGFibGUubmFtZSkgPyB0aGlzLnF1b3RlVGFibGUobWFpblRhYmxlLm5hbWUpIDogdGFibGVOYW1lLm1hcCgodCkgPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLnF1b3RlVGFibGUodFswXSwgdFsxXSkgOiB0aGlzLnF1b3RlVGFibGUodCwgdHJ1ZSk7XG4gICAgfSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChzdWJRdWVyeSAmJiBhdHRyaWJ1dGVzLm1haW4pIHtcbiAgICAgIGZvciAoY29uc3Qga2V5QXR0IG9mIG1haW5UYWJsZS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMubWFpbi5zb21lKChhdHRyKSA9PiBrZXlBdHQgPT09IGF0dHIgfHwga2V5QXR0ID09PSBhdHRyWzBdIHx8IGtleUF0dCA9PT0gYXR0clsxXSkpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChtYWluVGFibGUubW9kZWwucmF3QXR0cmlidXRlc1trZXlBdHRdLmZpZWxkID8gW2tleUF0dCwgbWFpblRhYmxlLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5QXR0XS5maWVsZF0gOiBrZXlBdHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMubWFpbiA9IHRoaXMuZXNjYXBlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLm1haW4sIG9wdGlvbnMsIG1haW5UYWJsZS5hcyk7XG4gICAgYXR0cmlidXRlcy5tYWluID0gYXR0cmlidXRlcy5tYWluIHx8IChvcHRpb25zLmluY2x1ZGUgPyBbYCR7bWFpblRhYmxlLmFzfS4qYF0gOiBbXCIqXCJdKTtcbiAgICBpZiAoc3ViUXVlcnkgfHwgb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLm1haW47XG4gICAgICBhdHRyaWJ1dGVzLm1haW4gPSBbYCR7bWFpblRhYmxlLmFzIHx8IG1haW5UYWJsZS5xdW90ZWROYW1lfS4qYF07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUuc2VwYXJhdGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqb2luUXVlcmllcyA9IHRoaXMuZ2VuZXJhdGVJbmNsdWRlKGluY2x1ZGUsIHsgZXh0ZXJuYWxBczogbWFpblRhYmxlLmFzLCBpbnRlcm5hbEFzOiBtYWluVGFibGUuYXMgfSwgdG9wTGV2ZWxJbmZvKTtcbiAgICAgICAgc3ViSm9pblF1ZXJpZXMgPSBzdWJKb2luUXVlcmllcy5jb25jYXQoam9pblF1ZXJpZXMuc3ViUXVlcnkpO1xuICAgICAgICBtYWluSm9pblF1ZXJpZXMgPSBtYWluSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLm1haW5RdWVyeSk7XG4gICAgICAgIGlmIChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IF8udW5pcShhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gXy51bmlxKGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaCh0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCwgYXR0cmlidXRlcy5zdWJRdWVyeSwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcykpO1xuICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKHN1YkpvaW5RdWVyaWVzLmpvaW4oXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgICAgaWYgKCFtYWluVGFibGUuYXMpIHtcbiAgICAgICAgICBtYWluVGFibGUuYXMgPSBtYWluVGFibGUucXVvdGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3aGVyZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLndoZXJlKTtcbiAgICAgICAgbGV0IGdyb3VwZWRMaW1pdE9yZGVyLCB3aGVyZUtleSwgaW5jbHVkZSwgZ3JvdXBlZFRhYmxlTmFtZSA9IG1haW5UYWJsZS5hcztcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHdoZXJlS2V5ID0gb3B0aW9ucy5ncm91cGVkTGltaXQub247XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ncm91cGVkTGltaXQub24gaW5zdGFuY2VvZiBIYXNNYW55KSB7XG4gICAgICAgICAgd2hlcmVLZXkgPSBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5mb3JlaWduS2V5RmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgIGdyb3VwZWRUYWJsZU5hbWUgPSBvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5tYW55RnJvbVNvdXJjZS5hcztcbiAgICAgICAgICBjb25zdCBncm91cGVkTGltaXRPcHRpb25zID0gTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh7XG4gICAgICAgICAgICBpbmNsdWRlOiBbe1xuICAgICAgICAgICAgICBhc3NvY2lhdGlvbjogb3B0aW9ucy5ncm91cGVkTGltaXQub24ubWFueUZyb21Tb3VyY2UsXG4gICAgICAgICAgICAgIGR1cGxpY2F0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHdoZXJlOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICAgICAgW09wLnBsYWNlaG9sZGVyXTogdHJ1ZVxuICAgICAgICAgICAgICB9LCBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoICYmIG9wdGlvbnMuZ3JvdXBlZExpbWl0LnRocm91Z2gud2hlcmUpXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG1vZGVsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3B0aW9ucy5oYXNKb2luID0gdHJ1ZTtcbiAgICAgICAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgICAgIG9wdGlvbnMuaW5jbHVkZU1hcCA9IE9iamVjdC5hc3NpZ24oZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlTWFwLCBvcHRpb25zLmluY2x1ZGVNYXApO1xuICAgICAgICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzID0gZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlTmFtZXMuY29uY2F0KG9wdGlvbnMuaW5jbHVkZU5hbWVzIHx8IFtdKTtcbiAgICAgICAgICBpbmNsdWRlID0gZ3JvdXBlZExpbWl0T3B0aW9ucy5pbmNsdWRlO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXIpKSB7XG4gICAgICAgICAgICBvcHRpb25zLm9yZGVyLmZvckVhY2goKG9yZGVyLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9yZGVyKSkge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXJbMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGFsaWFzID0gYHN1YnF1ZXJ5X29yZGVyXyR7aX1gO1xuICAgICAgICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMucHVzaChbb3JkZXIsIGFsaWFzXSk7XG4gICAgICAgICAgICAgIGFsaWFzID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlKGFsaWFzKSk7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vcmRlcltpXVswXSA9IGFsaWFzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JkZXJbaV0gPSBhbGlhcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cGVkTGltaXRPcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwZWRMaW1pdE9yZGVyID0gb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICBpZiAoIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMudG9wTGV2ZWxPcmRlckJ5UmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGVyZVtPcC5wbGFjZWhvbGRlcl0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VRdWVyeSA9IGBTRUxFQ1QgKiBGUk9NICgke3RoaXMuc2VsZWN0UXVlcnkodGFibGVOYW1lLCB7XG4gICAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgICAgICAgbGltaXQ6IG9wdGlvbnMuZ3JvdXBlZExpbWl0LmxpbWl0LFxuICAgICAgICAgIG9yZGVyOiBncm91cGVkTGltaXRPcmRlcixcbiAgICAgICAgICBhbGlhc2VzTWFwcGluZzogb3B0aW9ucy5hbGlhc2VzTWFwcGluZyxcbiAgICAgICAgICBhbGlhc2VzQnlUYWJsZTogb3B0aW9ucy5hbGlhc2VzQnlUYWJsZSxcbiAgICAgICAgICB3aGVyZSxcbiAgICAgICAgICBpbmNsdWRlLFxuICAgICAgICAgIG1vZGVsXG4gICAgICAgIH0sIG1vZGVsKS5yZXBsYWNlKC87JC8sIFwiXCIpfSkgJHt0aGlzLmdldEFsaWFzVG9rZW4oKX0gc3ViYDtcbiAgICAgICAgY29uc3QgcGxhY2VIb2xkZXIgPSB0aGlzLndoZXJlSXRlbVF1ZXJ5KE9wLnBsYWNlaG9sZGVyLCB0cnVlLCB7IG1vZGVsIH0pO1xuICAgICAgICBjb25zdCBzcGxpY2VQb3MgPSBiYXNlUXVlcnkuaW5kZXhPZihwbGFjZUhvbGRlcik7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgYCgke29wdGlvbnMuZ3JvdXBlZExpbWl0LnZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgbGV0IGdyb3VwV2hlcmU7XG4gICAgICAgICAgaWYgKHdoZXJlS2V5KSB7XG4gICAgICAgICAgICBncm91cFdoZXJlID0ge1xuICAgICAgICAgICAgICBbd2hlcmVLZXldOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgICAgICAgIGdyb3VwV2hlcmUgPSB7XG4gICAgICAgICAgICAgIFtvcHRpb25zLmdyb3VwZWRMaW1pdC5vbi5mb3JlaWduSWRlbnRpZmllckZpZWxkXTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBVdGlscy5zcGxpY2VTdHIoYmFzZVF1ZXJ5LCBzcGxpY2VQb3MsIHBsYWNlSG9sZGVyLmxlbmd0aCwgdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoZ3JvdXBXaGVyZSwgZ3JvdXBlZFRhYmxlTmFtZSkpO1xuICAgICAgICB9KS5qb2luKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJVTklPTiBBTExcIl0gPyBcIiBVTklPTiBBTEwgXCIgOiBcIiBVTklPTiBcIil9KWAsIG1haW5UYWJsZS5hcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaCh0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCwgYXR0cmlidXRlcy5tYWluLCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzKSk7XG4gICAgICB9XG4gICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKG1haW5Kb2luUXVlcmllcy5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcIndoZXJlXCIpICYmICFvcHRpb25zLmdyb3VwZWRMaW1pdCkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKG9wdGlvbnMud2hlcmUsIG1haW5UYWJsZS5hcyB8fCB0YWJsZU5hbWUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIFdIRVJFICR7b3B0aW9ucy53aGVyZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgV0hFUkUgJHtvcHRpb25zLndoZXJlfWApO1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiU0VMRUNUXCIpKSB7XG4gICAgICAgICAgICAgIG1haW5RdWVyeUl0ZW1zW2tleV0gPSB0aGlzLnNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICBvcHRpb25zLmdyb3VwID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmdyb3VwKSA/IG9wdGlvbnMuZ3JvdXAubWFwKCh0KSA9PiB0aGlzLmFsaWFzR3JvdXBpbmcodCwgbW9kZWwsIG1haW5UYWJsZS5hcywgb3B0aW9ucykpLmpvaW4oXCIsIFwiKSA6IHRoaXMuYWxpYXNHcm91cGluZyhvcHRpb25zLmdyb3VwLCBtb2RlbCwgbWFpblRhYmxlLmFzLCBvcHRpb25zKTtcbiAgICAgIGlmIChzdWJRdWVyeSAmJiBvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIEdST1VQIEJZICR7b3B0aW9ucy5ncm91cH1gKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgR1JPVVAgQlkgJHtvcHRpb25zLmdyb3VwfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiaGF2aW5nXCIpKSB7XG4gICAgICBvcHRpb25zLmhhdmluZyA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKG9wdGlvbnMuaGF2aW5nLCB0YWJsZU5hbWUsIG1vZGVsLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICBpZiAob3B0aW9ucy5oYXZpbmcpIHtcbiAgICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgSEFWSU5HICR7b3B0aW9ucy5oYXZpbmd9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIEhBVklORyAke29wdGlvbnMuaGF2aW5nfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9yZGVyKSB7XG4gICAgICBjb25zdCBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBzdWJRdWVyeSk7XG4gICAgICBpZiAob3JkZXJzLm1haW5RdWVyeU9yZGVyLmxlbmd0aCkge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGAgT1JERVIgQlkgJHtvcmRlcnMubWFpblF1ZXJ5T3JkZXIuam9pbihcIiwgXCIpfWApO1xuICAgICAgfVxuICAgICAgaWYgKG9yZGVycy5zdWJRdWVyeU9yZGVyLmxlbmd0aCkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBPUkRFUiBCWSAke29yZGVycy5zdWJRdWVyeU9yZGVyLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXRPcmRlciA9IHRoaXMuYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsKTtcbiAgICBpZiAobGltaXRPcmRlciAmJiAhb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2gobGltaXRPcmRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKGxpbWl0T3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcy5tYWluLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZS5hcyB9KTtcbiAgICAgIHF1ZXJ5ID0gYFNFTEVDVCAke2F0dHJpYnV0ZXMubWFpbi5qb2luKFwiLCBcIil9IEZST00gKCR7c3ViUXVlcnlJdGVtcy5qb2luKFwiXCIpfSkgJHt0aGlzLmdldEFsaWFzVG9rZW4oKX0gJHttYWluVGFibGUuYXN9JHttYWluSm9pblF1ZXJpZXMuam9pbihcIlwiKX0ke21haW5RdWVyeUl0ZW1zLmpvaW4oXCJcIil9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBtYWluUXVlcnlJdGVtcy5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2NrICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMubG9jaykge1xuICAgICAgbGV0IGxvY2sgPSBvcHRpb25zLmxvY2s7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2NrID0gb3B0aW9ucy5sb2NrLmxldmVsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMubG9ja0tleSAmJiBbXCJLRVkgU0hBUkVcIiwgXCJOTyBLRVkgVVBEQVRFXCJdLmluY2x1ZGVzKGxvY2spKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgRk9SICR7bG9ja31gO1xuICAgICAgfSBlbHNlIGlmIChsb2NrID09PSBcIlNIQVJFXCIpIHtcbiAgICAgICAgcXVlcnkgKz0gYCAke3RoaXMuX2RpYWxlY3Quc3VwcG9ydHMuZm9yU2hhcmV9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5ICs9IFwiIEZPUiBVUERBVEVcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2tPZiAmJiBvcHRpb25zLmxvY2sub2YgJiYgb3B0aW9ucy5sb2NrLm9mLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgT0YgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy5sb2NrLm9mLm5hbWUpfWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5za2lwTG9ja2VkICYmIG9wdGlvbnMuc2tpcExvY2tlZCkge1xuICAgICAgICBxdWVyeSArPSBcIiBTS0lQIExPQ0tFRFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cbiAgYWxpYXNHcm91cGluZyhmaWVsZCwgbW9kZWwsIHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNyYyA9IEFycmF5LmlzQXJyYXkoZmllbGQpID8gZmllbGRbMF0gOiBmaWVsZDtcbiAgICByZXR1cm4gdGhpcy5xdW90ZSh0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgc3JjLCBvcHRpb25zKSB8fCBzcmMsIG1vZGVsKTtcbiAgfVxuICBlc2NhcGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1haW5UYWJsZUFzKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXMgJiYgYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHtcbiAgICAgIGxldCBhZGRUYWJsZSA9IHRydWU7XG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyKSkge1xuICAgICAgICBpZiAoYXR0ci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7SlNPTi5zdHJpbmdpZnkoYXR0cil9IGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBkZWZpbml0aW9uLiBQbGVhc2UgdXNlIHRoZSBmb2xsb3dpbmcgZm9ybWF0OiBbJ2F0dHJpYnV0ZSBkZWZpbml0aW9uJywgJ2FsaWFzJ11gKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyID0gYXR0ci5zbGljZSgpO1xuICAgICAgICBpZiAoYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIGF0dHJbMF0gPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyWzBdKTtcbiAgICAgICAgICBhZGRUYWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVCZWhhdmlvciA9PT0gXCJlc2NhcGVcIiB8fCAhYXR0clswXS5pbmNsdWRlcyhcIihcIikgJiYgIWF0dHJbMF0uaW5jbHVkZXMoXCIpXCIpKSB7XG4gICAgICAgICAgYXR0clswXSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGVCZWhhdmlvciAhPT0gXCJ1bnNhZmUtbGVnYWN5XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dHJpYnV0ZXMgY2Fubm90IGluY2x1ZGUgcGFyZW50aGVzZXMgaW4gU2VxdWVsaXplIDY6XG5JbiBvcmRlciB0byBmaXggdGhlIHZ1bG5lcmFiaWxpdHkgQ1ZFLTIwMjMtMjI1NzgsIHdlIGhhZCB0byByZW1vdmUgc3VwcG9ydCBmb3IgdHJlYXRpbmcgYXR0cmlidXRlcyBhcyByYXcgU1FMIGlmIHRoZXkgaW5jbHVkZWQgcGFyZW50aGVzZXMuXG5TZXF1ZWxpemUgNyBlc2NhcGVzIGFsbCBhdHRyaWJ1dGVzLCBldmVuIGlmIHRoZXkgaW5jbHVkZSBwYXJlbnRoZXNlcy5cbkZvciBTZXF1ZWxpemUgNiwgYmVjYXVzZSB3ZSdyZSBpbnRyb2R1Y2luZyB0aGlzIGNoYW5nZSBpbiBhIG1pbm9yIHJlbGVhc2UsIHdlJ3ZlIG9wdGVkIGZvciB0aHJvd2luZyBhbiBlcnJvciBpbnN0ZWFkIG9mIHNpbGVudGx5IGVzY2FwaW5nIHRoZSBhdHRyaWJ1dGUgYXMgYSB3YXkgdG8gd2FybiB5b3UgYWJvdXQgdGhpcyBjaGFuZ2UuXG5cbkhlcmUgaXMgd2hhdCB5b3UgY2FuIGRvIHRvIGZpeCB0aGlzIGVycm9yOlxuLSBXcmFwIHRoZSBhdHRyaWJ1dGUgaW4gYSBsaXRlcmFsKCkgY2FsbC4gVGhpcyB3aWxsIG1ha2UgU2VxdWVsaXplIHRyZWF0IGl0IGFzIHJhdyBTUUwuXG4tIFNldCB0aGUgXCJhdHRyaWJ1dGVCZWhhdmlvclwiIHNlcXVlbGl6ZSBvcHRpb24gdG8gXCJlc2NhcGVcIiB0byBtYWtlIFNlcXVlbGl6ZSBlc2NhcGUgdGhlIGF0dHJpYnV0ZSwgbGlrZSBpbiBTZXF1ZWxpemUgdjcuIFdlIGhpZ2hseSByZWNvbW1lbmQgdGhpcyBvcHRpb24uXG4tIFNldCB0aGUgXCJhdHRyaWJ1dGVCZWhhdmlvclwiIHNlcXVlbGl6ZSBvcHRpb24gdG8gXCJ1bnNhZmUtbGVnYWN5XCIgdG8gbWFrZSBTZXF1ZWxpemUgZXNjYXBlIHRoZSBhdHRyaWJ1dGUsIGxpa2UgaW4gU2VxdWVsaXplIHY1LlxuXG5XZSBzaW5jZXJlbHkgYXBvbG9naXplIGZvciB0aGUgaW5jb252ZW5pZW5jZSB0aGlzIG1heSBjYXVzZSB5b3UuIFlvdSBjYW4gZmluZCBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBmb2xsb3dpbmcgdGhyZWFkczpcbmh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL3NlY3VyaXR5L2Fkdmlzb3JpZXMvR0hTQS1mNTk4LW1mcHYtZ21meFxuaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvZGlzY3Vzc2lvbnMvMTU2OTRgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWxpYXMgPSBhdHRyWzFdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIG1haW5UYWJsZUFzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyID0gW2F0dHJbMF0sIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKV0uam9pbihcIiBBUyBcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyID0gIWF0dHIuaW5jbHVkZXMoVXRpbHMuVElDS19DSEFSKSAmJiAhYXR0ci5pbmNsdWRlcygnXCInKSA/IHRoaXMucXVvdGVBdHRyaWJ1dGUoYXR0ciwgb3B0aW9ucy5tb2RlbCkgOiB0aGlzLmVzY2FwZShhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmICghXy5pc0VtcHR5KG9wdGlvbnMuaW5jbHVkZSkgJiYgKCFhdHRyLmluY2x1ZGVzKFwiLlwiKSB8fCBvcHRpb25zLmRvdE5vdGF0aW9uKSAmJiBhZGRUYWJsZSkge1xuICAgICAgICBhdHRyID0gYCR7bWFpblRhYmxlQXN9LiR7YXR0cn1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSk7XG4gIH1cbiAgZ2VuZXJhdGVJbmNsdWRlKGluY2x1ZGUsIHBhcmVudFRhYmxlTmFtZSwgdG9wTGV2ZWxJbmZvKSB7XG4gICAgY29uc3Qgam9pblF1ZXJpZXMgPSB7XG4gICAgICBtYWluUXVlcnk6IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBjb25zdCBtYWluQ2hpbGRJbmNsdWRlcyA9IFtdO1xuICAgIGNvbnN0IHN1YkNoaWxkSW5jbHVkZXMgPSBbXTtcbiAgICBsZXQgcmVxdWlyZWRNaXNtYXRjaCA9IGZhbHNlO1xuICAgIGNvbnN0IGluY2x1ZGVBcyA9IHtcbiAgICAgIGludGVybmFsQXM6IGluY2x1ZGUuYXMsXG4gICAgICBleHRlcm5hbEFzOiBpbmNsdWRlLmFzXG4gICAgfTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogW10sXG4gICAgICBzdWJRdWVyeTogW11cbiAgICB9O1xuICAgIGxldCBqb2luUXVlcnk7XG4gICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMua2V5c0VzY2FwZWQgPSB0cnVlO1xuICAgIGlmICh0b3BMZXZlbEluZm8ubmFtZXMubmFtZSAhPT0gcGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXMgJiYgdG9wTGV2ZWxJbmZvLm5hbWVzLmFzICE9PSBwYXJlbnRUYWJsZU5hbWUuZXh0ZXJuYWxBcykge1xuICAgICAgaW5jbHVkZUFzLmludGVybmFsQXMgPSBgJHtwYXJlbnRUYWJsZU5hbWUuaW50ZXJuYWxBc30tPiR7aW5jbHVkZS5hc31gO1xuICAgICAgaW5jbHVkZUFzLmV4dGVybmFsQXMgPSBgJHtwYXJlbnRUYWJsZU5hbWUuZXh0ZXJuYWxBc30uJHtpbmNsdWRlLmFzfWA7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlSWdub3JlQXR0cmlidXRlcyAhPT0gZmFsc2UpIHtcbiAgICAgIGluY2x1ZGUubW9kZWwuX2V4cGFuZEF0dHJpYnV0ZXMoaW5jbHVkZSk7XG4gICAgICBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgICAgY29uc3QgaW5jbHVkZUF0dHJpYnV0ZXMgPSBpbmNsdWRlLmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB7XG4gICAgICAgIGxldCBhdHRyQXMgPSBhdHRyO1xuICAgICAgICBsZXQgdmVyYmF0aW0gPSBmYWxzZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikgJiYgYXR0ci5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBpZiAoYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCAmJiAoYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwgfHwgYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkNhc3QgfHwgYXR0clswXSBpbnN0YW5jZW9mIFV0aWxzLkZuKSkge1xuICAgICAgICAgICAgdmVyYmF0aW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyID0gYXR0ci5tYXAoKGF0dHIyKSA9PiBhdHRyMiBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCA/IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIyKSA6IGF0dHIyKTtcbiAgICAgICAgICBhdHRyQXMgPSBhdHRyWzFdO1xuICAgICAgICAgIGF0dHIgPSBhdHRyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHJldHVybiBhdHRyLnZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkNhc3QgfHwgYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkZuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gc2VsZWN0IGF0dHJpYnV0ZXMgdXNpbmcgU2VxdWVsaXplLmNhc3Qgb3IgU2VxdWVsaXplLmZuIHdpdGhvdXQgc3BlY2lmeWluZyBhbiBhbGlhcyBmb3IgdGhlIHJlc3VsdCwgZHVyaW5nIGVhZ2VyIGxvYWRpbmcuIFRoaXMgbWVhbnMgdGhlIGF0dHJpYnV0ZSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgcmV0dXJuZWQgaW5zdGFuY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgaWYgKHZlcmJhdGltID09PSB0cnVlKSB7XG4gICAgICAgICAgcHJlZml4ID0gYXR0cjtcbiAgICAgICAgfSBlbHNlIGlmICgvIz4+fC0+Pi8udGVzdChhdHRyKSkge1xuICAgICAgICAgIHByZWZpeCA9IGAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LiR7YXR0ci5yZXBsYWNlKC9cXCh8XFwpL2csIFwiXCIpfSlgO1xuICAgICAgICB9IGVsc2UgaWYgKC9qc29uX2V4dHJhY3RcXCgvLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBhdHRyLnJlcGxhY2UoL2pzb25fZXh0cmFjdFxcKC9pLCBganNvbl9leHRyYWN0KCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS5gKTtcbiAgICAgICAgfSBlbHNlIGlmICgvanNvbl92YWx1ZVxcKC8udGVzdChhdHRyKSkge1xuICAgICAgICAgIHByZWZpeCA9IGF0dHIucmVwbGFjZSgvanNvbl92YWx1ZVxcKC9pLCBganNvbl92YWx1ZSgke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlZml4ID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWFzID0gYCR7aW5jbHVkZUFzLmV4dGVybmFsQXN9LiR7YXR0ckFzfWA7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgaW5jbHVkZUFzLmludGVybmFsQXMsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgICAgcHJlZml4LFxuICAgICAgICAgIFwiQVNcIixcbiAgICAgICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcywgdHJ1ZSlcbiAgICAgICAgXSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgaW5jbHVkZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBpbmNsdWRlQXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLnRocm91Z2gpIHtcbiAgICAgIGpvaW5RdWVyeSA9IHRoaXMuZ2VuZXJhdGVUaHJvdWdoSm9pbihpbmNsdWRlLCBpbmNsdWRlQXMsIHBhcmVudFRhYmxlTmFtZS5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICAgIGpvaW5RdWVyeSA9IHRoaXMuZ2VuZXJhdGVKb2luKGluY2x1ZGUsIHRvcExldmVsSW5mbyk7XG4gICAgfVxuICAgIGlmIChqb2luUXVlcnkuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoam9pblF1ZXJ5LmF0dHJpYnV0ZXMubWFpbik7XG4gICAgfVxuICAgIGlmIChqb2luUXVlcnkuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5zdWJRdWVyeS5jb25jYXQoam9pblF1ZXJ5LmF0dHJpYnV0ZXMuc3ViUXVlcnkpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkSW5jbHVkZSBvZiBpbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgaWYgKGNoaWxkSW5jbHVkZS5zZXBhcmF0ZSB8fCBjaGlsZEluY2x1ZGUuX3BzZXVkbykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkSm9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShjaGlsZEluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICAgICAgaWYgKGluY2x1ZGUucmVxdWlyZWQgPT09IGZhbHNlICYmIGNoaWxkSW5jbHVkZS5yZXF1aXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlcXVpcmVkTWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEluY2x1ZGUuc3ViUXVlcnkgJiYgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICAgICAgc3ViQ2hpbGRJbmNsdWRlcy5wdXNoKGNoaWxkSm9pblF1ZXJpZXMuc3ViUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLm1haW5RdWVyeSkge1xuICAgICAgICAgIG1haW5DaGlsZEluY2x1ZGVzLnB1c2goY2hpbGRKb2luUXVlcmllcy5tYWluUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluID0gYXR0cmlidXRlcy5tYWluLmNvbmNhdChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMubWFpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGNoaWxkSm9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkgJiYgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICBpZiAocmVxdWlyZWRNaXNtYXRjaCAmJiBzdWJDaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICggJHtqb2luUXVlcnkuYm9keX0ke3N1YkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKX0gKSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gJHtqb2luUXVlcnkuYm9keX0gT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgICBpZiAoc3ViQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChzdWJDaGlsZEluY2x1ZGVzLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChtYWluQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlcXVpcmVkTWlzbWF0Y2ggJiYgbWFpbkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBqb2luUXVlcmllcy5tYWluUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICggJHtqb2luUXVlcnkuYm9keX0ke21haW5DaGlsZEluY2x1ZGVzLmpvaW4oXCJcIil9ICkgT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAke2pvaW5RdWVyeS5ib2R5fSBPTiAke2pvaW5RdWVyeS5jb25kaXRpb259YCk7XG4gICAgICAgIGlmIChtYWluQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2gobWFpbkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goc3ViQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1haW5RdWVyeTogam9pblF1ZXJpZXMubWFpblF1ZXJ5LmpvaW4oXCJcIiksXG4gICAgICBzdWJRdWVyeTogam9pblF1ZXJpZXMuc3ViUXVlcnkuam9pbihcIlwiKSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9O1xuICB9XG4gIF9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF07XG4gICAgfVxuICAgIGlmIChhbGlhcy5tYXRjaCgvc3VicXVlcnlfb3JkZXJfWzAtOV0vKSkge1xuICAgICAgcmV0dXJuIGFsaWFzO1xuICAgIH1cbiAgICBjb25zdCBtaW5pZmllZEFsaWFzID0gYF8ke29wdGlvbnMuYWxpYXNlc01hcHBpbmcuc2l6ZX1gO1xuICAgIG9wdGlvbnMuYWxpYXNlc01hcHBpbmcuc2V0KG1pbmlmaWVkQWxpYXMsIGFsaWFzKTtcbiAgICBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdID0gbWluaWZpZWRBbGlhcztcbiAgICByZXR1cm4gbWluaWZpZWRBbGlhcztcbiAgfVxuICBfZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHtmaWVsZH1gXSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHtmaWVsZH1gXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2VuZXJhdGVKb2luKGluY2x1ZGUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICBjb25zdCBwYXJlbnQgPSBpbmNsdWRlLnBhcmVudDtcbiAgICBjb25zdCBwYXJlbnRJc1RvcCA9ICEhcGFyZW50ICYmICFpbmNsdWRlLnBhcmVudC5hc3NvY2lhdGlvbiAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbC5uYW1lID09PSB0b3BMZXZlbEluZm8ub3B0aW9ucy5tb2RlbC5uYW1lO1xuICAgIGxldCAkcGFyZW50O1xuICAgIGxldCBqb2luV2hlcmU7XG4gICAgY29uc3QgbGVmdCA9IGFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICBjb25zdCBhdHRyTGVmdCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID8gYXNzb2NpYXRpb24uaWRlbnRpZmllciA6IGFzc29jaWF0aW9uLnNvdXJjZUtleUF0dHJpYnV0ZSB8fCBsZWZ0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgZmllbGRMZWZ0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gPyBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQgOiBsZWZ0LnJhd0F0dHJpYnV0ZXNbYXNzb2NpYXRpb24uc291cmNlS2V5QXR0cmlidXRlIHx8IGxlZnQucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgbGV0IGFzTGVmdDtcbiAgICBjb25zdCByaWdodCA9IGluY2x1ZGUubW9kZWw7XG4gICAgY29uc3QgdGFibGVSaWdodCA9IHJpZ2h0LmdldFRhYmxlTmFtZSgpO1xuICAgIGNvbnN0IGZpZWxkUmlnaHQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/IHJpZ2h0LnJhd0F0dHJpYnV0ZXNbYXNzb2NpYXRpb24udGFyZ2V0SWRlbnRpZmllciB8fCByaWdodC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCA6IGFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcbiAgICBsZXQgYXNSaWdodCA9IGluY2x1ZGUuYXM7XG4gICAgd2hpbGUgKCgkcGFyZW50ID0gJHBhcmVudCAmJiAkcGFyZW50LnBhcmVudCB8fCBpbmNsdWRlLnBhcmVudCkgJiYgJHBhcmVudC5hc3NvY2lhdGlvbikge1xuICAgICAgaWYgKGFzTGVmdCkge1xuICAgICAgICBhc0xlZnQgPSBgJHskcGFyZW50LmFzfS0+JHthc0xlZnR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzTGVmdCA9ICRwYXJlbnQuYXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXNMZWZ0KVxuICAgICAgYXNMZWZ0ID0gcGFyZW50LmFzIHx8IHBhcmVudC5tb2RlbC5uYW1lO1xuICAgIGVsc2VcbiAgICAgIGFzUmlnaHQgPSBgJHthc0xlZnR9LT4ke2FzUmlnaHR9YDtcbiAgICBsZXQgam9pbk9uID0gYCR7dGhpcy5xdW90ZVRhYmxlKGFzTGVmdCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRMZWZ0KX1gO1xuICAgIGNvbnN0IHN1YnF1ZXJ5QXR0cmlidXRlcyA9IFtdO1xuICAgIGlmICh0b3BMZXZlbEluZm8ub3B0aW9ucy5ncm91cGVkTGltaXQgJiYgcGFyZW50SXNUb3AgfHwgdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmIGluY2x1ZGUucGFyZW50LnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5KSB7XG4gICAgICBpZiAocGFyZW50SXNUb3ApIHtcbiAgICAgICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHBhcmVudC5hcyB8fCBwYXJlbnQubW9kZWwubmFtZSk7XG4gICAgICAgIGpvaW5PbiA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBhdHRyTGVmdCwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IGAke3RhYmxlTmFtZX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyTGVmdCl9YDtcbiAgICAgICAgaWYgKHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICAgIGNvbnN0IGRiSWRlbnRpZmllciA9IGAke3RhYmxlTmFtZX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZExlZnQpfWA7XG4gICAgICAgICAgc3VicXVlcnlBdHRyaWJ1dGVzLnB1c2goZGJJZGVudGlmaWVyICE9PSBqb2luT24gPyBgJHtkYklkZW50aWZpZXJ9IEFTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckxlZnQpfWAgOiBkYklkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBqb2luU291cmNlID0gYCR7YXNMZWZ0LnJlcGxhY2UoLy0+L2csIFwiLlwiKX0uJHthdHRyTGVmdH1gO1xuICAgICAgICBqb2luT24gPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKGFzTGVmdCwgam9pblNvdXJjZSwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IHRoaXMucXVvdGVJZGVudGlmaWVyKGpvaW5Tb3VyY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBqb2luT24gKz0gYCA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRSaWdodCl9YDtcbiAgICBpZiAoaW5jbHVkZS5vbikge1xuICAgICAgam9pbk9uID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaW5jbHVkZS5vbiwge1xuICAgICAgICBwcmVmaXg6IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCkpLFxuICAgICAgICBtb2RlbDogaW5jbHVkZS5tb2RlbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLndoZXJlKSB7XG4gICAgICBqb2luV2hlcmUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShpbmNsdWRlLndoZXJlLCB7XG4gICAgICAgIHByZWZpeDogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihhc1JpZ2h0KSksXG4gICAgICAgIG1vZGVsOiBpbmNsdWRlLm1vZGVsXG4gICAgICB9KTtcbiAgICAgIGlmIChqb2luV2hlcmUpIHtcbiAgICAgICAgaWYgKGluY2x1ZGUub3IpIHtcbiAgICAgICAgICBqb2luT24gKz0gYCBPUiAke2pvaW5XaGVyZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGpvaW5PbiArPSBgIEFORCAke2pvaW5XaGVyZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWxpYXNBcyhhc1JpZ2h0LCB0b3BMZXZlbEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICBqb2luOiBpbmNsdWRlLnJlcXVpcmVkID8gXCJJTk5FUiBKT0lOXCIgOiBpbmNsdWRlLnJpZ2h0ICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJSSUdIVCBKT0lOXCJdID8gXCJSSUdIVCBPVVRFUiBKT0lOXCIgOiBcIkxFRlQgT1VURVIgSk9JTlwiLFxuICAgICAgYm9keTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlUmlnaHQsIGFzUmlnaHQpLFxuICAgICAgY29uZGl0aW9uOiBqb2luT24sXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIG1haW46IFtdLFxuICAgICAgICBzdWJRdWVyeTogc3VicXVlcnlBdHRyaWJ1dGVzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZW5lcmF0ZVJldHVyblZhbHVlcyhtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXR1cm5GaWVsZHMgPSBbXTtcbiAgICBjb25zdCByZXR1cm5UeXBlcyA9IFtdO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgdG1wVGFibGUgPSBcIlwiO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmV0dXJuaW5nKSkge1xuICAgICAgcmV0dXJuRmllbGRzLnB1c2goLi4ub3B0aW9ucy5yZXR1cm5pbmcubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKSk7XG4gICAgfSBlbHNlIGlmIChtb2RlbEF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChtb2RlbEF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgaWYgKCEoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVklSVFVBTCkpIHtcbiAgICAgICAgICByZXR1cm5GaWVsZHMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuZmllbGQpKTtcbiAgICAgICAgICByZXR1cm5UeXBlcy5wdXNoKGF0dHJpYnV0ZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkocmV0dXJuRmllbGRzKSkge1xuICAgICAgcmV0dXJuRmllbGRzLnB1c2goXCIqXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMucmV0dXJuaW5nKSB7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IGAgUkVUVVJOSU5HICR7cmV0dXJuRmllbGRzLmpvaW4oXCIsXCIpfWA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVybkludG9WYWx1ZXMpIHtcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gYCBSRVRVUk5JTkcgJHtyZXR1cm5GaWVsZHMuam9pbihcIixcIil9IElOVE8gYDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLm91dHB1dCkge1xuICAgICAgb3V0cHV0RnJhZ21lbnQgPSBgIE9VVFBVVCAke3JldHVybkZpZWxkcy5tYXAoKGZpZWxkKSA9PiBgSU5TRVJURUQuJHtmaWVsZH1gKS5qb2luKFwiLFwiKX1gO1xuICAgICAgaWYgKG9wdGlvbnMuaGFzVHJpZ2dlciAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnRtcFRhYmxlVHJpZ2dlcikge1xuICAgICAgICBjb25zdCB0bXBDb2x1bW5zID0gcmV0dXJuRmllbGRzLm1hcCgoZmllbGQsIGkpID0+IGAke2ZpZWxkfSAke3JldHVyblR5cGVzW2ldLnRvU3FsKCl9YCk7XG4gICAgICAgIHRtcFRhYmxlID0gYERFQ0xBUkUgQHRtcCBUQUJMRSAoJHt0bXBDb2x1bW5zLmpvaW4oXCIsXCIpfSk7IGA7XG4gICAgICAgIG91dHB1dEZyYWdtZW50ICs9IFwiIElOVE8gQHRtcFwiO1xuICAgICAgICByZXR1cm5pbmdGcmFnbWVudCA9IFwiOyBTRUxFQ1QgKiBGUk9NIEB0bXBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3V0cHV0RnJhZ21lbnQsIHJldHVybkZpZWxkcywgcmV0dXJuVHlwZXMsIHJldHVybmluZ0ZyYWdtZW50LCB0bXBUYWJsZSB9O1xuICB9XG4gIGdlbmVyYXRlVGhyb3VnaEpvaW4oaW5jbHVkZSwgaW5jbHVkZUFzLCBwYXJlbnRUYWJsZU5hbWUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IHRocm91Z2ggPSBpbmNsdWRlLnRocm91Z2g7XG4gICAgY29uc3QgdGhyb3VnaFRhYmxlID0gdGhyb3VnaC5tb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICBjb25zdCB0aHJvdWdoQXMgPSBgJHtpbmNsdWRlQXMuaW50ZXJuYWxBc30tPiR7dGhyb3VnaC5hc31gO1xuICAgIGNvbnN0IGV4dGVybmFsVGhyb3VnaEFzID0gYCR7aW5jbHVkZUFzLmV4dGVybmFsQXN9LiR7dGhyb3VnaC5hc31gO1xuICAgIGNvbnN0IHRocm91Z2hBdHRyaWJ1dGVzID0gdGhyb3VnaC5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgbGV0IGFsaWFzID0gYCR7ZXh0ZXJuYWxUaHJvdWdoQXN9LiR7QXJyYXkuaXNBcnJheShhdHRyKSA/IGF0dHJbMV0gOiBhdHRyfWA7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCB0aHJvdWdoQXMsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihBcnJheS5pc0FycmF5KGF0dHIpID8gYXR0clswXSA6IGF0dHIpfWAsXG4gICAgICAgIFwiQVNcIixcbiAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMpXG4gICAgICBdKTtcbiAgICB9KTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgcGFyZW50SXNUb3AgPSAhaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwubmFtZSA9PT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubW9kZWwubmFtZTtcbiAgICBjb25zdCB0YWJsZVNvdXJjZSA9IHBhcmVudFRhYmxlTmFtZTtcbiAgICBjb25zdCBpZGVudFNvdXJjZSA9IGFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcbiAgICBjb25zdCB0YWJsZVRhcmdldCA9IGluY2x1ZGVBcy5pbnRlcm5hbEFzO1xuICAgIGNvbnN0IGlkZW50VGFyZ2V0ID0gYXNzb2NpYXRpb24uZm9yZWlnbklkZW50aWZpZXJGaWVsZDtcbiAgICBjb25zdCBhdHRyVGFyZ2V0ID0gYXNzb2NpYXRpb24udGFyZ2V0S2V5RmllbGQ7XG4gICAgY29uc3Qgam9pblR5cGUgPSBpbmNsdWRlLnJlcXVpcmVkID8gXCJJTk5FUiBKT0lOXCIgOiBpbmNsdWRlLnJpZ2h0ICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJSSUdIVCBKT0lOXCJdID8gXCJSSUdIVCBPVVRFUiBKT0lOXCIgOiBcIkxFRlQgT1VURVIgSk9JTlwiO1xuICAgIGxldCBqb2luQm9keTtcbiAgICBsZXQgam9pbkNvbmRpdGlvbjtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgbWFpbjogW10sXG4gICAgICBzdWJRdWVyeTogW11cbiAgICB9O1xuICAgIGxldCBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5O1xuICAgIGxldCBzb3VyY2VKb2luT247XG4gICAgbGV0IHRhcmdldEpvaW5PbjtcbiAgICBsZXQgdGhyb3VnaFdoZXJlO1xuICAgIGxldCB0YXJnZXRXaGVyZTtcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgdGhyb3VnaEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5KSB7XG4gICAgICBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQ7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkgJiYgIWluY2x1ZGUucGFyZW50LnN1YlF1ZXJ5ICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsICE9PSB0b3BMZXZlbEluZm8ub3B0aW9ucy5tYWluTW9kZWwpIHtcbiAgICAgIGF0dHJTb3VyY2UgPSBhc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiAhcGFyZW50SXNUb3ApIHtcbiAgICAgIGNvbnN0IGpvaW5Tb3VyY2UgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlU291cmNlLCBgJHt0YWJsZVNvdXJjZX0uJHthdHRyU291cmNlfWAsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBgJHt0YWJsZVNvdXJjZX0uJHthdHRyU291cmNlfWA7XG4gICAgICBzb3VyY2VKb2luT24gPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihqb2luU291cmNlKX0gPSBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbGlhc2VkU291cmNlID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZVNvdXJjZSwgYXR0clNvdXJjZSwgdG9wTGV2ZWxJbmZvLm9wdGlvbnMpIHx8IGF0dHJTb3VyY2U7XG4gICAgICBzb3VyY2VKb2luT24gPSBgJHt0aGlzLnF1b3RlVGFibGUodGFibGVTb3VyY2UpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzZWRTb3VyY2UpfSA9IGA7XG4gICAgfVxuICAgIHNvdXJjZUpvaW5PbiArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50U291cmNlKX1gO1xuICAgIHRhcmdldEpvaW5PbiA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlVGFyZ2V0KX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyVGFyZ2V0KX0gPSBgO1xuICAgIHRhcmdldEpvaW5PbiArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50VGFyZ2V0KX1gO1xuICAgIGlmICh0aHJvdWdoLndoZXJlKSB7XG4gICAgICB0aHJvdWdoV2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh0aHJvdWdoLndoZXJlLCB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcykpLCB0aHJvdWdoLm1vZGVsKTtcbiAgICB9XG4gICAgdGhpcy5hbGlhc0FzKGluY2x1ZGVBcy5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8pO1xuICAgIGpvaW5Cb2R5ID0gYCggJHt0aGlzLnF1b3RlVGFibGUodGhyb3VnaFRhYmxlLCB0aHJvdWdoQXMpfSBJTk5FUiBKT0lOICR7dGhpcy5xdW90ZVRhYmxlKGluY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCksIGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0gT04gJHt0YXJnZXRKb2luT259YDtcbiAgICBpZiAodGhyb3VnaFdoZXJlKSB7XG4gICAgICBqb2luQm9keSArPSBgIEFORCAke3Rocm91Z2hXaGVyZX1gO1xuICAgIH1cbiAgICBqb2luQm9keSArPSBcIilcIjtcbiAgICBqb2luQ29uZGl0aW9uID0gc291cmNlSm9pbk9uO1xuICAgIGlmIChpbmNsdWRlLndoZXJlIHx8IGluY2x1ZGUudGhyb3VnaC53aGVyZSkge1xuICAgICAgaWYgKGluY2x1ZGUud2hlcmUpIHtcbiAgICAgICAgdGFyZ2V0V2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhpbmNsdWRlLndoZXJlLCB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKSksIGluY2x1ZGUubW9kZWwsIHRvcExldmVsSW5mby5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRhcmdldFdoZXJlKSB7XG4gICAgICAgICAgam9pbkNvbmRpdGlvbiArPSBgIEFORCAke3RhcmdldFdoZXJlfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGpvaW46IGpvaW5UeXBlLFxuICAgICAgYm9keTogam9pbkJvZHksXG4gICAgICBjb25kaXRpb246IGpvaW5Db25kaXRpb24sXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuICBhbGlhc0FzKGFzLCB0b3BMZXZlbEluZm8pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgYXMubGVuZ3RoID49IDY0KSB7XG4gICAgICBjb25zdCBhbGlhcyA9IGAlJHt0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlQWxpYXNlcy5zaXplfWA7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy5pbmNsdWRlQWxpYXNlcy5zZXQoYWxpYXMsIGFzKTtcbiAgICB9XG4gIH1cbiAgX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pIHtcbiAgICBpZiAoIXRvcExldmVsSW5mby5zdWJRdWVyeSB8fCAhaW5jbHVkZS5zdWJRdWVyeUZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRvcExldmVsSW5mby5vcHRpb25zLndoZXJlKSB7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZSA9IHt9O1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gaW5jbHVkZTtcbiAgICBsZXQgY2hpbGQgPSBpbmNsdWRlO1xuICAgIGxldCBuZXN0ZWRJbmNsdWRlcyA9IHRoaXMuX2dldFJlcXVpcmVkQ2xvc3VyZShpbmNsdWRlKS5pbmNsdWRlO1xuICAgIGxldCBxdWVyeTtcbiAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5wYXJlbnQgJiYgIXBhcmVudC5yZXF1aXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LnN1YlF1ZXJ5RmlsdGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5lc3RlZEluY2x1ZGVzID0gW19fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGNoaWxkKSwgeyBpbmNsdWRlOiBuZXN0ZWRJbmNsdWRlcywgYXR0cmlidXRlczogW10gfSldO1xuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHRvcEluY2x1ZGUgPSBuZXN0ZWRJbmNsdWRlc1swXTtcbiAgICBjb25zdCB0b3BQYXJlbnQgPSB0b3BJbmNsdWRlLnBhcmVudDtcbiAgICBjb25zdCB0b3BBc3NvY2lhdGlvbiA9IHRvcEluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgdG9wSW5jbHVkZS5hc3NvY2lhdGlvbiA9IHZvaWQgMDtcbiAgICBpZiAodG9wSW5jbHVkZS50aHJvdWdoICYmIE9iamVjdCh0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwpID09PSB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5zZWxlY3RRdWVyeSh0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwuZ2V0VGFibGVOYW1lKCksIHtcbiAgICAgICAgYXR0cmlidXRlczogW3RvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5wcmltYXJ5S2V5RmllbGRdLFxuICAgICAgICBpbmNsdWRlOiBNb2RlbC5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKHtcbiAgICAgICAgICBtb2RlbDogdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLFxuICAgICAgICAgIGluY2x1ZGU6IFt7XG4gICAgICAgICAgICBhc3NvY2lhdGlvbjogdG9wQXNzb2NpYXRpb24udG9UYXJnZXQsXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgICAgIHdoZXJlOiB0b3BJbmNsdWRlLndoZXJlLFxuICAgICAgICAgICAgaW5jbHVkZTogdG9wSW5jbHVkZS5pbmNsdWRlXG4gICAgICAgICAgfV1cbiAgICAgICAgfSkuaW5jbHVkZSxcbiAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBbT3AuYW5kXTogW1xuICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChbXG4gICAgICAgICAgICAgIGAke3RoaXMucXVvdGVUYWJsZSh0b3BQYXJlbnQubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wUGFyZW50Lm1vZGVsLnByaW1hcnlLZXlGaWVsZCl9YCxcbiAgICAgICAgICAgICAgYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCl9YFxuICAgICAgICAgICAgXS5qb2luKFwiID0gXCIpKSxcbiAgICAgICAgICAgIHRvcEluY2x1ZGUudGhyb3VnaC53aGVyZVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgbGltaXQ6IDEsXG4gICAgICAgIGluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzOiBmYWxzZVxuICAgICAgfSwgdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNCZWxvbmdzVG8gPSB0b3BBc3NvY2lhdGlvbi5hc3NvY2lhdGlvblR5cGUgPT09IFwiQmVsb25nc1RvXCI7XG4gICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IGlzQmVsb25nc1RvID8gdG9wQXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkIDogdG9wQXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQgfHwgdG9wUGFyZW50Lm1vZGVsLnByaW1hcnlLZXlGaWVsZDtcbiAgICAgIGNvbnN0IHRhcmdldEZpZWxkID0gaXNCZWxvbmdzVG8gPyB0b3BBc3NvY2lhdGlvbi5zb3VyY2VLZXlGaWVsZCB8fCB0b3BJbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlGaWVsZCA6IHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZDtcbiAgICAgIGNvbnN0IGpvaW4gPSBbXG4gICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEluY2x1ZGUuYXMpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhcmdldEZpZWxkKX1gLFxuICAgICAgICBgJHt0aGlzLnF1b3RlVGFibGUodG9wUGFyZW50LmFzIHx8IHRvcFBhcmVudC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzb3VyY2VGaWVsZCl9YFxuICAgICAgXS5qb2luKFwiID0gXCIpO1xuICAgICAgcXVlcnkgPSB0aGlzLnNlbGVjdFF1ZXJ5KHRvcEluY2x1ZGUubW9kZWwuZ2V0VGFibGVOYW1lKCksIHtcbiAgICAgICAgYXR0cmlidXRlczogW3RhcmdldEZpZWxkXSxcbiAgICAgICAgaW5jbHVkZTogTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh0b3BJbmNsdWRlKS5pbmNsdWRlLFxuICAgICAgICBtb2RlbDogdG9wSW5jbHVkZS5tb2RlbCxcbiAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICBbT3AuYW5kXTogW1xuICAgICAgICAgICAgdG9wSW5jbHVkZS53aGVyZSxcbiAgICAgICAgICAgIHsgW09wLmpvaW5dOiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGpvaW4pIH1cbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICB0YWJsZUFzOiB0b3BJbmNsdWRlLmFzLFxuICAgICAgICBpbmNsdWRlSWdub3JlQXR0cmlidXRlczogZmFsc2VcbiAgICAgIH0sIHRvcEluY2x1ZGUubW9kZWwpO1xuICAgIH1cbiAgICBpZiAoIXRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW09wLmFuZF0pIHtcbiAgICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW09wLmFuZF0gPSBbXTtcbiAgICB9XG4gICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmVbYF9fJHtpbmNsdWRlQXMuaW50ZXJuYWxBc31gXSA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoW1xuICAgICAgXCIoXCIsXG4gICAgICBxdWVyeS5yZXBsYWNlKC87JC8sIFwiXCIpLFxuICAgICAgXCIpXCIsXG4gICAgICBcIklTIE5PVCBOVUxMXCJcbiAgICBdLmpvaW4oXCIgXCIpKTtcbiAgfVxuICBfZ2V0UmVxdWlyZWRDbG9zdXJlKGluY2x1ZGUpIHtcbiAgICBjb25zdCBjb3B5ID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgaW5jbHVkZSksIHsgYXR0cmlidXRlczogW10sIGluY2x1ZGU6IFtdIH0pO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluY2x1ZGUuaW5jbHVkZSkpIHtcbiAgICAgIGNvcHkuaW5jbHVkZSA9IGluY2x1ZGUuaW5jbHVkZS5maWx0ZXIoKGkpID0+IGkucmVxdWlyZWQpLm1hcCgoaW5jKSA9PiB0aGlzLl9nZXRSZXF1aXJlZENsb3N1cmUoaW5jKSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIGdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBzdWJRdWVyeSkge1xuICAgIGNvbnN0IG1haW5RdWVyeU9yZGVyID0gW107XG4gICAgY29uc3Qgc3ViUXVlcnlPcmRlciA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMub3JkZXIpKSB7XG4gICAgICBmb3IgKGxldCBvcmRlciBvZiBvcHRpb25zLm9yZGVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICBvcmRlciA9IFtvcmRlcl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YlF1ZXJ5ICYmIEFycmF5LmlzQXJyYXkob3JkZXIpICYmIG9yZGVyWzBdICYmICEob3JkZXJbMF0gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikgJiYgISh0eXBlb2Ygb3JkZXJbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBvcmRlclswXS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkgJiYgISh0eXBlb2Ygb3JkZXJbMF0ubW9kZWwgPT09IFwiZnVuY3Rpb25cIiAmJiBvcmRlclswXS5tb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkgJiYgISh0eXBlb2Ygb3JkZXJbMF0gPT09IFwic3RyaW5nXCIgJiYgbW9kZWwgJiYgbW9kZWwuYXNzb2NpYXRpb25zICE9PSB2b2lkIDAgJiYgbW9kZWwuYXNzb2NpYXRpb25zW29yZGVyWzBdXSkpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZCA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbb3JkZXJbMF1dID8gbW9kZWwucmF3QXR0cmlidXRlc1tvcmRlclswXV0uZmllbGQgOiBvcmRlclswXTtcbiAgICAgICAgICBjb25zdCBzdWJRdWVyeUFsaWFzID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5uYW1lKSwgZmllbGQsIG9wdGlvbnMpO1xuICAgICAgICAgIGxldCBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgIGxldCBvcmRlclRvUXVvdGUgPSBbXTtcbiAgICAgICAgICBpZiAoc3ViUXVlcnlBbGlhcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb3JkZXJUb1F1b3RlID0gb3JkZXI7XG4gICAgICAgICAgICBwYXJlbnQgPSBtb2RlbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJUb1F1b3RlID0gW3N1YlF1ZXJ5QWxpYXMsIG9yZGVyLmxlbmd0aCA+IDEgPyBvcmRlclsxXSA6IFwiQVNDXCJdO1xuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3ViUXVlcnlPcmRlci5wdXNoKHRoaXMucXVvdGUob3JkZXJUb1F1b3RlLCBwYXJlbnQsIFwiLT5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMgJiYgbW9kZWwpIHtcbiAgICAgICAgICBjb25zdCBhbGlhc2VkQXR0cmlidXRlID0gb3B0aW9ucy5hdHRyaWJ1dGVzLmZpbmQoKGF0dHIpID0+IEFycmF5LmlzQXJyYXkoYXR0cikgJiYgYXR0clsxXSAmJiAoYXR0clswXSA9PT0gb3JkZXJbMF0gfHwgYXR0clsxXSA9PT0gb3JkZXJbMF0pKTtcbiAgICAgICAgICBpZiAoYWxpYXNlZEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQobW9kZWxOYW1lLCBhbGlhc2VkQXR0cmlidXRlWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG9yZGVyWzBdID0gbmV3IFV0aWxzLkNvbChhbGlhcyB8fCBhbGlhc2VkQXR0cmlidXRlWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFpblF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlKG9yZGVyLCBtb2RlbCwgXCItPlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLm9yZGVyIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICBjb25zdCBzcWwgPSB0aGlzLnF1b3RlKG9wdGlvbnMub3JkZXIsIG1vZGVsLCBcIi0+XCIpO1xuICAgICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICAgIHN1YlF1ZXJ5T3JkZXIucHVzaChzcWwpO1xuICAgICAgfVxuICAgICAgbWFpblF1ZXJ5T3JkZXIucHVzaChzcWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcmRlciBtdXN0IGJlIHR5cGUgb2YgYXJyYXkgb3IgaW5zdGFuY2Ugb2YgYSB2YWxpZCBzZXF1ZWxpemUgbWV0aG9kLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFpblF1ZXJ5T3JkZXIsIHN1YlF1ZXJ5T3JkZXIgfTtcbiAgfVxuICBfdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBleHRyYUluZm8gPSB7fSkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYXNQYXJ0ID0gZXh0cmFJbmZvLmFzICYmIGBhcyAke2V4dHJhSW5mby5hc31gIHx8IFwiXCI7XG4gICAgY29uc3QgbmFtZVBhcnQgPSBleHRyYUluZm8ubW9kZWxOYW1lICYmIGBmb3IgbW9kZWwgJyR7ZXh0cmFJbmZvLm1vZGVsTmFtZX0nYCB8fCBcIlwiO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgQXR0ZW1wdGVkIGEgU0VMRUNUIHF1ZXJ5ICR7bmFtZVBhcnR9ICR7YXNQYXJ0fSB3aXRob3V0IHNlbGVjdGluZyBhbnkgY29sdW1uc2A7XG4gICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9yLlF1ZXJ5RXJyb3IobWVzc2FnZS5yZXBsYWNlKC8gKy9nLCBcIiBcIikpO1xuICB9XG4gIHNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLCB0YWJsZXMsIG1haW5UYWJsZUFzKSB7XG4gICAgdGhpcy5fdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZUFzIH0pO1xuICAgIGxldCBmcmFnbWVudCA9IGBTRUxFQ1QgJHthdHRyaWJ1dGVzLmpvaW4oXCIsIFwiKX0gRlJPTSAke3RhYmxlc31gO1xuICAgIGlmIChtYWluVGFibGVBcykge1xuICAgICAgZnJhZ21lbnQgKz0gYCAke3RoaXMuZ2V0QWxpYXNUb2tlbigpfSAke21haW5UYWJsZUFzfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmluZGV4SGludHMgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleEhpbnRzKSB7XG4gICAgICBmb3IgKGNvbnN0IGhpbnQgb2Ygb3B0aW9ucy5pbmRleEhpbnRzKSB7XG4gICAgICAgIGlmIChJbmRleEhpbnRzW2hpbnQudHlwZV0pIHtcbiAgICAgICAgICBmcmFnbWVudCArPSBgICR7SW5kZXhIaW50c1toaW50LnR5cGVdfSBJTkRFWCAoJHtoaW50LnZhbHVlcy5tYXAoKGluZGV4TmFtZSkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5vZmZzZXQgIT0gbnVsbCAmJiBvcHRpb25zLmxpbWl0ID09IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9IFwiIExJTUlUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpICsgXCIsIFwiICsgMWUxMztcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gXCIgTElNSVQgXCIgKyB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCkgKyBcIiwgXCIgKyB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50ICs9IFwiIExJTUlUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuT3BlcmF0b3JNYXAsIHNtdGguY29tcGFyYXRvcikpIHtcbiAgICAgIHNtdGguY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbc210aC5jb21wYXJhdG9yXTtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5XaGVyZSkge1xuICAgICAgbGV0IHZhbHVlID0gc210aC5sb2dpYztcbiAgICAgIGxldCBrZXk7XG4gICAgICBpZiAoc210aC5hdHRyaWJ1dGUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAga2V5ID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoc210aC5hdHRyaWJ1dGUsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSBgJHt0aGlzLnF1b3RlVGFibGUoc210aC5hdHRyaWJ1dGUuTW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc210aC5hdHRyaWJ1dGUuZmllbGQgfHwgc210aC5hdHRyaWJ1dGUuZmllbGROYW1lKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnModmFsdWUsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCJOVUxMXCIpIHtcbiAgICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICAgICAgc210aC5jb21wYXJhdG9yID0gXCJJU1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSBcIiE9XCIpIHtcbiAgICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9IFwiSVMgTk9UXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7c210aC5jb21wYXJhdG9yfSBgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KHNtdGguYXR0cmlidXRlLCB2YWx1ZSwge1xuICAgICAgICAgIG1vZGVsOiBmYWN0b3J5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKFt0aGlzLk9wZXJhdG9yTWFwW09wLmJldHdlZW5dLCB0aGlzLk9wZXJhdG9yTWFwW09wLm5vdEJldHdlZW5dXS5pbmNsdWRlcyhzbXRoLmNvbXBhcmF0b3IpKSB7XG4gICAgICAgIHZhbHVlID0gYCR7dGhpcy5lc2NhcGUodmFsdWVbMF0pfSBBTkQgJHt0aGlzLmVzY2FwZSh2YWx1ZVsxXSl9YDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuYm9vbGVhblZhbHVlKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBcIk5VTExcIikge1xuICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9IFwiSVNcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc210aC5jb21wYXJhdG9yID09PSBcIiE9XCIpIHtcbiAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSBcIklTIE5PVFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke3NtdGguY29tcGFyYXRvcn0gYCk7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIHNtdGgudmFsO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmIChzbXRoLnZhbCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLnZhbCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHNtdGgudmFsKSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLnZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmVzY2FwZShzbXRoLnZhbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYENBU1QoJHtyZXN1bHR9IEFTICR7c210aC50eXBlLnRvVXBwZXJDYXNlKCl9KWA7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuRm4pIHtcbiAgICAgIHJldHVybiBgJHtzbXRoLmZufSgke3NtdGguYXJncy5tYXAoKGFyZykgPT4ge1xuICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGFyZywgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGFyZykpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIiA/IGFyZy5yZXBsYWNlKC9cXCQvZywgXCIkJCRcIikgOiBhcmcpO1xuICAgICAgfSkuam9pbihcIiwgXCIpfSlgO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNvbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc210aC5jb2wpICYmICFmYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIFNlcXVlbGl6ZS5jb2woKSB3aXRoIGFycmF5IG91dHNpZGUgb2Ygb3JkZXIgLyBncm91cCBjbGF1c2VcIik7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5jb2wuc3RhcnRzV2l0aChcIipcIikpIHtcbiAgICAgICAgcmV0dXJuIFwiKlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucXVvdGUoc210aC5jb2wsIGZhY3RvcnkpO1xuICAgIH1cbiAgICByZXR1cm4gc210aC50b1N0cmluZyh0aGlzLCBmYWN0b3J5KTtcbiAgfVxuICB3aGVyZVF1ZXJ5KHdoZXJlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLndoZXJlSXRlbXNRdWVyeSh3aGVyZSwgb3B0aW9ucyk7XG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGBXSEVSRSAke3F1ZXJ5fWA7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHdoZXJlSXRlbXNRdWVyeSh3aGVyZSwgb3B0aW9ucywgYmluZGluZykge1xuICAgIGlmICh3aGVyZSA9PT0gbnVsbCB8fCB3aGVyZSA9PT0gdm9pZCAwIHx8IFV0aWxzLmdldENvbXBsZXhTaXplKHdoZXJlKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2hlcmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIGB7d2hlcmU6ICdyYXcgcXVlcnknfWAgaGFzIGJlZW4gcmVtb3ZlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgYmluZGluZyA9IGJpbmRpbmcgfHwgXCJBTkRcIjtcbiAgICBpZiAoYmluZGluZ1swXSAhPT0gXCIgXCIpXG4gICAgICBiaW5kaW5nID0gYCAke2JpbmRpbmd9IGA7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh3aGVyZSkpIHtcbiAgICAgIFV0aWxzLmdldENvbXBsZXhLZXlzKHdoZXJlKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB3aGVyZVtwcm9wXTtcbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHByb3AsIGl0ZW0sIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodm9pZCAwLCB3aGVyZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoICYmIGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCkuam9pbihiaW5kaW5nKSB8fCBcIlwiO1xuICB9XG4gIHdoZXJlSXRlbVF1ZXJ5KGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdIRVJFIHBhcmFtZXRlciBcIiR7a2V5fVwiIGhhcyBpbnZhbGlkIFwidW5kZWZpbmVkXCIgdmFsdWVgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYga2V5LmluY2x1ZGVzKFwiLlwiKSAmJiBvcHRpb25zLm1vZGVsKSB7XG4gICAgICBjb25zdCBrZXlQYXJ0cyA9IGtleS5zcGxpdChcIi5cIik7XG4gICAgICBpZiAob3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXSAmJiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5UGFydHNbMF1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICBjb25zdCB0bXAgPSB7fTtcbiAgICAgICAgY29uc3QgZmllbGQyID0gb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXTtcbiAgICAgICAgXy5zZXQodG1wLCBrZXlQYXJ0cy5zbGljZSgxKSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShmaWVsZDIuZmllbGQgfHwga2V5UGFydHNbMF0sIHRtcCwgX19zcHJlYWRWYWx1ZXMoeyBmaWVsZDogZmllbGQyIH0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmllbGQgPSB0aGlzLl9maW5kRmllbGQoa2V5LCBvcHRpb25zKTtcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBmaWVsZCAmJiBmaWVsZC50eXBlIHx8IG9wdGlvbnMudHlwZTtcbiAgICBjb25zdCBpc1BsYWluT2JqZWN0ID0gXy5pc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICBjb25zdCBpc0FycmF5ID0gIWlzUGxhaW5PYmplY3QgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAga2V5ID0gdGhpcy5PcGVyYXRvcnNBbGlhc01hcCAmJiB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwW2tleV0gfHwga2V5O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVLZXlzID0gaXNQbGFpbk9iamVjdCAmJiBVdGlscy5nZXRDb21wbGV4S2V5cyh2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIHZhbHVlS2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkodmFsdWVLZXlzWzBdLCB2YWx1ZVt2YWx1ZUtleXNbMF1dLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBvcFZhbHVlMiA9IG9wdGlvbnMuYmluZFBhcmFtID8gXCJOVUxMXCIgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUyLCB0aGlzLk9wZXJhdG9yTWFwW09wLmlzXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBjb25zdCBvcFZhbHVlMiA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIG9wVmFsdWUyLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgJiYgIShrZXkgIT09IHZvaWQgMCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkZuKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gdm9pZCAwICYmIGlzQXJyYXkpIHtcbiAgICAgIGlmIChVdGlscy5jYW5UcmVhdEFycmF5QXNBbmQodmFsdWUpKSB7XG4gICAgICAgIGtleSA9IE9wLmFuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIGxpdGVyYWwgcmVwbGFjZW1lbnRzIGluIHRoZSBgd2hlcmVgIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleSA9PT0gT3Aub3IgfHwga2V5ID09PSBPcC5hbmQgfHwga2V5ID09PSBPcC5ub3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUdyb3VwQmluZChrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlW09wLm9yXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlQmluZCh0aGlzLk9wZXJhdG9yTWFwW09wLm9yXSwga2V5LCB2YWx1ZVtPcC5vcl0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWVbT3AuYW5kXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlQmluZCh0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0sIGtleSwgdmFsdWVbT3AuYW5kXSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5ICYmIGZpZWxkVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QgJiYgZmllbGRUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04gJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlSlNPTihrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QgJiYgdmFsdWVLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdLCBrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgT3AuaW4sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QpIHtcbiAgICAgIGlmICh0aGlzLk9wZXJhdG9yTWFwW3ZhbHVlS2V5c1swXV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCB2YWx1ZUtleXNbMF0sIHZhbHVlW3ZhbHVlS2V5c1swXV0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSBPcC5wbGFjZWhvbGRlcikge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUodGhpcy5PcGVyYXRvck1hcFtrZXldLCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgY29uc3Qgb3BWYWx1ZSA9IG9wdGlvbnMuYmluZFBhcmFtID8gdGhpcy5mb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBvcHRpb25zLmJpbmRQYXJhbSkgOiB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQpO1xuICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlLCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG4gIF9maW5kRmllbGQoa2V5LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZmllbGQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmZpZWxkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXMgJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXAgJiYgb3B0aW9ucy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXBba2V5XSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV07XG4gICAgfVxuICB9XG4gIF93aGVyZUdyb3VwQmluZChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYmluZGluZyA9IGtleSA9PT0gT3Aub3IgPyB0aGlzLk9wZXJhdG9yTWFwW09wLm9yXSA6IHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXTtcbiAgICBjb25zdCBvdXRlckJpbmRpbmcgPSBrZXkgPT09IE9wLm5vdCA/IFwiTk9UIFwiIDogXCJcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpdGVtKSA9PiB7XG4gICAgICAgIGxldCBpdGVtUXVlcnkgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShpdGVtLCBvcHRpb25zLCB0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0pO1xuICAgICAgICBpZiAoaXRlbVF1ZXJ5ICYmIGl0ZW1RdWVyeS5sZW5ndGggJiYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSAmJiBVdGlscy5nZXRDb21wbGV4U2l6ZShpdGVtKSA+IDEpIHtcbiAgICAgICAgICBpdGVtUXVlcnkgPSBgKCR7aXRlbVF1ZXJ5fSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUXVlcnk7XG4gICAgICB9KS5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5sZW5ndGggJiYgdmFsdWUuam9pbihiaW5kaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeSh2YWx1ZSwgb3B0aW9ucywgYmluZGluZyk7XG4gICAgfVxuICAgIGlmICgoa2V5ID09PSBPcC5vciB8fCBrZXkgPT09IE9wLm5vdCkgJiYgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gXCIwID0gMVwiO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPyBgJHtvdXRlckJpbmRpbmd9KCR7dmFsdWV9KWAgOiB2b2lkIDA7XG4gIH1cbiAgX3doZXJlQmluZChiaW5kaW5nLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gVXRpbHMuZ2V0Q29tcGxleEtleXModmFsdWUpLm1hcCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbcHJvcF07XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgeyBbcHJvcF06IGl0ZW0gfSwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IHRoaXMud2hlcmVJdGVtUXVlcnkoa2V5LCBpdGVtLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoID8gYCgke3ZhbHVlLmpvaW4oYmluZGluZyl9KWAgOiB2b2lkIDA7XG4gIH1cbiAgX3doZXJlSlNPTihrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgYmFzZUtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgaWYgKG9wdGlvbnMucHJlZml4KSB7XG4gICAgICBpZiAob3B0aW9ucy5wcmVmaXggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgIGJhc2VLZXkgPSBgJHt0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChvcHRpb25zLnByZWZpeCl9LiR7YmFzZUtleX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUtleSA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnByZWZpeCl9LiR7YmFzZUtleX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBVdGlscy5nZXRPcGVyYXRvcnModmFsdWUpLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgICAgW29wXTogdmFsdWVbb3BdXG4gICAgICB9O1xuICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgd2hlcmUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGpzb246IGZhbHNlIH0pKSk7XG4gICAgfSk7XG4gICAgXy5mb3JPd24odmFsdWUsIChpdGVtLCBwcm9wKSA9PiB7XG4gICAgICB0aGlzLl90cmF2ZXJzZUpTT04oaXRlbXMsIGJhc2VLZXksIHByb3AsIGl0ZW0sIFtwcm9wXSk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gaXRlbXMuam9pbih0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF0pO1xuICAgIHJldHVybiBpdGVtcy5sZW5ndGggPiAxID8gYCgke3Jlc3VsdH0pYCA6IHJlc3VsdDtcbiAgfVxuICBfdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBwcm9wLCBpdGVtLCBwYXRoKSB7XG4gICAgbGV0IGNhc3Q7XG4gICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXS5pbmNsdWRlcyhcIjo6XCIpKSB7XG4gICAgICBjb25zdCB0bXAgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0uc3BsaXQoXCI6OlwiKTtcbiAgICAgIGNhc3QgPSB0bXBbMV07XG4gICAgICBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPSB0bXBbMF07XG4gICAgfVxuICAgIGxldCBwYXRoS2V5ID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShiYXNlS2V5LCBwYXRoKTtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICBVdGlscy5nZXRPcGVyYXRvcnMoaXRlbSkuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl90b0pTT05WYWx1ZShpdGVtW29wXSk7XG4gICAgICAgIGxldCBpc0pzb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBvcCA9PT0gT3AuY29udGFpbnMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgaXNKc29uID0gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhdGhLZXkgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGJhc2VLZXksIHBhdGgsIGlzSnNvbik7XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh0aGlzLl9jYXN0S2V5KHBhdGhLZXksIHZhbHVlLCBjYXN0KSwgeyBbb3BdOiB2YWx1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIF8uZm9yT3duKGl0ZW0sICh2YWx1ZSwgaXRlbVByb3ApID0+IHtcbiAgICAgICAgdGhpcy5fdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBpdGVtUHJvcCwgdmFsdWUsIHBhdGguY29uY2F0KFtpdGVtUHJvcF0pKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtID0gdGhpcy5fdG9KU09OVmFsdWUoaXRlbSk7XG4gICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHRoaXMuX2Nhc3RLZXkocGF0aEtleSwgaXRlbSwgY2FzdCksIHsgW09wLmVxXTogaXRlbSB9KSk7XG4gIH1cbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIF9jYXN0S2V5KGtleSwgdmFsdWUsIGNhc3QsIGpzb24pIHtcbiAgICBjYXN0ID0gY2FzdCB8fCB0aGlzLl9nZXRKc29uQ2FzdChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlWzBdIDogdmFsdWUpO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICByZXR1cm4gbmV3IFV0aWxzLkxpdGVyYWwodGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QobmV3IFV0aWxzLkNhc3QobmV3IFV0aWxzLkxpdGVyYWwoa2V5KSwgY2FzdCwganNvbikpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKGtleSk7XG4gIH1cbiAgX2dldEpzb25DYXN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIFwiZG91YmxlIHByZWNpc2lvblwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gXCJ0aW1lc3RhbXB0elwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLCBjb21wYXJhdG9yLCBwcmVmaXgpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5fSBhbmQgJHt2YWx1ZX0gaGFzIG5vIGNvbXBhcmF0b3JgKTtcbiAgICB9XG4gICAga2V5ID0gdGhpcy5fZ2V0U2FmZUtleShrZXksIHByZWZpeCk7XG4gICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtjb21wYXJhdG9yfSBgKTtcbiAgfVxuICBfZ2V0U2FmZUtleShrZXksIHByZWZpeCkge1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgIGtleSA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGtleSk7XG4gICAgICByZXR1cm4gdGhpcy5fcHJlZml4S2V5KHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGtleSksIHByZWZpeCk7XG4gICAgfVxuICAgIGlmIChVdGlscy5pc0NvbFN0cmluZyhrZXkpKSB7XG4gICAgICBrZXkgPSBrZXkuc3Vic3RyKDEsIGtleS5sZW5ndGggLSAyKS5zcGxpdChcIi5cIik7XG4gICAgICBpZiAoa2V5Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAga2V5ID0gW1xuICAgICAgICAgIGtleS5zbGljZSgwLCAtMSkuam9pbihcIi0+XCIpLFxuICAgICAgICAgIGtleVtrZXkubGVuZ3RoIC0gMV1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXkubWFwKChpZGVudGlmaWVyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyKSkuam9pbihcIi5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcmVmaXhLZXkodGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSwgcHJlZml4KTtcbiAgfVxuICBfcHJlZml4S2V5KGtleSwgcHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgaWYgKHByZWZpeCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChwcmVmaXgpLCBrZXldLmpvaW4oXCIuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0aGlzLnF1b3RlVGFibGUocHJlZml4KSwga2V5XS5qb2luKFwiLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBfd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHByb3AgPT09IE9wLm5vdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHByb3AgPSBPcC5ub3RJbjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICAgIHByb3AgPSBPcC5uZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW3Byb3BdIHx8IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdO1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSBPcC5pbjpcbiAgICAgIGNhc2UgT3Aubm90SW46XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdmFsdWUudmFsLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dmFsdWUubWFwKChpdGVtKSA9PiB0aGlzLmVzY2FwZShpdGVtLCBmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLmluXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBcIihOVUxMKVwiLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBjYXNlIE9wLmFueTpcbiAgICAgIGNhc2UgT3AuYWxsOlxuICAgICAgICBjb21wYXJhdG9yID0gYCR7dGhpcy5PcGVyYXRvck1hcFtPcC5lcV19ICR7Y29tcGFyYXRvcn1gO1xuICAgICAgICBpZiAodmFsdWVbT3AudmFsdWVzXSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKFZBTFVFUyAke3ZhbHVlW09wLnZhbHVlc10ubWFwKChpdGVtKSA9PiBgKCR7dGhpcy5lc2NhcGUoaXRlbSl9KWApLmpvaW4oXCIsIFwiKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKX0pYCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5iZXR3ZWVuOlxuICAgICAgY2FzZSBPcC5ub3RCZXR3ZWVuOlxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCR7dGhpcy5lc2NhcGUodmFsdWVbMF0sIGZpZWxkKX0gQU5EICR7dGhpcy5lc2NhcGUodmFsdWVbMV0sIGZpZWxkKX1gLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICBjYXNlIE9wLnJhdzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGAkcmF3YCB3aGVyZSBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAgVXNlIGBzZXF1ZWxpemUubGl0ZXJhbGAgaW5zdGVhZC5cIik7XG4gICAgICBjYXNlIE9wLmNvbDpcbiAgICAgICAgY29tcGFyYXRvciA9IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIC0xKS5qb2luKFwiLT5cIiksXG4gICAgICAgICAgICB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLm1hcCgoaWRlbnRpZmllcikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpLmpvaW4oXCIuXCIpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICBjYXNlIE9wLnN0YXJ0c1dpdGg6XG4gICAgICBjYXNlIE9wLmVuZHNXaXRoOlxuICAgICAgY2FzZSBPcC5zdWJzdHJpbmc6XG4gICAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW09wLmxpa2VdO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdHRlcm4gPSBgJHt2YWx1ZX0lYDtcbiAgICAgICAgaWYgKHByb3AgPT09IE9wLmVuZHNXaXRoKVxuICAgICAgICAgIHBhdHRlcm4gPSBgJSR7dmFsdWV9YDtcbiAgICAgICAgaWYgKHByb3AgPT09IE9wLnN1YnN0cmluZylcbiAgICAgICAgICBwYXR0ZXJuID0gYCUke3ZhbHVlfSVgO1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUocGF0dGVybiksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlT3B0aW9ucyA9IHtcbiAgICAgIGFjY2VwdFN0cmluZ3M6IGNvbXBhcmF0b3IuaW5jbHVkZXModGhpcy5PcGVyYXRvck1hcFtPcC5saWtlXSlcbiAgICB9O1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBpZiAodmFsdWVbT3AuY29sXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy53aGVyZUl0ZW1RdWVyeShudWxsLCB2YWx1ZSksIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZVtPcC5hbnldKSB7XG4gICAgICAgIGVzY2FwZU9wdGlvbnMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt0aGlzLmVzY2FwZSh2YWx1ZVtPcC5hbnldLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyl9KWAsIGAke2NvbXBhcmF0b3J9ICR7dGhpcy5PcGVyYXRvck1hcFtPcC5hbnldfWAsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZVtPcC5hbGxdKSB7XG4gICAgICAgIGVzY2FwZU9wdGlvbnMuaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAoJHt0aGlzLmVzY2FwZSh2YWx1ZVtPcC5hbGxdLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyl9KWAsIGAke2NvbXBhcmF0b3J9ICR7dGhpcy5PcGVyYXRvck1hcFtPcC5hbGxdfWAsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsICYmIGNvbXBhcmF0b3IgPT09IHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgdGhpcy5PcGVyYXRvck1hcFtPcC5pc10sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBudWxsICYmIGNvbXBhcmF0b3IgPT09IHRoaXMuT3BlcmF0b3JNYXBbT3AubmVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgdGhpcy5PcGVyYXRvck1hcFtPcC5ub3RdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB0aGlzLmVzY2FwZSh2YWx1ZSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gIH1cbiAgZ2V0V2hlcmVDb25kaXRpb25zKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVOYW1lKSkge1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lWzBdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFibGVOYW1lKSkge1xuICAgICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWVbMV07XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChwcmVwZW5kID09PSB2b2lkIDApIHtcbiAgICAgIHByZXBlbmQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc210aCAmJiBzbXRoIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICB9XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChzbXRoKSkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWUsXG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc210aCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgbGV0IHByaW1hcnlLZXlzID0gZmFjdG9yeSA/IE9iamVjdC5rZXlzKGZhY3RvcnkucHJpbWFyeUtleXMpIDogW107XG4gICAgICBpZiAocHJpbWFyeUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICBwcmltYXJ5S2V5cyA9IHByaW1hcnlLZXlzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJpbWFyeUtleXMgPSBcImlkXCI7XG4gICAgICB9XG4gICAgICB3aGVyZVtwcmltYXJ5S2V5c10gPSBzbXRoO1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHdoZXJlLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzbXRoID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aCwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc210aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVzY2FwZShzbXRoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc210aCkpIHtcbiAgICAgIGlmIChzbXRoLmxlbmd0aCA9PT0gMCB8fCBzbXRoLmxlbmd0aCA+IDAgJiYgc210aFswXS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIjE9MVwiO1xuICAgICAgaWYgKFV0aWxzLmNhblRyZWF0QXJyYXlBc0FuZChzbXRoKSkge1xuICAgICAgICBjb25zdCBfc210aCA9IHsgW09wLmFuZF06IHNtdGggfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKF9zbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwcG9ydCBmb3IgbGl0ZXJhbCByZXBsYWNlbWVudHMgaW4gdGhlIGB3aGVyZWAgb2JqZWN0IGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoc210aCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aCwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgd2hlcmUgb3B0aW9uIHZhbHVlOiAke3V0aWwuaW5zcGVjdChzbXRoKX0uIFBsZWFzZSByZWZlciB0byB0aGUgU2VxdWVsaXplIGRvY3VtZW50YXRpb24gdG8gbGVhcm4gbW9yZSBhYm91dCB3aGljaCB2YWx1ZXMgYXJlIGFjY2VwdGVkIGFzIHBhcnQgb2YgdGhlIHdoZXJlIG9wdGlvbi5gKTtcbiAgfVxuICBwYXJzZUNvbmRpdGlvbk9iamVjdChjb25kaXRpb25zLCBwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGggfHwgW107XG4gICAgcmV0dXJuIF8ucmVkdWNlKGNvbmRpdGlvbnMsIChyZXN1bHQsIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHZhbHVlLCBwYXRoLmNvbmNhdChrZXkpKSk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7IHBhdGg6IHBhdGguY29uY2F0KGtleSksIHZhbHVlIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gIH1cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGF1dGhUZXN0UXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIDErMSBBUyByZXN1bHRcIjtcbiAgfVxufVxuT2JqZWN0LmFzc2lnbihRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnNcIikpO1xuT2JqZWN0LmFzc2lnbihRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUsIHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvci90cmFuc2FjdGlvblwiKSk7XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Op = __webpack_require__(/*! ../../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst Utils = __webpack_require__(/*! ../../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst OperatorHelpers = {\n  OperatorMap: {\n    [Op.eq]: \"=\",\n    [Op.ne]: \"!=\",\n    [Op.gte]: \">=\",\n    [Op.gt]: \">\",\n    [Op.lte]: \"<=\",\n    [Op.lt]: \"<\",\n    [Op.not]: \"IS NOT\",\n    [Op.is]: \"IS\",\n    [Op.in]: \"IN\",\n    [Op.notIn]: \"NOT IN\",\n    [Op.like]: \"LIKE\",\n    [Op.notLike]: \"NOT LIKE\",\n    [Op.iLike]: \"ILIKE\",\n    [Op.notILike]: \"NOT ILIKE\",\n    [Op.startsWith]: \"LIKE\",\n    [Op.endsWith]: \"LIKE\",\n    [Op.substring]: \"LIKE\",\n    [Op.regexp]: \"~\",\n    [Op.notRegexp]: \"!~\",\n    [Op.iRegexp]: \"~*\",\n    [Op.notIRegexp]: \"!~*\",\n    [Op.between]: \"BETWEEN\",\n    [Op.notBetween]: \"NOT BETWEEN\",\n    [Op.overlap]: \"&&\",\n    [Op.contains]: \"@>\",\n    [Op.contained]: \"<@\",\n    [Op.adjacent]: \"-|-\",\n    [Op.strictLeft]: \"<<\",\n    [Op.strictRight]: \">>\",\n    [Op.noExtendRight]: \"&<\",\n    [Op.noExtendLeft]: \"&>\",\n    [Op.any]: \"ANY\",\n    [Op.all]: \"ALL\",\n    [Op.and]: \" AND \",\n    [Op.or]: \" OR \",\n    [Op.col]: \"COL\",\n    [Op.placeholder]: \"$$PLACEHOLDER$$\",\n    [Op.match]: \"@@\"\n  },\n  OperatorsAliasMap: {},\n  setOperatorsAliases(aliases) {\n    if (!aliases || _.isEmpty(aliases)) {\n      this.OperatorsAliasMap = false;\n    } else {\n      this.OperatorsAliasMap = __spreadValues({}, aliases);\n    }\n  },\n  _replaceAliases(orig) {\n    const obj = {};\n    if (!this.OperatorsAliasMap) {\n      return orig;\n    }\n    Utils.getOperators(orig).forEach((op) => {\n      const item = orig[op];\n      if (_.isPlainObject(item)) {\n        obj[op] = this._replaceAliases(item);\n      } else {\n        obj[op] = item;\n      }\n    });\n    _.forOwn(orig, (item, prop) => {\n      prop = this.OperatorsAliasMap[prop] || prop;\n      if (_.isPlainObject(item)) {\n        item = this._replaceAliases(item);\n      }\n      obj[prop] = item;\n    });\n    return obj;\n  }\n};\nmodule.exports = OperatorHelpers;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMsMkVBQW9CO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0Q7QUFDaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzLmpzPzEyYjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzXCIpO1xuY29uc3QgT3BlcmF0b3JIZWxwZXJzID0ge1xuICBPcGVyYXRvck1hcDoge1xuICAgIFtPcC5lcV06IFwiPVwiLFxuICAgIFtPcC5uZV06IFwiIT1cIixcbiAgICBbT3AuZ3RlXTogXCI+PVwiLFxuICAgIFtPcC5ndF06IFwiPlwiLFxuICAgIFtPcC5sdGVdOiBcIjw9XCIsXG4gICAgW09wLmx0XTogXCI8XCIsXG4gICAgW09wLm5vdF06IFwiSVMgTk9UXCIsXG4gICAgW09wLmlzXTogXCJJU1wiLFxuICAgIFtPcC5pbl06IFwiSU5cIixcbiAgICBbT3Aubm90SW5dOiBcIk5PVCBJTlwiLFxuICAgIFtPcC5saWtlXTogXCJMSUtFXCIsXG4gICAgW09wLm5vdExpa2VdOiBcIk5PVCBMSUtFXCIsXG4gICAgW09wLmlMaWtlXTogXCJJTElLRVwiLFxuICAgIFtPcC5ub3RJTGlrZV06IFwiTk9UIElMSUtFXCIsXG4gICAgW09wLnN0YXJ0c1dpdGhdOiBcIkxJS0VcIixcbiAgICBbT3AuZW5kc1dpdGhdOiBcIkxJS0VcIixcbiAgICBbT3Auc3Vic3RyaW5nXTogXCJMSUtFXCIsXG4gICAgW09wLnJlZ2V4cF06IFwiflwiLFxuICAgIFtPcC5ub3RSZWdleHBdOiBcIiF+XCIsXG4gICAgW09wLmlSZWdleHBdOiBcIn4qXCIsXG4gICAgW09wLm5vdElSZWdleHBdOiBcIiF+KlwiLFxuICAgIFtPcC5iZXR3ZWVuXTogXCJCRVRXRUVOXCIsXG4gICAgW09wLm5vdEJldHdlZW5dOiBcIk5PVCBCRVRXRUVOXCIsXG4gICAgW09wLm92ZXJsYXBdOiBcIiYmXCIsXG4gICAgW09wLmNvbnRhaW5zXTogXCJAPlwiLFxuICAgIFtPcC5jb250YWluZWRdOiBcIjxAXCIsXG4gICAgW09wLmFkamFjZW50XTogXCItfC1cIixcbiAgICBbT3Auc3RyaWN0TGVmdF06IFwiPDxcIixcbiAgICBbT3Auc3RyaWN0UmlnaHRdOiBcIj4+XCIsXG4gICAgW09wLm5vRXh0ZW5kUmlnaHRdOiBcIiY8XCIsXG4gICAgW09wLm5vRXh0ZW5kTGVmdF06IFwiJj5cIixcbiAgICBbT3AuYW55XTogXCJBTllcIixcbiAgICBbT3AuYWxsXTogXCJBTExcIixcbiAgICBbT3AuYW5kXTogXCIgQU5EIFwiLFxuICAgIFtPcC5vcl06IFwiIE9SIFwiLFxuICAgIFtPcC5jb2xdOiBcIkNPTFwiLFxuICAgIFtPcC5wbGFjZWhvbGRlcl06IFwiJCRQTEFDRUhPTERFUiQkXCIsXG4gICAgW09wLm1hdGNoXTogXCJAQFwiXG4gIH0sXG4gIE9wZXJhdG9yc0FsaWFzTWFwOiB7fSxcbiAgc2V0T3BlcmF0b3JzQWxpYXNlcyhhbGlhc2VzKSB7XG4gICAgaWYgKCFhbGlhc2VzIHx8IF8uaXNFbXB0eShhbGlhc2VzKSkge1xuICAgICAgdGhpcy5PcGVyYXRvcnNBbGlhc01hcCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwID0gX19zcHJlYWRWYWx1ZXMoe30sIGFsaWFzZXMpO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VBbGlhc2VzKG9yaWcpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBpZiAoIXRoaXMuT3BlcmF0b3JzQWxpYXNNYXApIHtcbiAgICAgIHJldHVybiBvcmlnO1xuICAgIH1cbiAgICBVdGlscy5nZXRPcGVyYXRvcnMob3JpZykuZm9yRWFjaCgob3ApID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBvcmlnW29wXTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgICAgb2JqW29wXSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW29wXSA9IGl0ZW07XG4gICAgICB9XG4gICAgfSk7XG4gICAgXy5mb3JPd24ob3JpZywgKGl0ZW0sIHByb3ApID0+IHtcbiAgICAgIHByb3AgPSB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwW3Byb3BdIHx8IHByb3A7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyhpdGVtKTtcbiAgICAgIH1cbiAgICAgIG9ialtwcm9wXSA9IGl0ZW07XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JIZWxwZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlcmF0b3JzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst TransactionQueries = {\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    return `SET TRANSACTION ISOLATION LEVEL ${value};`;\n  },\n  generateTransactionId() {\n    return uuidv4();\n  },\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"START TRANSACTION;\";\n  },\n  deferConstraintsQuery() {\n  },\n  setConstraintQuery() {\n  },\n  setDeferredQuery() {\n  },\n  setImmediateQuery() {\n  },\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT;\";\n  },\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"ROLLBACK;\";\n  }\n};\nmodule.exports = TransactionQueries;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLHdGQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQSw4QkFBOEI7QUFDOUIsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci90cmFuc2FjdGlvbi5qcz85NTViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZShcInV1aWRcIikudjQ7XG5jb25zdCBUcmFuc2FjdGlvblF1ZXJpZXMgPSB7XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGBTRVQgVFJBTlNBQ1RJT04gSVNPTEFUSU9OIExFVkVMICR7dmFsdWV9O2A7XG4gIH0sXG4gIGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gdXVpZHY0KCk7XG4gIH0sXG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSwgdHJ1ZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIlNUQVJUIFRSQU5TQUNUSU9OO1wiO1xuICB9LFxuICBkZWZlckNvbnN0cmFpbnRzUXVlcnkoKSB7XG4gIH0sXG4gIHNldENvbnN0cmFpbnRRdWVyeSgpIHtcbiAgfSxcbiAgc2V0RGVmZXJyZWRRdWVyeSgpIHtcbiAgfSxcbiAgc2V0SW1tZWRpYXRlUXVlcnkoKSB7XG4gIH0sXG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBcIkNPTU1JVDtcIjtcbiAgfSxcbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUTyBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lLCB0cnVlKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiUk9MTEJBQ0s7XCI7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uUXVlcmllcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map((schemaName) => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map((value) => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), { type: QueryTypes.VERSION }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), { cascade: true }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { supportsSearchPath: false }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWINDEXES }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.FOREIGNKEYS });\n    const results = await Promise.all(tableNames.map((tableName) => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map((r) => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance)\n      results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n      const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find((fields) => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\")\n      identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances)\n        continue;\n      if (!Array.isArray(instances))\n        instances = [instances];\n      for (const _instance of instances)\n        await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\")\n      where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), { type: QueryTypes.SELECT, model });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {\n  }\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql)\n      return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQW1CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsY0FBYywwQkFBMEI7QUFDako7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLGVBQWU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUIsR0FBRyxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDJCQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsMEJBQTBCLFdBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyw4QkFBOEI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDhCQUE4QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyxrQ0FBa0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsK0ZBQStGLDRCQUE0QjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsZ0RBQWdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlLmpzPzE1ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNsYXNzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplLCBxdWVyeUdlbmVyYXRvcikge1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBxdWVyeUdlbmVyYXRvcjtcbiAgfVxuICBhc3luYyBjcmVhdGVEYXRhYmFzZShkYXRhYmFzZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZHJvcERhdGFiYXNlKGRhdGFiYXNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlU2NoZW1hKHNjaGVtYSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BTY2hlbWEoc2NoZW1hKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkcm9wQWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCF0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9kaWFsZWN0LnN1cHBvcnRzLnNjaGVtYXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5kcm9wKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBzY2hlbWFzID0gYXdhaXQgdGhpcy5zaG93QWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2NoZW1hcy5tYXAoKHNjaGVtYU5hbWUpID0+IHRoaXMuZHJvcFNjaGVtYShzY2hlbWFOYW1lLCBvcHRpb25zKSkpO1xuICB9XG4gIGFzeW5jIHNob3dBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHR5cGU6IHRoaXMuc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0VMRUNUXG4gICAgfSk7XG4gICAgY29uc3Qgc2hvd1NjaGVtYXNTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dTY2hlbWFzUXVlcnkob3B0aW9ucyk7XG4gICAgY29uc3Qgc2NoZW1hTmFtZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzaG93U2NoZW1hc1NxbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF8uZmxhdHRlbihzY2hlbWFOYW1lcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZS5zY2hlbWFfbmFtZSA/IHZhbHVlLnNjaGVtYV9uYW1lIDogdmFsdWUpKTtcbiAgfVxuICBhc3luYyBkYXRhYmFzZVZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnZlcnNpb25RdWVyeSgpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLlZFUlNJT04gfSkpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBsZXQgc3FsID0gXCJcIjtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5mb3JPd24ob3B0aW9ucy51bmlxdWVLZXlzLCAodW5pcXVlS2V5KSA9PiB7XG4gICAgICAgIGlmICh1bmlxdWVLZXkuY3VzdG9tSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgIHVuaXF1ZUtleS5jdXN0b21JbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIG9wdGlvbnMudW5pcXVlS2V5cyA9IG9wdGlvbnMudW5pcXVlS2V5cyB8fCBtb2RlbC51bmlxdWVLZXlzO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzID0gXy5tYXBWYWx1ZXMoYXR0cmlidXRlcywgKGF0dHJpYnV0ZSkgPT4gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlRW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCk7XG4gICAgaWYgKCF0YWJsZU5hbWUuc2NoZW1hICYmIChvcHRpb25zLnNjaGVtYSB8fCAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEpKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZFNjaGVtYSh7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgX3NjaGVtYTogISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hXG4gICAgICB9KTtcbiAgICB9XG4gICAgYXR0cmlidXRlcyA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIHtcbiAgICAgIHRhYmxlOiB0YWJsZU5hbWUsXG4gICAgICBjb250ZXh0OiBcImNyZWF0ZVRhYmxlXCIsXG4gICAgICB3aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzOiBvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHNcbiAgICB9KTtcbiAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyB0YWJsZUV4aXN0cyh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnRhYmxlRXhpc3RzUXVlcnkodGFibGVOYW1lKTtcbiAgICBjb25zdCBvdXQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNIT1dUQUJMRVNcbiAgICB9KSk7XG4gICAgcmV0dXJuIG91dC5sZW5ndGggPT09IDE7XG4gIH1cbiAgYXN5bmMgZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5jYXNjYWRlID0gb3B0aW9ucy5jYXNjYWRlIHx8IG9wdGlvbnMuZm9yY2UgfHwgZmFsc2U7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlTmFtZXMpIHtcbiAgICAgIGlmICghc2tpcC5pbmNsdWRlcyh0YWJsZU5hbWUudGFibGVOYW1lIHx8IHRhYmxlTmFtZSkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kcm9wVGFibGUodGFibGVOYW1lLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBjYXNjYWRlOiB0cnVlIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZHJvcEFsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zaG93QWxsVGFibGVzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gYXdhaXQgdGhpcy5nZXRGb3JlaWduS2V5c0ZvclRhYmxlcyh0YWJsZU5hbWVzLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0YWJsZU5hbWVzKSB7XG4gICAgICBsZXQgbm9ybWFsaXplZFRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgbm9ybWFsaXplZFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5IG9mIGZvcmVpZ25LZXlzW25vcm1hbGl6ZWRUYWJsZU5hbWVdKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyByZW5hbWVUYWJsZShiZWZvcmUsIGFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNob3dBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TSE9XVEFCTEVTXG4gICAgfSk7XG4gICAgY29uc3Qgc2hvd1RhYmxlc1NxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd1RhYmxlc1F1ZXJ5KHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSk7XG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNob3dUYWJsZXNTcWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfLmZsYXR0ZW4odGFibGVOYW1lcyk7XG4gIH1cbiAgYXN5bmMgZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hRGVsaW1pdGVyID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYSB8fCBudWxsO1xuICAgICAgc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwib2JqZWN0XCIgJiYgdGFibGVOYW1lICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcik7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuREVTQ1JJQkUgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm9yaWdpbmFsICYmIGUub3JpZ2luYWwuY29kZSA9PT0gXCJFUl9OT19TVUNIX1RBQkxFXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGRDb2x1bW4odGFibGUsIGtleSwgYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0YWJsZSB8fCAha2V5IHx8ICFhdHRyaWJ1dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZENvbHVtbiB0YWtlcyBhdCBsZWFzdCAzIGFyZ3VtZW50cyAodGFibGUsIGF0dHJpYnV0ZSBuYW1lLCBhdHRyaWJ1dGUgZGVmaW5pdGlvbilcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGF0dHJpYnV0ZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGF0dHJpYnV0ZSksIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpLCBvcHRpb25zKTtcbiAgfVxuICBub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpIHtcbiAgICBsZXQgYXR0cmlidXRlO1xuICAgIGlmIChPYmplY3QudmFsdWVzKERhdGFUeXBlcykuaW5jbHVkZXMoZGF0YVR5cGVPck9wdGlvbnMpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7IHR5cGU6IGRhdGFUeXBlT3JPcHRpb25zLCBhbGxvd051bGw6IHRydWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlID0gZGF0YVR5cGVPck9wdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcjIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIyLCBmb3JjZSk7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVycyhpZGVudGlmaWVycykge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcnMoaWRlbnRpZmllcnMpO1xuICB9XG4gIGFzeW5jIGNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGRhdGFUeXBlT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTCh7XG4gICAgICBbYXR0cmlidXRlTmFtZV06IHRoaXMubm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKVxuICAgIH0sIHtcbiAgICAgIGNvbnRleHQ6IFwiY2hhbmdlQ29sdW1uXCIsXG4gICAgICB0YWJsZTogdGFibGVOYW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIHF1ZXJ5KTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBhc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGlmIChkZXNjcmlwdGlvbltjb2x1bW5OYW1lXSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRhYmxlICR7dGFibGVOYW1lfSBkb2Vzbid0IGhhdmUgdGhlIGNvbHVtbiAke2NvbHVtbk5hbWV9YCk7XG4gIH1cbiAgYXN5bmMgcmVuYW1lQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBkYXRhID0gKGF3YWl0IHRoaXMuYXNzZXJ0VGFibGVIYXNDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgb3B0aW9ucykpW2F0dHJOYW1lQmVmb3JlXTtcbiAgICBjb25zdCBfb3B0aW9ucyA9IHt9O1xuICAgIF9vcHRpb25zW2F0dHJOYW1lQWZ0ZXJdID0ge1xuICAgICAgYXR0cmlidXRlOiBhdHRyTmFtZUFmdGVyLFxuICAgICAgdHlwZTogZGF0YS50eXBlLFxuICAgICAgYWxsb3dOdWxsOiBkYXRhLmFsbG93TnVsbCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGF0YS5kZWZhdWx0VmFsdWVcbiAgICB9O1xuICAgIGlmIChkYXRhLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCAmJiAhZGF0YS5hbGxvd051bGwpIHtcbiAgICAgIGRlbGV0ZSBfb3B0aW9uc1thdHRyTmFtZUFmdGVyXS5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoX29wdGlvbnMpKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBhZGRJbmRleCh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgcmF3VGFibGVuYW1lID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBhdHRyaWJ1dGVzO1xuICAgICAgYXR0cmlidXRlcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cbiAgICBpZiAoIXJhd1RhYmxlbmFtZSkge1xuICAgICAgcmF3VGFibGVuYW1lID0gdGFibGVOYW1lO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuZmllbGRzID0gYXR0cmlidXRlcztcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UgfSkpO1xuICB9XG4gIGFzeW5jIHNob3dJbmRleCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLlNIT1dJTkRFWEVTIH0pKTtcbiAgfVxuICBhc3luYyBnZXRGb3JlaWduS2V5c0ZvclRhYmxlcyh0YWJsZU5hbWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhYmxlTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTIH0pO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0YWJsZU5hbWVzLm1hcCgodGFibGVOYW1lKSA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpLCBvcHRpb25zKSkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIHRhYmxlTmFtZXMuZm9yRWFjaCgodGFibGVOYW1lLCBpKSA9PiB7XG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIHRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuICAgICAgcmVzdWx0W3RhYmxlTmFtZV0gPSBBcnJheS5pc0FycmF5KHJlc3VsdHNbaV0pID8gcmVzdWx0c1tpXS5tYXAoKHIpID0+IHIuY29uc3RyYWludF9uYW1lKSA6IFtyZXN1bHRzW2ldICYmIHJlc3VsdHNbaV0uY29uc3RyYWludF9uYW1lXTtcbiAgICAgIHJlc3VsdFt0YWJsZU5hbWVdID0gcmVzdWx0W3RhYmxlTmFtZV0uZmlsdGVyKF8uaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZU1xuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIHF1ZXJ5T3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlSW5kZXgodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGFkZENvbnN0cmFpbnQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGRzIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy5maWVsZHNcIik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25zdHJhaW50IHR5cGUgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLnR5cGVcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzaG93Q29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0eXBlOiBRdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UUyB9KSk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBpbnNlcnQoaW5zdGFuY2UsIHRhYmxlTmFtZSwgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLmhhc1RyaWdnZXI7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5JTlNFUlQ7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSlcbiAgICAgIHJlc3VsdHNbMF0uaXNOZXdSZWNvcmQgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBvcHRpb25zLmNvbmZsaWN0RmllbGRzIHx8IFtdO1xuICAgIGlmIChvcHRpb25zLnVwc2VydEtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBwcmltYXJ5S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWVsZCk7XG4gICAgICBjb25zdCB1bmlxdWVLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5maWx0ZXIoKGMpID0+IGMuZmllbGRzLmxlbmd0aCA+IDApLm1hcCgoYykgPT4gYy5maWVsZHMpO1xuICAgICAgY29uc3QgaW5kZXhLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5faW5kZXhlcykuZmlsdGVyKChjKSA9PiBjLnVuaXF1ZSAmJiBjLmZpZWxkcy5sZW5ndGggPiAwKS5tYXAoKGMpID0+IGMuZmllbGRzKTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2Ygb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB1bmlxdWVLZXlzLmZpbmQoKGZpZWxkcykgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSB1bmlxdWVLZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXhLZXkgPSBpbmRleEtleXMuZmluZCgoZmllbGRzKSA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgICAgaWYgKGluZGV4S2V5KSB7XG4gICAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gaW5kZXhLZXk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnVwc2VydEtleXMubGVuZ3RoID09PSAwIHx8IF8uaW50ZXJzZWN0aW9uKG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUsIHByaW1hcnlLZXlzKS5sZW5ndGgpIHtcbiAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gcHJpbWFyeUtleXM7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBfLnVuaXEob3B0aW9ucy51cHNlcnRLZXlzKTtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgbW9kZWwucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYnVsa0luc2VydCh0YWJsZU5hbWUsIHJlY29yZHMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuSU5TRVJUO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIHJlY29yZHMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgfVxuICBhc3luYyB1cGRhdGUoaW5zdGFuY2UsIHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyMiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy5oYXNUcmlnZ2VyO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBkYXRlUXVlcnkodGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIyLCBvcHRpb25zLCBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYnVsa1VwZGF0ZSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllcjIsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgaWRlbnRpZmllcjIgPT09IFwib2JqZWN0XCIpXG4gICAgICBpZGVudGlmaWVyMiA9IFV0aWxzLmNsb25lRGVlcChpZGVudGlmaWVyMik7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllcjIsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IHRhYmxlID0gXy5pc09iamVjdCh0YWJsZU5hbWUpID8gdGFibGVOYW1lIDogeyB0YWJsZU5hbWUgfTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWwgPyBvcHRpb25zLm1vZGVsIDogXy5maW5kKHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5tb2RlbHMsIHsgdGFibGVOYW1lOiB0YWJsZS50YWJsZU5hbWUgfSk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkZWxldGUoaW5zdGFuY2UsIHRhYmxlTmFtZSwgaWRlbnRpZmllcjIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXNjYWRlcyA9IFtdO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVsZXRlUXVlcnkodGFibGVOYW1lLCBpZGVudGlmaWVyMiwge30sIGluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmICghIWluc3RhbmNlLmNvbnN0cnVjdG9yICYmICEhaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgbGV0IGFzc29jaWF0aW9uO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NvY2lhdGlvbiA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLmFzc29jaWF0aW9uc1trZXlzW2ldXTtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9uLm9wdGlvbnMgJiYgYXNzb2NpYXRpb24ub3B0aW9ucy5vbkRlbGV0ZSAmJiBhc3NvY2lhdGlvbi5vcHRpb25zLm9uRGVsZXRlLnRvTG93ZXJDYXNlKCkgPT09IFwiY2FzY2FkZVwiICYmIGFzc29jaWF0aW9uLm9wdGlvbnMudXNlSG9va3MgPT09IHRydWUpIHtcbiAgICAgICAgICBjYXNjYWRlcy5wdXNoKGFzc29jaWF0aW9uLmFjY2Vzc29ycy5nZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FzY2FkZSBvZiBjYXNjYWRlcykge1xuICAgICAgbGV0IGluc3RhbmNlcyA9IGF3YWl0IGluc3RhbmNlW2Nhc2NhZGVdKG9wdGlvbnMpO1xuICAgICAgaWYgKCFpbnN0YW5jZXMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpXG4gICAgICAgIGluc3RhbmNlcyA9IFtpbnN0YW5jZXNdO1xuICAgICAgZm9yIChjb25zdCBfaW5zdGFuY2Ugb2YgaW5zdGFuY2VzKVxuICAgICAgICBhd2FpdCBfaW5zdGFuY2UuZGVzdHJveShvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGJ1bGtEZWxldGUodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgbGltaXQ6IG51bGwgfSk7XG4gICAgaWYgKG9wdGlvbnMudHJ1bmNhdGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyID09PSBcIm9iamVjdFwiKVxuICAgICAgd2hlcmUgPSBVdGlscy5jbG9uZURlZXAod2hlcmUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMsIG1vZGVsKSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2VsZWN0KG1vZGVsLCB0YWJsZU5hbWUsIG9wdGlvbnNBcmcpIHtcbiAgICBjb25zdCBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uc0FyZyksIHsgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QsIG1vZGVsIH0pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgbW9kZWwpLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBpbmNyZW1lbnQobW9kZWwsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hcml0aG1ldGljUXVlcnkoXCIrXCIsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRlY3JlbWVudChtb2RlbCwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFyaXRobWV0aWNRdWVyeShcIi1cIiwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmF3U2VsZWN0KHRhYmxlTmFtZSwgb3B0aW9ucywgYXR0cmlidXRlU2VsZWN0b3IsIE1vZGVsKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICBwbGFpbjogdHJ1ZSxcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUXG4gICAgfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zZWxlY3RRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIE1vZGVsKTtcbiAgICBpZiAoYXR0cmlidXRlU2VsZWN0b3IgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHBhc3MgYW4gYXR0cmlidXRlIHNlbGVjdG9yIVwiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBsYWluKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YSA/IGRhdGFbYXR0cmlidXRlU2VsZWN0b3JdIDogbnVsbDtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZGF0YVR5cGUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFUeXBlID0gb3B0aW9ucy5kYXRhVHlwZTtcbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREVDSU1BTCB8fCBkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5GTE9BVCkge1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSU5URUdFUiB8fCBkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CSUdJTlQpIHtcbiAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdCwgMTApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURSkge1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiAhKHJlc3VsdCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNyZWF0ZVRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgdGltaW5nVHlwZSwgZmlyZU9uQXJyYXksIGZ1bmN0aW9uTmFtZSwgZnVuY3Rpb25QYXJhbXMsIG9wdGlvbnNBcnJheSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCB0aW1pbmdUeXBlLCBmaXJlT25BcnJheSwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgb3B0aW9uc0FycmF5KTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZVRyaWdnZXIodGFibGVOYW1lLCBvbGRUcmlnZ2VyTmFtZSwgbmV3VHJpZ2dlck5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkcm9wRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUZ1bmN0aW9uKG9sZEZ1bmN0aW9uTmFtZSwgcGFyYW1zLCBuZXdGdW5jdGlvbk5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBlbnN1cmVFbnVtcygpIHtcbiAgfVxuICBhc3luYyBzZXRJc29sYXRpb25MZXZlbCh0cmFuc2FjdGlvbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzZXQgaXNvbGF0aW9uIGxldmVsIGZvciBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IVwiKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlLCB7XG4gICAgICBwYXJlbnQ6IHRyYW5zYWN0aW9uLnBhcmVudFxuICAgIH0pO1xuICAgIGlmICghc3FsKVxuICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHN0YXJ0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBzdGFydCBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfSk7XG4gICAgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lID0gdHJhbnNhY3Rpb24ucGFyZW50ID8gdHJhbnNhY3Rpb24ubmFtZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZGVmZXJDb25zdHJhaW50cyh0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpO1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb21taXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbW1pdCBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IVwiKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24sXG4gICAgICBzdXBwb3J0c1NlYXJjaFBhdGg6IGZhbHNlLFxuICAgICAgY29tcGxldGVzVHJhbnNhY3Rpb246IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIHRyYW5zYWN0aW9uLmZpbmlzaGVkID0gXCJjb21taXRcIjtcbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgfVxuICBhc3luYyByb2xsYmFja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcm9sbGJhY2sgYSB0cmFuc2FjdGlvbiB3aXRob3V0IHRyYW5zYWN0aW9uIG9iamVjdCFcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbixcbiAgICAgIHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UsXG4gICAgICBjb21wbGV0ZXNUcmFuc2FjdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSA9IHRyYW5zYWN0aW9uLnBhcmVudCA/IHRyYW5zYWN0aW9uLm5hbWUgOiB2b2lkIDA7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIHRyYW5zYWN0aW9uLmZpbmlzaGVkID0gXCJyb2xsYmFja1wiO1xuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG59XG5leHBvcnRzLlF1ZXJ5SW50ZXJmYWNlID0gUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst Dot = __webpack_require__(/*! dottie */ \"(rsc)/./node_modules/dottie/dottie.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst uuid = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst { safeStringifyJson } = __webpack_require__(/*! ../../utils.js */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass AbstractQuery {\n  constructor(connection, sequelize, options) {\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = __spreadValues({\n      plain: false,\n      raw: false,\n      logging: console.log\n    }, options);\n    this.checkLoggingOption();\n    if (options.rawErrors) {\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n    options = options || {};\n    if (typeof replacementFunc !== \"function\") {\n      options = replacementFunc || {};\n      replacementFunc = void 0;\n    }\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values2) => {\n          if (values2[key] !== void 0) {\n            return match;\n          }\n          return void 0;\n        };\n      } else {\n        replacementFunc = (match, key, values2, timeZone2, dialect2) => {\n          if (values2[key] !== void 0) {\n            return SqlString.escape(values2[key], timeZone2, dialect2);\n          }\n          return void 0;\n        };\n      }\n    } else if (options.skipValueReplace) {\n      const origReplacementFunc = replacementFunc;\n      replacementFunc = (match, key, values2, timeZone2, dialect2, options2) => {\n        if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {\n          return match;\n        }\n        return void 0;\n      };\n    }\n    const timeZone = null;\n    const list = Array.isArray(values);\n    sql = sql.replace(/\\B\\$(\\$|\\w+)/g, (match, key) => {\n      if (key === \"$\") {\n        return options.skipUnescape ? match : key;\n      }\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else if (!key.match(/^\\d*$/)) {\n        replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n      }\n      if (replVal === void 0) {\n        throw new Error(`Named bind parameter \"${match}\" has no value in the given object.`);\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n  formatError(error, errStack) {\n    error.stack = errStack;\n    return error;\n  }\n  run() {\n    throw new Error(\"The run method wasn't overwritten!\");\n  }\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n  }\n  getInsertIdField() {\n    return \"insertId\";\n  }\n  getUniqueConstraintErrorMessage(field) {\n    let message = field ? `${field} must be unique` : \"Must be unique\";\n    if (field && this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, \"\"))) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n  isInsertQuery(results, metaData) {\n    let result = true;\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n    result = result && this.sql.toLowerCase().startsWith(\"insert into\");\n    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n  handleShowTablesQuery(results) {\n    return _.flatten(results.map((resultSet) => Object.values(resultSet)));\n  }\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n  handleSelectQuery(results) {\n    let result = null;\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = results.map((result2) => _.reduce(fieldMap, (result3, name, field) => {\n        if (result3[field] !== void 0 && name !== field) {\n          result3[name] = result3[field];\n          delete result3[field];\n        }\n        return result3;\n      }, result2));\n    }\n    if (this.options.raw) {\n      result = results.map((result2) => {\n        let o = {};\n        for (const key in result2) {\n          if (Object.prototype.hasOwnProperty.call(result2, key)) {\n            o[key] = result2[key];\n          }\n        }\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n        return o;\n      });\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.originalAttributes || this.options.attributes\n      });\n    }\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"show\");\n    result = result || this.sql.toLowerCase().startsWith(\"describe\");\n    return result;\n  }\n  isCallQuery() {\n    return this.sql.toLowerCase().startsWith(\"call\");\n  }\n  _logQuery(sql, debugContext, parameters) {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = \"\";\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(\";\") ? \"\" : \";\";\n      let paramStr;\n      if (Array.isArray(parameters)) {\n        paramStr = parameters.map((p) => safeStringifyJson(p)).join(\", \");\n      } else {\n        paramStr = safeStringifyJson(parameters);\n      }\n      logParameter = `${delimiter} ${paramStr}`;\n    }\n    const fmt = `(${connection.uuid || \"default\"}): ${sql}${logParameter}`;\n    const msg = `Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`Executing ${fmt}`, options);\n    }\n    return () => {\n      const afterMsg = `Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n  static _groupJoinData(rows, includeOptions, options) {\n    if (!rows.length) {\n      return [];\n    }\n    let i;\n    let length;\n    let $i;\n    let $length;\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString;\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    let previousPiece;\n    const buildIncludeMap = (piece) => {\n      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = `${previousPiece}.${piece}`;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key2, memo) => {\n      if (!Object.prototype.hasOwnProperty.call(memo, key2)) {\n        memo[key2] = key2.substr(0, key2.lastIndexOf(\".\"));\n      }\n      return memo[key2];\n    };\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {\n        const index = key2.lastIndexOf(\".\");\n        removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key2];\n    };\n    const keyPrefixMemo = {};\n    const keyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {\n        const prefixString = keyPrefixString(key2, keyPrefixStringMemo);\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split(\".\") : [];\n        }\n        keyPrefixMemo[key2] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key2];\n    };\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {\n        const prefix2 = keyPrefix(key2);\n        const length2 = prefix2.length;\n        lastKeyPrefixMemo[key2] = !length2 ? \"\" : prefix2[length2 - 1];\n      }\n      return lastKeyPrefixMemo[key2];\n    };\n    const getUniqueKeyAttributes = (model) => {\n      let uniqueKeyAttributes2 = _.chain(model.uniqueKeys);\n      uniqueKeyAttributes2 = uniqueKeyAttributes2.result(`${uniqueKeyAttributes2.findKey()}.fields`).map((field) => _.findKey(model.attributes, (chr) => chr.field === field)).value();\n      return uniqueKeyAttributes2;\n    };\n    const stringify = (obj) => obj instanceof Buffer ? obj.toString(\"hex\") : obj;\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n      if (rowsI === 0) {\n        keys = _.sortBy(Object.keys(row), (item) => [item.split(\".\").length]);\n        keyLength = keys.length;\n      }\n      if (checkExisting) {\n        topExists = false;\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = \"\";\n        if ($length === 1) {\n          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n        } else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n          }\n        } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n      topValues = values = {};\n      $prevKeyPrefix = void 0;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[\"\"] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = void 0;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n                } else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n                  }\n                } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else if (!resultMap[itemHash]) {\n              $parent = resultMap[parentHash];\n              $lastKeyPrefix = lastKeyPrefix(prevKey);\n              if (includeMap[prevKey].association.isSingleAssociation) {\n                if ($parent) {\n                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                }\n              } else {\n                if (!$parent[$lastKeyPrefix]) {\n                  $parent[$lastKeyPrefix] = [];\n                }\n                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n              }\n            }\n            values = {};\n          } else {\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length - 1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]] || {};\n              }\n            }\n          }\n        }\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n            } else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n              }\n            } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else if (!resultMap[itemHash]) {\n          $parent = resultMap[parentHash];\n          $lastKeyPrefix = lastKeyPrefix(prevKey);\n          if (includeMap[prevKey].association.isSingleAssociation) {\n            if ($parent) {\n              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n            }\n          } else {\n            if (!$parent[$lastKeyPrefix]) {\n              $parent[$lastKeyPrefix] = [];\n            }\n            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n    return results;\n  }\n}\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports[\"default\"] = AbstractQuery;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMscURBQVE7QUFDNUIscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELGFBQWEsd0ZBQWtCO0FBQy9CLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxFQUFFLFNBQVM7QUFDOUM7QUFDQSxvQkFBb0IsNkJBQTZCLEtBQUssSUFBSSxFQUFFLGFBQWE7QUFDekUsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMsR0FBRyxNQUFNO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsK0JBQStCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0NBQXNDLFFBQVEsR0FBRyxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTyxHQUFHLHdCQUF3QjtBQUNqRixrQkFBa0I7QUFDbEIsK0JBQStCLGNBQWM7QUFDN0MsaURBQWlELE9BQU8sR0FBRyx5QkFBeUI7QUFDcEY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFLHVDQUF1QyxPQUFPLEdBQUcsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxrQ0FBa0MsUUFBUSxHQUFHLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLEdBQUcsd0JBQXdCO0FBQzdFLGNBQWM7QUFDZCwyQkFBMkIsY0FBYztBQUN6Qyw2Q0FBNkMsT0FBTyxHQUFHLHlCQUF5QjtBQUNoRjtBQUNBLGNBQWM7QUFDZDtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsbUNBQW1DLE9BQU8sR0FBRyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcz83NGNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKFwiLi4vLi4vc3FsLXN0cmluZ1wiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBEb3QgPSByZXF1aXJlKFwiZG90dGllXCIpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlcHJlY2F0aW9uc1wiKTtcbmNvbnN0IHV1aWQgPSByZXF1aXJlKFwidXVpZFwiKS52NDtcbmNvbnN0IHsgc2FmZVN0cmluZ2lmeUpzb24gfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy5qc1wiKTtcbmNsYXNzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnV1aWQgPSB1dWlkKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmluc3RhbmNlID0gb3B0aW9ucy5pbnN0YW5jZTtcbiAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBwbGFpbjogZmFsc2UsXG4gICAgICByYXc6IGZhbHNlLFxuICAgICAgbG9nZ2luZzogY29uc29sZS5sb2dcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmNoZWNrTG9nZ2luZ09wdGlvbigpO1xuICAgIGlmIChvcHRpb25zLnJhd0Vycm9ycykge1xuICAgICAgdGhpcy5mb3JtYXRFcnJvciA9IEFic3RyYWN0UXVlcnkucHJvdG90eXBlLmZvcm1hdEVycm9yO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYywgb3B0aW9ucykge1xuICAgIGlmICghdmFsdWVzKSB7XG4gICAgICByZXR1cm4gW3NxbCwgW11dO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50RnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvcHRpb25zID0gcmVwbGFjZW1lbnRGdW5jIHx8IHt9O1xuICAgICAgcmVwbGFjZW1lbnRGdW5jID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoIXJlcGxhY2VtZW50RnVuYykge1xuICAgICAgaWYgKG9wdGlvbnMuc2tpcFZhbHVlUmVwbGFjZSkge1xuICAgICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMikgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIsIHRpbWVab25lMiwgZGlhbGVjdDIpID0+IHtcbiAgICAgICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBTcWxTdHJpbmcuZXNjYXBlKHZhbHVlczJba2V5XSwgdGltZVpvbmUyLCBkaWFsZWN0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNraXBWYWx1ZVJlcGxhY2UpIHtcbiAgICAgIGNvbnN0IG9yaWdSZXBsYWNlbWVudEZ1bmMgPSByZXBsYWNlbWVudEZ1bmM7XG4gICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMiwgdGltZVpvbmUyLCBkaWFsZWN0Miwgb3B0aW9uczIpID0+IHtcbiAgICAgICAgaWYgKG9yaWdSZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzMiwgdGltZVpvbmUyLCBkaWFsZWN0Miwgb3B0aW9uczIpICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgICBjb25zdCBsaXN0ID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpO1xuICAgIHNxbCA9IHNxbC5yZXBsYWNlKC9cXEJcXCQoXFwkfFxcdyspL2csIChtYXRjaCwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcIiRcIikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5za2lwVW5lc2NhcGUgPyBtYXRjaCA6IGtleTtcbiAgICAgIH1cbiAgICAgIGxldCByZXBsVmFsO1xuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgaWYgKGtleS5tYXRjaCgvXlsxLTldXFxkKiQvKSkge1xuICAgICAgICAgIGtleSA9IGtleSAtIDE7XG4gICAgICAgICAgcmVwbFZhbCA9IHJlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgha2V5Lm1hdGNoKC9eXFxkKiQvKSkge1xuICAgICAgICByZXBsVmFsID0gcmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcGxWYWwgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVkIGJpbmQgcGFyYW1ldGVyIFwiJHttYXRjaH1cIiBoYXMgbm8gdmFsdWUgaW4gdGhlIGdpdmVuIG9iamVjdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXBsVmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBbc3FsLCBbXV07XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyb3IsIGVyclN0YWNrKSB7XG4gICAgZXJyb3Iuc3RhY2sgPSBlcnJTdGFjaztcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcnVuKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBydW4gbWV0aG9kIHdhc24ndCBvdmVyd3JpdHRlbiFcIik7XG4gIH1cbiAgY2hlY2tMb2dnaW5nT3B0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vVHJ1ZUxvZ2dpbmcoKTtcbiAgICAgIHRoaXMub3B0aW9ucy5sb2dnaW5nID0gY29uc29sZS5sb2c7XG4gICAgfVxuICB9XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwiaW5zZXJ0SWRcIjtcbiAgfVxuICBnZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBmaWVsZCA/IGAke2ZpZWxkfSBtdXN0IGJlIHVuaXF1ZWAgOiBcIk11c3QgYmUgdW5pcXVlXCI7XG4gICAgaWYgKGZpZWxkICYmIHRoaXMubW9kZWwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMubW9kZWwudW5pcXVlS2V5cykpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwudW5pcXVlS2V5c1trZXldLmZpZWxkcy5pbmNsdWRlcyhmaWVsZC5yZXBsYWNlKC9cIi9nLCBcIlwiKSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0ubXNnKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0ubXNnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBpc1Jhd1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5SQVc7XG4gIH1cbiAgaXNWZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlZFUlNJT047XG4gIH1cbiAgaXNVcHNlcnRRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICB9XG4gIGlzSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuSU5TRVJUKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImluc2VydCBpbnRvXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAoIXJlc3VsdHMgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIHRoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpKSk7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmICghbWV0YURhdGEgfHwgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1ldGFEYXRhLCB0aGlzLmdldEluc2VydElkRmllbGQoKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1t0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0gPSBpZDtcbiAgICB9XG4gIH1cbiAgaXNTaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlNIT1dUQUJMRVM7XG4gIH1cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHJlc3VsdHMubWFwKChyZXN1bHRTZXQpID0+IE9iamVjdC52YWx1ZXMocmVzdWx0U2V0KSkpO1xuICB9XG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV0lOREVYRVM7XG4gIH1cbiAgaXNTaG93Q29uc3RyYWludHNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTO1xuICB9XG4gIGlzRGVzY3JpYmVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuREVTQ1JJQkU7XG4gIH1cbiAgaXNTZWxlY3RRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0VMRUNUO1xuICB9XG4gIGlzQnVsa1VwZGF0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICB9XG4gIGlzQnVsa0RlbGV0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLREVMRVRFO1xuICB9XG4gIGlzRm9yZWlnbktleXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVM7XG4gIH1cbiAgaXNVcGRhdGVRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICB9XG4gIGhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmZpZWxkTWFwKSB7XG4gICAgICBjb25zdCBmaWVsZE1hcCA9IHRoaXMub3B0aW9ucy5maWVsZE1hcDtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcCgocmVzdWx0MikgPT4gXy5yZWR1Y2UoZmllbGRNYXAsIChyZXN1bHQzLCBuYW1lLCBmaWVsZCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0M1tmaWVsZF0gIT09IHZvaWQgMCAmJiBuYW1lICE9PSBmaWVsZCkge1xuICAgICAgICAgIHJlc3VsdDNbbmFtZV0gPSByZXN1bHQzW2ZpZWxkXTtcbiAgICAgICAgICBkZWxldGUgcmVzdWx0M1tmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDM7XG4gICAgICB9LCByZXN1bHQyKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucmF3KSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRzLm1hcCgocmVzdWx0MikgPT4ge1xuICAgICAgICBsZXQgbyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQyKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQyLCBrZXkpKSB7XG4gICAgICAgICAgICBvW2tleV0gPSByZXN1bHQyW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmVzdCkge1xuICAgICAgICAgIG8gPSBEb3QudHJhbnNmb3JtKG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuaGFzSm9pbiA9PT0gdHJ1ZSkge1xuICAgICAgcmVzdWx0cyA9IEFic3RyYWN0UXVlcnkuX2dyb3VwSm9pbkRhdGEocmVzdWx0cywge1xuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgaW5jbHVkZU1hcDogdGhpcy5vcHRpb25zLmluY2x1ZGVNYXAsXG4gICAgICAgIGluY2x1ZGVOYW1lczogdGhpcy5vcHRpb25zLmluY2x1ZGVOYW1lc1xuICAgICAgfSwge1xuICAgICAgICBjaGVja0V4aXN0aW5nOiB0aGlzLm9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvblxuICAgICAgfSk7XG4gICAgICByZXN1bHQgPSB0aGlzLm1vZGVsLmJ1bGtCdWlsZChyZXN1bHRzLCB7XG4gICAgICAgIGlzTmV3UmVjb3JkOiBmYWxzZSxcbiAgICAgICAgaW5jbHVkZTogdGhpcy5vcHRpb25zLmluY2x1ZGUsXG4gICAgICAgIGluY2x1ZGVOYW1lczogdGhpcy5vcHRpb25zLmluY2x1ZGVOYW1lcyxcbiAgICAgICAgaW5jbHVkZU1hcDogdGhpcy5vcHRpb25zLmluY2x1ZGVNYXAsXG4gICAgICAgIGluY2x1ZGVWYWxpZGF0ZWQ6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgfHwgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMsXG4gICAgICAgIHJhdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwuYnVsa0J1aWxkKHJlc3VsdHMsIHtcbiAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlLFxuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgfHwgdGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnBsYWluKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHJlc3VsdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1Nob3dPckRlc2NyaWJlUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzaG93XCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJkZXNjcmliZVwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzQ2FsbFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJjYWxsXCIpO1xuICB9XG4gIF9sb2dRdWVyeShzcWwsIGRlYnVnQ29udGV4dCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBiZW5jaG1hcmsgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmJlbmNobWFyayB8fCBvcHRpb25zLmJlbmNobWFyaztcbiAgICBjb25zdCBsb2dRdWVyeVBhcmFtZXRlcnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmxvZ1F1ZXJ5UGFyYW1ldGVycyB8fCBvcHRpb25zLmxvZ1F1ZXJ5UGFyYW1ldGVycztcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBsb2dQYXJhbWV0ZXIgPSBcIlwiO1xuICAgIGlmIChsb2dRdWVyeVBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycykge1xuICAgICAgY29uc3QgZGVsaW1pdGVyID0gc3FsLmVuZHNXaXRoKFwiO1wiKSA/IFwiXCIgOiBcIjtcIjtcbiAgICAgIGxldCBwYXJhbVN0cjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHBhcmFtU3RyID0gcGFyYW1ldGVycy5tYXAoKHApID0+IHNhZmVTdHJpbmdpZnlKc29uKHApKS5qb2luKFwiLCBcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbVN0ciA9IHNhZmVTdHJpbmdpZnlKc29uKHBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgICAgbG9nUGFyYW1ldGVyID0gYCR7ZGVsaW1pdGVyfSAke3BhcmFtU3RyfWA7XG4gICAgfVxuICAgIGNvbnN0IGZtdCA9IGAoJHtjb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogJHtzcWx9JHtsb2dQYXJhbWV0ZXJ9YDtcbiAgICBjb25zdCBtc2cgPSBgRXhlY3V0aW5nICR7Zm10fWA7XG4gICAgZGVidWdDb250ZXh0KG1zZyk7XG4gICAgaWYgKCFiZW5jaG1hcmspIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgRXhlY3V0aW5nICR7Zm10fWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJNc2cgPSBgRXhlY3V0ZWQgJHtmbXR9YDtcbiAgICAgIGRlYnVnQ29udGV4dChhZnRlck1zZyk7XG4gICAgICBpZiAoYmVuY2htYXJrKSB7XG4gICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhhZnRlck1zZywgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgX2dyb3VwSm9pbkRhdGEocm93cywgaW5jbHVkZU9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGxldCBpO1xuICAgIGxldCBsZW5ndGg7XG4gICAgbGV0ICRpO1xuICAgIGxldCAkbGVuZ3RoO1xuICAgIGxldCByb3dzSTtcbiAgICBsZXQgcm93O1xuICAgIGNvbnN0IHJvd3NMZW5ndGggPSByb3dzLmxlbmd0aDtcbiAgICBsZXQga2V5cztcbiAgICBsZXQga2V5O1xuICAgIGxldCBrZXlJO1xuICAgIGxldCBrZXlMZW5ndGg7XG4gICAgbGV0IHByZXZLZXk7XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgdG9wVmFsdWVzO1xuICAgIGxldCB0b3BFeGlzdHM7XG4gICAgY29uc3QgY2hlY2tFeGlzdGluZyA9IG9wdGlvbnMuY2hlY2tFeGlzdGluZztcbiAgICBsZXQgaXRlbUhhc2g7XG4gICAgbGV0IHBhcmVudEhhc2g7XG4gICAgbGV0IHRvcEhhc2g7XG4gICAgY29uc3QgcmVzdWx0cyA9IGNoZWNrRXhpc3RpbmcgPyBbXSA6IG5ldyBBcnJheShyb3dzTGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHRNYXAgPSB7fTtcbiAgICBjb25zdCBpbmNsdWRlTWFwID0ge307XG4gICAgbGV0ICRrZXlQcmVmaXg7XG4gICAgbGV0ICRrZXlQcmVmaXhTdHJpbmc7XG4gICAgbGV0ICRwcmV2S2V5UHJlZml4U3RyaW5nO1xuICAgIGxldCAkcHJldktleVByZWZpeDtcbiAgICBsZXQgJGxhc3RLZXlQcmVmaXg7XG4gICAgbGV0ICRjdXJyZW50O1xuICAgIGxldCAkcGFyZW50O1xuICAgIGxldCBwcmV2aW91c1BpZWNlO1xuICAgIGNvbnN0IGJ1aWxkSW5jbHVkZU1hcCA9IChwaWVjZSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgkY3VycmVudC5pbmNsdWRlTWFwLCBwaWVjZSkpIHtcbiAgICAgICAgaW5jbHVkZU1hcFtrZXldID0gJGN1cnJlbnQgPSAkY3VycmVudC5pbmNsdWRlTWFwW3BpZWNlXTtcbiAgICAgICAgaWYgKHByZXZpb3VzUGllY2UpIHtcbiAgICAgICAgICBwcmV2aW91c1BpZWNlID0gYCR7cHJldmlvdXNQaWVjZX0uJHtwaWVjZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzUGllY2UgPSBwaWVjZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdWRlTWFwW3ByZXZpb3VzUGllY2VdID0gJGN1cnJlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBrZXlQcmVmaXhTdHJpbmdNZW1vID0ge307XG4gICAgY29uc3Qga2V5UHJlZml4U3RyaW5nID0gKGtleTIsIG1lbW8pID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lbW8sIGtleTIpKSB7XG4gICAgICAgIG1lbW9ba2V5Ml0gPSBrZXkyLnN1YnN0cigwLCBrZXkyLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtb1trZXkyXTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZUtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCByZW1vdmVLZXlQcmVmaXggPSAoa2V5MikgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVtb3ZlS2V5UHJlZml4TWVtbywga2V5MikpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBrZXkyLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgcmVtb3ZlS2V5UHJlZml4TWVtb1trZXkyXSA9IGtleTIuc3Vic3RyKGluZGV4ID09PSAtMSA/IDAgOiBpbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZUtleVByZWZpeE1lbW9ba2V5Ml07XG4gICAgfTtcbiAgICBjb25zdCBrZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3Qga2V5UHJlZml4ID0gKGtleTIpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGtleVByZWZpeE1lbW8sIGtleTIpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeFN0cmluZyA9IGtleVByZWZpeFN0cmluZyhrZXkyLCBrZXlQcmVmaXhTdHJpbmdNZW1vKTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa2V5UHJlZml4TWVtbywgcHJlZml4U3RyaW5nKSkge1xuICAgICAgICAgIGtleVByZWZpeE1lbW9bcHJlZml4U3RyaW5nXSA9IHByZWZpeFN0cmluZyA/IHByZWZpeFN0cmluZy5zcGxpdChcIi5cIikgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBrZXlQcmVmaXhNZW1vW2tleTJdID0ga2V5UHJlZml4TWVtb1twcmVmaXhTdHJpbmddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleVByZWZpeE1lbW9ba2V5Ml07XG4gICAgfTtcbiAgICBjb25zdCBsYXN0S2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IGxhc3RLZXlQcmVmaXggPSAoa2V5MikgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGFzdEtleVByZWZpeE1lbW8sIGtleTIpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeDIgPSBrZXlQcmVmaXgoa2V5Mik7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBwcmVmaXgyLmxlbmd0aDtcbiAgICAgICAgbGFzdEtleVByZWZpeE1lbW9ba2V5Ml0gPSAhbGVuZ3RoMiA/IFwiXCIgOiBwcmVmaXgyW2xlbmd0aDIgLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0S2V5UHJlZml4TWVtb1trZXkyXTtcbiAgICB9O1xuICAgIGNvbnN0IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMgPSAobW9kZWwpID0+IHtcbiAgICAgIGxldCB1bmlxdWVLZXlBdHRyaWJ1dGVzMiA9IF8uY2hhaW4obW9kZWwudW5pcXVlS2V5cyk7XG4gICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzMiA9IHVuaXF1ZUtleUF0dHJpYnV0ZXMyLnJlc3VsdChgJHt1bmlxdWVLZXlBdHRyaWJ1dGVzMi5maW5kS2V5KCl9LmZpZWxkc2ApLm1hcCgoZmllbGQpID0+IF8uZmluZEtleShtb2RlbC5hdHRyaWJ1dGVzLCAoY2hyKSA9PiBjaHIuZmllbGQgPT09IGZpZWxkKSkudmFsdWUoKTtcbiAgICAgIHJldHVybiB1bmlxdWVLZXlBdHRyaWJ1dGVzMjtcbiAgICB9O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIEJ1ZmZlciA/IG9iai50b1N0cmluZyhcImhleFwiKSA6IG9iajtcbiAgICBsZXQgcHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgbGV0IHVuaXF1ZUtleUF0dHJpYnV0ZXM7XG4gICAgbGV0IHByZWZpeDtcbiAgICBmb3IgKHJvd3NJID0gMDsgcm93c0kgPCByb3dzTGVuZ3RoOyByb3dzSSsrKSB7XG4gICAgICByb3cgPSByb3dzW3Jvd3NJXTtcbiAgICAgIGlmIChyb3dzSSA9PT0gMCkge1xuICAgICAgICBrZXlzID0gXy5zb3J0QnkoT2JqZWN0LmtleXMocm93KSwgKGl0ZW0pID0+IFtpdGVtLnNwbGl0KFwiLlwiKS5sZW5ndGhdKTtcbiAgICAgICAga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICB0b3BFeGlzdHMgPSBmYWxzZTtcbiAgICAgICAgJGxlbmd0aCA9IGluY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgdG9wSGFzaCA9IFwiXCI7XG4gICAgICAgIGlmICgkbGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdG9wSGFzaCA9IHN0cmluZ2lmeShyb3dbaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXNbMF1dKTtcbiAgICAgICAgfSBlbHNlIGlmICgkbGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgIHRvcEhhc2ggKz0gc3RyaW5naWZ5KHJvd1tpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlc1skaV1dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIV8uaXNFbXB0eShpbmNsdWRlT3B0aW9ucy5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVPcHRpb25zLm1vZGVsKTtcbiAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgdG9wSGFzaCArPSByb3dbdW5pcXVlS2V5QXR0cmlidXRlc1skaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9wVmFsdWVzID0gdmFsdWVzID0ge307XG4gICAgICAkcHJldktleVByZWZpeCA9IHZvaWQgMDtcbiAgICAgIGZvciAoa2V5SSA9IDA7IGtleUkgPCBrZXlMZW5ndGg7IGtleUkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2tleUldO1xuICAgICAgICAka2V5UHJlZml4U3RyaW5nID0ga2V5UHJlZml4U3RyaW5nKGtleSwga2V5UHJlZml4U3RyaW5nTWVtbyk7XG4gICAgICAgICRrZXlQcmVmaXggPSBrZXlQcmVmaXgoa2V5KTtcbiAgICAgICAgaWYgKHJvd3NJID09PSAwICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5jbHVkZU1hcCwga2V5KSkge1xuICAgICAgICAgIGlmICghJGtleVByZWZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluY2x1ZGVNYXBba2V5XSA9IGluY2x1ZGVNYXBbXCJcIl0gPSBpbmNsdWRlT3B0aW9ucztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGN1cnJlbnQgPSBpbmNsdWRlT3B0aW9ucztcbiAgICAgICAgICAgIHByZXZpb3VzUGllY2UgPSB2b2lkIDA7XG4gICAgICAgICAgICAka2V5UHJlZml4LmZvckVhY2goYnVpbGRJbmNsdWRlTWFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRwcmV2S2V5UHJlZml4ICE9PSB2b2lkIDAgJiYgJHByZXZLZXlQcmVmaXggIT09ICRrZXlQcmVmaXgpIHtcbiAgICAgICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICAgICAgbGVuZ3RoID0gJHByZXZLZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAgICAgJHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBwYXJlbnRIYXNoID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJHBhcmVudCA/IGAkeyRwYXJlbnR9LiR7JHByZXZLZXlQcmVmaXhbaV19YCA6ICRwcmV2S2V5UHJlZml4W2ldO1xuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzID0gaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICRsZW5ndGggPSBwcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWzBdfWBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHN0cmluZ2lmeShyb3dbYCR7cHJlZml4fS4ke3ByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXX1gXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHJvd1tgJHtwcmVmaXh9LiR7dW5pcXVlS2V5QXR0cmlidXRlc1skaV19YF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50SGFzaCkge1xuICAgICAgICAgICAgICAgICAgcGFyZW50SGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1IYXNoID0gcGFyZW50SGFzaCArIGl0ZW1IYXNoO1xuICAgICAgICAgICAgICAgICRwYXJlbnQgPSBwcmVmaXg7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gaXRlbUhhc2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtSGFzaCA9IHRvcEhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbUhhc2ggPT09IHRvcEhhc2gpIHtcbiAgICAgICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgICAgICRwYXJlbnQgPSByZXN1bHRNYXBbcGFyZW50SGFzaF07XG4gICAgICAgICAgICAgICRsYXN0S2V5UHJlZml4ID0gbGFzdEtleVByZWZpeChwcmV2S2V5KTtcbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVNYXBbcHJldktleV0uYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICgkcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghJHBhcmVudFskbGFzdEtleVByZWZpeF0pIHtcbiAgICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdLnB1c2gocmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkY3VycmVudCA9IHRvcFZhbHVlcztcbiAgICAgICAgICAgIGxlbmd0aCA9ICRrZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgdmFsdWVzID0gJGN1cnJlbnRbJGtleVByZWZpeFtpXV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGN1cnJlbnQgPSAkY3VycmVudFska2V5UHJlZml4W2ldXSB8fCB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXNbcmVtb3ZlS2V5UHJlZml4KGtleSldID0gcm93W2tleV07XG4gICAgICAgIHByZXZLZXkgPSBrZXk7XG4gICAgICAgICRwcmV2S2V5UHJlZml4ID0gJGtleVByZWZpeDtcbiAgICAgICAgJHByZXZLZXlQcmVmaXhTdHJpbmcgPSAka2V5UHJlZml4U3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrRXhpc3RpbmcpIHtcbiAgICAgICAgbGVuZ3RoID0gJHByZXZLZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICAkcGFyZW50ID0gbnVsbDtcbiAgICAgICAgcGFyZW50SGFzaCA9IG51bGw7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICRwYXJlbnQgPyBgJHskcGFyZW50fS4keyRwcmV2S2V5UHJlZml4W2ldfWAgOiAkcHJldktleVByZWZpeFtpXTtcbiAgICAgICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzID0gaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgJGxlbmd0aCA9IHByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGl0ZW1IYXNoID0gcHJlZml4O1xuICAgICAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbMF19YF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkbGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCAkbGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldfWBdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwpO1xuICAgICAgICAgICAgICBmb3IgKCRpID0gMDsgJGkgPCB1bmlxdWVLZXlBdHRyaWJ1dGVzLmxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgICAgIGl0ZW1IYXNoICs9IHJvd1tgJHtwcmVmaXh9LiR7dW5pcXVlS2V5QXR0cmlidXRlc1skaV19YF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyZW50SGFzaCkge1xuICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1IYXNoID0gcGFyZW50SGFzaCArIGl0ZW1IYXNoO1xuICAgICAgICAgICAgJHBhcmVudCA9IHByZWZpeDtcbiAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gaXRlbUhhc2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1IYXNoID0gdG9wSGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbUhhc2ggPT09IHRvcEhhc2gpIHtcbiAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcEV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFyZXN1bHRNYXBbaXRlbUhhc2hdKSB7XG4gICAgICAgICAgJHBhcmVudCA9IHJlc3VsdE1hcFtwYXJlbnRIYXNoXTtcbiAgICAgICAgICAkbGFzdEtleVByZWZpeCA9IGxhc3RLZXlQcmVmaXgocHJldktleSk7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXBbcHJldktleV0uYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICAgICAgaWYgKCRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoISRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdKSB7XG4gICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XS5wdXNoKHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcEV4aXN0cykge1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh0b3BWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzW3Jvd3NJXSA9IHRvcFZhbHVlcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RRdWVyeTtcbm1vZHVsZS5leHBvcnRzLkFic3RyYWN0UXVlcnkgPSBBYnN0cmFjdFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0UXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/connection-manager.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").db2);\nconst debug = logger.debugContext(\"connection:db2\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, (error) => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close((error) => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n    return Promise.resolve();\n  }\n  validate(connection) {\n    return connection && connection.connected;\n  }\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQixxR0FBK0I7QUFDakQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz8yMTdiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5kYjI7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOmRiMlwiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwiZGIyXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwiaWJtX2RiXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICBob3N0bmFtZTogY29uZmlnLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgIHVpZDogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgcHdkOiBjb25maWcucGFzc3dvcmRcbiAgICB9O1xuICAgIGlmIChjb25maWcuc3NsKSB7XG4gICAgICBjb25uZWN0aW9uQ29uZmlnW1wic2VjdXJpdHlcIl0gPSBjb25maWcuc3NsO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnNzbGNlcnRpZmljYXRlKSB7XG4gICAgICBjb25uZWN0aW9uQ29uZmlnW1wiU1NMU2VydmVyQ2VydGlmaWNhdGVcIl0gPSBjb25maWcuc3NsY2VydGlmaWNhdGU7XG4gICAgfVxuICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykpIHtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZ1trZXldID0gY29uZmlnLmRpYWxlY3RPcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uMiA9IG5ldyB0aGlzLmxpYi5EYXRhYmFzZSgpO1xuICAgICAgICBjb25uZWN0aW9uMi5saWIgPSB0aGlzLmxpYjtcbiAgICAgICAgY29ubmVjdGlvbjIub3Blbihjb25uZWN0aW9uQ29uZmlnLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJTUUwzMDA4MU5cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY29ubmVjdGlvbjIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGRlYnVnKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmNvbm5lY3RlZDtcbiAgfVxuICBfZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/data-types.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008478.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`Db2 does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.db2 = [\"TIMESTAMP\"];\n  BaseTypes.STRING.types.db2 = [\"VARCHAR\"];\n  BaseTypes.CHAR.types.db2 = [\"CHAR\"];\n  BaseTypes.TEXT.types.db2 = [\"VARCHAR\", \"CLOB\"];\n  BaseTypes.TINYINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.SMALLINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.db2 = [\"INTEGER\"];\n  BaseTypes.INTEGER.types.db2 = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.db2 = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.db2 = [\"DOUBLE\", \"REAL\", \"FLOAT\"];\n  BaseTypes.TIME.types.db2 = [\"TIME\"];\n  BaseTypes.DATEONLY.types.db2 = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.db2 = [\"BOOLEAN\", \"BOOL\", \"SMALLINT\", \"BIT\"];\n  BaseTypes.BLOB.types.db2 = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.db2 = [\"DECIMAL\"];\n  BaseTypes.UUID.types.db2 = [\"CHAR () FOR BIT DATA\"];\n  BaseTypes.ENUM.types.db2 = [\"VARCHAR\"];\n  BaseTypes.REAL.types.db2 = [\"REAL\"];\n  BaseTypes.DOUBLE.types.db2 = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.db2 = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          return \"BLOB(255)\";\n        }\n        if (this._length.toLowerCase() === \"medium\") {\n          return \"BLOB(16M)\";\n        }\n        if (this._length.toLowerCase() === \"long\") {\n          return \"BLOB(2G)\";\n        }\n        return `BLOB(${this._length})`;\n      }\n      return \"BLOB\";\n    }\n    escape(blob) {\n      return `BLOB('${blob.toString().replace(/'/g, \"''\")}')`;\n    }\n    _stringify(value) {\n      if (Buffer.isBuffer(value)) {\n        return `BLOB('${value.toString().replace(/'/g, \"''\")}')`;\n      }\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n      const hex = value.toString(\"hex\");\n      return this._hexify(hex);\n    }\n    _hexify(hex) {\n      return `x'${hex}'`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        if (this._length <= 4e3) {\n          return `VARCHAR(${this._length})`;\n        }\n        return `CLOB(${this._length})`;\n      }\n      if (this._length < 255) {\n        return `CHAR(${this._length}) FOR BIT DATA`;\n      }\n      if (this._length <= 4e3) {\n        return `VARCHAR(${this._length}) FOR BIT DATA`;\n      }\n      return `BLOB(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._hexify(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      let len = 0;\n      if (this._length) {\n        switch (this._length.toLowerCase()) {\n          case \"tiny\":\n            len = 256;\n            break;\n          case \"medium\":\n            len = 8192;\n            break;\n          case \"long\":\n            len = 65536;\n            break;\n        }\n        if (isNaN(this._length)) {\n          this._length = 32672;\n        }\n        if (len > 0) {\n          this._length = len;\n        }\n      } else {\n        this._length = 32672;\n      }\n      if (this._length > 32672) {\n        len = `CLOB(${this._length})`;\n      } else {\n        len = `VARCHAR(${this._length})`;\n      }\n      warn(`Db2 does not support TEXT datatype. ${len} will be used instead.`);\n      return len;\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          value = value === \"true\" ? true : value === \"false\" ? false : value;\n          value = value === \"\u0001\" ? true : value === \"\\0\" ? false : value;\n        } else if (typeof value === \"number\") {\n          value = value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) FOR BIT DATA\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"CURRENT TIME\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      if (this._length < 0) {\n        this._length = 0;\n      }\n      if (this._length > 6) {\n        this._length = 6;\n      }\n      return `TIMESTAMP${this._length ? `(${this._length})` : \"\"}`;\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length > 0) {\n        let msec = \".\";\n        for (let i = 0; i < this._length && i < 6; i++) {\n          msec += \"S\";\n        }\n        return date.format(`YYYY-MM-DD HH:mm:ss${msec}`);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value) {\n      if (typeof value !== \"string\") {\n        value = value.string();\n      }\n      if (value === null) {\n        return value;\n      }\n      value = new Date(momentTz.utc(value));\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return momentTz(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Db2 does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"Db2 does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"Db2 does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"Db2 does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"db2 does not support DOUBLE with options. Plain DOUBLE will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"DOUBLE\";\n    }\n  }\n  DOUBLE.prototype.key = DOUBLE.key = \"DOUBLE\";\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    DOUBLE,\n    \"DOUBLE PRECISION\": DOUBLE,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYSx5QkFBeUIsYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxRQUFRO0FBQ1IseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CLGFBQWEsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL2RhdGEtdHlwZXMuanM/NzA1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodm9pZCAwLCBcImh0dHBzOi8vd3d3LmlibS5jb20vc3VwcG9ydC9rbm93bGVkZ2VjZW50ZXIvU1NFUEdHXzExLjEuMC9jb20uaWJtLmRiMi5sdXcuc3FsLnJlZi5kb2MvZG9jL3IwMDA4NDc4Lmh0bWxcIik7XG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX2xlbmd0aCB8fCBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCB8fCBkYXRhVHlwZS5fdW5zaWduZWQgfHwgZGF0YVR5cGUuX3plcm9maWxsKSB7XG4gICAgICB3YXJuKGBEYjIgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIG9wdGlvbnMuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREFURS50eXBlcy5kYjIgPSBbXCJUSU1FU1RBTVBcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMuZGIyID0gW1wiVkFSQ0hBUlwiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMuZGIyID0gW1wiQ0hBUlwiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMuZGIyID0gW1wiVkFSQ0hBUlwiLCBcIkNMT0JcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLmRiMiA9IFtcIlNNQUxMSU5UXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMuZGIyID0gW1wiU01BTExJTlRcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMuZGIyID0gW1wiSU5URUdFUlwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMuZGIyID0gW1wiSU5URUdFUlwiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5kYjIgPSBbXCJCSUdJTlRcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5kYjIgPSBbXCJET1VCTEVcIiwgXCJSRUFMXCIsIFwiRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLmRiMiA9IFtcIlRJTUVcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5kYjIgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5kYjIgPSBbXCJCT09MRUFOXCIsIFwiQk9PTFwiLCBcIlNNQUxMSU5UXCIsIFwiQklUXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5kYjIgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5kYjIgPSBbXCJERUNJTUFMXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5kYjIgPSBbXCJDSEFSICgpIEZPUiBCSVQgREFUQVwiXTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMuZGIyID0gW1wiVkFSQ0hBUlwiXTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMuZGIyID0gW1wiUkVBTFwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5kYjIgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5kYjIgPSBmYWxzZTtcbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSBcInRpbnlcIikge1xuICAgICAgICAgIHJldHVybiBcIkJMT0IoMjU1KVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gXCJtZWRpdW1cIikge1xuICAgICAgICAgIHJldHVybiBcIkJMT0IoMTZNKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gXCJsb25nXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCJCTE9CKDJHKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQkxPQigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIkJMT0JcIjtcbiAgICB9XG4gICAgZXNjYXBlKGJsb2IpIHtcbiAgICAgIHJldHVybiBgQkxPQignJHtibG9iLnRvU3RyaW5nKCkucmVwbGFjZSgvJy9nLCBcIicnXCIpfScpYDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGBCTE9CKCcke3ZhbHVlLnRvU3RyaW5nKCkucmVwbGFjZSgvJy9nLCBcIicnXCIpfScpYDtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBoZXggPSB2YWx1ZS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHJldHVybiB0aGlzLl9oZXhpZnkoaGV4KTtcbiAgICB9XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIHJldHVybiBgeCcke2hleH0nYDtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAoIXRoaXMuX2JpbmFyeSkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IDRlMykge1xuICAgICAgICAgIHJldHVybiBgVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYENMT0IoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIDwgMjU1KSB7XG4gICAgICAgIHJldHVybiBgQ0hBUigke3RoaXMuX2xlbmd0aH0pIEZPUiBCSVQgREFUQWA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IDRlMykge1xuICAgICAgICByZXR1cm4gYFZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KSBGT1IgQklUIERBVEFgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBCTE9CKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBCTE9CLnByb3RvdHlwZS5faGV4aWZ5KHZhbHVlLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl9iaW5hcnkgPyBCdWZmZXIuZnJvbSh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIFNUUklORy5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgbGVuID0gMDtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgXCJ0aW55XCI6XG4gICAgICAgICAgICBsZW4gPSAyNTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgICBsZW4gPSA4MTkyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxvbmdcIjpcbiAgICAgICAgICAgIGxlbiA9IDY1NTM2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX2xlbmd0aCkpIHtcbiAgICAgICAgICB0aGlzLl9sZW5ndGggPSAzMjY3MjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMzI2NzI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoID4gMzI2NzIpIHtcbiAgICAgICAgbGVuID0gYENMT0IoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBgVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHdhcm4oYERiMiBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgZGF0YXR5cGUuICR7bGVufSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIHJldHVybiBsZW47XG4gICAgfVxuICB9XG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCT09MRUFOXCI7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gXCJcdTAwMDFcIiA/IHRydWUgOiB2YWx1ZSA9PT0gXCJcXDBcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gMSA/IHRydWUgOiB2YWx1ZSA9PT0gMCA/IGZhbHNlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQk9PTEVBTi5wYXJzZSA9IEJPT0xFQU4ucHJvdG90eXBlLl9zYW5pdGl6ZTtcbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNIQVIoMzYpIEZPUiBCSVQgREFUQVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBOT1cgZXh0ZW5kcyBCYXNlVHlwZXMuTk9XIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNVUlJFTlQgVElNRVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA8IDApIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPiA2KSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYFRJTUVTVEFNUCR7dGhpcy5fbGVuZ3RoID8gYCgke3RoaXMuX2xlbmd0aH0pYCA6IFwiXCJ9YDtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBtc2VjID0gXCIuXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGVuZ3RoICYmIGkgPCA2OyBpKyspIHtcbiAgICAgICAgICBtc2VjICs9IFwiU1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlLmZvcm1hdChgWVlZWS1NTS1ERCBISDptbTpzcyR7bXNlY31gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3NcIik7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gbmV3IERhdGUobW9tZW50VHoudXRjKHZhbHVlKSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnRUeih2YWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJEYjIgZG9lcyBub3Qgc3VwcG9ydCBSRUFMIHdpdGggb3B0aW9ucy4gUGxhaW4gYFJFQUxgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9kZWNpbWFscykge1xuICAgICAgICB3YXJuKFwiRGIyIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgd2l0aCBkZWNpbWFscy4gUGxhaW4gYEZMT0FUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICB3YXJuKFwiRGIyIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgdW5zaWduZWQuIGBVTlNJR05FRGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiRGIyIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgemVyb2ZpbGwuIGBaRVJPRklMTGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlZBUkNIQVIoMjU1KVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiZGIyIGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFIHdpdGggb3B0aW9ucy4gUGxhaW4gRE9VQkxFIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiRE9VQkxFXCI7XG4gICAgfVxuICB9XG4gIERPVUJMRS5wcm90b3R5cGUua2V5ID0gRE9VQkxFLmtleSA9IFwiRE9VQkxFXCI7XG4gIHJldHVybiB7XG4gICAgQkxPQixcbiAgICBCT09MRUFOLFxuICAgIEVOVU0sXG4gICAgU1RSSU5HLFxuICAgIFVVSUQsXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBOT1csXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBJTlRFR0VSLFxuICAgIERPVUJMRSxcbiAgICBcIkRPVUJMRSBQUkVDSVNJT05cIjogRE9VQkxFLFxuICAgIEJJR0lOVCxcbiAgICBSRUFMLFxuICAgIEZMT0FULFxuICAgIFRFWFRcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").db2);\nconst { Db2QueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js\");\nclass Db2Dialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new Db2QueryInterface(sequelize, this.queryGenerator);\n  }\n}\nDb2Dialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: false,\n  schemas: true,\n  finalTable: true,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: false,\n    update: true\n  },\n  constraints: {\n    restrict: true,\n    default: false\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nDb2Dialect.prototype.defaultVersion = \"1.0.0\";\nDb2Dialect.prototype.Query = Query;\nDb2Dialect.prototype.name = \"db2\";\nDb2Dialect.prototype.TICK_CHAR = '\"';\nDb2Dialect.prototype.TICK_CHAR_LEFT = '\"';\nDb2Dialect.prototype.TICK_CHAR_RIGHT = '\"';\nDb2Dialect.prototype.DataTypes = DataTypes;\nmodule.exports = Db2Dialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx5RUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDbEQsa0JBQWtCLHFHQUErQjtBQUNqRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL2luZGV4LmpzPzdhODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuZGIyO1xuY29uc3QgeyBEYjJRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgRGIyRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IERiMlF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cbkRiMkRpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIkRFRkFVTFRcIjogdHJ1ZSxcbiAgXCJERUZBVUxUIFZBTFVFU1wiOiBmYWxzZSxcbiAgXCJWQUxVRVMgKClcIjogZmFsc2UsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IGZhbHNlLFxuICBcIk9SREVSIE5VTExTXCI6IGZhbHNlLFxuICBsb2NrOiBmYWxzZSxcbiAgdHJhbnNhY3Rpb25zOiB0cnVlLFxuICBtaWdyYXRpb25zOiBmYWxzZSxcbiAgcmV0dXJuVmFsdWVzOiBmYWxzZSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgZmluYWxUYWJsZTogdHJ1ZSxcbiAgYXV0b0luY3JlbWVudDoge1xuICAgIGlkZW50aXR5SW5zZXJ0OiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIHVwZGF0ZTogdHJ1ZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiB0cnVlLFxuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHVzaW5nOiBmYWxzZSxcbiAgICB3aGVyZTogdHJ1ZVxuICB9LFxuICBOVU1FUklDOiB0cnVlLFxuICB0bXBUYWJsZVRyaWdnZXI6IHRydWVcbn0pO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjEuMC4wXCI7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuRGIyRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwiZGIyXCI7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSAnXCInO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gJ1wiJztcbkRiMkRpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbm1vZHVsZS5leHBvcnRzID0gRGIyRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query-generator.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP_LIKE\",\n      [Op.notRegexp]: \"NOT REGEXP_LIKE\"\n    });\n    this.autoGenValue = 1;\n  }\n  createSchema(schema) {\n    return [\n      \"CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;\n    const sql = { query };\n    sql.bind = [\n      { ParamType: \"INOUT\", Data: \"ERRORSCHEMA\" },\n      { ParamType: \"INOUT\", Data: \"ERRORTABLE\" }\n    ];\n    return sql;\n  }\n  showSchemasQuery() {\n    return `SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;\n  }\n  versionQuery() {\n    return \"select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const query = \"CREATE TABLE <%= table %> (<%= attributes %>)\", primaryKeys = [], foreignKeys = {}, attrStr = [], commentTemplate = \" -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;\";\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, \"\").trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            dataType = commentMatch[1];\n          }\n        }\n        if (_.includes(dataType, \"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (_.includes(dataType, \"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, \"\")}`);\n          }\n        } else if (_.includes(dataType, \"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, \"NOT NULL\")) {\n                dataType += \" NOT NULL\";\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(\", \")\n    }, pkString = primaryKeys.map((pk) => {\n      return this.quoteIdentifier(pk);\n    }).join(\", \");\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",',\n      'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",',\n      'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",',\n      'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"',\n      \"FROM\",\n      \"SYSIBM.SYSCOLUMNS\",\n      \"WHERE TBNAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += \" AND TBCREATOR = USER\";\n    }\n    return `${sql};`;\n  }\n  renameTableQuery(before, after) {\n    const query = \"RENAME TABLE <%= before %> TO <%= after %>;\";\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n  showTablesQuery() {\n    return `SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || this.sequelize.config.username.toUpperCase();\n    return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const query = \"DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const query = \"ALTER TABLE <%= table %> ADD <%= attribute %>;\", attribute = _.template(\"<%= key %> <%= definition %>\", this._templateSettings)({\n      key: this.quoteIdentifier(key),\n      definition: this.attributeToSQL(dataType, {\n        context: \"addColumn\"\n      })\n    });\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const query = \"ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;\";\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> <%= query %>;\";\n    const attrString = [], constraintString = [];\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template(\"<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>\", this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, \"\")\n          }));\n        } else if (_.startsWith(definition, \"DROP \")) {\n          attrString.push(_.template(\"<%= attrName %> <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template(\"<%= attrName %> SET <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n    let finalQuery = \"\";\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(\" ALTER COLUMN \")}`;\n      finalQuery += constraintString.length ? \" \" : \"\";\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(\" ADD CONSTRAINT \")}`;\n    }\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;\", newName = Object.keys(attributes)[0];\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === \"CASCADE\") {\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = \"INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;\";\n    if (options.returning) {\n      query = \"SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);\";\n    }\n    const emptyQuery = \"INSERT INTO <%= table %>\", tuples = [], allAttributes = [], allQueries = [];\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n    if (options.returning) {\n      outputFragment = \"\";\n    }\n    _.forEach(attrValueHashes, (attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(\",\")}`);\n    }\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, (attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key]), void 0, { context: \"INSERT\" }).join(\",\")})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\"),\n      tuples,\n      output: outputFragment\n    };\n    const generatedQuery = _.template(allQueries.join(\";\"), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if (!options.limit) {\n      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;\n      return sql;\n    }\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(\",\")}`;\n    query = `SELECT * FROM FINAL TABLE (${query});`;\n    return { query, bind };\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    }).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(\", \");\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const query = \"DELETE FROM <%= table %><%= where %><%= limit %>\";\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = \"\";\n    if (options.offset > 0) {\n      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n    return _.template(query, this._templateSettings)(replacements);\n  }\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = void 0;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n    return `${sql} ORDER BY CONSTNAME;`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = \"DROP INDEX <%= indexName %>\";\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n    return _.template(sql, this._templateSettings)(values);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let template;\n    let changeNull = 1;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n    } else {\n      template = attribute.type.toString();\n    }\n    if (options && options.context === \"changeColumn\" && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {\n      template += \" NOT NULL\";\n      changeNull = 0;\n    }\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName}_${attrName}_fidx`;\n        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != \"CASCADE\") {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (options && options.context === \"changeColumn\" && changeNull === 1 && attribute.allowNull !== void 0) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push(\"DROP NOT NULL\");\n      } else {\n        template.push(\"NOT NULL\");\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n      if (key && !attribute.field && typeof attribute === \"object\")\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQuerySQL(condition) {\n    return `SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT TABNAME AS \"tableName\",',\n      'COLNAME AS \"columnName\",',\n      'CONSTNAME AS \"constraintName\"',\n      \"FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'\",\n      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,\n      `AND TABNAME = ${tableName};`\n    ].join(\" \");\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template(\"ALTER TABLE <%= table %> DROP <%= key %>\", this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = \"ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;\";\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n  setAutocommitQuery() {\n    return \"\";\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = \"\";\n    if (offset > 0) {\n      fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n    }\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === void 0 ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === void 0) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now(\"db2\");\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${identifier}'`;\n  }\n  return \"\";\n}\nmodule.exports = Db2QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLDRHQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDcEM7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEseUNBQXlDO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw0R0FBNEc7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzlGO0FBQ0EsWUFBWTtBQUNaLDRCQUE0Qiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDOUY7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsU0FBUztBQUNqRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwrQ0FBK0MsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2hLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCLElBQUksa0JBQWtCO0FBQ2hHO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRCxFQUFFLFdBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QixnQkFBZ0IsNEJBQTRCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxNQUFNLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHlCQUF5QixZQUFZLFNBQVMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBc0UsbUJBQW1CLFlBQVk7QUFDN0gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsRUFBRTtBQUNySixRQUFRO0FBQ1IsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsYUFBYTtBQUNoSztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRCxxQ0FBcUMsNEJBQTRCLEVBQUUsc0NBQXNDLGFBQWEsNEJBQTRCLGlCQUFpQixpQkFBaUI7QUFDcEwsMENBQTBDLE1BQU0sRUFBRTtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsR0FBRyxLQUFLLElBQUksaUJBQWlCLEdBQUcsSUFBSTtBQUN2RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLE1BQU07QUFDbkQsS0FBSztBQUNMLDZGQUE2RixzQkFBc0I7QUFDbkgsOEJBQThCLGlCQUFpQixXQUFXLG9CQUFvQjtBQUM5RSw4QkFBOEIsaUJBQWlCLEtBQUssa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNqSyxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsYUFBYSxLQUFLLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxSkFBcUosVUFBVTtBQUMvSjtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0EsY0FBYyxLQUFLLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDLEtBQUs7QUFDekU7QUFDQSxPQUFPLGFBQWE7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0U7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLEdBQUcsU0FBUztBQUN4RCxvQ0FBb0MsUUFBUSxlQUFlLFNBQVM7QUFDcEU7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrZkFBa2YsV0FBVztBQUM3ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RCx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUMsU0FBUztBQUM5QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktZ2VuZXJhdG9yLmpzPzlhMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKFwiY3J5cHRvXCIpLnJhbmRvbUJ5dGVzO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgdGhyb3dNZXRob2RVbmRlZmluZWQgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcihgVGhlIG1ldGhvZCBcIiR7bWV0aG9kTmFtZX1cIiBpcyBub3QgZGVmaW5lZCEgUGxlYXNlIGFkZCBpdCB0byB5b3VyIHNxbCBkaWFsZWN0LmApO1xufTtcbmNsYXNzIERiMlF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLk9wZXJhdG9yTWFwID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5PcGVyYXRvck1hcCksIHtcbiAgICAgIFtPcC5yZWdleHBdOiBcIlJFR0VYUF9MSUtFXCIsXG4gICAgICBbT3Aubm90UmVnZXhwXTogXCJOT1QgUkVHRVhQX0xJS0VcIlxuICAgIH0pO1xuICAgIHRoaXMuYXV0b0dlblZhbHVlID0gMTtcbiAgfVxuICBjcmVhdGVTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiQ1JFQVRFIFNDSEVNQVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIFwiO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYENBTEwgU1lTUFJPQy5BRE1JTl9EUk9QX1NDSEVNQSgke3dyYXBTaW5nbGVRdW90ZShzY2hlbWEudHJpbSgpKX0sIE5VTEwsID8gLCA/KWA7XG4gICAgY29uc3Qgc3FsID0geyBxdWVyeSB9O1xuICAgIHNxbC5iaW5kID0gW1xuICAgICAgeyBQYXJhbVR5cGU6IFwiSU5PVVRcIiwgRGF0YTogXCJFUlJPUlNDSEVNQVwiIH0sXG4gICAgICB7IFBhcmFtVHlwZTogXCJJTk9VVFwiLCBEYXRhOiBcIkVSUk9SVEFCTEVcIiB9XG4gICAgXTtcbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgU0NIRU1BTkFNRSBBUyBcInNjaGVtYV9uYW1lXCIgRlJPTSBTWVNDQVQuU0NIRU1BVEEgV0hFUkUgKFNDSEVNQU5BTUUgTk9UIExJS0UgJ1NZUyUnKSBBTkQgU0NIRU1BTkFNRSBOT1QgSU4gKCdOVUxMSUQnLCAnU1FMSicsICdFUlJPUlNDSEVNQScpYDtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwic2VsZWN0IHNlcnZpY2VfbGV2ZWwgYXMgVkVSU0lPTiBmcm9tIFRBQkxFIChzeXNwcm9jLmVudl9nZXRfaW5zdF9pbmZvKCkpIGFzIEFcIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJDUkVBVEUgVEFCTEUgPCU9IHRhYmxlICU+ICg8JT0gYXR0cmlidXRlcyAlPilcIiwgcHJpbWFyeUtleXMgPSBbXSwgZm9yZWlnbktleXMgPSB7fSwgYXR0clN0ciA9IFtdLCBjb21tZW50VGVtcGxhdGUgPSBcIiAtLSA8JT0gY29tbWVudCAlPiwgVGFibGVOYW1lID0gPCU9IHRhYmxlICU+LCBDb2x1bW5OYW1lID0gPCU9IGNvbHVtbiAlPjtcIjtcbiAgICBsZXQgY29tbWVudFN0ciA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbGV0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJDT01NRU5UIFwiKSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRNYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoQ09NTUVOVC4qKSQvKTtcbiAgICAgICAgICBpZiAoY29tbWVudE1hdGNoICYmIGNvbW1lbnRNYXRjaC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50VGV4dCA9IGNvbW1lbnRNYXRjaFsyXS5yZXBsYWNlKC9DT01NRU5ULywgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgY29tbWVudFN0ciArPSBfLnRlbXBsYXRlKGNvbW1lbnRUZW1wbGF0ZSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgICAgICAgICB0YWJsZTogdGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVOYW1lKSxcbiAgICAgICAgICAgICAgY29tbWVudDogdGhpcy5lc2NhcGUoY29tbWVudFRleHQpLFxuICAgICAgICAgICAgICBjb2x1bW46IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhdGFUeXBlID0gY29tbWVudE1hdGNoWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pbmNsdWRlcyhkYXRhVHlwZSwgXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgICAgaWYgKF8uaW5jbHVkZXMoZGF0YVR5cGUsIFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZSgvUFJJTUFSWSBLRVkvLCBcIlwiKX1gKTtcbiAgICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKC9QUklNQVJZIEtFWS8sIFwiXCIpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKGRhdGFUeXBlLCBcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdWtleSBpbiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5c1t1a2V5XS5maWVsZHMuaW5jbHVkZXMoYXR0cikgJiYgIV8uaW5jbHVkZXMoZGF0YVR5cGUsIFwiTk9UIE5VTExcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyaWJ1dGVzOiBhdHRyU3RyLmpvaW4oXCIsIFwiKVxuICAgIH0sIHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKTtcbiAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKCFfLmlzU3RyaW5nKGluZGV4TmFtZSkpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oXCJfXCIpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsIENPTlNUUkFJTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCwgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgJHtfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh2YWx1ZXMpLnRyaW0oKX07JHtjb21tZW50U3RyfWA7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hKSB7XG4gICAgbGV0IHNxbCA9IFtcbiAgICAgICdTRUxFQ1QgTkFNRSBBUyBcIk5hbWVcIiwgVEJOQU1FIEFTIFwiVGFibGVcIiwgVEJDUkVBVE9SIEFTIFwiU2NoZW1hXCIsJyxcbiAgICAgICdUUklNKENPTFRZUEUpIEFTIFwiVHlwZVwiLCBMRU5HVEggQVMgXCJMZW5ndGhcIiwgU0NBTEUgQVMgXCJTY2FsZVwiLCcsXG4gICAgICAnTlVMTFMgQVMgXCJJc051bGxcIiwgREVGQVVMVCBBUyBcIkRlZmF1bHRcIiwgQ09MTk8gQVMgXCJDb2xub1wiLCcsXG4gICAgICAnSURFTlRJVFkgQVMgXCJJc0lkZW50aXR5XCIsIEtFWVNFUSBBUyBcIktleVNlcVwiLCBSRU1BUktTIEFTIFwiQ29tbWVudFwiJyxcbiAgICAgIFwiRlJPTVwiLFxuICAgICAgXCJTWVNJQk0uU1lTQ09MVU1OU1wiLFxuICAgICAgXCJXSEVSRSBUQk5BTUUgPVwiLFxuICAgICAgd3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSlcbiAgICBdLmpvaW4oXCIgXCIpO1xuICAgIGlmIChzY2hlbWEpIHtcbiAgICAgIHNxbCArPSBgIEFORCBUQkNSRUFUT1IgPSR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYSl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3FsICs9IFwiIEFORCBUQkNSRUFUT1IgPSBVU0VSXCI7XG4gICAgfVxuICAgIHJldHVybiBgJHtzcWx9O2A7XG4gIH1cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIlJFTkFNRSBUQUJMRSA8JT0gYmVmb3JlICU+IFRPIDwlPSBhZnRlciAlPjtcIjtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgYmVmb3JlOiB0aGlzLnF1b3RlVGFibGUoYmVmb3JlKSxcbiAgICAgIGFmdGVyOiB0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpXG4gICAgfSk7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIFRBQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiwgVFJJTShUQUJTQ0hFTUEpIEFTIFwidGFibGVTY2hlbWFcIiBGUk9NIFNZU0NBVC5UQUJMRVMgV0hFUkUgVEFCU0NIRU1BID0gVVNFUiBBTkQgVFlQRSA9ICdUJyBPUkRFUiBCWSBUQUJTQ0hFTUEsIFRBQk5BTUVgO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSB8fCB0aGlzLnNlcXVlbGl6ZS5jb25maWcudXNlcm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gYFNFTEVDVCBuYW1lIEZST00gc3lzaWJtLnN5c3RhYmxlcyBXSEVSRSBOQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX0gQU5EIENSRUFUT1IgPSAke3dyYXBTaW5nbGVRdW90ZShzY2hlbWFOYW1lKX1gO1xuICB9XG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJEUk9QIFRBQkxFIDwlPSB0YWJsZSAlPlwiO1xuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKVxuICAgIH07XG4gICAgcmV0dXJuIGAke18udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHZhbHVlcykudHJpbSgpfTtgO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgZGF0YVR5cGUuZmllbGQgPSBrZXk7XG4gICAgY29uc3QgcXVlcnkgPSBcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZSAlPiBBREQgPCU9IGF0dHJpYnV0ZSAlPjtcIiwgYXR0cmlidXRlID0gXy50ZW1wbGF0ZShcIjwlPSBrZXkgJT4gPCU9IGRlZmluaXRpb24gJT5cIiwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAga2V5OiB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgZGVmaW5pdGlvbjogdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwge1xuICAgICAgICBjb250ZXh0OiBcImFkZENvbHVtblwiXG4gICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgIGF0dHJpYnV0ZVxuICAgIH0pO1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJBTFRFUiBUQUJMRSA8JT0gdGFibGVOYW1lICU+IERST1AgQ09MVU1OIDwlPSBhdHRyaWJ1dGVOYW1lICU+O1wiO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZU5hbWU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgYXR0cmlidXRlTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSlcbiAgICB9KTtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlTmFtZSAlPiA8JT0gcXVlcnkgJT47XCI7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdLCBjb25zdHJhaW50U3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBsZXQgZGVmcyA9IFthdHRyVmFsdWVdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0clZhbHVlKSkge1xuICAgICAgICBkZWZzID0gYXR0clZhbHVlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBkZWZzW2ldO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5tYXRjaCgvUkVGRVJFTkNFUy8pKSB7XG4gICAgICAgICAgY29uc3RyYWludFN0cmluZy5wdXNoKF8udGVtcGxhdGUoXCI8JT0gZmtOYW1lICU+IEZPUkVJR04gS0VZICg8JT0gYXR0ck5hbWUgJT4pIDwlPSBkZWZpbml0aW9uICU+XCIsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgICAgICAgIGZrTmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYCR7YXR0cmlidXRlTmFtZX1fZm9yZWlnbl9pZHhgKSxcbiAgICAgICAgICAgIGF0dHJOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLnN0YXJ0c1dpdGgoZGVmaW5pdGlvbiwgXCJEUk9QIFwiKSkge1xuICAgICAgICAgIGF0dHJTdHJpbmcucHVzaChfLnRlbXBsYXRlKFwiPCU9IGF0dHJOYW1lICU+IDwlPSBkZWZpbml0aW9uICU+XCIsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgICAgICAgIGF0dHJOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0clN0cmluZy5wdXNoKF8udGVtcGxhdGUoXCI8JT0gYXR0ck5hbWUgJT4gU0VUIDwlPSBkZWZpbml0aW9uICU+XCIsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgICAgICAgIGF0dHJOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpbmFsUXVlcnkgPSBcIlwiO1xuICAgIGlmIChhdHRyU3RyaW5nLmxlbmd0aCkge1xuICAgICAgZmluYWxRdWVyeSArPSBgQUxURVIgQ09MVU1OICR7YXR0clN0cmluZy5qb2luKFwiIEFMVEVSIENPTFVNTiBcIil9YDtcbiAgICAgIGZpbmFsUXVlcnkgKz0gY29uc3RyYWludFN0cmluZy5sZW5ndGggPyBcIiBcIiA6IFwiXCI7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50U3RyaW5nLmxlbmd0aCkge1xuICAgICAgZmluYWxRdWVyeSArPSBgQUREIENPTlNUUkFJTlQgJHtjb25zdHJhaW50U3RyaW5nLmpvaW4oXCIgQUREIENPTlNUUkFJTlQgXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZU5hbWU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgcXVlcnk6IGZpbmFsUXVlcnlcbiAgICB9KTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlTmFtZSAlPiBSRU5BTUUgQ09MVU1OIDwlPSBiZWZvcmUgJT4gVE8gPCU9IGFmdGVyICU+O1wiLCBuZXdOYW1lID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylbMF07XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlTmFtZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBiZWZvcmU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJCZWZvcmUpLFxuICAgICAgYWZ0ZXI6IHRoaXMucXVvdGVJZGVudGlmaWVyKG5ld05hbWUpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLm9uVXBkYXRlICYmIG9wdGlvbnMub25VcGRhdGUudG9VcHBlckNhc2UoKSA9PT0gXCJDQVNDQURFXCIpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHRoaXMuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGFibGVOYW1lfSBBREQgJHtjb25zdHJhaW50U25pcHBldH07YDtcbiAgfVxuICBidWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBsZXQgcXVlcnkgPSBcIklOU0VSVCBJTlRPIDwlPSB0YWJsZSAlPiAoPCU9IGF0dHJpYnV0ZXMgJT4pPCU9IG91dHB1dCAlPiBWQUxVRVMgPCU9IHR1cGxlcyAlPjtcIjtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIHF1ZXJ5ID0gXCJTRUxFQ1QgKiBGUk9NIEZJTkFMIFRBQkxFKCBJTlNFUlQgSU5UTyA8JT0gdGFibGUgJT4gKDwlPSBhdHRyaWJ1dGVzICU+KTwlPSBvdXRwdXQgJT4gVkFMVUVTIDwlPSB0dXBsZXMgJT4pO1wiO1xuICAgIH1cbiAgICBjb25zdCBlbXB0eVF1ZXJ5ID0gXCJJTlNFUlQgSU5UTyA8JT0gdGFibGUgJT5cIiwgdHVwbGVzID0gW10sIGFsbEF0dHJpYnV0ZXMgPSBbXSwgYWxsUXVlcmllcyA9IFtdO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudDtcbiAgICBjb25zdCB2YWx1ZXNGb3JFbXB0eVF1ZXJ5ID0gW107XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgfVxuICAgIF8uZm9yRWFjaChhdHRyVmFsdWVIYXNoZXMsIChhdHRyVmFsdWVIYXNoKSA9PiB7XG4gICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhhdHRyVmFsdWVIYXNoKTtcbiAgICAgIGNvbnN0IGZpcnN0QXR0ciA9IGF0dHJpYnV0ZXNbZmllbGRzWzBdXTtcbiAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxICYmIGZpcnN0QXR0ciAmJiBmaXJzdEF0dHIuYXV0b0luY3JlbWVudCAmJiBhdHRyVmFsdWVIYXNoW2ZpZWxkc1swXV0gPT09IG51bGwpIHtcbiAgICAgICAgdmFsdWVzRm9yRW1wdHlRdWVyeS5wdXNoKGAoJHt0aGlzLmF1dG9HZW5WYWx1ZSsrfSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXy5mb3JPd24oYXR0clZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGFsbEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBhdHRyaWJ1dGVzW2tleV0gJiYgYXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgYWxsQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh2YWx1ZXNGb3JFbXB0eVF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGFsbFF1ZXJpZXMucHVzaChgJHtlbXB0eVF1ZXJ5fSBWQUxVRVMgJHt2YWx1ZXNGb3JFbXB0eVF1ZXJ5LmpvaW4oXCIsXCIpfWApO1xuICAgIH1cbiAgICBpZiAoYWxsQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBfLmZvckVhY2goYXR0clZhbHVlSGFzaGVzLCAoYXR0clZhbHVlSGFzaCkgPT4ge1xuICAgICAgICB0dXBsZXMucHVzaChgKCR7YWxsQXR0cmlidXRlcy5tYXAoKGtleSkgPT4gdGhpcy5lc2NhcGUoYXR0clZhbHVlSGFzaFtrZXldKSwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSkuam9pbihcIixcIil9KWApO1xuICAgICAgfSk7XG4gICAgICBhbGxRdWVyaWVzLnB1c2gocXVlcnkpO1xuICAgIH1cbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyaWJ1dGVzOiBhbGxBdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsXCIpLFxuICAgICAgdHVwbGVzLFxuICAgICAgb3V0cHV0OiBvdXRwdXRGcmFnbWVudFxuICAgIH07XG4gICAgY29uc3QgZ2VuZXJhdGVkUXVlcnkgPSBfLnRlbXBsYXRlKGFsbFF1ZXJpZXMuam9pbihcIjtcIiksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHJlcGxhY2VtZW50cyk7XG4gICAgcmV0dXJuIGdlbmVyYXRlZFF1ZXJ5O1xuICB9XG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBzdXBlci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLmxpbWl0KSB7XG4gICAgICBzcWwucXVlcnkgPSBgU0VMRUNUICogRlJPTSBGSU5BTCBUQUJMRSAoJHtzcWwucXVlcnl9KTtgO1xuICAgICAgcmV0dXJuIHNxbDtcbiAgICB9XG4gICAgYXR0clZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChhdHRyVmFsdWVIYXNoLCBvcHRpb25zLm9taXROdWxsLCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSB8fCB0aGlzLmJpbmRQYXJhbShiaW5kKTtcbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJWYWx1ZUhhc2gpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0clZhbHVlSGFzaFtrZXldO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0pfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9LCBiaW5kUGFyYW0pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcXVlcnk7XG4gICAgY29uc3Qgd2hlcmVPcHRpb25zID0gXy5kZWZhdWx0cyh7IGJpbmRQYXJhbSB9LCBvcHRpb25zKTtcbiAgICBxdWVyeSA9IGBVUERBVEUgKFNFTEVDVCAqIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9IEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZKSBTRVQgJHt2YWx1ZXMuam9pbihcIixcIil9YDtcbiAgICBxdWVyeSA9IGBTRUxFQ1QgKiBGUk9NIEZJTkFMIFRBQkxFICgke3F1ZXJ5fSk7YDtcbiAgICByZXR1cm4geyBxdWVyeSwgYmluZCB9O1xuICB9XG4gIHVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCkge1xuICAgIGNvbnN0IHRhcmdldFRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV90YXJnZXRgKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fc291cmNlYCk7XG4gICAgY29uc3QgcHJpbWFyeUtleXNBdHRycyA9IFtdO1xuICAgIGNvbnN0IGlkZW50aXR5QXR0cnMgPSBbXTtcbiAgICBjb25zdCB1bmlxdWVBdHRycyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlTmFtZVF1b3RlZCA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0ucHJpbWFyeUtleSkge1xuICAgICAgICBwcmltYXJ5S2V5c0F0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnVuaXF1ZSkge1xuICAgICAgICB1bmlxdWVBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGlkZW50aXR5QXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBtb2RlbC5faW5kZXhlcykge1xuICAgICAgaWYgKGluZGV4LnVuaXF1ZSAmJiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIgPyBmaWVsZCA6IGZpZWxkLm5hbWUgfHwgZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIGlmICh1bmlxdWVBdHRycy5pbmRleE9mKGZpZWxkTmFtZSkgPT09IC0xICYmIG1vZGVsLnJhd0F0dHJpYnV0ZXNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgdW5pcXVlQXR0cnMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1cGRhdGVLZXlzID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBjb25zdCBpbnNlcnRLZXlzUXVvdGVkID0gaW5zZXJ0S2V5cy5tYXAoKGtleSkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IGluc2VydFZhbHVlc0VzY2FwZWQgPSBpbnNlcnRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLmVzY2FwZShpbnNlcnRWYWx1ZXNba2V5XSkpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBzb3VyY2VUYWJsZVF1ZXJ5ID0gYFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7XG4gICAgbGV0IGpvaW5Db25kaXRpb247XG4gICAgY29uc3QgY2xhdXNlcyA9IHdoZXJlW09wLm9yXS5maWx0ZXIoKGNsYXVzZSkgPT4ge1xuICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZSkge1xuICAgICAgICBpZiAoIWNsYXVzZVtrZXldKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldEpvaW5TbmlwcGV0ID0gKGFycmF5KSA9PiB7XG4gICAgICByZXR1cm4gYXJyYXkubWFwKChrZXkpID0+IHtcbiAgICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7c291cmNlVGFibGVBbGlhc30uJHtrZXl9YDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGNsYXVzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmltYXJ5IEtleSBvciBVbmlxdWUga2V5IHNob3VsZCBiZSBwYXNzZWQgdG8gdXBzZXJ0IHF1ZXJ5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2VzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjbGF1c2VzW2tleV0pO1xuICAgICAgICBpZiAocHJpbWFyeUtleXNBdHRycy5pbmRleE9mKGtleXNbMF0pICE9PSAtMSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldChwcmltYXJ5S2V5c0F0dHJzKS5qb2luKFwiIEFORCBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgham9pbkNvbmRpdGlvbikge1xuICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQodW5pcXVlQXR0cnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRVcGRhdGVDbGF1c2VzID0gdXBkYXRlS2V5cy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgaWYgKGlkZW50aXR5QXR0cnMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KS5tYXAoKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmVzY2FwZSh1cGRhdGVWYWx1ZXNba2V5XSk7XG4gICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7dmFsdWV9YDtcbiAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgdXBkYXRlU25pcHBldCA9IGZpbHRlcmVkVXBkYXRlQ2xhdXNlcy5sZW5ndGggPiAwID8gYFdIRU4gTUFUQ0hFRCBUSEVOIFVQREFURSBTRVQgJHtmaWx0ZXJlZFVwZGF0ZUNsYXVzZXN9YCA6IFwiXCI7XG4gICAgY29uc3QgaW5zZXJ0U25pcHBldCA9IGAoJHtpbnNlcnRLZXlzUXVvdGVkfSkgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDtcbiAgICBsZXQgcXVlcnkgPSBgTUVSR0UgSU5UTyAke3RhYmxlTmFtZVF1b3RlZH0gQVMgJHt0YXJnZXRUYWJsZUFsaWFzfSBVU0lORyAoJHtzb3VyY2VUYWJsZVF1ZXJ5fSkgQVMgJHtzb3VyY2VUYWJsZUFsaWFzfSgke2luc2VydEtleXNRdW90ZWR9KSBPTiAke2pvaW5Db25kaXRpb259YDtcbiAgICBxdWVyeSArPSBgICR7dXBkYXRlU25pcHBldH0gV0hFTiBOT1QgTUFUQ0hFRCBUSEVOIElOU0VSVCAke2luc2VydFNuaXBwZXR9O2A7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IElNTUVESUFURWA7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVlcnkgPSBcIkRFTEVURSBGUk9NIDwlPSB0YWJsZSAlPjwlPSB3aGVyZSAlPjwlPSBsaW1pdCAlPlwiO1xuICAgIHdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBsZXQgbGltaXQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLm9mZnNldCA+IDApIHtcbiAgICAgIGxpbWl0ID0gYCBPRkZTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCl9IFJPV1NgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgbGltaXQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgfVxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgIGxpbWl0LFxuICAgICAgdGFibGUsXG4gICAgICB3aGVyZVxuICAgIH07XG4gICAgaWYgKHJlcGxhY2VtZW50cy53aGVyZSkge1xuICAgICAgcmVwbGFjZW1lbnRzLndoZXJlID0gYCBXSEVSRSAke3JlcGxhY2VtZW50cy53aGVyZX1gO1xuICAgIH1cbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykocmVwbGFjZW1lbnRzKTtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGxldCBzcWwgPSAnU0VMRUNUIE5BTUUgQVMgXCJuYW1lXCIsIFRCTkFNRSBBUyBcInRhYmxlTmFtZVwiLCBVTklRVUVSVUxFIEFTIFwia2V5VHlwZVwiLCBDT0xOQU1FUywgSU5ERVhUWVBFIEFTIFwidHlwZVwiIEZST00gU1lTSUJNLlNZU0lOREVYRVMgV0hFUkUgVEJOQU1FID0gPCU9IHRhYmxlTmFtZSAlPic7XG4gICAgbGV0IHNjaGVtYSA9IHZvaWQgMDtcbiAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgc3FsID0gYCR7c3FsfSBBTkQgVEJDUkVBVE9SID0gPCU9IHNjaGVtYU5hbWUgJT5gO1xuICAgIH1cbiAgICBzcWwgPSBgJHtzcWx9IE9SREVSIEJZIE5BTUU7YDtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShzcWwsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlTmFtZTogd3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSksXG4gICAgICBzY2hlbWFOYW1lOiB3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKVxuICAgIH0pO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBsZXQgc3FsID0gYFNFTEVDVCBDT05TVE5BTUUgQVMgXCJjb25zdHJhaW50TmFtZVwiLCBUUklNKFRBQlNDSEVNQSkgQVMgXCJzY2hlbWFOYW1lXCIsIFRBQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiBGUk9NIFNZU0NBVC5UQUJDT05TVCBXSEVSRSBUQUJOQU1FID0gJyR7dGFibGVOYW1lfSdgO1xuICAgIGlmIChjb25zdHJhaW50TmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIENPTlNUTkFNRSBMSUtFICclJHtjb25zdHJhaW50TmFtZX0lJ2A7XG4gICAgfVxuICAgIHJldHVybiBgJHtzcWx9IE9SREVSIEJZIENPTlNUTkFNRTtgO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBcIkRST1AgSU5ERVggPCU9IGluZGV4TmFtZSAlPlwiO1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgdGFibGVOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKSxcbiAgICAgIGluZGV4TmFtZTogdGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSlcbiAgICB9O1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHNxbCwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykodmFsdWVzKTtcbiAgfVxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHRlbXBsYXRlO1xuICAgIGxldCBjaGFuZ2VOdWxsID0gMTtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcylcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwoKTtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ0hFQ0sgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKX0gSU4oJHthdHRyaWJ1dGUudmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKX0pKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSBcImNoYW5nZUNvbHVtblwiICYmIGF0dHJpYnV0ZS50eXBlKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGBEQVRBIFRZUEUgJHt0ZW1wbGF0ZX1gO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UgfHwgYXR0cmlidXRlLnByaW1hcnlLZXkgPT09IHRydWUgfHwgYXR0cmlidXRlLnVuaXF1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICAgIGNoYW5nZU51bGwgPSAwO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIGxldCBpbml0aWFsVmFsdWUgPSAxO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5pbml0aWFsQXV0b0luY3JlbWVudCkge1xuICAgICAgICBpbml0aWFsVmFsdWUgPSBhdHRyaWJ1dGUuaW5pdGlhbEF1dG9JbmNyZW1lbnQ7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSArPSBgIEdFTkVSQVRFRCBCWSBERUZBVUxUIEFTIElERU5USVRZKFNUQVJUIFdJVEggJHtpbml0aWFsVmFsdWV9LCBJTkNSRU1FTlQgQlkgMSlgO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgIT09IFwiVEVYVFwiICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgVU5JUVVFXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICB9XG4gICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzKSAmJiBhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSBcImFkZENvbHVtblwiICYmIG9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIGNvbnN0IGZrTmFtZSA9IGAke29wdGlvbnMudGFibGVOYW1lfV8ke2F0dHJOYW1lfV9maWR4YDtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCwgQ09OU1RSQUlOVCAke2ZrTmFtZX0gRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KWA7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSAmJiBhdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKSAhPSBcIkNBU0NBREVcIikge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gXCJjaGFuZ2VDb2x1bW5cIiAmJiBjaGFuZ2VOdWxsID09PSAxICYmIGF0dHJpYnV0ZS5hbGxvd051bGwgIT09IHZvaWQgMCkge1xuICAgICAgdGVtcGxhdGUgPSBbdGVtcGxhdGVdO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwpIHtcbiAgICAgICAgdGVtcGxhdGUucHVzaChcIkRST1AgTk9UIE5VTExcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZS5wdXNoKFwiTk9UIE5VTExcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCAmJiB0eXBlb2YgYXR0cmlidXRlLmNvbW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke2F0dHJpYnV0ZS5jb21tZW50fWA7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9LCBleGlzdGluZ0NvbnN0cmFpbnRzID0gW107XG4gICAgbGV0IGtleSwgYXR0cmlidXRlO1xuICAgIGZvciAoa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoZXhpc3RpbmdDb25zdHJhaW50cy5pbmRleE9mKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpICE9PSAtMSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiXCI7XG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGUudW5pcXVlICYmIGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSBcIlwiO1xuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmdDb25zdHJhaW50cy5wdXNoKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5ICYmICFhdHRyaWJ1dGUuZmllbGQgJiYgdHlwZW9mIGF0dHJpYnV0ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgYXR0cmlidXRlLmZpZWxkID0ga2V5O1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVUcmlnZ2VyXCIpO1xuICB9XG4gIGRyb3BUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcFRyaWdnZXJcIik7XG4gIH1cbiAgcmVuYW1lVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZVRyaWdnZXJcIik7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVGdW5jdGlvblwiKTtcbiAgfVxuICBkcm9wRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wRnVuY3Rpb25cIik7XG4gIH1cbiAgcmVuYW1lRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVGdW5jdGlvblwiKTtcbiAgfVxuICBfZ2V0Rm9yZWlnbktleXNRdWVyeVNRTChjb25kaXRpb24pIHtcbiAgICByZXR1cm4gYFNFTEVDVCBSLkNPTlNUTkFNRSBBUyBcImNvbnN0cmFpbnROYW1lXCIsIFRSSU0oUi5UQUJTQ0hFTUEpIEFTIFwiY29uc3RyYWludFNjaGVtYVwiLCBSLlRBQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiwgVFJJTShSLlRBQlNDSEVNQSkgQVMgXCJ0YWJsZVNjaGVtYVwiLCBMSVNUQUdHKEMuQ09MTkFNRSwnLCAnKSBXSVRISU4gR1JPVVAgKE9SREVSIEJZIEMuQ09MTkFNRSkgQVMgXCJjb2x1bW5OYW1lXCIsIFRSSU0oUi5SRUZUQUJTQ0hFTUEpIEFTIFwicmVmZXJlbmNlZFRhYmxlU2NoZW1hXCIsIFIuUkVGVEFCTkFNRSBBUyBcInJlZmVyZW5jZWRUYWJsZU5hbWVcIiwgVFJJTShSLlBLX0NPTE5BTUVTKSBBUyBcInJlZmVyZW5jZWRDb2x1bW5OYW1lXCIgRlJPTSBTWVNDQVQuUkVGRVJFTkNFUyBSLCBTWVNDQVQuS0VZQ09MVVNFIEMgV0hFUkUgUi5DT05TVE5BTUUgPSBDLkNPTlNUTkFNRSBBTkQgUi5UQUJTQ0hFTUEgPSBDLlRBQlNDSEVNQSBBTkQgUi5UQUJOQU1FID0gQy5UQUJOQU1FJHtjb25kaXRpb259IEdST1VQIEJZIFIuUkVGVEFCU0NIRU1BLCBSLlJFRlRBQk5BTUUsIFIuVEFCU0NIRU1BLCBSLlRBQk5BTUUsIFIuQ09OU1ROQU1FLCBSLlBLX0NPTE5BTUVTYDtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBzY2hlbWFOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgfHwgc2NoZW1hTmFtZTtcbiAgICBsZXQgc3FsID0gXCJcIjtcbiAgICBpZiAodGFibGVOYW1lKSB7XG4gICAgICBzcWwgPSBgIEFORCBSLlRBQk5BTUUgPSAke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWA7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgUi5UQUJTQ0hFTUEgPSAke3dyYXBTaW5nbGVRdW90ZShzY2hlbWFOYW1lKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVNRTChzcWwpO1xuICB9XG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hO1xuICAgIGxldCBzcWwgPSBcIlwiO1xuICAgIGlmICh0YWJsZU5hbWUpIHtcbiAgICAgIHNxbCA9IGAgQU5EIFIuVEFCTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YDtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBSLlRBQlNDSEVNQSA9ICR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYU5hbWUpfWA7XG4gICAgfVxuICAgIGlmIChjb2x1bW5OYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgQy5DT0xOQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUoY29sdW1uTmFtZSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlTUUwoc3FsKTtcbiAgfVxuICBnZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICdTRUxFQ1QgVEFCTkFNRSBBUyBcInRhYmxlTmFtZVwiLCcsXG4gICAgICAnQ09MTkFNRSBBUyBcImNvbHVtbk5hbWVcIiwnLFxuICAgICAgJ0NPTlNUTkFNRSBBUyBcImNvbnN0cmFpbnROYW1lXCInLFxuICAgICAgXCJGUk9NIFNZU0NBVC5LRVlDT0xVU0UgV0hFUkUgQ09OU1ROQU1FIExJS0UgJ1BLXyUnXCIsXG4gICAgICBgQU5EIENPTE5BTUUgPSAke3dyYXBTaW5nbGVRdW90ZShhdHRyaWJ1dGVOYW1lKX1gLFxuICAgICAgYEFORCBUQUJOQU1FID0gJHt0YWJsZU5hbWV9O2BcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUoXCJBTFRFUiBUQUJMRSA8JT0gdGFibGUgJT4gRFJPUCA8JT0ga2V5ICU+XCIsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGtleTogdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSlcbiAgICB9KTtcbiAgfVxuICBkcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBjb25zdCBzcWwgPSBcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZSAlPiBEUk9QIENPTlNUUkFJTlQgPCU9IGNvbnN0cmFpbnQgJT47XCI7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUoc3FsLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBjb25zdHJhaW50OiB0aGlzLnF1b3RlSWRlbnRpZmllcihjb25zdHJhaW50TmFtZSlcbiAgICB9KTtcbiAgfVxuICBzZXRBdXRvY29tbWl0UXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSgpIHtcbiAgfVxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKDEwKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkUgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiQkVHSU4gVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQ09NTUlUIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDA7XG4gICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgZnJhZ21lbnQgKz0gYCBPRkZTRVQgJHt0aGlzLmVzY2FwZShvZmZzZXQpfSBST1dTYDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGZyYWdtZW50ICs9IGAgRkVUQ0ggTkVYVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBST1dTIE9OTFlgO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgYWRkVW5pcXVlRmllbGRzKGRhdGFWYWx1ZXMsIHJhd0F0dHJpYnV0ZXMsIHVuaXFubykge1xuICAgIHVuaXFubyA9IHVuaXFubyA9PT0gdm9pZCAwID8gMSA6IHVuaXFubztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAocmF3QXR0cmlidXRlc1trZXldLnVuaXF1ZSAmJiBkYXRhVmFsdWVzW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAocmF3QXR0cmlidXRlc1trZXldLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuREFURSkge1xuICAgICAgICAgIGRhdGFWYWx1ZXNba2V5XSA9IFV0aWxzLm5vdyhcImRiMlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChyYXdBdHRyaWJ1dGVzW2tleV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5TVFJJTkcpIHtcbiAgICAgICAgICBkYXRhVmFsdWVzW2tleV0gPSBgdW5pcXVlJHt1bmlxbm8rK31gO1xuICAgICAgICB9IGVsc2UgaWYgKHJhd0F0dHJpYnV0ZXNba2V5XS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLklOVEVHRVIpIHtcbiAgICAgICAgICBkYXRhVmFsdWVzW2tleV0gPSB1bmlxbm8rKztcbiAgICAgICAgfSBlbHNlIGlmIChyYXdBdHRyaWJ1dGVzW2tleV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CT09MRUFOKSB7XG4gICAgICAgICAgZGF0YVZhbHVlc1trZXldID0gbmV3IERhdGFUeXBlcy5CT09MRUFOKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5pcW5vO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKSwgJ1wiJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIGlmIChpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIGAnJHtpZGVudGlmaWVyfSdgO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxubW9kdWxlLmV4cG9ydHMgPSBEYjJRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query-interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    indexes = _.map(model.uniqueKeys, (value) => {\n      return value.fields;\n    });\n    model._indexes.forEach((value) => {\n      if (value.unique) {\n        indexFields = value.fields.map((field) => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    if (options.indexes) {\n      options.indexes.forEach((fields) => {\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach((field) => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach((fields) => {\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach((field) => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: \"createTable\", withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.Db2QueryInterface = Db2QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUVBQW1FLDhHQUE4RztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9xdWVyeS1pbnRlcmZhY2UuanM/YmRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY2xhc3MgRGIyUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVNcbiAgICB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy51c2VybmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIHF1ZXJ5T3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgd2hlcmVzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgbGV0IGluZGV4ZXMgPSBbXTtcbiAgICBsZXQgaW5kZXhGaWVsZHM7XG4gICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgaWYgKCFVdGlscy5pc1doZXJlRW1wdHkod2hlcmUpKSB7XG4gICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgfVxuICAgIGluZGV4ZXMgPSBfLm1hcChtb2RlbC51bmlxdWVLZXlzLCAodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZS5maWVsZHM7XG4gICAgfSk7XG4gICAgbW9kZWwuX2luZGV4ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZS51bmlxdWUpIHtcbiAgICAgICAgaW5kZXhGaWVsZHMgPSB2YWx1ZS5maWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoZmllbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpbmRleGVzLnB1c2goaW5kZXhGaWVsZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgaWYgKF8uaW50ZXJzZWN0aW9uKGF0dHJpYnV0ZXMsIGluZGV4KS5sZW5ndGggPT09IGluZGV4Lmxlbmd0aCkge1xuICAgICAgICB3aGVyZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4KSB7XG4gICAgICAgICAgd2hlcmVbZmllbGRdID0gaW5zZXJ0VmFsdWVzW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoZXJlID0geyBbT3Aub3JdOiB3aGVyZXMgfTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFtyZXN1bHQsIHZvaWQgMF07XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGUodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIGxldCBzcWwgPSBcIlwiO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmZvck93bihvcHRpb25zLnVuaXF1ZUtleXMsICh1bmlxdWVLZXkpID0+IHtcbiAgICAgICAgaWYgKHVuaXF1ZUtleS5jdXN0b21JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5pcXVlS2V5LmN1c3RvbUluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtb2RlbCkge1xuICAgICAgb3B0aW9ucy51bmlxdWVLZXlzID0gb3B0aW9ucy51bmlxdWVLZXlzIHx8IG1vZGVsLnVuaXF1ZUtleXM7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSBfLm1hcFZhbHVlcyhhdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKSk7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXhlcykge1xuICAgICAgb3B0aW9ucy5pbmRleGVzLmZvckVhY2goKGZpZWxkcykgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZEFyciA9IGZpZWxkcy5maWVsZHM7XG4gICAgICAgIGlmIChmaWVsZEFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBmaWVsZEFyci5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gYXR0cmlidXRlc1twcm9wZXJ0eV0uZmllbGQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3Byb3BlcnR5XS51bmlxdWUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbHRlcikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZXhlcykge1xuICAgICAgICBvcHRpb25zLmluZGV4ZXMuZm9yRWFjaCgoZmllbGRzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZmllbGRBcnIgPSBmaWVsZHMuZmllbGRzO1xuICAgICAgICAgIGlmIChmaWVsZEFyci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGZpZWxkQXJyLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gYXR0cmlidXRlc1twcm9wZXJ0eV0uZmllbGQgJiYgYXR0cmlidXRlc1twcm9wZXJ0eV0udW5pcXVlKSB7XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW3Byb3BlcnR5XS51bmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGFibGVOYW1lLnNjaGVtYSAmJiAob3B0aW9ucy5zY2hlbWEgfHwgISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hKSkge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRTY2hlbWEoe1xuICAgICAgICB0YWJsZU5hbWUsXG4gICAgICAgIF9zY2hlbWE6ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSB8fCBvcHRpb25zLnNjaGVtYVxuICAgICAgfSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCB7IHRhYmxlOiB0YWJsZU5hbWUsIGNvbnRleHQ6IFwiY3JlYXRlVGFibGVcIiwgd2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50czogb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzIH0pO1xuICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG59XG5leHBvcnRzLkRiMlF1ZXJ5SW50ZXJmYWNlID0gRGIyUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst debug = logger.debugContext(\"sql:db2\");\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value) {\n    if (Buffer.isBuffer(value)) {\n      return { ParamType: \"INPUT\", DataType: \"BLOB\", Data: value };\n    }\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n  async _run(connection, sql, parameters) {\n    this.sql = sql;\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log(`Executing (${this.connection.uuid || \"default\"}): ${this.sql}`, this.options);\n    }\n    const errStack = new Error().stack;\n    return new Promise((resolve, reject) => {\n      if (_.startsWith(this.sql, \"BEGIN TRANSACTION\")) {\n        connection.beginTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"COMMIT TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"ROLLBACK TRANSACTION\")) {\n        connection.rollbackTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"SAVE TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            connection.beginTransaction((err2) => {\n              if (err2) {\n                reject(this.formatError(err2, errStack));\n              } else {\n                resolve(this.formatResults());\n              }\n            });\n          }\n        }, this.options.transaction.name);\n      } else {\n        const params = [];\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const param = this.getSQLTypeFromJsType(value, key);\n            params.push(param);\n          });\n        }\n        const SQL = this.sql.toUpperCase();\n        let newSql = this.sql;\n        if ((this.isSelectQuery() || _.startsWith(SQL, \"SELECT \")) && SQL.indexOf(\" FROM \", 8) === -1) {\n          if (this.sql.charAt(this.sql.length - 1) === \";\") {\n            newSql = this.sql.slice(0, this.sql.length - 1);\n          }\n          newSql += \" FROM SYSIBM.SYSDUMMY1;\";\n        }\n        connection.prepare(newSql, (err, stmt) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          }\n          stmt.execute(params, (err2, result, outparams) => {\n            debug(`executed(${this.connection.uuid || \"default\"}):${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`);\n            if (benchmark) {\n              this.sequelize.log(`Executed (${this.connection.uuid || \"default\"}): ${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`, Date.now() - queryBegin, this.options);\n            }\n            if (err2 && err2.message) {\n              err2 = this.filterSQLError(err2, this.sql, connection);\n              if (err2 === null) {\n                stmt.closeSync();\n                resolve(this.formatResults([], 0));\n              }\n            }\n            if (err2) {\n              err2.sql = sql;\n              stmt.closeSync();\n              reject(this.formatError(err2, errStack, connection, parameters));\n            } else {\n              let data = [];\n              let metadata = [];\n              let affectedRows = 0;\n              if (typeof result === \"object\") {\n                if (_.startsWith(this.sql, \"DELETE FROM \")) {\n                  affectedRows = result.getAffectedRowsSync();\n                } else {\n                  data = result.fetchAllSync();\n                  metadata = result.getColumnMetadataSync();\n                }\n                result.closeSync();\n              }\n              stmt.closeSync();\n              const datalen = data.length;\n              if (datalen > 0) {\n                const coltypes = {};\n                for (let i = 0; i < metadata.length; i++) {\n                  coltypes[metadata[i].SQL_DESC_NAME] = metadata[i].SQL_DESC_TYPE_NAME;\n                }\n                for (let i = 0; i < datalen; i++) {\n                  for (const column in data[i]) {\n                    const parse = parserStore.get(coltypes[column]);\n                    const value = data[i][column];\n                    if (value !== null) {\n                      if (parse) {\n                        data[i][column] = parse(value);\n                      } else if (coltypes[column] === \"TIMESTAMP\") {\n                        data[i][column] = new Date(moment.utc(value));\n                      } else if (coltypes[column] === \"BLOB\") {\n                        data[i][column] = new Buffer.from(value);\n                      } else if (coltypes[column].indexOf(\"FOR BIT DATA\") > 0) {\n                        data[i][column] = new Buffer.from(value, \"hex\");\n                      }\n                    }\n                  }\n                }\n                if (outparams && outparams.length) {\n                  data.unshift(outparams);\n                }\n                resolve(this.formatResults(data, datalen, metadata, connection));\n              } else {\n                resolve(this.formatResults(data, affectedRows));\n              }\n            }\n          });\n        });\n      }\n    });\n  }\n  async run(sql, parameters) {\n    return await this._run(this.connection, sql, parameters);\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    if (Array.isArray(values) && typeof values[0] === \"object\") {\n      bindParam = values;\n    }\n    return [sql, bindParam];\n  }\n  filterSQLError(err, sql, connection) {\n    if (err.message.search(\"SQL0204N\") != -1 && _.startsWith(sql, \"DROP \")) {\n      err = null;\n    } else if (err.message.search(\"SQL0443N\") != -1) {\n      if (this.isDropSchemaQuery()) {\n        connection.querySync(\"DROP TABLE ERRORSCHEMA.ERRORTABLE;\");\n        connection.querySync(this.sql);\n      }\n      err = null;\n    } else if (err.message.search(\"SQL0601N\") != -1) {\n      const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name \"(.*)\" of type \"(.*)\"./);\n      if (match && match.length > 1 && match[2] === \"TABLE\") {\n        let table;\n        const mtarray = match[1].split(\".\");\n        if (mtarray[1]) {\n          table = `\"${mtarray[0]}\".\"${mtarray[1]}\"`;\n        } else {\n          table = `\"${mtarray[0]}\"`;\n        }\n        if (connection.dropTable !== false) {\n          connection.querySync(`DROP TABLE ${table}`);\n          err = connection.querySync(sql);\n        } else {\n          err = null;\n        }\n      } else {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0911N\") != -1) {\n      if (err.message.search('Reason code \"2\"') != -1) {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0605W\") != -1) {\n      err = null;\n    } else if (err.message.search(\"SQL0668N\") != -1 && _.startsWith(sql, \"ALTER TABLE \")) {\n      connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(\" \")[0]}')`);\n      err = connection.querySync(sql);\n    }\n    if (err && err.length === 0) {\n      err = null;\n    }\n    return err;\n  }\n  formatResults(data, rowCount, metadata, conn) {\n    let result = this.instance;\n    if (this.isInsertQuery(data, metadata)) {\n      this.handleInsertQuery(data, metadata);\n      if (!this.instance) {\n        if (this.options.plain) {\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      result = data;\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"Y\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.KeySeq > 0,\n          autoIncrement: _result.IsIdentity === \"Y\" ? true : false,\n          comment: _result.Comment\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n    } else if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isUpsertQuery()) {\n      result = data;\n    } else if (this.isDropSchemaQuery()) {\n      result = data[0];\n      if (conn) {\n        const query = \"DROP TABLE ERRORSCHEMA.ERRORTABLE\";\n        conn.querySync(query);\n      }\n    } else if (this.isCallQuery()) {\n      result = data;\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.length;\n    } else if (this.isBulkDeleteQuery()) {\n      result = rowCount;\n    } else if (this.isVersionQuery()) {\n      result = data[0].VERSION;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, rowCount];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      result = [data, metadata];\n    } else {\n      result = data;\n    }\n    return result;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return _.remove(data, (constraint) => {\n      return !_.startsWith(constraint.constraintName, \"SQL\");\n    });\n  }\n  formatError(err, errStack, conn, parameters) {\n    let match;\n    if (!(err && err.message)) {\n      err[\"message\"] = \"No error message found.\";\n    }\n    match = err.message.match(/SQL0803N {2}One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by \"(\\d)+\" constrains table \"(.*)\\.(.*)\" from having duplicate values for the index key./);\n    if (match && match.length > 0) {\n      let uniqueIndexName = \"\";\n      let uniqueKey = \"\";\n      const fields = {};\n      let message = err.message;\n      const query = `SELECT INDNAME FROM SYSCAT.INDEXES  WHERE IID = ${match[1]} AND TABSCHEMA = '${match[2]}' AND TABNAME = '${match[3]}'`;\n      if (!!conn && match.length > 3) {\n        uniqueIndexName = conn.querySync(query);\n        uniqueIndexName = uniqueIndexName[0][\"INDNAME\"];\n      }\n      if (this.model && !!uniqueIndexName) {\n        uniqueKey = this.model.uniqueKeys[uniqueIndexName];\n      }\n      if (!uniqueKey && this.options.fields) {\n        uniqueKey = this.options.fields[match[1] - 1];\n      }\n      if (uniqueKey) {\n        if (this.options.where && this.options.where[uniqueKey.column] !== void 0) {\n          fields[uniqueKey.column] = this.options.where[uniqueKey.column];\n        } else if (this.options.instance && this.options.instance.dataValues && this.options.instance.dataValues[uniqueKey.column]) {\n          fields[uniqueKey.column] = this.options.instance.dataValues[uniqueKey.column];\n        } else if (parameters) {\n          fields[uniqueKey.column] = parameters[\"0\"];\n        }\n      }\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/SQL0532N {2}A parent row cannot be deleted because the relationship \"(.*)\" restricts the deletion/) || err.message.match(/SQL0530N/) || err.message.match(/SQL0531N/);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/SQL0204N {2}\"(.*)\" is an undefined name./);\n    if (match && match.length > 1) {\n      const constraint = match[1];\n      let table = err.sql.match(/table \"(.+?)\"/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[0],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isDropSchemaQuery() {\n    let result = false;\n    if (_.startsWith(this.sql, \"CALL SYSPROC.ADMIN_DROP_SCHEMA\")) {\n      result = true;\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    result = result || this.sql.startsWith('SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES');\n    return result;\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.keyType === \"P\",\n          fields: [],\n          name: item.name,\n          tableName: item.tableName,\n          unique: item.keyType === \"U\",\n          type: item.type\n        };\n        _.forEach(item.COLNAMES.replace(/\\+|-/g, (x) => {\n          return ` ${x}`;\n        }).split(\" \"), (column) => {\n          let columnName = column.trim();\n          if (columnName) {\n            columnName = columnName.replace(/\\+|-/, \"\");\n            currItem.fields.push({\n              attribute: columnName,\n              length: void 0,\n              order: column.indexOf(\"-\") === -1 ? \"ASC\" : \"DESC\",\n              collate: void 0\n            });\n          }\n        });\n        result.push(currItem);\n      }\n    });\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1Q0FBdUMsa0NBQWtDLEtBQUssU0FBUztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSSxRQUFRLEVBQUUsd0NBQXdDLHNDQUFzQyxPQUFPO0FBQ25LO0FBQ0EsOENBQThDLGtDQUFrQyxLQUFLLFFBQVEsRUFBRSx3Q0FBd0Msc0NBQXNDLE9BQU87QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVcsS0FBSyxXQUFXO0FBQ2pELFVBQVU7QUFDVixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixrRUFBa0UsZ0NBQWdDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsVUFBVSxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL3F1ZXJ5LmpzP2UwNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwiZGIyXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6ZGIyXCIpO1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJpZFwiO1xuICB9XG4gIGdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7IFBhcmFtVHlwZTogXCJJTlBVVFwiLCBEYXRhVHlwZTogXCJCTE9CXCIsIERhdGE6IHZhbHVlIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgYXN5bmMgX3J1bihjb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCBiZW5jaG1hcmsgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmJlbmNobWFyayB8fCB0aGlzLm9wdGlvbnMuYmVuY2htYXJrO1xuICAgIGxldCBxdWVyeUJlZ2luO1xuICAgIGlmIChiZW5jaG1hcmspIHtcbiAgICAgIHF1ZXJ5QmVnaW4gPSBEYXRlLm5vdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYEV4ZWN1dGluZyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiAke3RoaXMuc3FsfWAsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGVyclN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiQkVHSU4gVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgY29ubmVjdGlvbi5iZWdpblRyYW5zYWN0aW9uKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJDT01NSVQgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgY29ubmVjdGlvbi5jb21taXRUcmFuc2FjdGlvbigoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgY29ubmVjdGlvbi5yb2xsYmFja1RyYW5zYWN0aW9uKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJTQVZFIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uY29tbWl0VHJhbnNhY3Rpb24oKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iZWdpblRyYW5zYWN0aW9uKChlcnIyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyMiwgZXJyU3RhY2spKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cygpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBfLmZvck93bihwYXJhbWV0ZXJzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLmdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFNRTCA9IHRoaXMuc3FsLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGxldCBuZXdTcWwgPSB0aGlzLnNxbDtcbiAgICAgICAgaWYgKCh0aGlzLmlzU2VsZWN0UXVlcnkoKSB8fCBfLnN0YXJ0c1dpdGgoU1FMLCBcIlNFTEVDVCBcIikpICYmIFNRTC5pbmRleE9mKFwiIEZST00gXCIsIDgpID09PSAtMSkge1xuICAgICAgICAgIGlmICh0aGlzLnNxbC5jaGFyQXQodGhpcy5zcWwubGVuZ3RoIC0gMSkgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICBuZXdTcWwgPSB0aGlzLnNxbC5zbGljZSgwLCB0aGlzLnNxbC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV3U3FsICs9IFwiIEZST00gU1lTSUJNLlNZU0RVTU1ZMTtcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uLnByZXBhcmUobmV3U3FsLCAoZXJyLCBzdG10KSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG10LmV4ZWN1dGUocGFyYW1zLCAoZXJyMiwgcmVzdWx0LCBvdXRwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKGBleGVjdXRlZCgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6JHtuZXdTcWx9ICR7cGFyYW1ldGVycyA/IHV0aWwuaW5zcGVjdChwYXJhbWV0ZXJzLCB7IGNvbXBhY3Q6IHRydWUsIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSB9KSA6IFwiXCJ9YCk7XG4gICAgICAgICAgICBpZiAoYmVuY2htYXJrKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgRXhlY3V0ZWQgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogJHtuZXdTcWx9ICR7cGFyYW1ldGVycyA/IHV0aWwuaW5zcGVjdChwYXJhbWV0ZXJzLCB7IGNvbXBhY3Q6IHRydWUsIGJyZWFrTGVuZ3RoOiBJbmZpbml0eSB9KSA6IFwiXCJ9YCwgRGF0ZS5ub3coKSAtIHF1ZXJ5QmVnaW4sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyMiAmJiBlcnIyLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgZXJyMiA9IHRoaXMuZmlsdGVyU1FMRXJyb3IoZXJyMiwgdGhpcy5zcWwsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICBpZiAoZXJyMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0bXQuY2xvc2VTeW5jKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoW10sIDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgICAgZXJyMi5zcWwgPSBzcWw7XG4gICAgICAgICAgICAgIHN0bXQuY2xvc2VTeW5jKCk7XG4gICAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVycjIsIGVyclN0YWNrLCBjb25uZWN0aW9uLCBwYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgbWV0YWRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgbGV0IGFmZmVjdGVkUm93cyA9IDA7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJERUxFVEUgRlJPTSBcIikpIHtcbiAgICAgICAgICAgICAgICAgIGFmZmVjdGVkUm93cyA9IHJlc3VsdC5nZXRBZmZlY3RlZFJvd3NTeW5jKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQuZmV0Y2hBbGxTeW5jKCk7XG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHJlc3VsdC5nZXRDb2x1bW5NZXRhZGF0YVN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNsb3NlU3luYygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0bXQuY2xvc2VTeW5jKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGFsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKGRhdGFsZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdHlwZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb2x0eXBlc1ttZXRhZGF0YVtpXS5TUUxfREVTQ19OQU1FXSA9IG1ldGFkYXRhW2ldLlNRTF9ERVNDX1RZUEVfTkFNRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29sdW1uIGluIGRhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQoY29sdHlwZXNbY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGF0YVtpXVtjb2x1bW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bY29sdW1uXSA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHR5cGVzW2NvbHVtbl0gPT09IFwiVElNRVNUQU1QXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bY29sdW1uXSA9IG5ldyBEYXRlKG1vbWVudC51dGModmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHR5cGVzW2NvbHVtbl0gPT09IFwiQkxPQlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW2NvbHVtbl0gPSBuZXcgQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdHlwZXNbY29sdW1uXS5pbmRleE9mKFwiRk9SIEJJVCBEQVRBXCIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtjb2x1bW5dID0gbmV3IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImhleFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG91dHBhcmFtcyAmJiBvdXRwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLnVuc2hpZnQob3V0cGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoZGF0YSwgZGF0YWxlbiwgbWV0YWRhdGEsIGNvbm5lY3Rpb24pKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cyhkYXRhLCBhZmZlY3RlZFJvd3MpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3J1bih0aGlzLmNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycyk7XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgbGV0IGJpbmRQYXJhbSA9IHt9O1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyKSA9PiB7XG4gICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYmluZFBhcmFtW2tleV0gPSB2YWx1ZXMyW2tleV07XG4gICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykgJiYgdHlwZW9mIHZhbHVlc1swXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYmluZFBhcmFtID0gdmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuICBmaWx0ZXJTUUxFcnJvcihlcnIsIHNxbCwgY29ubmVjdGlvbikge1xuICAgIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwMjA0TlwiKSAhPSAtMSAmJiBfLnN0YXJ0c1dpdGgoc3FsLCBcIkRST1AgXCIpKSB7XG4gICAgICBlcnIgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDQ0M05cIikgIT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLmlzRHJvcFNjaGVtYVF1ZXJ5KCkpIHtcbiAgICAgICAgY29ubmVjdGlvbi5xdWVyeVN5bmMoXCJEUk9QIFRBQkxFIEVSUk9SU0NIRU1BLkVSUk9SVEFCTEU7XCIpO1xuICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5U3luYyh0aGlzLnNxbCk7XG4gICAgICB9XG4gICAgICBlcnIgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDYwMU5cIikgIT0gLTEpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDA2MDFOIHsyfVRoZSBuYW1lIG9mIHRoZSBvYmplY3QgdG8gYmUgY3JlYXRlZCBpcyBpZGVudGljYWwgdG8gdGhlIGV4aXN0aW5nIG5hbWUgXCIoLiopXCIgb2YgdHlwZSBcIiguKilcIi4vKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoWzJdID09PSBcIlRBQkxFXCIpIHtcbiAgICAgICAgbGV0IHRhYmxlO1xuICAgICAgICBjb25zdCBtdGFycmF5ID0gbWF0Y2hbMV0uc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAobXRhcnJheVsxXSkge1xuICAgICAgICAgIHRhYmxlID0gYFwiJHttdGFycmF5WzBdfVwiLlwiJHttdGFycmF5WzFdfVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWJsZSA9IGBcIiR7bXRhcnJheVswXX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uZHJvcFRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnlTeW5jKGBEUk9QIFRBQkxFICR7dGFibGV9YCk7XG4gICAgICAgICAgZXJyID0gY29ubmVjdGlvbi5xdWVyeVN5bmMoc3FsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDkxMU5cIikgIT0gLTEpIHtcbiAgICAgIGlmIChlcnIubWVzc2FnZS5zZWFyY2goJ1JlYXNvbiBjb2RlIFwiMlwiJykgIT0gLTEpIHtcbiAgICAgICAgZXJyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDA2MDVXXCIpICE9IC0xKSB7XG4gICAgICBlcnIgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDY2OE5cIikgIT0gLTEgJiYgXy5zdGFydHNXaXRoKHNxbCwgXCJBTFRFUiBUQUJMRSBcIikpIHtcbiAgICAgIGNvbm5lY3Rpb24ucXVlcnlTeW5jKGBDQUxMIFNZU1BST0MuQURNSU5fQ01EKCdSRU9SRyBUQUJMRSAke3NxbC5zdWJzdHJpbmcoMTIpLnNwbGl0KFwiIFwiKVswXX0nKWApO1xuICAgICAgZXJyID0gY29ubmVjdGlvbi5xdWVyeVN5bmMoc3FsKTtcbiAgICB9XG4gICAgaWYgKGVyciAmJiBlcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSwgcm93Q291bnQsIG1ldGFkYXRhLCBjb25uKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhLCBtZXRhZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhaW4pIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSBkYXRhWzBdO1xuICAgICAgICAgIHJlc3VsdCA9IHJlY29yZFtPYmplY3Qua2V5cyhyZWNvcmQpWzBdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChfcmVzdWx0LkRlZmF1bHQpIHtcbiAgICAgICAgICBfcmVzdWx0LkRlZmF1bHQgPSBfcmVzdWx0LkRlZmF1bHQucmVwbGFjZShcIignXCIsIFwiXCIpLnJlcGxhY2UoXCInKVwiLCBcIlwiKS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5Jc051bGwgPT09IFwiWVwiID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5U2VxID4gMCxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBfcmVzdWx0LklzSWRlbnRpdHkgPT09IFwiWVwiID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEcm9wU2NoZW1hUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YVswXTtcbiAgICAgIGlmIChjb25uKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gXCJEUk9QIFRBQkxFIEVSUk9SU0NIRU1BLkVSUk9SVEFCTEVcIjtcbiAgICAgICAgY29ubi5xdWVyeVN5bmMocXVlcnkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gcm93Q291bnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGFbMF0uVkVSU0lPTjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gW3Jlc3VsdCwgcm93Q291bnRdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gW2RhdGEsIG1ldGFkYXRhXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0U2V0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSkge1xuICAgIHJldHVybiBfLnJlbW92ZShkYXRhLCAoY29uc3RyYWludCkgPT4ge1xuICAgICAgcmV0dXJuICFfLnN0YXJ0c1dpdGgoY29uc3RyYWludC5jb25zdHJhaW50TmFtZSwgXCJTUUxcIik7XG4gICAgfSk7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaywgY29ubiwgcGFyYW1ldGVycykge1xuICAgIGxldCBtYXRjaDtcbiAgICBpZiAoIShlcnIgJiYgZXJyLm1lc3NhZ2UpKSB7XG4gICAgICBlcnJbXCJtZXNzYWdlXCJdID0gXCJObyBlcnJvciBtZXNzYWdlIGZvdW5kLlwiO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwODAzTiB7Mn1PbmUgb3IgbW9yZSB2YWx1ZXMgaW4gdGhlIElOU0VSVCBzdGF0ZW1lbnQsIFVQREFURSBzdGF0ZW1lbnQsIG9yIGZvcmVpZ24ga2V5IHVwZGF0ZSBjYXVzZWQgYnkgYSBERUxFVEUgc3RhdGVtZW50IGFyZSBub3QgdmFsaWQgYmVjYXVzZSB0aGUgcHJpbWFyeSBrZXksIHVuaXF1ZSBjb25zdHJhaW50IG9yIHVuaXF1ZSBpbmRleCBpZGVudGlmaWVkIGJ5IFwiKFxcZCkrXCIgY29uc3RyYWlucyB0YWJsZSBcIiguKilcXC4oLiopXCIgZnJvbSBoYXZpbmcgZHVwbGljYXRlIHZhbHVlcyBmb3IgdGhlIGluZGV4IGtleS4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHVuaXF1ZUluZGV4TmFtZSA9IFwiXCI7XG4gICAgICBsZXQgdW5pcXVlS2V5ID0gXCJcIjtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgICAgbGV0IG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gYFNFTEVDVCBJTkROQU1FIEZST00gU1lTQ0FULklOREVYRVMgIFdIRVJFIElJRCA9ICR7bWF0Y2hbMV19IEFORCBUQUJTQ0hFTUEgPSAnJHttYXRjaFsyXX0nIEFORCBUQUJOQU1FID0gJyR7bWF0Y2hbM119J2A7XG4gICAgICBpZiAoISFjb25uICYmIG1hdGNoLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdW5pcXVlSW5kZXhOYW1lID0gY29ubi5xdWVyeVN5bmMocXVlcnkpO1xuICAgICAgICB1bmlxdWVJbmRleE5hbWUgPSB1bmlxdWVJbmRleE5hbWVbMF1bXCJJTkROQU1FXCJdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubW9kZWwgJiYgISF1bmlxdWVJbmRleE5hbWUpIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbC51bmlxdWVLZXlzW3VuaXF1ZUluZGV4TmFtZV07XG4gICAgICB9XG4gICAgICBpZiAoIXVuaXF1ZUtleSAmJiB0aGlzLm9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IHRoaXMub3B0aW9ucy5maWVsZHNbbWF0Y2hbMV0gLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53aGVyZSAmJiB0aGlzLm9wdGlvbnMud2hlcmVbdW5pcXVlS2V5LmNvbHVtbl0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGZpZWxkc1t1bmlxdWVLZXkuY29sdW1uXSA9IHRoaXMub3B0aW9ucy53aGVyZVt1bmlxdWVLZXkuY29sdW1uXTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuaW5zdGFuY2UgJiYgdGhpcy5vcHRpb25zLmluc3RhbmNlLmRhdGFWYWx1ZXMgJiYgdGhpcy5vcHRpb25zLmluc3RhbmNlLmRhdGFWYWx1ZXNbdW5pcXVlS2V5LmNvbHVtbl0pIHtcbiAgICAgICAgICBmaWVsZHNbdW5pcXVlS2V5LmNvbHVtbl0gPSB0aGlzLm9wdGlvbnMuaW5zdGFuY2UuZGF0YVZhbHVlc1t1bmlxdWVLZXkuY29sdW1uXTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgZmllbGRzW3VuaXF1ZUtleS5jb2x1bW5dID0gcGFyYW1ldGVyc1tcIjBcIl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1bmlxdWVLZXkgJiYgISF1bmlxdWVLZXkubXNnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwNTMyTiB7Mn1BIHBhcmVudCByb3cgY2Fubm90IGJlIGRlbGV0ZWQgYmVjYXVzZSB0aGUgcmVsYXRpb25zaGlwIFwiKC4qKVwiIHJlc3RyaWN0cyB0aGUgZGVsZXRpb24vKSB8fCBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDUzME4vKSB8fCBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDUzMU4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIGZpZWxkczogbnVsbCxcbiAgICAgICAgaW5kZXg6IG1hdGNoWzFdLFxuICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDIwNE4gezJ9XCIoLiopXCIgaXMgYW4gdW5kZWZpbmVkIG5hbWUuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBtYXRjaFsxXTtcbiAgICAgIGxldCB0YWJsZSA9IGVyci5zcWwubWF0Y2goL3RhYmxlIFwiKC4rPylcIi9pKTtcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBtYXRjaFswXSxcbiAgICAgICAgY29uc3RyYWludCxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gIH1cbiAgaXNEcm9wU2NoZW1hUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChfLnN0YXJ0c1dpdGgodGhpcy5zcWwsIFwiQ0FMTCBTWVNQUk9DLkFETUlOX0RST1BfU0NIRU1BXCIpKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzU2hvd09yRGVzY3JpYmVRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNlbGVjdCBjLmNvbHVtbl9uYW1lIGFzICduYW1lJywgYy5kYXRhX3R5cGUgYXMgJ3R5cGUnLCBjLmlzX251bGxhYmxlIGFzICdpc251bGwnXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzZWxlY3QgdGFibGVuYW1lID0gdC5uYW1lLCBuYW1lID0gaW5kLm5hbWUsXCIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWVcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWVcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnN0YXJ0c1dpdGgoJ1NFTEVDVCBOQU1FIEFTIFwibmFtZVwiLCBUQk5BTUUgQVMgXCJ0YWJsZU5hbWVcIiwgVU5JUVVFUlVMRSBBUyBcImtleVR5cGVcIiwgQ09MTkFNRVMsIElOREVYVFlQRSBBUyBcInR5cGVcIiBGUk9NIFNZU0lCTS5TWVNJTkRFWEVTJyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBsZXQgY3Vyckl0ZW07XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoIWN1cnJJdGVtIHx8IGN1cnJJdGVtLm5hbWUgIT09IGl0ZW0uS2V5X25hbWUpIHtcbiAgICAgICAgY3Vyckl0ZW0gPSB7XG4gICAgICAgICAgcHJpbWFyeTogaXRlbS5rZXlUeXBlID09PSBcIlBcIixcbiAgICAgICAgICBmaWVsZHM6IFtdLFxuICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICB0YWJsZU5hbWU6IGl0ZW0udGFibGVOYW1lLFxuICAgICAgICAgIHVuaXF1ZTogaXRlbS5rZXlUeXBlID09PSBcIlVcIixcbiAgICAgICAgICB0eXBlOiBpdGVtLnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgXy5mb3JFYWNoKGl0ZW0uQ09MTkFNRVMucmVwbGFjZSgvXFwrfC0vZywgKHgpID0+IHtcbiAgICAgICAgICByZXR1cm4gYCAke3h9YDtcbiAgICAgICAgfSkuc3BsaXQoXCIgXCIpLCAoY29sdW1uKSA9PiB7XG4gICAgICAgICAgbGV0IGNvbHVtbk5hbWUgPSBjb2x1bW4udHJpbSgpO1xuICAgICAgICAgIGlmIChjb2x1bW5OYW1lKSB7XG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gY29sdW1uTmFtZS5yZXBsYWNlKC9cXCt8LS8sIFwiXCIpO1xuICAgICAgICAgICAgY3Vyckl0ZW0uZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgICAgIGxlbmd0aDogdm9pZCAwLFxuICAgICAgICAgICAgICBvcmRlcjogY29sdW1uLmluZGV4T2YoXCItXCIpID09PSAtMSA/IFwiQVNDXCIgOiBcIkRFU0NcIixcbiAgICAgICAgICAgICAgY29sbGF0ZTogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucHVzaChjdXJySXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50QXR0cmlidXRlID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGlkID0gbnVsbDtcbiAgICAgIGxldCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSBudWxsO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUpICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZCAhPT0gdm9pZCAwKVxuICAgICAgICBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdO1xuICAgICAgaWQgPSBpZCB8fCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgJiYgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhc107XG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdID0gaWQ7XG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mariadb);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mariadb\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mariadb\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mariadb\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false\n    }, config.dialectOptions);\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ER_ACCESS_DENIED_NO_PASSWORD_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n        case \"ENETUNREACH\":\n        case \"EADDRNOTAVAIL\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isValid()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await connection.end();\n  }\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0Isa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQix5R0FBbUM7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkUsUUFBUTtBQUNSLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbWFyaWFkYi9jb25uZWN0aW9uLW1hbmFnZXIuanM/YzQ0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm1hcmlhZGI7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOm1hcmlhZGJcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm1hcmlhZGJcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJtYXJpYWRiXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgbGV0IHR6T2Zmc2V0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZTtcbiAgICB0ek9mZnNldCA9IC9cXC8vLnRlc3QodHpPZmZzZXQpID8gbW9tZW50VHoudHoodHpPZmZzZXQpLmZvcm1hdChcIlpcIikgOiB0ek9mZnNldDtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9zdDogY29uZmlnLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCxcbiAgICAgIHVzZXI6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgdGltZXpvbmU6IHR6T2Zmc2V0LFxuICAgICAgdHlwZUNhc3Q6IENvbm5lY3Rpb25NYW5hZ2VyLl90eXBlY2FzdC5iaW5kKHRoaXMpLFxuICAgICAgYmlnTnVtYmVyU3RyaW5nczogZmFsc2UsXG4gICAgICBzdXBwb3J0QmlnTnVtYmVyczogdHJ1ZSxcbiAgICAgIGZvdW5kUm93czogZmFsc2VcbiAgICB9LCBjb25maWcuZGlhbGVjdE9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCkpIHtcbiAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwgPSBbY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsXTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmluaXRTcWwucHVzaChgU0VUIHRpbWVfem9uZSA9ICcke3R6T2Zmc2V0fSdgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCA9IGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5saWIuY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShjb25uZWN0aW9uLnNlcnZlclZlcnNpb24oKSkudmVyc2lvbjtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgIGNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSBcIkVTT0NLRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRUNPTk5SRVNFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFUElQRVwiOlxuICAgICAgICAgIGNhc2UgXCJQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1RcIjpcbiAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICBjYXNlIFwiRUNPTk5SRUZVU0VEXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFUl9BQ0NFU1NfREVOSUVEX0VSUk9SXCI6XG4gICAgICAgIGNhc2UgXCJFUl9BQ0NFU1NfREVOSUVEX05PX1BBU1NXT1JEX0VSUk9SXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRU5PVEZPVU5EXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUhPU1RVTlJFQUNIXCI6XG4gICAgICAgIGNhc2UgXCJFTkVUVU5SRUFDSFwiOlxuICAgICAgICBjYXNlIFwiRUFERFJOT1RBVkFJTFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSU5WQUxcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIWNvbm5lY3Rpb24uaXNWYWxpZCgpKSB7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5lbmQoKTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5pc1ZhbGlkKCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://mariadb.com/kb/en/library/resultset/#field-types\";\n  BaseTypes.DATE.types.mariadb = [\"DATETIME\"];\n  BaseTypes.STRING.types.mariadb = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mariadb = [\"STRING\"];\n  BaseTypes.TEXT.types.mariadb = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mariadb = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mariadb = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mariadb = [\"INT24\"];\n  BaseTypes.INTEGER.types.mariadb = [\"LONG\"];\n  BaseTypes.BIGINT.types.mariadb = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mariadb = [\"FLOAT\"];\n  BaseTypes.TIME.types.mariadb = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mariadb = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mariadb = [\"TINY\"];\n  BaseTypes.BLOB.types.mariadb = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mariadb = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mariadb = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mariadb = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      } else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsZ0RBQUs7QUFDekIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRCQUE0QixPQUFPLEVBQUUsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21hcmlhZGIvZGF0YS10eXBlcy5qcz9lMTEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgd2t4ID0gcmVxdWlyZShcIndreFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBCYXNlVHlwZXMuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9IFwiaHR0cHM6Ly9tYXJpYWRiLmNvbS9rYi9lbi9saWJyYXJ5L3Jlc3VsdHNldC8jZmllbGQtdHlwZXNcIjtcbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubWFyaWFkYiA9IFtcIkRBVEVUSU1FXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm1hcmlhZGIgPSBbXCJWQVJfU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5tYXJpYWRiID0gW1wiU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5tYXJpYWRiID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubWFyaWFkYiA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5tYXJpYWRiID0gW1wiU0hPUlRcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubWFyaWFkYiA9IFtcIklOVDI0XCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5tYXJpYWRiID0gW1wiTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5tYXJpYWRiID0gW1wiTE9OR0xPTkdcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5tYXJpYWRiID0gW1wiRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm1hcmlhZGIgPSBbXCJUSU1FXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMubWFyaWFkYiA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm1hcmlhZGIgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5tYXJpYWRiID0gW1wiVElOWUJMT0JcIiwgXCJCTE9CXCIsIFwiTE9OR0JMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm1hcmlhZGIgPSBbXCJORVdERUNJTUFMXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5tYXJpYWRiID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm1hcmlhZGIgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubWFyaWFkYiA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5tYXJpYWRiID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubWFyaWFkYiA9IFtcIkdFT01FVFJZXCJdO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5tYXJpYWRiID0gW1wiSlNPTlwiXTtcbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gc3VwZXIudG9TcWwoKTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICBkZWZpbml0aW9uICs9IFwiIFVOU0lHTkVEXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBcIiBaRVJPRklMTFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID8gYERBVEVUSU1FKCR7dGhpcy5fbGVuZ3RofSlgIDogXCJEQVRFVElNRVwiO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1NcIik7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudFR6LnR6KHZhbHVlLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYCR7dmFsdWV9ICR7b3B0aW9ucy50aW1lem9uZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZygpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0hBUigzNikgQklOQVJZXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgICBzdXBlcih0eXBlLCBzcmlkKTtcbiAgICAgIGlmIChfLmlzRW1wdHkodGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLmtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMudHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcigpO1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDQpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZSh2YWx1ZSkudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3FsVHlwZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYEVOVU0oJHt0aGlzLnZhbHVlcy5tYXAoKHZhbHVlKSA9PiBvcHRpb25zLmVzY2FwZSh2YWx1ZSkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSBcIndoZXJlXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgRU5VTSxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFVVSUQsXG4gICAgR0VPTUVUUlksXG4gICAgREVDSU1BTCxcbiAgICBKU09OOiBKU09OVFlQRVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js\");\nconst { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mariadb);\nclass MariadbDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMariadbDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  schemas: true,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMariadbDialect.prototype.defaultVersion = \"10.1.44\";\nMariadbDialect.prototype.Query = Query;\nMariadbDialect.prototype.QueryGenerator = QueryGenerator;\nMariadbDialect.prototype.DataTypes = DataTypes;\nMariadbDialect.prototype.name = \"mariadb\";\nMariadbDialect.prototype.TICK_CHAR = \"`\";\nMariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;\nMariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;\nmodule.exports = MariadbDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLHdCQUF3QixtQkFBTyxDQUFDLGtGQUFhO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFzQjtBQUN4RCxjQUFjLG1CQUFPLENBQUMsNkVBQVM7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ2xELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEUsa0JBQWtCLHlHQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbWFyaWFkYi9pbmRleC5qcz9hNDM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHsgTXlTUUxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL215c3FsL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm1hcmlhZGI7XG5jbGFzcyBNYXJpYWRiRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE15U1FMUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxuICBjYW5CYWNrc2xhc2hFc2NhcGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJWQUxVRVMgKClcIjogdHJ1ZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgZm9yU2hhcmU6IFwiTE9DSyBJTiBTSEFSRSBNT0RFXCIsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiBmYWxzZSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6IFwiIElHTk9SRVwiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBcIiBPTiBEVVBMSUNBVEUgS0VZIFVQREFURVwiXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHBhcnNlcjogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiAxXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGNoZWNrOiBmYWxzZVxuICB9LFxuICBpbmRleFZpYUFsdGVyOiB0cnVlLFxuICBpbmRleEhpbnRzOiB0cnVlLFxuICBOVU1FUklDOiB0cnVlLFxuICBHRU9NRVRSWTogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgUkVHRVhQOiB0cnVlXG59KTtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiMTAuMS40NFwiO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuUXVlcnlHZW5lcmF0b3IgPSBRdWVyeUdlbmVyYXRvcjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwibWFyaWFkYlwiO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9IFwiYFwiO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBNYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBNYXJpYWRiRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst Utils = __webpack_require__(/*! ./../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n  createSchema(schema, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE SCHEMA IF NOT EXISTS\",\n      this.quoteIdentifier(schema),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n  showSchemasQuery(options) {\n    const schemasToSkip = [\n      \"'MYSQL'\",\n      \"'INFORMATION_SCHEMA'\",\n      \"'PERFORMANCE_SCHEMA'\"\n    ];\n    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {\n      for (const schemaName of options.skip) {\n        schemasToSkip.push(this.escape(schemaName));\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT SCHEMA_NAME as schema_name\",\n      \"FROM INFORMATION_SCHEMA.SCHEMATA\",\n      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(\", \")})`,\n      \";\"\n    ]);\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA')\";\n    }\n    return `${query};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = MariaDBQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbWFyaWFkYi9xdWVyeS1nZW5lcmF0b3IuanM/NDcxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IE15U1FMUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vbXlzcWwvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi8uLi8uLi91dGlsc1wiKTtcbmNsYXNzIE1hcmlhREJRdWVyeUdlbmVyYXRvciBleHRlbmRzIE15U1FMUXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJDUkVBVEUgU0NIRU1BIElGIE5PVCBFWElTVFNcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUkFDVEVSIFNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY2hhcnNldCl9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgREVGQVVMVCBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBgRFJPUCBTQ0hFTUEgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKX07YDtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY2hlbWFzVG9Ta2lwID0gW1xuICAgICAgXCInTVlTUUwnXCIsXG4gICAgICBcIidJTkZPUk1BVElPTl9TQ0hFTUEnXCIsXG4gICAgICBcIidQRVJGT1JNQU5DRV9TQ0hFTUEnXCJcbiAgICBdO1xuICAgIGlmIChvcHRpb25zLnNraXAgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLnNraXApICYmIG9wdGlvbnMuc2tpcC5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHNjaGVtYU5hbWUgb2Ygb3B0aW9ucy5za2lwKSB7XG4gICAgICAgIHNjaGVtYXNUb1NraXAucHVzaCh0aGlzLmVzY2FwZShzY2hlbWFOYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIFNDSEVNQV9OQU1FIGFzIHNjaGVtYV9uYW1lXCIsXG4gICAgICBcIkZST00gSU5GT1JNQVRJT05fU0NIRU1BLlNDSEVNQVRBXCIsXG4gICAgICBgV0hFUkUgU0NIRU1BX05BTUUgTk9UIElOICgke3NjaGVtYXNUb1NraXAuam9pbihcIiwgXCIpfSlgLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoZGF0YWJhc2UpIHtcbiAgICBsZXQgcXVlcnkgPSBcIlNFTEVDVCBUQUJMRV9OQU1FLCBUQUJMRV9TQ0hFTUEgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSdcIjtcbiAgICBpZiAoZGF0YWJhc2UpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoZGF0YWJhc2UpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ICs9IFwiIEFORCBUQUJMRV9TQ0hFTUEgTk9UIElOICgnTVlTUUwnLCAnSU5GT1JNQVRJT05fU0NIRU1BJywgJ1BFUkZPUk1BTkNFX1NDSEVNQScpXCI7XG4gICAgfVxuICAgIHJldHVybiBgJHtxdWVyeX07YDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgXCJgXCIpLCBcImBcIik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gTWFyaWFEQlF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mariadb\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      results = await connection.query(this.sql, parameters);\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = new Array(data.affectedRows);\n          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;\n          for (let i = 0; i < data.affectedRows; i++) {\n            result[i] = { [pkField]: startId + i };\n          }\n          return [result, data.affectedRows];\n        }\n        return [data[this.getInsertIdField()], data.affectedRows];\n      }\n    }\n    if (this.isSelectQuery()) {\n      this.handleJsonSelectQuery(data);\n      return this.handleSelectQuery(data);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isRawQuery()) {\n      const meta = data.meta;\n      delete data.meta;\n      return [data, meta];\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toLowerCase().startsWith(\"enum\") ? _result.Type.replace(/^enum/i, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    return result;\n  }\n  handleJsonSelectQuery(rows) {\n    if (!this.model || !this.model.fieldRawAttributesMap) {\n      return;\n    }\n    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {\n      const modelField = this.model.fieldRawAttributesMap[_field];\n      if (modelField.type instanceof DataTypes.JSON) {\n        rows = rows.map((row) => {\n          if (row[modelField.fieldName] && typeof row[modelField.fieldName] === \"string\" && !this.connection.info.hasMinVersion(10, 5, 2)) {\n            row[modelField.fieldName] = JSON.parse(row[modelField.fieldName]);\n          }\n          if (DataTypes.JSON.parse) {\n            return DataTypes.JSON.parse(modelField, this.sequelize.options, row[modelField.fieldName]);\n          }\n          return row;\n        });\n      }\n    }\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MariaDB Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    switch (err.errno) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?\\s.*$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: err.errno === ER_ROW_IS_REFERENCED ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => ({\n      tableName: resultSet.TABLE_NAME,\n      schema: resultSet.TABLE_SCHEMA\n    }));\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.Key_name === \"PRIMARY\",\n          fields: [],\n          name: item.Key_name,\n          tableName: item.Table,\n          unique: item.Non_unique !== 1,\n          type: item.Index_type\n        };\n        result.push(currItem);\n      }\n      currItem.fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n    });\n    return result;\n  }\n}\nmodule.exports = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbWFyaWFkYi9xdWVyeS5qcz9kMzk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgQWJzdHJhY3RRdWVyeSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeVwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBFUl9EVVBfRU5UUlkgPSAxMDYyO1xuY29uc3QgRVJfREVBRExPQ0sgPSAxMjEzO1xuY29uc3QgRVJfUk9XX0lTX1JFRkVSRU5DRUQgPSAxNDUxO1xuY29uc3QgRVJfTk9fUkVGRVJFTkNFRF9ST1cgPSAxNDUyO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOm1hcmlhZGJcIik7XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIF9fc3ByZWFkVmFsdWVzKHsgc2hvd1dhcm5pbmdzOiBmYWxzZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0gW107XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlc18pID0+IHtcbiAgICAgIGlmICh2YWx1ZXNfW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBiaW5kUGFyYW0ucHVzaCh2YWx1ZXNfW2tleV0pO1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtLmxlbmd0aCA+IDAgPyBiaW5kUGFyYW0gOiB2b2lkIDBdO1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2hvd1dhcm5pbmdzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zaG93V2FybmluZ3MgfHwgb3B0aW9ucy5zaG93V2FybmluZ3M7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgZGVidWcoXCJwYXJhbWV0ZXJzKCVqKVwiLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgY29uc3QgZXJyRm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IGNvbm5lY3Rpb24ucXVlcnkodGhpcy5zcWwsIHBhcmFtZXRlcnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBlcnJvci5lcnJubyA9PT0gRVJfREVBRExPQ0spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvcHRpb25zLnRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yXykge1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgPSBcInJvbGxiYWNrXCI7XG4gICAgICB9XG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IsIGVyckZvclN0YWNrLnN0YWNrKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gICAgaWYgKHNob3dXYXJuaW5ncyAmJiByZXN1bHRzICYmIHJlc3VsdHMud2FybmluZ1N0YXR1cyA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nV2FybmluZ3MocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhLmFmZmVjdGVkUm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3MgPT09IDFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkoZGF0YS5hZmZlY3RlZFJvd3MpO1xuICAgICAgICAgIGNvbnN0IHBrRmllbGQgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuYWZmZWN0ZWRSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHsgW3BrRmllbGRdOiBzdGFydElkICsgaSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV0sIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICB0aGlzLmhhbmRsZUpzb25TZWxlY3RRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBkYXRhLm1ldGE7XG4gICAgICBkZWxldGUgZGF0YS5tZXRhO1xuICAgICAgcmV0dXJuIFtkYXRhLCBtZXRhXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpIHx8IHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICByZXN1bHRbX3Jlc3VsdC5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImVudW1cIikgPyBfcmVzdWx0LlR5cGUucmVwbGFjZSgvXmVudW0vaSwgXCJFTlVNXCIpIDogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk51bGwgPT09IFwiWUVTXCIsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXkgPT09IFwiUFJJXCIsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIFwiRXh0cmFcIikgJiYgX3Jlc3VsdC5FeHRyYS50b0xvd2VyQ2FzZSgpID09PSBcImF1dG9faW5jcmVtZW50XCIsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50ID8gX3Jlc3VsdC5Db21tZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVKc29uU2VsZWN0UXVlcnkocm93cykge1xuICAgIGlmICghdGhpcy5tb2RlbCB8fCAhdGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBfZmllbGQgb2YgT2JqZWN0LmtleXModGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXApKSB7XG4gICAgICBjb25zdCBtb2RlbEZpZWxkID0gdGhpcy5tb2RlbC5maWVsZFJhd0F0dHJpYnV0ZXNNYXBbX2ZpZWxkXTtcbiAgICAgIGlmIChtb2RlbEZpZWxkLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICByb3dzID0gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGlmIChyb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdICYmIHR5cGVvZiByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdID09PSBcInN0cmluZ1wiICYmICF0aGlzLmNvbm5lY3Rpb24uaW5mby5oYXNNaW5WZXJzaW9uKDEwLCA1LCAyKSkge1xuICAgICAgICAgICAgcm93W21vZGVsRmllbGQuZmllbGROYW1lXSA9IEpTT04ucGFyc2Uocm93W21vZGVsRmllbGQuZmllbGROYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChEYXRhVHlwZXMuSlNPTi5wYXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGFUeXBlcy5KU09OLnBhcnNlKG1vZGVsRmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9nV2FybmluZ3MocmVzdWx0cykge1xuICAgIGNvbnN0IHdhcm5pbmdSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW4oXCJTSE9XIFdBUk5JTkdTXCIpO1xuICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYE1hcmlhREIgV2FybmluZ3MgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogYDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgX3dhcm5pbmdSb3cgb2Ygd2FybmluZ1Jlc3VsdHMpIHtcbiAgICAgIGlmIChfd2FybmluZ1JvdyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBfd2FybmluZ1Jvd1tTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF93YXJuaW5nUmVzdWx0IG9mIF93YXJuaW5nUm93KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3dhcm5pbmdSZXN1bHQsIFwiTWVzc2FnZVwiKSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goX3dhcm5pbmdSZXN1bHQuTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBfb2JqZWN0S2V5IG9mIF93YXJuaW5nUmVzdWx0LmtleXMoKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChbX29iamVjdEtleSwgX3dhcm5pbmdSZXN1bHRbX29iamVjdEtleV1dLmpvaW4oXCI6IFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VxdWVsaXplLmxvZyh3YXJuaW5nTWVzc2FnZSArIG1lc3NhZ2VzLmpvaW4oXCI7IFwiKSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSB7XG4gICAgc3dpdGNoIChlcnIuZXJybm8pIHtcbiAgICAgIGNhc2UgRVJfRFVQX0VOVFJZOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0R1cGxpY2F0ZSBlbnRyeSAnKFtcXHNcXFNdKiknIGZvciBrZXkgJz8oKC58XFxzKSo/KSc/XFxzLiokLyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChcIi1cIikgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkS2V5ID0gbWF0Y2ggPyBtYXRjaFsyXSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRWYWwgPSBtYXRjaCA/IG1hdGNoWzFdIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1tmaWVsZEtleV07XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBpZiAodW5pcXVlS2V5Lm1zZylcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KHVuaXF1ZUtleS5maWVsZHMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkS2V5XSA9IGZpZWxkVmFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBFUl9ST1dfSVNfUkVGRVJFTkNFRDpcbiAgICAgIGNhc2UgRVJfTk9fUkVGRVJFTkNFRF9ST1c6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvQ09OU1RSQUlOVCAoW2BcIl0pKC4qKVxcMSBGT1JFSUdOIEtFWSBcXChcXDEoLiopXFwxXFwpIFJFRkVSRU5DRVMgXFwxKC4qKVxcMSBcXChcXDEoLiopXFwxXFwpLyk7XG4gICAgICAgIGNvbnN0IHF1b3RlQ2hhciA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcImBcIjtcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWF0Y2ggPyBtYXRjaFszXS5zcGxpdChuZXcgUmVnRXhwKGAke3F1b3RlQ2hhcn0sICoke3F1b3RlQ2hhcn1gKSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIHJlbHR5cGU6IGVyci5lcnJubyA9PT0gRVJfUk9XX0lTX1JFRkVSRU5DRUQgPyBcInBhcmVudFwiIDogXCJjaGlsZFwiLFxuICAgICAgICAgIHRhYmxlOiBtYXRjaCA/IG1hdGNoWzRdIDogdm9pZCAwLFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzICYmIGZpZWxkcy5sZW5ndGggJiYgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkc1swXV0gfHwgdm9pZCAwLFxuICAgICAgICAgIGluZGV4OiBtYXRjaCA/IG1hdGNoWzJdIDogdm9pZCAwLFxuICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdFNldCkgPT4gKHtcbiAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICB9KSk7XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgbGV0IGN1cnJJdGVtO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKCFjdXJySXRlbSB8fCBjdXJySXRlbS5uYW1lICE9PSBpdGVtLktleV9uYW1lKSB7XG4gICAgICAgIGN1cnJJdGVtID0ge1xuICAgICAgICAgIHByaW1hcnk6IGl0ZW0uS2V5X25hbWUgPT09IFwiUFJJTUFSWVwiLFxuICAgICAgICAgIGZpZWxkczogW10sXG4gICAgICAgICAgbmFtZTogaXRlbS5LZXlfbmFtZSxcbiAgICAgICAgICB0YWJsZU5hbWU6IGl0ZW0uVGFibGUsXG4gICAgICAgICAgdW5pcXVlOiBpdGVtLk5vbl91bmlxdWUgIT09IDEsXG4gICAgICAgICAgdHlwZTogaXRlbS5JbmRleF90eXBlXG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJJdGVtKTtcbiAgICAgIH1cbiAgICAgIGN1cnJJdGVtLmZpZWxkc1tpdGVtLlNlcV9pbl9pbmRleCAtIDFdID0ge1xuICAgICAgICBhdHRyaWJ1dGU6IGl0ZW0uQ29sdW1uX25hbWUsXG4gICAgICAgIGxlbmd0aDogaXRlbS5TdWJfcGFydCB8fCB2b2lkIDAsXG4gICAgICAgIG9yZGVyOiBpdGVtLkNvbGxhdGlvbiA9PT0gXCJBXCIgPyBcIkFTQ1wiIDogdm9pZCAwXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  AsyncQueueError: () => AsyncQueueError,\n  default: () => async_queue_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ../../errors/base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ../../errors/connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AsyncQueueError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n}\nclass AsyncQueue {\n  constructor() {\n    __publicField(this, \"previous\");\n    __publicField(this, \"closed\");\n    __publicField(this, \"rejectCurrent\");\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {\n    };\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could finish executing\")));\n  }\n  enqueue(asyncFunction) {\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could be executed\")));\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\nvar async_queue_default = AsyncQueue;\n//# sourceMappingURL=async-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHdGQUF5QjtBQUNwRSx5Q0FBeUMsbUJBQU8sQ0FBQyxvR0FBK0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvYXN5bmMtcXVldWUuanM/NWUzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBBc3luY1F1ZXVlRXJyb3I6ICgpID0+IEFzeW5jUXVldWVFcnJvcixcbiAgZGVmYXVsdDogKCkgPT4gYXN5bmNfcXVldWVfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi8uLi9lcnJvcnMvYmFzZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi8uLi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBBc3luY1F1ZXVlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQXN5bmNRdWV1ZUVycm9yXCI7XG4gIH1cbn1cbmNsYXNzIEFzeW5jUXVldWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJldmlvdXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNsb3NlZFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVqZWN0Q3VycmVudFwiKTtcbiAgICB0aGlzLnByZXZpb3VzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlamVjdEN1cnJlbnQgPSAoKSA9PiB7XG4gICAgfTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5yZWplY3RDdXJyZW50KG5ldyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0KG5ldyBBc3luY1F1ZXVlRXJyb3IoXCJ0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGlzIHF1ZXJ5IGNvdWxkIGZpbmlzaCBleGVjdXRpbmdcIikpKTtcbiAgfVxuICBlbnF1ZXVlKGFzeW5jRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMucHJldmlvdXMudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMucmVqZWN0Q3VycmVudCA9IHJlamVjdDtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdChuZXcgQXN5bmNRdWV1ZUVycm9yKFwidGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgdGhpcyBxdWVyeSBjb3VsZCBiZSBleGVjdXRlZFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luY0Z1bmN0aW9uKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBhc3luY19xdWV1ZV9kZWZhdWx0ID0gQXN5bmNRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLXF1ZXVlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst AsyncQueue = (__webpack_require__(/*! ./async-queue */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\")[\"default\"]);\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mssql);\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n        const connectHandler = (error) => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error)\n            return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n        const errorHandler = (error) => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", (error) => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EAFNOSUPPORT\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n    connection.queue.close();\n    return new Promise((resolve) => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixrQ0FBa0MsbUJBQU8sQ0FBQyxrSEFBZ0M7QUFDMUUsbUJBQW1CLHlIQUFnQztBQUNuRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxrQkFBa0IsdUdBQWlDO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9jb25uZWN0aW9uLW1hbmFnZXIuanM/OTRkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgQXN5bmNRdWV1ZSA9IHJlcXVpcmUoXCIuL2FzeW5jLXF1ZXVlXCIpLmRlZmF1bHQ7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5tc3NxbDtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwibXNzcWxcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOm1zc3FsXCIpO1xuY29uc3QgZGVidWdUZWRpb3VzID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246bXNzcWw6dGVkaW91c1wiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAxNDMzO1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcInRlZGlvdXNcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSB7XG4gICAgICBzZXJ2ZXI6IGNvbmZpZy5ob3N0LFxuICAgICAgYXV0aGVudGljYXRpb246IHtcbiAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICB1c2VyTmFtZTogY29uZmlnLnVzZXJuYW1lIHx8IHZvaWQgMCxcbiAgICAgICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkIHx8IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwb3J0OiBwYXJzZUludChjb25maWcucG9ydCwgMTApLFxuICAgICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgICB0cnVzdFNlcnZlckNlcnRpZmljYXRlOiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMuaW5zdGFuY2VOYW1lKSB7XG4gICAgICAgIGRlbGV0ZSBjb25uZWN0aW9uQ29uZmlnLm9wdGlvbnMucG9ydDtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMuYXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uQ29uZmlnLmF1dGhlbnRpY2F0aW9uLCBjb25maWcuZGlhbGVjdE9wdGlvbnMuYXV0aGVudGljYXRpb24pO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihjb25uZWN0aW9uQ29uZmlnLm9wdGlvbnMsIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgdGhpcy5saWIuQ29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc3RhdGUgPT09IGNvbm5lY3Rpb24uU1RBVEUuSU5JVElBTElaRUQpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uLnF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICAgICAgY29ubmVjdGlvbi5saWIgPSB0aGlzLmxpYjtcbiAgICAgICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGJ5IHJlbW90ZSBzZXJ2ZXJcIikpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoXCJlbmRcIiwgZW5kSGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZShcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiRVNPQ0tFVFwiOlxuICAgICAgICAgICAgY2FzZSBcIkVDT05OUkVTRVRcIjpcbiAgICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLm9uKFwiZGVidWdcIiwgZGVidWdUZWRpb3VzLmxvZy5iaW5kKGRlYnVnVGVkaW91cykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFlcnJvci5jb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICBjYXNlIFwiRVNPQ0tFVFwiOlxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFSE9TVFVOUkVBQ0hcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjb25uZWN0IEVORVRVTlJFQUNIXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFQUREUk5PVEFWQUlMXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFQUZOT1NVUFBPUlRcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJnZXRhZGRyaW5mbyBFTk9URk9VTkRcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRUNPTk5SRUZVU0VEXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICAgIGNhc2UgXCJFUl9BQ0NFU1NfREVOSUVEX0VSUk9SXCI6XG4gICAgICAgIGNhc2UgXCJFTE9HSU5cIjpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycm9yKTtcbiAgICAgICAgY2FzZSBcIkVJTlZBTFwiOlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29ubmVjdGlvbi5xdWV1ZS5jbG9zZSgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29ubmVjdGlvbi5vbihcImVuZFwiLCByZXNvbHZlKTtcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBjbG9zZWRcIik7XG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIChjb25uZWN0aW9uLmxvZ2dlZEluIHx8IGNvbm5lY3Rpb24uc3RhdGUubmFtZSA9PT0gXCJMb2dnZWRJblwiKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.mssql = [43];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  BaseTypes.TINYINT.types.mssql = [30];\n  BaseTypes.SMALLINT.types.mssql = [34];\n  BaseTypes.MEDIUMINT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  BaseTypes.GEOMETRY.types.mssql = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.\");\n          return \"VARBINARY(256)\";\n        }\n        warn(\"MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.\");\n      }\n      return \"VARBINARY(MAX)\";\n    }\n    _hexify(hex) {\n      return `0x${hex}`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        return `NVARCHAR(${this._length})`;\n      }\n      return `BINARY(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._stringify(value);\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.\");\n          return \"NVARCHAR(256)\";\n        }\n        warn(\"MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.\");\n      }\n      return \"NVARCHAR(MAX)\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BIT\";\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36)\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"GETDATE()\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"DATETIMEOFFSET\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"MSSQL does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"MSSQL does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"MSSQL does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWEseUJBQXlCLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvZGF0YS10eXBlcy5qcz9kYTliIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh2b2lkIDAsIFwiaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczE4Nzc1MiUyOHY9c3FsLjExMCUyOS5hc3B4XCIpO1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl9sZW5ndGggfHwgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggfHwgZGF0YVR5cGUuX3Vuc2lnbmVkIHx8IGRhdGFUeXBlLl96ZXJvZmlsbCkge1xuICAgICAgd2FybihgTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIG9wdGlvbnMuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREFURS50eXBlcy5tc3NxbCA9IFs0M107XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubXNzcWwgPSBbMjMxLCAxNzNdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5tc3NxbCA9IFsxNzVdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5tc3NxbCA9IFszMF07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5tc3NxbCA9IFszNF07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubXNzcWwgPSBbMzhdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5tc3NxbCA9IFsxMDldO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5tc3NxbCA9IFs0MV07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5tc3NxbCA9IFs0MF07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm1zc3FsID0gWzEwNF07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm1zc3FsID0gWzE2NV07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm1zc3FsID0gWzEwNl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIGNsYXNzIEJMT0IgZXh0ZW5kcyBCYXNlVHlwZXMuQkxPQiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW55XCIpIHtcbiAgICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIHdpdGggdGhlIGBsZW5ndGhgID0gYHRpbnlgIG9wdGlvbi4gYFZBUkJJTkFSWSgyNTYpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgICAgcmV0dXJuIFwiVkFSQklOQVJZKDI1NilcIjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIHdpdGggdGhlIGBsZW5ndGhgIG9wdGlvbi4gYFZBUkJJTkFSWShNQVgpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJWQVJCSU5BUlkoTUFYKVwiO1xuICAgIH1cbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgcmV0dXJuIGAweCR7aGV4fWA7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNUUklORyBleHRlbmRzIEJhc2VUeXBlcy5TVFJJTkcge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKCF0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBOVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBCTE9CLnByb3RvdHlwZS5fc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl9iaW5hcnkgPyBCdWZmZXIuZnJvbSh2YWx1ZSkgOiB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIFNUUklORy5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGgudG9Mb3dlckNhc2UoKSA9PT0gXCJ0aW55XCIpIHtcbiAgICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggdGhlIGBsZW5ndGhgID0gYHRpbnlgIG9wdGlvbi4gYE5WQVJDSEFSKDI1NilgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICByZXR1cm4gXCJOVkFSQ0hBUigyNTYpXCI7XG4gICAgICAgIH1cbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIHRoZSBgbGVuZ3RoYCBvcHRpb24uIGBOVkFSQ0hBUihNQVgpYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJOVkFSQ0hBUihNQVgpXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCSVRcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNIQVIoMzYpXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIE5PVyBleHRlbmRzIEJhc2VUeXBlcy5OT1cge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiR0VUREFURSgpXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJEQVRFVElNRU9GRlNFVFwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgUkVBTCB3aXRoIG9wdGlvbnMuIFBsYWluIGBSRUFMYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBGTE9BVCBleHRlbmRzIEJhc2VUeXBlcy5GTE9BVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fZGVjaW1hbHMpIHtcbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgd2l0aCBkZWNpbWFscy4gUGxhaW4gYEZMT0FUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB1bnNpZ25lZC4gYFVOU0lHTkVEYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHplcm9maWxsLiBgWkVST0ZJTExgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJWQVJDSEFSKDI1NSlcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBCTE9CLFxuICAgIEJPT0xFQU4sXG4gICAgRU5VTSxcbiAgICBTVFJJTkcsXG4gICAgVVVJRCxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIE5PVyxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIFJFQUwsXG4gICAgRkxPQVQsXG4gICAgVEVYVFxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mssql);\nconst { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js\");\nclass MssqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nMssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: true,\n  \"DEFAULT VALUES\": true,\n  \"LIMIT ON UPDATE\": true,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: {\n    output: true\n  },\n  schemas: true,\n  autoIncrement: {\n    identityInsert: true,\n    defaultValue: false,\n    update: false\n  },\n  constraints: {\n    restrict: false,\n    default: true\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: true,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nMssqlDialect.prototype.defaultVersion = \"12.0.2000\";\nMssqlDialect.prototype.Query = Query;\nMssqlDialect.prototype.name = \"mssql\";\nMssqlDialect.prototype.TICK_CHAR = '\"';\nMssqlDialect.prototype.TICK_CHAR_LEFT = \"[\";\nMssqlDialect.prototype.TICK_CHAR_RIGHT = \"]\";\nMssqlDialect.prototype.DataTypes = DataTypes;\nmodule.exports = MssqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFtQjtBQUNsRCxrQkFBa0IsdUdBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2luZGV4LmpzPzkwMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubXNzcWw7XG5jb25zdCB7IE1TU3FsUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIE1zc3FsRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE1TU3FsUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgREVGQVVMVDogdHJ1ZSxcbiAgXCJERUZBVUxUIFZBTFVFU1wiOiB0cnVlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiB0cnVlLFxuICBcIk9SREVSIE5VTExTXCI6IGZhbHNlLFxuICBsb2NrOiBmYWxzZSxcbiAgdHJhbnNhY3Rpb25zOiB0cnVlLFxuICBtaWdyYXRpb25zOiBmYWxzZSxcbiAgcmV0dXJuVmFsdWVzOiB7XG4gICAgb3V0cHV0OiB0cnVlXG4gIH0sXG4gIHNjaGVtYXM6IHRydWUsXG4gIGF1dG9JbmNyZW1lbnQ6IHtcbiAgICBpZGVudGl0eUluc2VydDogdHJ1ZSxcbiAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIHVwZGF0ZTogZmFsc2VcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogZmFsc2UsXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB0eXBlOiB0cnVlLFxuICAgIHVzaW5nOiBmYWxzZSxcbiAgICB3aGVyZTogdHJ1ZVxuICB9LFxuICBOVU1FUklDOiB0cnVlLFxuICB0bXBUYWJsZVRyaWdnZXI6IHRydWVcbn0pO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiMTIuMC4yMDAwXCI7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcIm1zc3FsXCI7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gXCJbXCI7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFwiXVwiO1xuTXNzcWxEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5tb2R1bGUuZXhwb3J0cyA9IE1zc3FsRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst TableHints = __webpack_require__(/*! ../../table-hints */ \"(rsc)/./node_modules/sequelize/lib/table-hints.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({ collate: null }, options);\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : \"\";\n    return [\n      \"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"CREATE DATABASE\",\n      this.quoteIdentifier(databaseName),\n      `${collation};`,\n      \"END;\"\n    ].join(\" \");\n  }\n  dropDatabaseQuery(databaseName) {\n    return [\n      \"IF EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"DROP DATABASE\",\n      this.quoteIdentifier(databaseName),\n      \";\",\n      \"END;\"\n    ].join(\" \");\n  }\n  createSchema(schema) {\n    return [\n      \"IF NOT EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      wrapSingleQuote(schema),\n      \")\",\n      \"BEGIN\",\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      \"IF EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      quotedSchema,\n      \")\",\n      \"BEGIN\",\n      \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\",\n      \"DECLARE @cascade TABLE (\",\n      \"id INT NOT NULL IDENTITY PRIMARY KEY,\",\n      \"ms_sql NVARCHAR(2000) NOT NULL );\",\n      \"INSERT INTO @cascade ( ms_sql )\",\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      \"FROM sys.objects o\",\n      \"JOIN sys.schemas s on o.schema_id = s.schema_id\",\n      \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\",\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \",\n      quotedSchema,\n      \"ORDER BY o.type ASC;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"WHILE @id IS NOT NULL\",\n      \"BEGIN\",\n      \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\",\n      \"BEGIN CATCH BREAK; THROW; END CATCH;\",\n      \"DELETE FROM @cascade WHERE id = @id;\",\n      \"SELECT @id = NULL, @ms_sql = NULL;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"END\",\n      \"EXEC sp_executesql N'DROP SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      \")\",\n      \"AND\",\n      '\"s\".\"name\" NOT LIKE',\n      \"'db_%'\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return [\n      \"DECLARE @ms_ver NVARCHAR(20);\",\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(\" \");\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = {}, attributesClauseParts = [];\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          dataType = commentMatch[1];\n        }\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`);\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(\", \")})`,\n      \";\",\n      commentStr\n    ]);\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      \"SELECT\",\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      \"FROM\",\n      \"INFORMATION_SCHEMA.TABLES t\",\n      \"INNER JOIN\",\n      \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\",\n      \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \",\n      \"cu.column_name, tc.CONSTRAINT_TYPE \",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \",\n      \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \",\n      \"and tc.constraint_name=cu.constraint_name \",\n      \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \",\n      \"ON pk.table_schema=c.table_schema \",\n      \"AND pk.table_name=c.table_name \",\n      \"AND pk.column_name=c.column_name \",\n      \"INNER JOIN sys.columns AS sc\",\n      \"ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name\",\n      \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\",\n      \"AND prop.minor_id = sc.column_id\",\n      \"AND prop.name = 'MS_Description'\",\n      \"WHERE t.TABLE_NAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n    return sql;\n  }\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || \"dbo\";\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      \"DROP TABLE\",\n      quoteTbl,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    let commentStr = \"\";\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      delete dataType[\"comment\"];\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: \"addColumn\" }),\n      \";\",\n      commentStr\n    ]);\n  }\n  commentTemplate(comment, table, column) {\n    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [], constraintString = [];\n    let commentString = \"\";\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes(\"COMMENT \")) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        definition = commentMatch[1];\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, \"\")}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\",\n      commentString\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      \"EXEC sp_rename\",\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      \";\"\n    ]);\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false, outputFragment = \"\";\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach((attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach((attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key])).join(\",\")})`);\n      });\n      const quotedAttributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n      allQueries.push((tupleStr) => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map((v) => typeof v === \"string\" ? v : v(tupleStr)).join(\";\");\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(\";\");\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n    }\n    return sql;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    identityAttrs.forEach((key) => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n      }\n    });\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (typeof clause[key] === \"undefined\" || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => !identityAttrs.includes(key)).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(\", \")}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments([\n      \"DELETE\",\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      \"FROM\",\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      \";\",\n      \"SELECT @@ROWCOUNT AS AFFECTEDROWS\",\n      \";\"\n    ]);\n  }\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n        attribute.onUpdate = \"\";\n      }\n    }\n    let template;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    template = attribute.type.toString();\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" IDENTITY(1,1)\";\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n          attribute.onUpdate = \"\";\n        }\n      }\n      if (key && !attribute.field)\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${\"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \"}${catalogName ? `constraintCatalog = '${catalogName}', ` : \"\"}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : \"\"}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : \"\"}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;\n  }\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      \"WHERE\",\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      \"AND\",\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      \"SELECT K.TABLE_NAME AS tableName,\",\n      \"K.COLUMN_NAME AS columnName,\",\n      \"K.CONSTRAINT_NAME AS constraintName\",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\",\n      \"ON C.TABLE_NAME = K.TABLE_NAME\",\n      \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\",\n      \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\",\n      \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\",\n      \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\",\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      \";\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      \"SELECT name FROM sys.default_constraints\",\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      \";\"\n    ]);\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifier(constraintName),\n      \";\"\n    ]);\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n    if (isSQLServer2008 && options.offset) {\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n      const tmpTable = mainTableAs || \"OffsetTable\";\n      if (options.include) {\n        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n        return Utils.joinSQLFragments([\n          \"SELECT TOP 100 PERCENT\",\n          attributes.join(\", \"),\n          \"FROM (\",\n          [\n            \"SELECT\",\n            options.limit && `TOP ${options.limit}`,\n            \"* FROM (\",\n            [\n              \"SELECT ROW_NUMBER() OVER (\",\n              [\n                \"ORDER BY\",\n                orders.mainQueryOrder.join(\", \")\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                \"SELECT DISTINCT\",\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        \"SELECT TOP 100 PERCENT\",\n        attributes.join(\", \"),\n        \"FROM (\",\n        [\n          \"SELECT\",\n          options.limit && `TOP ${options.limit}`,\n          \"* FROM (\",\n          [\n            \"SELECT ROW_NUMBER() OVER (\",\n            [\n              \"ORDER BY\",\n              orders.mainQueryOrder.join(\", \")\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(\", \"),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n  addLimitAndOffset(options, model) {\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n      return \"\";\n    }\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = \"\";\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map((order) => {\n            const value = Array.isArray(order) ? order[0] : order;\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some((fieldName) => fieldName === (primaryKey.col || primaryKey));\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n            fragment += tablePkFragment;\n          }\n        }\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, \"\")}]`;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\nmodule.exports = MSSQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLDRHQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5RUFBeUU7QUFDekU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QywwQkFBMEIsT0FBTyxVQUFVO0FBQzNDLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVHO0FBQ0EsWUFBWTtBQUNaLDBDQUEwQyw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSxtREFBbUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ3BLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkJBQTJCLElBQUksa0JBQWtCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QyxzQkFBc0IsaUJBQWlCLEdBQUcsaUNBQWlDO0FBQzNFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCLElBQUksd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsd0JBQXdCLHFCQUFxQix3QkFBd0I7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUIsd0ZBQXdGLDRCQUE0QiwyQ0FBMkMsOEJBQThCO0FBQ2pTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlLElBQUksNENBQTRDO0FBQzdHLFFBQVE7QUFDUiwyQkFBMkIsZ0JBQWdCLEVBQUUsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCLEdBQUcsV0FBVztBQUNuRCxVQUFVLFFBQVE7QUFDbEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLEVBQUUsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5RixPQUFPO0FBQ1A7QUFDQSxtREFBbUQsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixTQUFTLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsZ0RBQWdELGFBQWEsSUFBSSxFQUFFLGlCQUFpQixzQkFBc0IsYUFBYSxJQUFJO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLGlCQUFpQixHQUFHLElBQUk7QUFDdkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixHQUFHLEtBQUssSUFBSSxNQUFNO0FBQ25ELEtBQUs7QUFDTCw2RkFBNkYsaUNBQWlDO0FBQzlILDhCQUE4QixpQkFBaUIsV0FBVyxvQkFBb0I7QUFDOUUsOEJBQThCLGlCQUFpQixvQkFBb0Isa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNoTCxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZSwyQkFBMkI7QUFDekc7QUFDQSxxQ0FBcUMsaUJBQWlCLElBQUksRUFBRSxPQUFPLHNCQUFzQixpQkFBaUIsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQixFQUFFO0FBQzlFO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssaUNBQWlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QyxLQUFLO0FBQ3pFO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUUsRUFBRSxzQ0FBc0MsWUFBWSxVQUFVLCtHQUErRyxpQ0FBaUMsWUFBWSxVQUFVLDZFQUE2RSxzQ0FBc0MsWUFBWSxVQUFVO0FBQzViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBOEMsaUJBQWlCLDJCQUEyQjtBQUMzRztBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RCw0QkFBNEIsVUFBVTtBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pELGtGQUFrRixjQUFjO0FBQ2hHLG9DQUFvQyxZQUFZO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0RBQWtEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxVQUFVLFFBQVEsS0FBSyxTQUFTO0FBQzVEO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBLG9CQUFvQixVQUFVLGtCQUFrQixPQUFPO0FBQ3ZEO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsS0FBSyxTQUFTO0FBQzFELDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0Esa0JBQWtCLFVBQVUsa0JBQWtCLE9BQU87QUFDckQ7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLDJCQUEyQixZQUFZO0FBQ3ZDLHFFQUFxRSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDLEdBQUcsaUNBQWlDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LWdlbmVyYXRvci5qcz8wZDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgVGFibGVIaW50cyA9IHJlcXVpcmUoXCIuLi8uLi90YWJsZS1oaW50c1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgcmFuZG9tQnl0ZXMgPSByZXF1aXJlKFwiY3J5cHRvXCIpLnJhbmRvbUJ5dGVzO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IHRocm93TWV0aG9kVW5kZWZpbmVkID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBtZXRob2QgXCIke21ldGhvZE5hbWV9XCIgaXMgbm90IGRlZmluZWQhIFBsZWFzZSBhZGQgaXQgdG8geW91ciBzcWwgZGlhbGVjdC5gKTtcbn07XG5jbGFzcyBNU1NRTFF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHsgY29sbGF0ZTogbnVsbCB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBjb2xsYXRpb24gPSBvcHRpb25zLmNvbGxhdGUgPyBgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCA6IFwiXCI7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiSUYgTk9UIEVYSVNUUyAoU0VMRUNUICogRlJPTSBzeXMuZGF0YWJhc2VzIFdIRVJFIG5hbWUgPVwiLFxuICAgICAgd3JhcFNpbmdsZVF1b3RlKGRhdGFiYXNlTmFtZSksXG4gICAgICBcIilcIixcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiQ1JFQVRFIERBVEFCQVNFXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgYCR7Y29sbGF0aW9ufTtgLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBbXG4gICAgICBcIklGIEVYSVNUUyAoU0VMRUNUICogRlJPTSBzeXMuZGF0YWJhc2VzIFdIRVJFIG5hbWUgPVwiLFxuICAgICAgd3JhcFNpbmdsZVF1b3RlKGRhdGFiYXNlTmFtZSksXG4gICAgICBcIilcIixcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiRFJPUCBEQVRBQkFTRVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJJRiBOT1QgRVhJU1RTIChTRUxFQ1Qgc2NoZW1hX25hbWVcIixcbiAgICAgIFwiRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGFcIixcbiAgICAgIFwiV0hFUkUgc2NoZW1hX25hbWUgPVwiLFxuICAgICAgd3JhcFNpbmdsZVF1b3RlKHNjaGVtYSksXG4gICAgICBcIilcIixcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiRVhFQyBzcF9leGVjdXRlc3FsIE4nQ1JFQVRFIFNDSEVNQVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIFwiOydcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IHF1b3RlZFNjaGVtYSA9IHdyYXBTaW5nbGVRdW90ZShzY2hlbWEpO1xuICAgIHJldHVybiBbXG4gICAgICBcIklGIEVYSVNUUyAoU0VMRUNUIHNjaGVtYV9uYW1lXCIsXG4gICAgICBcIkZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhXCIsXG4gICAgICBcIldIRVJFIHNjaGVtYV9uYW1lID1cIixcbiAgICAgIHF1b3RlZFNjaGVtYSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJERUNMQVJFIEBpZCBJTlQsIEBtc19zcWwgTlZBUkNIQVIoMjAwMCk7XCIsXG4gICAgICBcIkRFQ0xBUkUgQGNhc2NhZGUgVEFCTEUgKFwiLFxuICAgICAgXCJpZCBJTlQgTk9UIE5VTEwgSURFTlRJVFkgUFJJTUFSWSBLRVksXCIsXG4gICAgICBcIm1zX3NxbCBOVkFSQ0hBUigyMDAwKSBOT1QgTlVMTCApO1wiLFxuICAgICAgXCJJTlNFUlQgSU5UTyBAY2FzY2FkZSAoIG1zX3NxbCApXCIsXG4gICAgICBcIlNFTEVDVCBDQVNFIFdIRU4gby50eXBlIElOICgnRicsJ1BLJylcIixcbiAgICAgIFwiVEhFTiBOJ0FMVEVSIFRBQkxFIFsnKyBzLm5hbWUgKyBOJ10uWycgKyBwLm5hbWUgKyBOJ10gRFJPUCBDT05TVFJBSU5UIFsnICsgby5uYW1lICsgTiddJ1wiLFxuICAgICAgXCJFTFNFIE4nRFJPUCBUQUJMRSBbJysgcy5uYW1lICsgTiddLlsnICsgby5uYW1lICsgTiddJyBFTkRcIixcbiAgICAgIFwiRlJPTSBzeXMub2JqZWN0cyBvXCIsXG4gICAgICBcIkpPSU4gc3lzLnNjaGVtYXMgcyBvbiBvLnNjaGVtYV9pZCA9IHMuc2NoZW1hX2lkXCIsXG4gICAgICBcIkxFRlQgT1VURVIgSk9JTiBzeXMub2JqZWN0cyBwIG9uIG8ucGFyZW50X29iamVjdF9pZCA9IHAub2JqZWN0X2lkXCIsXG4gICAgICBcIldIRVJFIG8udHlwZSBJTiAoJ0YnLCAnUEsnLCAnVScpIEFORCBzLm5hbWUgPSBcIixcbiAgICAgIHF1b3RlZFNjaGVtYSxcbiAgICAgIFwiT1JERVIgQlkgby50eXBlIEFTQztcIixcbiAgICAgIFwiU0VMRUNUIFRPUCAxIEBpZCA9IGlkLCBAbXNfc3FsID0gbXNfc3FsIEZST00gQGNhc2NhZGUgT1JERVIgQlkgaWQ7XCIsXG4gICAgICBcIldISUxFIEBpZCBJUyBOT1QgTlVMTFwiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJCRUdJTiBUUlkgRVhFQyBzcF9leGVjdXRlc3FsIEBtc19zcWw7IEVORCBUUllcIixcbiAgICAgIFwiQkVHSU4gQ0FUQ0ggQlJFQUs7IFRIUk9XOyBFTkQgQ0FUQ0g7XCIsXG4gICAgICBcIkRFTEVURSBGUk9NIEBjYXNjYWRlIFdIRVJFIGlkID0gQGlkO1wiLFxuICAgICAgXCJTRUxFQ1QgQGlkID0gTlVMTCwgQG1zX3NxbCA9IE5VTEw7XCIsXG4gICAgICBcIlNFTEVDVCBUT1AgMSBAaWQgPSBpZCwgQG1zX3NxbCA9IG1zX3NxbCBGUk9NIEBjYXNjYWRlIE9SREVSIEJZIGlkO1wiLFxuICAgICAgXCJFTkRcIixcbiAgICAgIFwiRVhFQyBzcF9leGVjdXRlc3FsIE4nRFJPUCBTQ0hFTUFcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSksXG4gICAgICBcIjsnXCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ1NFTEVDVCBcIm5hbWVcIiBhcyBcInNjaGVtYV9uYW1lXCIgRlJPTSBzeXMuc2NoZW1hcyBhcyBzJyxcbiAgICAgICdXSEVSRSBcInNcIi5cIm5hbWVcIiBOT1QgSU4gKCcsXG4gICAgICBcIidJTkZPUk1BVElPTl9TQ0hFTUEnLCAnZGJvJywgJ2d1ZXN0JywgJ3N5cycsICdhcmNoaXZlJ1wiLFxuICAgICAgXCIpXCIsXG4gICAgICBcIkFORFwiLFxuICAgICAgJ1wic1wiLlwibmFtZVwiIE5PVCBMSUtFJyxcbiAgICAgIFwiJ2RiXyUnXCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJERUNMQVJFIEBtc192ZXIgTlZBUkNIQVIoMjApO1wiLFxuICAgICAgXCJTRVQgQG1zX3ZlciA9IFJFVkVSU0UoQ09OVkVSVChOVkFSQ0hBUigyMCksIFNFUlZFUlBST1BFUlRZKCdQcm9kdWN0VmVyc2lvbicpKSk7XCIsXG4gICAgICBcIlNFTEVDVCBSRVZFUlNFKFNVQlNUUklORyhAbXNfdmVyLCBDSEFSSU5ERVgoJy4nLCBAbXNfdmVyKSsxLCAyMCkpIEFTICd2ZXJzaW9uJ1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW10sIGZvcmVpZ25LZXlzID0ge30sIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cyA9IFtdO1xuICAgIGxldCBjb21tZW50U3RyID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBsZXQgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIkNPTU1FTlQgXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChDT01NRU5ULiopJC8pO1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gY29tbWVudE1hdGNoWzJdLnJlcGxhY2UoXCJDT01NRU5UXCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICBjb21tZW50U3RyICs9IHRoaXMuY29tbWVudFRlbXBsYXRlKGNvbW1lbnRUZXh0LCB0YWJsZU5hbWUsIGF0dHIpO1xuICAgICAgICAgIGRhdGFUeXBlID0gY29tbWVudE1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbihcIl9cIil9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYENPTlNUUkFJTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYElGIE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZU5hbWV9JywgJ1UnKSBJUyBOVUxMYCxcbiAgICAgIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9ICgke2F0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5qb2luKFwiLCBcIil9KWAsXG4gICAgICBcIjtcIixcbiAgICAgIGNvbW1lbnRTdHJcbiAgICBdKTtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEpIHtcbiAgICBsZXQgc3FsID0gW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIFwiYy5DT0xVTU5fTkFNRSBBUyAnTmFtZScsXCIsXG4gICAgICBcImMuREFUQV9UWVBFIEFTICdUeXBlJyxcIixcbiAgICAgIFwiYy5DSEFSQUNURVJfTUFYSU1VTV9MRU5HVEggQVMgJ0xlbmd0aCcsXCIsXG4gICAgICBcImMuSVNfTlVMTEFCTEUgYXMgJ0lzTnVsbCcsXCIsXG4gICAgICBcIkNPTFVNTl9ERUZBVUxUIEFTICdEZWZhdWx0JyxcIixcbiAgICAgIFwicGsuQ09OU1RSQUlOVF9UWVBFIEFTICdDb25zdHJhaW50JyxcIixcbiAgICAgIFwiQ09MVU1OUFJPUEVSVFkoT0JKRUNUX0lEKCdbJyArIGMuVEFCTEVfU0NIRU1BICsgJ10uWycgKyBjLlRBQkxFX05BTUUgKyAnXScpLCBjLkNPTFVNTl9OQU1FLCAnSXNJZGVudGl0eScpIGFzICdJc0lkZW50aXR5JyxcIixcbiAgICAgIFwiQ0FTVChwcm9wLnZhbHVlIEFTIE5WQVJDSEFSKSBBUyAnQ29tbWVudCdcIixcbiAgICAgIFwiRlJPTVwiLFxuICAgICAgXCJJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIHRcIixcbiAgICAgIFwiSU5ORVIgSk9JTlwiLFxuICAgICAgXCJJTkZPUk1BVElPTl9TQ0hFTUEuQ09MVU1OUyBjIE9OIHQuVEFCTEVfTkFNRSA9IGMuVEFCTEVfTkFNRSBBTkQgdC5UQUJMRV9TQ0hFTUEgPSBjLlRBQkxFX1NDSEVNQVwiLFxuICAgICAgXCJMRUZUIEpPSU4gKFNFTEVDVCB0Yy50YWJsZV9zY2hlbWEsIHRjLnRhYmxlX25hbWUsIFwiLFxuICAgICAgXCJjdS5jb2x1bW5fbmFtZSwgdGMuQ09OU1RSQUlOVF9UWVBFIFwiLFxuICAgICAgXCJGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UUyB0YyBcIixcbiAgICAgIFwiSk9JTiBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSAgY3UgXCIsXG4gICAgICBcIk9OIHRjLnRhYmxlX3NjaGVtYT1jdS50YWJsZV9zY2hlbWEgYW5kIHRjLnRhYmxlX25hbWU9Y3UudGFibGVfbmFtZSBcIixcbiAgICAgIFwiYW5kIHRjLmNvbnN0cmFpbnRfbmFtZT1jdS5jb25zdHJhaW50X25hbWUgXCIsXG4gICAgICBcImFuZCB0Yy5DT05TVFJBSU5UX1RZUEU9J1BSSU1BUlkgS0VZJykgcGsgXCIsXG4gICAgICBcIk9OIHBrLnRhYmxlX3NjaGVtYT1jLnRhYmxlX3NjaGVtYSBcIixcbiAgICAgIFwiQU5EIHBrLnRhYmxlX25hbWU9Yy50YWJsZV9uYW1lIFwiLFxuICAgICAgXCJBTkQgcGsuY29sdW1uX25hbWU9Yy5jb2x1bW5fbmFtZSBcIixcbiAgICAgIFwiSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBBUyBzY1wiLFxuICAgICAgXCJPTiBzYy5vYmplY3RfaWQgPSBPQkpFQ1RfSUQoJ1snICsgdC5UQUJMRV9TQ0hFTUEgKyAnXS5bJyArIHQuVEFCTEVfTkFNRSArICddJykgQU5EIHNjLm5hbWUgPSBjLmNvbHVtbl9uYW1lXCIsXG4gICAgICBcIkxFRlQgSk9JTiBzeXMuZXh0ZW5kZWRfcHJvcGVydGllcyBwcm9wIE9OIHByb3AubWFqb3JfaWQgPSBzYy5vYmplY3RfaWRcIixcbiAgICAgIFwiQU5EIHByb3AubWlub3JfaWQgPSBzYy5jb2x1bW5faWRcIixcbiAgICAgIFwiQU5EIHByb3AubmFtZSA9ICdNU19EZXNjcmlwdGlvbidcIixcbiAgICAgIFwiV0hFUkUgdC5UQUJMRV9OQU1FID1cIixcbiAgICAgIHdyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICBzcWwgKz0gYEFORCB0LlRBQkxFX1NDSEVNQSA9JHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIHJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcikge1xuICAgIHJldHVybiBgRVhFQyBzcF9yZW5hbWUgJHt0aGlzLnF1b3RlVGFibGUoYmVmb3JlKX0sICR7dGhpcy5xdW90ZVRhYmxlKGFmdGVyKX07YDtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIFRBQkxFX05BTUUsIFRBQkxFX1NDSEVNQSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJztcIjtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgfHwgXCJkYm9cIjtcbiAgICByZXR1cm4gYFNFTEVDVCBUQUJMRV9OQU1FLCBUQUJMRV9TQ0hFTUEgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRScgQU5EIFRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9IEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKHNjaGVtYU5hbWUpfWA7XG4gIH1cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVUYmwgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgSUYgT0JKRUNUX0lEKCcke3F1b3RlVGJsfScsICdVJykgSVMgTk9UIE5VTExgLFxuICAgICAgXCJEUk9QIFRBQkxFXCIsXG4gICAgICBxdW90ZVRibCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICBkYXRhVHlwZS5maWVsZCA9IGtleTtcbiAgICBsZXQgY29tbWVudFN0ciA9IFwiXCI7XG4gICAgaWYgKGRhdGFUeXBlLmNvbW1lbnQgJiYgXy5pc1N0cmluZyhkYXRhVHlwZS5jb21tZW50KSkge1xuICAgICAgY29tbWVudFN0ciA9IHRoaXMuY29tbWVudFRlbXBsYXRlKGRhdGFUeXBlLmNvbW1lbnQsIHRhYmxlLCBrZXkpO1xuICAgICAgZGVsZXRlIGRhdGFUeXBlW1wiY29tbWVudFwiXTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgIFwiQUREXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwgeyBjb250ZXh0OiBcImFkZENvbHVtblwiIH0pLFxuICAgICAgXCI7XCIsXG4gICAgICBjb21tZW50U3RyXG4gICAgXSk7XG4gIH1cbiAgY29tbWVudFRlbXBsYXRlKGNvbW1lbnQsIHRhYmxlLCBjb2x1bW4pIHtcbiAgICByZXR1cm4gYCBFWEVDIHNwX2FkZGV4dGVuZGVkcHJvcGVydHkgQG5hbWUgPSBOJ01TX0Rlc2NyaXB0aW9uJywgQHZhbHVlID0gJHt0aGlzLmVzY2FwZShjb21tZW50KX0sIEBsZXZlbDB0eXBlID0gTidTY2hlbWEnLCBAbGV2ZWwwbmFtZSA9ICdkYm8nLCBAbGV2ZWwxdHlwZSA9IE4nVGFibGUnLCBAbGV2ZWwxbmFtZSA9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGUpfSwgQGxldmVsMnR5cGUgPSBOJ0NvbHVtbicsIEBsZXZlbDJuYW1lID0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihjb2x1bW4pfTtgO1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QIENPTFVNTlwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXSwgY29uc3RyYWludFN0cmluZyA9IFtdO1xuICAgIGxldCBjb21tZW50U3RyaW5nID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgcXVvdGVkQXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiQ09NTUVOVCBcIikpIHtcbiAgICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gZGVmaW5pdGlvbi5tYXRjaCgvXiguKykgKENPTU1FTlQuKikkLyk7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gY29tbWVudE1hdGNoWzJdLnJlcGxhY2UoXCJDT01NRU5UXCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgY29tbWVudFN0cmluZyArPSB0aGlzLmNvbW1lbnRUZW1wbGF0ZShjb21tZW50VGV4dCwgdGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGNvbW1lbnRNYXRjaFsxXTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBjb25zdHJhaW50U3RyaW5nLnB1c2goYEZPUkVJR04gS0VZICgke3F1b3RlZEF0dHJOYW1lfSkgJHtkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgXCJcIil9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyaW5nLnB1c2goYCR7cXVvdGVkQXR0ck5hbWV9ICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyU3RyaW5nLmxlbmd0aCAmJiBgQUxURVIgQ09MVU1OICR7YXR0clN0cmluZy5qb2luKFwiLCBcIil9YCxcbiAgICAgIGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoICYmIGBBREQgJHtjb25zdHJhaW50U3RyaW5nLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgXCI7XCIsXG4gICAgICBjb21tZW50U3RyaW5nXG4gICAgXSk7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbmV3TmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiRVhFQyBzcF9yZW5hbWVcIixcbiAgICAgIGAnJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0uJHthdHRyQmVmb3JlfScsYCxcbiAgICAgIGAnJHtuZXdOYW1lfScsYCxcbiAgICAgIFwiJ0NPTFVNTidcIixcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaGVzLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gW107XG4gICAgY29uc3QgYWxsUXVlcmllcyA9IFtdO1xuICAgIGxldCBuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyID0gZmFsc2UsIG91dHB1dEZyYWdtZW50ID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudDtcbiAgICB9XG4gICAgY29uc3QgZW1wdHlRdWVyeSA9IGBJTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlfSR7b3V0cHV0RnJhZ21lbnR9IERFRkFVTFQgVkFMVUVTYDtcbiAgICBhdHRyVmFsdWVIYXNoZXMuZm9yRWFjaCgoYXR0clZhbHVlSGFzaCkgPT4ge1xuICAgICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMoYXR0clZhbHVlSGFzaCk7XG4gICAgICBjb25zdCBmaXJzdEF0dHIgPSBhdHRyaWJ1dGVzW2ZpZWxkc1swXV07XG4gICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMSAmJiBmaXJzdEF0dHIgJiYgZmlyc3RBdHRyLmF1dG9JbmNyZW1lbnQgJiYgYXR0clZhbHVlSGFzaFtmaWVsZHNbMF1dID09PSBudWxsKSB7XG4gICAgICAgIGFsbFF1ZXJpZXMucHVzaChlbXB0eVF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXy5mb3JPd24oYXR0clZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIGF0dHJpYnV0ZXNba2V5XSAmJiBhdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgIG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsQXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIGF0dHJpYnV0ZXNba2V5XSAmJiBhdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKGFsbEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgYXR0clZhbHVlSGFzaGVzLmZvckVhY2goKGF0dHJWYWx1ZUhhc2gpID0+IHtcbiAgICAgICAgdHVwbGVzLnB1c2goYCgke2FsbEF0dHJpYnV0ZXMubWFwKChrZXkpID0+IHRoaXMuZXNjYXBlKGF0dHJWYWx1ZUhhc2hba2V5XSkpLmpvaW4oXCIsXCIpfSlgKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcXVvdGVkQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIixcIik7XG4gICAgICBhbGxRdWVyaWVzLnB1c2goKHR1cGxlU3RyKSA9PiBgSU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZX0gKCR7cXVvdGVkQXR0cmlidXRlc30pJHtvdXRwdXRGcmFnbWVudH0gVkFMVUVTICR7dHVwbGVTdHJ9O2ApO1xuICAgIH1cbiAgICBjb25zdCBjb21tYW5kcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGJhdGNoID0gTWF0aC5mbG9vcigyNTAgLyAoYWxsQXR0cmlidXRlcy5sZW5ndGggKyAxKSkgKyAxO1xuICAgIHdoaWxlIChvZmZzZXQgPCBNYXRoLm1heCh0dXBsZXMubGVuZ3RoLCAxKSkge1xuICAgICAgY29uc3QgdHVwbGVTdHIgPSB0dXBsZXMuc2xpY2Uob2Zmc2V0LCBNYXRoLm1pbih0dXBsZXMubGVuZ3RoLCBvZmZzZXQgKyBiYXRjaCkpO1xuICAgICAgbGV0IGdlbmVyYXRlZFF1ZXJ5ID0gYWxsUXVlcmllcy5tYXAoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdiA6IHYodHVwbGVTdHIpKS5qb2luKFwiO1wiKTtcbiAgICAgIGlmIChuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyKSB7XG4gICAgICAgIGdlbmVyYXRlZFF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT047ICR7Z2VuZXJhdGVkUXVlcnl9OyBTRVQgSURFTlRJVFlfSU5TRVJUICR7cXVvdGVkVGFibGV9IE9GRjtgO1xuICAgICAgfVxuICAgICAgY29tbWFuZHMucHVzaChnZW5lcmF0ZWRRdWVyeSk7XG4gICAgICBvZmZzZXQgKz0gYmF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5qb2luKFwiO1wiKTtcbiAgfVxuICB1cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qgc3FsID0gc3VwZXIudXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcyk7XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUFyZ3MgPSBgVVBEQVRFIFRPUCgke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgO1xuICAgICAgc3FsLnF1ZXJ5ID0gc3FsLnF1ZXJ5LnJlcGxhY2UoXCJVUERBVEVcIiwgdXBkYXRlQXJncyk7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgdXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsKSB7XG4gICAgY29uc3QgdGFyZ2V0VGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3RhcmdldGApO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV9zb3VyY2VgKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5c0F0dHJzID0gW107XG4gICAgY29uc3QgaWRlbnRpdHlBdHRycyA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZUF0dHJzID0gW107XG4gICAgY29uc3QgdGFibGVOYW1lUXVvdGVkID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnByaW1hcnlLZXkpIHtcbiAgICAgICAgcHJpbWFyeUtleXNBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS51bmlxdWUpIHtcbiAgICAgICAgdW5pcXVlQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCkge1xuICAgICAgICBpZGVudGl0eUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5kZXggb2YgbW9kZWwuX2luZGV4ZXMpIHtcbiAgICAgIGlmIChpbmRleC51bmlxdWUgJiYgaW5kZXguZmllbGRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGROYW1lID0gdHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiID8gZmllbGQgOiBmaWVsZC5uYW1lIHx8IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgICAgICBpZiAoIXVuaXF1ZUF0dHJzLmluY2x1ZGVzKGZpZWxkTmFtZSkgJiYgbW9kZWwucmF3QXR0cmlidXRlc1tmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICB1bmlxdWVBdHRycy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXNRdW90ZWQgPSBpbnNlcnRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzRXNjYXBlZCA9IGluc2VydEtleXMubWFwKChrZXkpID0+IHRoaXMuZXNjYXBlKGluc2VydFZhbHVlc1trZXldKSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlUXVlcnkgPSBgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDtcbiAgICBsZXQgam9pbkNvbmRpdGlvbjtcbiAgICBpZGVudGl0eUF0dHJzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGluc2VydFZhbHVlc1trZXldICYmIGluc2VydFZhbHVlc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNsYXVzZXMgPSB3aGVyZVtPcC5vcl0uZmlsdGVyKChjbGF1c2UpID0+IHtcbiAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGF1c2Vba2V5XSA9PT0gXCJ1bmRlZmluZWRcIiB8fCBjbGF1c2Vba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0pO1xuICAgIGNvbnN0IGdldEpvaW5TbmlwcGV0ID0gKGFycmF5KSA9PiB7XG4gICAgICByZXR1cm4gYXJyYXkubWFwKChrZXkpID0+IHtcbiAgICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7c291cmNlVGFibGVBbGlhc30uJHtrZXl9YDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGNsYXVzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcmltYXJ5IEtleSBvciBVbmlxdWUga2V5IHNob3VsZCBiZSBwYXNzZWQgdG8gdXBzZXJ0IHF1ZXJ5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBjbGF1c2VzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjbGF1c2VzW2tleV0pO1xuICAgICAgICBpZiAocHJpbWFyeUtleXNBdHRycy5pbmNsdWRlcyhrZXlzWzBdKSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldChwcmltYXJ5S2V5c0F0dHJzKS5qb2luKFwiIEFORCBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgham9pbkNvbmRpdGlvbikge1xuICAgICAgICBqb2luQ29uZGl0aW9uID0gZ2V0Sm9pblNuaXBwZXQodW5pcXVlQXR0cnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRVcGRhdGVDbGF1c2VzID0gdXBkYXRlS2V5cy5maWx0ZXIoKGtleSkgPT4gIWlkZW50aXR5QXR0cnMuaW5jbHVkZXMoa2V5KSkubWFwKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5lc2NhcGUodXBkYXRlVmFsdWVzW2tleV0pO1xuICAgICAga2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KTtcbiAgICAgIHJldHVybiBgJHt0YXJnZXRUYWJsZUFsaWFzfS4ke2tleX0gPSAke3ZhbHVlfWA7XG4gICAgfSk7XG4gICAgY29uc3QgdXBkYXRlU25pcHBldCA9IGZpbHRlcmVkVXBkYXRlQ2xhdXNlcy5sZW5ndGggPiAwID8gYFdIRU4gTUFUQ0hFRCBUSEVOIFVQREFURSBTRVQgJHtmaWx0ZXJlZFVwZGF0ZUNsYXVzZXMuam9pbihcIiwgXCIpfWAgOiBcIlwiO1xuICAgIGNvbnN0IGluc2VydFNuaXBwZXQgPSBgKCR7aW5zZXJ0S2V5c1F1b3RlZH0pIFZBTFVFUygke2luc2VydFZhbHVlc0VzY2FwZWR9KWA7XG4gICAgbGV0IHF1ZXJ5ID0gYE1FUkdFIElOVE8gJHt0YWJsZU5hbWVRdW90ZWR9IFdJVEgoSE9MRExPQ0spIEFTICR7dGFyZ2V0VGFibGVBbGlhc30gVVNJTkcgKCR7c291cmNlVGFibGVRdWVyeX0pIEFTICR7c291cmNlVGFibGVBbGlhc30oJHtpbnNlcnRLZXlzUXVvdGVkfSkgT04gJHtqb2luQ29uZGl0aW9ufWA7XG4gICAgcXVlcnkgKz0gYCAke3VwZGF0ZVNuaXBwZXR9IFdIRU4gTk9UIE1BVENIRUQgVEhFTiBJTlNFUlQgJHtpbnNlcnRTbmlwcGV0fSBPVVRQVVQgJGFjdGlvbiwgSU5TRVJURUQuKjtgO1xuICAgIGlmIChuZWVkSWRlbnRpdHlJbnNlcnRXcmFwcGVyKSB7XG4gICAgICBxdWVyeSA9IGBTRVQgSURFTlRJVFlfSU5TRVJUICR7dGFibGVOYW1lUXVvdGVkfSBPTjsgJHtxdWVyeX0gU0VUIElERU5USVRZX0lOU0VSVCAke3RhYmxlTmFtZVF1b3RlZH0gT0ZGO2A7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3Qgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiREVMRVRFXCIsXG4gICAgICBvcHRpb25zLmxpbWl0ICYmIGBUT1AoJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYCxcbiAgICAgIFwiRlJPTVwiLFxuICAgICAgdGFibGUsXG4gICAgICB3aGVyZUNsYXVzZSAmJiBgV0hFUkUgJHt3aGVyZUNsYXVzZX1gLFxuICAgICAgXCI7XCIsXG4gICAgICBcIlNFTEVDVCBAQFJPV0NPVU5UIEFTIEFGRkVDVEVEUk9XU1wiLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRVhFQyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lID0gTicke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSc7YDtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYEVYRUMgc3BfaGVscGNvbnN0cmFpbnQgQG9iam5hbWUgPSAke3RoaXMuZXNjYXBlKHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpKX07YDtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYERST1AgSU5ERVggJHt0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKX0gT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKX1gO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUuTW9kZWwgJiYgYXR0cmlidXRlLk1vZGVsLnRhYmxlTmFtZSA9PT0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBzZWxmIHJlZmVyZW5jaWFsIGNvbnN0cmFpbnRzLCB3ZSB3aWxsIHJlbW92ZSBpdCBidXQgd2UgcmVjb21tZW5kIHJlc3RydWN0dXJpbmcgeW91ciBxdWVyeVwiKTtcbiAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRlbXBsYXRlO1xuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUudmFsdWVzICYmICFhdHRyaWJ1dGUudmFsdWVzKVxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUudmFsdWVzO1xuICAgICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1NxbCgpO1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuZmllbGQpfSBJTigke2F0dHJpYnV0ZS52YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgICAgfSkuam9pbihcIiwgXCIpfSkpYDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZygpO1xuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9IGVsc2UgaWYgKCFhdHRyaWJ1dGUucHJpbWFyeUtleSAmJiAhVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOVUxMXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgSURFTlRJVFkoMSwxKVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgIT09IFwiVEVYVFwiICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgVU5JUVVFXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICB9XG4gICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzKSAmJiBhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIil9KWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQgJiYgdHlwZW9mIGF0dHJpYnV0ZS5jb21tZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHthdHRyaWJ1dGUuY29tbWVudH1gO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fSwgZXhpc3RpbmdDb25zdHJhaW50cyA9IFtdO1xuICAgIGxldCBrZXksIGF0dHJpYnV0ZTtcbiAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ29uc3RyYWludHMuaW5jbHVkZXMoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSBcIlwiO1xuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmdDb25zdHJhaW50cy5wdXNoKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIGF0dHJpYnV0ZS5vblVwZGF0ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgJiYgIWF0dHJpYnV0ZS5maWVsZClcbiAgICAgICAgYXR0cmlidXRlLmZpZWxkID0ga2V5O1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVUcmlnZ2VyXCIpO1xuICB9XG4gIGRyb3BUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcFRyaWdnZXJcIik7XG4gIH1cbiAgcmVuYW1lVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZVRyaWdnZXJcIik7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVGdW5jdGlvblwiKTtcbiAgfVxuICBkcm9wRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wRnVuY3Rpb25cIik7XG4gIH1cbiAgcmVuYW1lRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVGdW5jdGlvblwiKTtcbiAgfVxuICBfZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeChjYXRhbG9nTmFtZSkge1xuICAgIHJldHVybiBgJHtcIlNFTEVDVCBjb25zdHJhaW50X25hbWUgPSBPQkouTkFNRSwgY29uc3RyYWludE5hbWUgPSBPQkouTkFNRSwgXCJ9JHtjYXRhbG9nTmFtZSA/IGBjb25zdHJhaW50Q2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiBcIlwifWNvbnN0cmFpbnRTY2hlbWEgPSBTQ0hFTUFfTkFNRShPQkouU0NIRU1BX0lEKSwgdGFibGVOYW1lID0gVEIuTkFNRSwgdGFibGVTY2hlbWEgPSBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpLCAke2NhdGFsb2dOYW1lID8gYHRhYmxlQ2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiBcIlwifWNvbHVtbk5hbWUgPSBDT0wuTkFNRSwgcmVmZXJlbmNlZFRhYmxlU2NoZW1hID0gU0NIRU1BX05BTUUoUlRCLlNDSEVNQV9JRCksICR7Y2F0YWxvZ05hbWUgPyBgcmVmZXJlbmNlZENhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nLCBgIDogXCJcIn1yZWZlcmVuY2VkVGFibGVOYW1lID0gUlRCLk5BTUUsIHJlZmVyZW5jZWRDb2x1bW5OYW1lID0gUkNPTC5OQU1FIEZST00gc3lzLmZvcmVpZ25fa2V5X2NvbHVtbnMgRktDIElOTkVSIEpPSU4gc3lzLm9iamVjdHMgT0JKIE9OIE9CSi5PQkpFQ1RfSUQgPSBGS0MuQ09OU1RSQUlOVF9PQkpFQ1RfSUQgSU5ORVIgSk9JTiBzeXMudGFibGVzIFRCIE9OIFRCLk9CSkVDVF9JRCA9IEZLQy5QQVJFTlRfT0JKRUNUX0lEIElOTkVSIEpPSU4gc3lzLmNvbHVtbnMgQ09MIE9OIENPTC5DT0xVTU5fSUQgPSBQQVJFTlRfQ09MVU1OX0lEIEFORCBDT0wuT0JKRUNUX0lEID0gVEIuT0JKRUNUX0lEIElOTkVSIEpPSU4gc3lzLnRhYmxlcyBSVEIgT04gUlRCLk9CSkVDVF9JRCA9IEZLQy5SRUZFUkVOQ0VEX09CSkVDVF9JRCBJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIFJDT0wgT04gUkNPTC5DT0xVTU5fSUQgPSBSRUZFUkVOQ0VEX0NPTFVNTl9JRCBBTkQgUkNPTC5PQkpFQ1RfSUQgPSBSVEIuT0JKRUNUX0lEYDtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBjYXRhbG9nTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBsZXQgc3FsID0gYCR7dGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVByZWZpeChjYXRhbG9nTmFtZSl9IFdIRVJFIFRCLk5BTUUgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YDtcbiAgICBpZiAodGFibGUuc2NoZW1hKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKX1gO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICB0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KCksXG4gICAgICBcIldIRVJFXCIsXG4gICAgICBgVEIuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gLFxuICAgICAgXCJBTkRcIixcbiAgICAgIGBDT0wuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUoYXR0cmlidXRlTmFtZSl9YCxcbiAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCkgPSR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSl9YFxuICAgIF0pO1xuICB9XG4gIGdldFByaW1hcnlLZXlDb25zdHJhaW50UXVlcnkodGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBLLlRBQkxFX05BTUUgQVMgdGFibGVOYW1lLFwiLFxuICAgICAgXCJLLkNPTFVNTl9OQU1FIEFTIGNvbHVtbk5hbWUsXCIsXG4gICAgICBcIksuQ09OU1RSQUlOVF9OQU1FIEFTIGNvbnN0cmFpbnROYW1lXCIsXG4gICAgICBcIkZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTIEFTIENcIixcbiAgICAgIFwiSk9JTiBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSBBUyBLXCIsXG4gICAgICBcIk9OIEMuVEFCTEVfTkFNRSA9IEsuVEFCTEVfTkFNRVwiLFxuICAgICAgXCJBTkQgQy5DT05TVFJBSU5UX0NBVEFMT0cgPSBLLkNPTlNUUkFJTlRfQ0FUQUxPR1wiLFxuICAgICAgXCJBTkQgQy5DT05TVFJBSU5UX1NDSEVNQSA9IEsuQ09OU1RSQUlOVF9TQ0hFTUFcIixcbiAgICAgIFwiQU5EIEMuQ09OU1RSQUlOVF9OQU1FID0gSy5DT05TVFJBSU5UX05BTUVcIixcbiAgICAgIFwiV0hFUkUgQy5DT05TVFJBSU5UX1RZUEUgPSAnUFJJTUFSWSBLRVknXCIsXG4gICAgICBgQU5EIEsuQ09MVU1OX05BTUUgPSAke3dyYXBTaW5nbGVRdW90ZShhdHRyaWJ1dGVOYW1lKX1gLFxuICAgICAgYEFORCBLLlRBQkxFX05BTUUgPSAke3RhYmxlTmFtZX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KVxuICAgIF0pO1xuICB9XG4gIGdldERlZmF1bHRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBuYW1lIEZST00gc3lzLmRlZmF1bHRfY29uc3RyYWludHNcIixcbiAgICAgIGBXSEVSRSBQQVJFTlRfT0JKRUNUX0lEID0gT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlfScsICdVJylgLFxuICAgICAgYEFORCBQQVJFTlRfQ09MVU1OX0lEID0gKFNFTEVDVCBjb2x1bW5faWQgRlJPTSBzeXMuY29sdW1ucyBXSEVSRSBOQU1FID0gKCcke2F0dHJpYnV0ZU5hbWV9JylgLFxuICAgICAgYEFORCBvYmplY3RfaWQgPSBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGV9JywgJ1UnKSlgLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUCBDT05TVFJBSU5UXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihjb25zdHJhaW50TmFtZSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkoKSB7XG4gIH1cbiAgZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCkge1xuICAgIHJldHVybiByYW5kb21CeXRlcygxMCkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIkJFR0lOIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBcIkNPTU1JVCBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICByb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFJPTExCQUNLIFRSQU5TQUNUSU9OICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBcIlJPTExCQUNLIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIHNlbGVjdEZyb21UYWJsZUZyYWdtZW50KG9wdGlvbnMsIG1vZGVsLCBhdHRyaWJ1dGVzLCB0YWJsZXMsIG1haW5UYWJsZUFzLCB3aGVyZSkge1xuICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGVBcyB9KTtcbiAgICBjb25zdCBkYlZlcnNpb24gPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbjtcbiAgICBjb25zdCBpc1NRTFNlcnZlcjIwMDggPSBzZW12ZXIudmFsaWQoZGJWZXJzaW9uKSAmJiBzZW12ZXIubHQoZGJWZXJzaW9uLCBcIjExLjAuMFwiKTtcbiAgICBpZiAoaXNTUUxTZXJ2ZXIyMDA4ICYmIG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgY29uc3QgaXNTdWJRdWVyeSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICAgIGxldCBvcmRlcnMgPSB7IG1haW5RdWVyeU9yZGVyOiBbXSB9O1xuICAgICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgICAgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgaXNTdWJRdWVyeSk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXJzLm1haW5RdWVyeU9yZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcmRlcnMubWFpblF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihtb2RlbC5wcmltYXJ5S2V5RmllbGQpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRtcFRhYmxlID0gbWFpblRhYmxlQXMgfHwgXCJPZmZzZXRUYWJsZVwiO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICBjb25zdCBzdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCA/IG9wdGlvbnMubGltaXQgJiYgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uIDogb3B0aW9ucy5zdWJRdWVyeTtcbiAgICAgICAgY29uc3QgbWFpblRhYmxlID0ge1xuICAgICAgICAgIG5hbWU6IG1haW5UYWJsZUFzLFxuICAgICAgICAgIHF1b3RlZE5hbWU6IG51bGwsXG4gICAgICAgICAgYXM6IG51bGwsXG4gICAgICAgICAgbW9kZWxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxJbmZvID0ge1xuICAgICAgICAgIG5hbWVzOiBtYWluVGFibGUsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBzdWJRdWVyeVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbWFpbkpvaW5RdWVyaWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgICBpZiAoaW5jbHVkZS5zZXBhcmF0ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpvaW5RdWVyaWVzID0gdGhpcy5nZW5lcmF0ZUluY2x1ZGUoaW5jbHVkZSwgeyBleHRlcm5hbEFzOiBtYWluVGFibGVBcywgaW50ZXJuYWxBczogbWFpblRhYmxlQXMgfSwgdG9wTGV2ZWxJbmZvKTtcbiAgICAgICAgICBtYWluSm9pblF1ZXJpZXMgPSBtYWluSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLm1haW5RdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICAgIFwiU0VMRUNUIFRPUCAxMDAgUEVSQ0VOVFwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXMuam9pbihcIiwgXCIpLFxuICAgICAgICAgIFwiRlJPTSAoXCIsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCJTRUxFQ1RcIixcbiAgICAgICAgICAgIG9wdGlvbnMubGltaXQgJiYgYFRPUCAke29wdGlvbnMubGltaXR9YCxcbiAgICAgICAgICAgIFwiKiBGUk9NIChcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgXCJTRUxFQ1QgUk9XX05VTUJFUigpIE9WRVIgKFwiLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJPUkRFUiBCWVwiLFxuICAgICAgICAgICAgICAgIG9yZGVycy5tYWluUXVlcnlPcmRlci5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgYCkgYXMgcm93X251bSwgJHt0bXBUYWJsZX0uKiBGUk9NIChgLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJTRUxFQ1QgRElTVElOQ1RcIixcbiAgICAgICAgICAgICAgICBgJHt0bXBUYWJsZX0uKiBGUk9NICR7dGFibGVzfSBBUyAke3RtcFRhYmxlfWAsXG4gICAgICAgICAgICAgICAgbWFpbkpvaW5RdWVyaWVzLFxuICAgICAgICAgICAgICAgIHdoZXJlICYmIGBXSEVSRSAke3doZXJlfWBcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX1gXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX0gV0hFUkUgcm93X251bSA+ICR7b2Zmc2V0fWBcbiAgICAgICAgICBdLFxuICAgICAgICAgIGApIEFTICR7dG1wVGFibGV9YFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgXCJTRUxFQ1QgVE9QIDEwMCBQRVJDRU5UXCIsXG4gICAgICAgIGF0dHJpYnV0ZXMuam9pbihcIiwgXCIpLFxuICAgICAgICBcIkZST00gKFwiLFxuICAgICAgICBbXG4gICAgICAgICAgXCJTRUxFQ1RcIixcbiAgICAgICAgICBvcHRpb25zLmxpbWl0ICYmIGBUT1AgJHtvcHRpb25zLmxpbWl0fWAsXG4gICAgICAgICAgXCIqIEZST00gKFwiLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIFwiU0VMRUNUIFJPV19OVU1CRVIoKSBPVkVSIChcIixcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgXCJPUkRFUiBCWVwiLFxuICAgICAgICAgICAgICBvcmRlcnMubWFpblF1ZXJ5T3JkZXIuam9pbihcIiwgXCIpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgYCkgYXMgcm93X251bSwgKiBGUk9NICR7dGFibGVzfSBBUyAke3RtcFRhYmxlfWAsXG4gICAgICAgICAgICB3aGVyZSAmJiBgV0hFUkUgJHt3aGVyZX1gXG4gICAgICAgICAgXSxcbiAgICAgICAgICBgKSBBUyAke3RtcFRhYmxlfSBXSEVSRSByb3dfbnVtID4gJHtvZmZzZXR9YFxuICAgICAgICBdLFxuICAgICAgICBgKSBBUyAke3RtcFRhYmxlfWBcbiAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgaXNTUUxTZXJ2ZXIyMDA4ICYmIG9wdGlvbnMubGltaXQgJiYgYFRPUCAke29wdGlvbnMubGltaXR9YCxcbiAgICAgIGF0dHJpYnV0ZXMuam9pbihcIiwgXCIpLFxuICAgICAgYEZST00gJHt0YWJsZXN9YCxcbiAgICAgIG1haW5UYWJsZUFzICYmIGBBUyAke21haW5UYWJsZUFzfWAsXG4gICAgICBvcHRpb25zLnRhYmxlSGludCAmJiBUYWJsZUhpbnRzW29wdGlvbnMudGFibGVIaW50XSAmJiBgV0lUSCAoJHtUYWJsZUhpbnRzW29wdGlvbnMudGFibGVIaW50XX0pYFxuICAgIF0pO1xuICB9XG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgaWYgKHNlbXZlci52YWxpZCh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbikgJiYgc2VtdmVyLmx0KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCBcIjExLjAuMFwiKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgaXNTdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCA/IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA6IG9wdGlvbnMuc3ViUXVlcnk7XG4gICAgbGV0IGZyYWdtZW50ID0gXCJcIjtcbiAgICBsZXQgb3JkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCB8fCBvcHRpb25zLm9mZnNldCkge1xuICAgICAgaWYgKCFvcHRpb25zLm9yZGVyIHx8IG9wdGlvbnMub3JkZXIubGVuZ3RoID09PSAwIHx8IG9wdGlvbnMuaW5jbHVkZSAmJiBvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGV0IHByaW1hcnlLZXkgPSBtb2RlbC5wcmltYXJ5S2V5RmllbGQ7XG4gICAgICAgIGNvbnN0IHRhYmxlUGtGcmFnbWVudCA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlQXMgfHwgbW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIocHJpbWFyeUtleSl9YDtcbiAgICAgICAgY29uc3QgYWxpYXNlZEF0dHJpYnV0ZSA9IChvcHRpb25zLmF0dHJpYnV0ZXMgfHwgW10pLmZpbmQoKGF0dHIpID0+IEFycmF5LmlzQXJyYXkoYXR0cikgJiYgYXR0clsxXSAmJiAoYXR0clswXSA9PT0gcHJpbWFyeUtleSB8fCBhdHRyWzFdID09PSBwcmltYXJ5S2V5KSk7XG4gICAgICAgIGlmIChhbGlhc2VkQXR0cmlidXRlKSB7XG4gICAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy50YWJsZUFzIHx8IG1vZGVsLm5hbWUpO1xuICAgICAgICAgIGNvbnN0IGFsaWFzID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZChtb2RlbE5hbWUsIGFsaWFzZWRBdHRyaWJ1dGVbMV0sIG9wdGlvbnMpO1xuICAgICAgICAgIHByaW1hcnlLZXkgPSBuZXcgVXRpbHMuQ29sKGFsaWFzIHx8IGFsaWFzZWRBdHRyaWJ1dGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5vcmRlciB8fCAhb3B0aW9ucy5vcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICBmcmFnbWVudCArPSBgIE9SREVSIEJZICR7dGFibGVQa0ZyYWdtZW50fWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgb3JkZXJGaWVsZE5hbWVzID0gKG9wdGlvbnMub3JkZXIgfHwgW10pLm1hcCgob3JkZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQXJyYXkuaXNBcnJheShvcmRlcikgPyBvcmRlclswXSA6IG9yZGVyO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuQ29sKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5jb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcHJpbWFyeUtleUZpZWxkQWxyZWFkeVByZXNlbnQgPSBvcmRlckZpZWxkTmFtZXMuc29tZSgoZmllbGROYW1lKSA9PiBmaWVsZE5hbWUgPT09IChwcmltYXJ5S2V5LmNvbCB8fCBwcmltYXJ5S2V5KSk7XG4gICAgICAgICAgaWYgKCFwcmltYXJ5S2V5RmllbGRBbHJlYWR5UHJlc2VudCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgKz0gb3B0aW9ucy5vcmRlciAmJiAhaXNTdWJRdWVyeSA/IFwiLCBcIiA6IFwiIE9SREVSIEJZIFwiO1xuICAgICAgICAgICAgZnJhZ21lbnQgKz0gdGFibGVQa0ZyYWdtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBPRkZTRVQgJHt0aGlzLmVzY2FwZShvZmZzZXQpfSBST1dTYDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGZyYWdtZW50ICs9IGAgRkVUQ0ggTkVYVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBST1dTIE9OTFlgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIGBbJHtpZGVudGlmaWVyLnJlcGxhY2UoL1tbXFxdJ10rL2csIFwiXCIpfV1gO1xuICB9XG59XG5mdW5jdGlvbiB3cmFwU2luZ2xlUXVvdGUoaWRlbnRpZmllcikge1xuICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgXCInXCIpLCBcIidcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1TU1FMUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nclass MSSqlQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = __spreadValues({ raw: true }, options || {});\n    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n    const [results0] = await this.sequelize.query(findConstraintSql, options);\n    if (results0.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);\n    const [results] = await this.sequelize.query(findForeignKeySql, options);\n    if (results.length) {\n      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      await this.sequelize.query(dropForeignKeySql, options);\n    }\n    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);\n    if (result.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);\n    return this.sequelize.query(removeSql, options);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    const model = options.model;\n    const wheres = [];\n    options = __spreadValues({}, options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    let indexes = Object.values(model.uniqueKeys).map((item) => item.fields);\n    indexes = indexes.concat(Object.values(model._indexes).filter((item) => item.unique).map((item) => item.fields));\n    const attributes = Object.keys(insertValues);\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.MSSqlQueryInterface = MSSqlQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsV0FBVyxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvcXVlcnktaW50ZXJmYWNlLmpzP2M3MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBNU1NxbFF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMgfHwge30pO1xuICAgIGNvbnN0IGZpbmRDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXREZWZhdWx0Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdHMwXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGZpbmRDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0czAubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkcm9wQ29uc3RyYWludFNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdHMwWzBdLm5hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBmaW5kRm9yZWlnbktleVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZmluZEZvcmVpZ25LZXlTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgZHJvcEZvcmVpZ25LZXlTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCByZXN1bHRzWzBdLmNvbnN0cmFpbnRfbmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wRm9yZWlnbktleVNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlLZXlDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRQcmltYXJ5S2V5Q29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgY29uc3QgW3Jlc3VsdF0gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShwcmltYXJ5S2V5Q29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRyb3BDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0WzBdLmNvbnN0cmFpbnROYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcmVtb3ZlU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShyZW1vdmVTcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCB3aGVyZXMgPSBbXTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmICghVXRpbHMuaXNXaGVyZUVtcHR5KHdoZXJlKSkge1xuICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgIH1cbiAgICBsZXQgaW5kZXhlcyA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykubWFwKChpdGVtKSA9PiBpdGVtLmZpZWxkcyk7XG4gICAgaW5kZXhlcyA9IGluZGV4ZXMuY29uY2F0KE9iamVjdC52YWx1ZXMobW9kZWwuX2luZGV4ZXMpLmZpbHRlcigoaXRlbSkgPT4gaXRlbS51bmlxdWUpLm1hcCgoaXRlbSkgPT4gaXRlbS5maWVsZHMpKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgIGlmIChfLmludGVyc2VjdGlvbihhdHRyaWJ1dGVzLCBpbmRleCkubGVuZ3RoID09PSBpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgd2hlcmUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleCkge1xuICAgICAgICAgIHdoZXJlW2ZpZWxkXSA9IGluc2VydFZhbHVlc1tmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgd2hlcmVzLnB1c2god2hlcmUpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGVyZSA9IHsgW09wLm9yXTogd2hlcmVzIH07XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxufVxuZXhwb3J0cy5NU1NxbFF1ZXJ5SW50ZXJmYWNlID0gTVNTcWxRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:mssql\");\nconst minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);\nconst maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum))\n    return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum)\n    e *= 10;\n  return Math.log10(e);\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = { type: TYPES.NVarChar, typeOptions: {}, value };\n    if (typeof value === \"number\") {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        paramType.typeOptions = { precision: 30, scale: getScale(value) };\n      }\n    } else if (typeof value === \"bigint\") {\n      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {\n        paramType.type = TYPES.VarChar;\n        paramType.value = value.toString();\n      } else {\n        return this.getSQLTypeFromJsType(Number(value), TYPES);\n      }\n    } else if (typeof value === \"boolean\") {\n      paramType.type = TYPES.Bit;\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n  async _run(connection, sql, parameters, errStack) {\n    this.sql = sql;\n    const { options } = this;\n    const complete = this._logQuery(sql, debug, parameters);\n    const query = new Promise((resolve, reject) => {\n      if (sql.startsWith(\"BEGIN TRANSACTION\")) {\n        return connection.beginTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith(\"COMMIT TRANSACTION\")) {\n        return connection.commitTransaction((error) => error ? reject(error) : resolve([]));\n      }\n      if (sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n        return connection.rollbackTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      if (sql.startsWith(\"SAVE TRANSACTION\")) {\n        return connection.saveTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      const rows2 = [];\n      const request = new connection.lib.Request(sql, (err, rowCount2) => err ? reject(err) : resolve([rows2, rowCount2]));\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n      request.on(\"row\", (columns) => {\n        rows2.push(columns);\n      });\n      connection.execSql(request);\n    });\n    let rows, rowCount;\n    try {\n      [rows, rowCount] = await query;\n    } catch (err) {\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err, errStack);\n    }\n    complete();\n    if (Array.isArray(rows)) {\n      rows = rows.map((columns) => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n        return row;\n      });\n    }\n    return this.formatResults(rows, rowCount);\n  }\n  run(sql, parameters) {\n    const errForStack = new Error();\n    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters, errForStack.stack));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return `@${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam];\n  }\n  formatResults(data, rowCount) {\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      const result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"YES\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === \"PRIMARY KEY\",\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n        if (result[_result.Name].type.includes(\"CHAR\") && _result.Length) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += \"(MAX)\";\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] ? data[0].AFFECTEDROWS : 0;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      if (data && data.length === 0) {\n        return [this.instance || data, false];\n      }\n      this.handleInsertQuery(data);\n      return [this.instance || data, data[0].$action === \"INSERT\"];\n    }\n    if (this.isUpdateQuery()) {\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      return [data, rowCount];\n    }\n    return data;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return data.slice(1).map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n  formatError(err, errStack) {\n    let match;\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = \"Validation error\";\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[3]) {\n        const values = match[3].split(\",\").map((part) => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[3];\n        }\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : void 0;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n      item.index_keys.split(\",\").forEach((column) => {\n        let columnName = column.trim();\n        if (columnName.includes(\"(-)\")) {\n          columnName = columnName.replace(\"(-)\", \"\");\n        }\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: void 0,\n          order: column.includes(\"(-)\") ? \"DESC\" : \"ASC\",\n          collate: void 0\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.index_name.toLowerCase().startsWith(\"pk\"),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: void 0,\n      unique: item.index_description.toLowerCase().includes(\"unique\"),\n      type: void 0\n    }));\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL3F1ZXJ5LmpzPzlhZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwibXNzcWxcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOm1zc3FsXCIpO1xuY29uc3QgbWluU2FmZUludGVnZXJBc0JpZ0ludCA9IEJpZ0ludChOdW1iZXIuTUlOX1NBRkVfSU5URUdFUik7XG5jb25zdCBtYXhTYWZlSW50ZWdlckFzQmlnSW50ID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbmZ1bmN0aW9uIGdldFNjYWxlKGFOdW0pIHtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYU51bSkpXG4gICAgcmV0dXJuIDA7XG4gIGxldCBlID0gMTtcbiAgd2hpbGUgKE1hdGgucm91bmQoYU51bSAqIGUpIC8gZSAhPT0gYU51bSlcbiAgICBlICo9IDEwO1xuICByZXR1cm4gTWF0aC5sb2cxMChlKTtcbn1cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwiaWRcIjtcbiAgfVxuICBnZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSwgVFlQRVMpIHtcbiAgICBjb25zdCBwYXJhbVR5cGUgPSB7IHR5cGU6IFRZUEVTLk5WYXJDaGFyLCB0eXBlT3B0aW9uczoge30sIHZhbHVlIH07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMjE0NzQ4MzY0OCAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5JbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5CaWdJbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuTnVtZXJpYztcbiAgICAgICAgcGFyYW1UeXBlLnR5cGVPcHRpb25zID0geyBwcmVjaXNpb246IDMwLCBzY2FsZTogZ2V0U2NhbGUodmFsdWUpIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGlmICh2YWx1ZSA8IG1pblNhZmVJbnRlZ2VyQXNCaWdJbnQgfHwgdmFsdWUgPiBtYXhTYWZlSW50ZWdlckFzQmlnSW50KSB7XG4gICAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuVmFyQ2hhcjtcbiAgICAgICAgcGFyYW1UeXBlLnZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNRTFR5cGVGcm9tSnNUeXBlKE51bWJlcih2YWx1ZSksIFRZUEVTKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHBhcmFtVHlwZS50eXBlID0gVFlQRVMuQml0O1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5WYXJCaW5hcnk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbVR5cGU7XG4gIH1cbiAgYXN5bmMgX3J1bihjb25uZWN0aW9uLCBzcWwsIHBhcmFtZXRlcnMsIGVyclN0YWNrKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgY29uc3QgcXVlcnkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoc3FsLnN0YXJ0c1dpdGgoXCJCRUdJTiBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5iZWdpblRyYW5zYWN0aW9uKChlcnJvcikgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSwgY29ubmVjdGlvbi5saWIuSVNPTEFUSU9OX0xFVkVMW29wdGlvbnMuaXNvbGF0aW9uTGV2ZWxdKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aChcIkNPTU1JVCBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jb21taXRUcmFuc2FjdGlvbigoZXJyb3IpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aChcIlJPTExCQUNLIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLnJvbGxiYWNrVHJhbnNhY3Rpb24oKGVycm9yKSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aChcIlNBVkUgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2F2ZVRyYW5zYWN0aW9uKChlcnJvcikgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSksIG9wdGlvbnMudHJhbnNhY3Rpb24ubmFtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzMiA9IFtdO1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBjb25uZWN0aW9uLmxpYi5SZXF1ZXN0KHNxbCwgKGVyciwgcm93Q291bnQyKSA9PiBlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUoW3Jvd3MyLCByb3dDb3VudDJdKSk7XG4gICAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgICBfLmZvck93bihwYXJhbWV0ZXJzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBhcmFtVHlwZSA9IHRoaXMuZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUsIGNvbm5lY3Rpb24ubGliLlRZUEVTKTtcbiAgICAgICAgICByZXF1ZXN0LmFkZFBhcmFtZXRlcihrZXksIHBhcmFtVHlwZS50eXBlLCB2YWx1ZSwgcGFyYW1UeXBlLnR5cGVPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXF1ZXN0Lm9uKFwicm93XCIsIChjb2x1bW5zKSA9PiB7XG4gICAgICAgIHJvd3MyLnB1c2goY29sdW1ucyk7XG4gICAgICB9KTtcbiAgICAgIGNvbm5lY3Rpb24uZXhlY1NxbChyZXF1ZXN0KTtcbiAgICB9KTtcbiAgICBsZXQgcm93cywgcm93Q291bnQ7XG4gICAgdHJ5IHtcbiAgICAgIFtyb3dzLCByb3dDb3VudF0gPSBhd2FpdCBxdWVyeTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5zcWwgPSBzcWw7XG4gICAgICBlcnIucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3MpKSB7XG4gICAgICByb3dzID0gcm93cy5tYXAoKGNvbHVtbnMpID0+IHtcbiAgICAgICAgY29uc3Qgcm93ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnMpIHtcbiAgICAgICAgICBjb25zdCB0eXBlaWQgPSBjb2x1bW4ubWV0YWRhdGEudHlwZS5pZDtcbiAgICAgICAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldCh0eXBlaWQpO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbHVtbi52YWx1ZTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiAhIXBhcnNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm93W2NvbHVtbi5tZXRhZGF0YS5jb2xOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyb3dzLCByb3dDb3VudCk7XG4gIH1cbiAgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGVyckZvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5xdWV1ZS5lbnF1ZXVlKCgpID0+IHRoaXMuX3J1bih0aGlzLmNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycywgZXJyRm9yU3RhY2suc3RhY2spKTtcbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSB7fTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMikgPT4ge1xuICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGJpbmRQYXJhbVtrZXldID0gdmFsdWVzMltrZXldO1xuICAgICAgICByZXR1cm4gYEAke2tleX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhLCByb3dDb3VudCkge1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIGlmIChfcmVzdWx0LkRlZmF1bHQpIHtcbiAgICAgICAgICBfcmVzdWx0LkRlZmF1bHQgPSBfcmVzdWx0LkRlZmF1bHQucmVwbGFjZShcIignXCIsIFwiXCIpLnJlcGxhY2UoXCInKVwiLCBcIlwiKS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5Jc051bGwgPT09IFwiWUVTXCIgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5Db25zdHJhaW50ID09PSBcIlBSSU1BUlkgS0VZXCIsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogX3Jlc3VsdC5Jc0lkZW50aXR5ID09PSAxLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZS5pbmNsdWRlcyhcIkNIQVJcIikgJiYgX3Jlc3VsdC5MZW5ndGgpIHtcbiAgICAgICAgICBpZiAoX3Jlc3VsdC5MZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlICs9IFwiKE1BWClcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0udHlwZSArPSBgKCR7X3Jlc3VsdC5MZW5ndGh9KWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd0NvdW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXSA/IGRhdGFbMF0uQUZGRUNURURST1dTIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCBmYWxzZV07XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIGRhdGFbMF0uJGFjdGlvbiA9PT0gXCJJTlNFUlRcIl07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW2RhdGEsIHJvd0NvdW50XTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdFNldCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZSgxKS5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0cmFpbnRbXy5jYW1lbENhc2Uoa2V5KV0gPSByZXN1bHRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25zdHJhaW50O1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvVmlvbGF0aW9uIG9mICg/OlVOSVFVRXxQUklNQVJZKSBLRVkgY29uc3RyYWludCAnKFteJ10qKScuIENhbm5vdCBpbnNlcnQgZHVwbGljYXRlIGtleSBpbiBvYmplY3QgJy4qJy4oOj8gVGhlIGR1cGxpY2F0ZSBrZXkgdmFsdWUgaXMgXFwoKC4qKVxcKS4pPy8pO1xuICAgIG1hdGNoID0gbWF0Y2ggfHwgZXJyLm1lc3NhZ2UubWF0Y2goL0Nhbm5vdCBpbnNlcnQgZHVwbGljYXRlIGtleSByb3cgaW4gb2JqZWN0IC4qIHdpdGggdW5pcXVlIGluZGV4ICcoLiopJy8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICBjb25zdCB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5c1ttYXRjaFsxXV07XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgaWYgKHVuaXF1ZUtleSAmJiAhIXVuaXF1ZUtleS5tc2cpIHtcbiAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2hbM10uc3BsaXQoXCIsXCIpLm1hcCgocGFydCkgPT4gcGFydC50cmltKCkpO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbbWF0Y2hbMV1dID0gbWF0Y2hbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRmFpbGVkIG9uIHN0ZXAgJyguKiknLkNvdWxkIG5vdCBjcmVhdGUgY29uc3RyYWludC4gU2VlIHByZXZpb3VzIGVycm9ycy4vKSB8fCBlcnIubWVzc2FnZS5tYXRjaCgvVGhlIERFTEVURSBzdGF0ZW1lbnQgY29uZmxpY3RlZCB3aXRoIHRoZSBSRUZFUkVOQ0UgY29uc3RyYWludCBcIiguKilcIi4gVGhlIGNvbmZsaWN0IG9jY3VycmVkIGluIGRhdGFiYXNlIFwiKC4qKVwiLCB0YWJsZSBcIiguKilcIiwgY29sdW1uICcoLiopJy4vKSB8fCBlcnIubWVzc2FnZS5tYXRjaCgvVGhlICg/OklOU0VSVHxNRVJHRXxVUERBVEUpIHN0YXRlbWVudCBjb25mbGljdGVkIHdpdGggdGhlIEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgXCIoLiopXCIuIFRoZSBjb25mbGljdCBvY2N1cnJlZCBpbiBkYXRhYmFzZSBcIiguKilcIiwgdGFibGUgXCIoLiopXCIsIGNvbHVtbiAnKC4qKScuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBmaWVsZHM6IG51bGwsXG4gICAgICAgIGluZGV4OiBtYXRjaFsxXSxcbiAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0NvdWxkIG5vdCBkcm9wIGNvbnN0cmFpbnQuIFNlZSBwcmV2aW91cyBlcnJvcnMuLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBjb25zdHJhaW50ID0gZXJyLnNxbC5tYXRjaCgvKD86Y29uc3RyYWludHxpbmRleCkgXFxbKC4rPylcXF0vaSk7XG4gICAgICBjb25zdHJhaW50ID0gY29uc3RyYWludCA/IGNvbnN0cmFpbnRbMV0gOiB2b2lkIDA7XG4gICAgICBsZXQgdGFibGUgPSBlcnIuc3FsLm1hdGNoKC90YWJsZSBcXFsoLis/KVxcXS9pKTtcbiAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBtYXRjaFsxXSxcbiAgICAgICAgY29uc3RyYWludCxcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gIH1cbiAgaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2VsZWN0IGMuY29sdW1uX25hbWUgYXMgJ25hbWUnLCBjLmRhdGFfdHlwZSBhcyAndHlwZScsIGMuaXNfbnVsbGFibGUgYXMgJ2lzbnVsbCdcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNlbGVjdCB0YWJsZW5hbWUgPSB0Lm5hbWUsIG5hbWUgPSBpbmQubmFtZSxcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImV4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZVwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lXCIpO1xuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoIShpdGVtLmluZGV4X25hbWUgaW4gYWNjKSkge1xuICAgICAgICBhY2NbaXRlbS5pbmRleF9uYW1lXSA9IGl0ZW07XG4gICAgICAgIGl0ZW0uZmllbGRzID0gW107XG4gICAgICB9XG4gICAgICBpdGVtLmluZGV4X2tleXMuc3BsaXQoXCIsXCIpLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgICBsZXQgY29sdW1uTmFtZSA9IGNvbHVtbi50cmltKCk7XG4gICAgICAgIGlmIChjb2x1bW5OYW1lLmluY2x1ZGVzKFwiKC0pXCIpKSB7XG4gICAgICAgICAgY29sdW1uTmFtZSA9IGNvbHVtbk5hbWUucmVwbGFjZShcIigtKVwiLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhY2NbaXRlbS5pbmRleF9uYW1lXS5maWVsZHMucHVzaCh7XG4gICAgICAgICAgYXR0cmlidXRlOiBjb2x1bW5OYW1lLFxuICAgICAgICAgIGxlbmd0aDogdm9pZCAwLFxuICAgICAgICAgIG9yZGVyOiBjb2x1bW4uaW5jbHVkZXMoXCIoLSlcIikgPyBcIkRFU0NcIiA6IFwiQVNDXCIsXG4gICAgICAgICAgY29sbGF0ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgaXRlbS5pbmRleF9rZXlzO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIF8ubWFwKGRhdGEsIChpdGVtKSA9PiAoe1xuICAgICAgcHJpbWFyeTogaXRlbS5pbmRleF9uYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInBrXCIpLFxuICAgICAgZmllbGRzOiBpdGVtLmZpZWxkcyxcbiAgICAgIG5hbWU6IGl0ZW0uaW5kZXhfbmFtZSxcbiAgICAgIHRhYmxlTmFtZTogdm9pZCAwLFxuICAgICAgdW5pcXVlOiBpdGVtLmluZGV4X2Rlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ1bmlxdWVcIiksXG4gICAgICB0eXBlOiB2b2lkIDBcbiAgICB9KSk7XG4gIH1cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgY29uc3QgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBpZCA9IG51bGw7XG4gICAgICBsZXQgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gbnVsbDtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdXRvSW5jcmVtZW50QXR0cmlidXRlKSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQgIT09IHZvaWQgMClcbiAgICAgICAgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlXTtcbiAgICAgIGlkID0gaWQgfHwgYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzICYmIHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXNdO1xuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50QXR0cmlidXRlXSA9IGlkO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzWzBdKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSByZXN1bHRzWzBdW2tleV07XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mysql);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mysql\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mysql\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mysql2\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: \"-FOUND_ROWS\",\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = this.lib.createConnection(connectionConfig);\n        const errorHandler = (e) => {\n          connection2.removeListener(\"connect\", connectHandler);\n          connection2.removeListener(\"error\", connectHandler);\n          reject(e);\n        };\n        const connectHandler = () => {\n          connection2.removeListener(\"error\", errorHandler);\n          resolve(connection2);\n        };\n        connection2.on(\"error\", errorHandler);\n        connection2.once(\"connect\", connectHandler);\n      });\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n        await promisify((cb) => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection._closing) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQix1R0FBaUM7QUFDbkQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVM7QUFDOUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9jb25uZWN0aW9uLW1hbmFnZXIuanM/NGQyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubXlzcWw7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOm15c3FsXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJteXNxbFwiKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcIm15c3FsMlwiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgZmxhZ3M6IFwiLUZPVU5EX1JPV1NcIixcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgdGltZXpvbmU6IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUsXG4gICAgICB0eXBlQ2FzdDogQ29ubmVjdGlvbk1hbmFnZXIuX3R5cGVjYXN0LmJpbmQodGhpcyksXG4gICAgICBiaWdOdW1iZXJTdHJpbmdzOiBmYWxzZSxcbiAgICAgIHN1cHBvcnRCaWdOdW1iZXJzOiB0cnVlXG4gICAgfSwgY29uZmlnLmRpYWxlY3RPcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbjIgPSB0aGlzLmxpYi5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24yLnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbjIucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uMi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uMik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24yLm9uKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbjIub25jZShcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICBjb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgXCJFU09DS0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVDT05OUkVTRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRVBJUEVcIjpcbiAgICAgICAgICBjYXNlIFwiUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUXCI6XG4gICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICAgIGxldCB0ek9mZnNldCA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmU7XG4gICAgICAgIHR6T2Zmc2V0ID0gL1xcLy8udGVzdCh0ek9mZnNldCkgPyBtb21lbnRUei50eih0ek9mZnNldCkuZm9ybWF0KFwiWlwiKSA6IHR6T2Zmc2V0O1xuICAgICAgICBhd2FpdCBwcm9taXNpZnkoKGNiKSA9PiBjb25uZWN0aW9uLnF1ZXJ5KGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2AsIGNiKSkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICBjYXNlIFwiRUNPTk5SRUZVU0VEXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFUl9BQ0NFU1NfREVOSUVEX0VSUk9SXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRU5PVEZPVU5EXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUhPU1RVTlJFQUNIXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVJTlZBTFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmIChjb25uZWN0aW9uLl9jbG9zaW5nKSB7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4gY29ubmVjdGlvbi5lbmQoY2FsbGJhY2spKSgpO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiAhY29ubmVjdGlvbi5fZmF0YWxFcnJvciAmJiAhY29ubmVjdGlvbi5fcHJvdG9jb2xFcnJvciAmJiAhY29ubmVjdGlvbi5fY2xvc2luZyAmJiAhY29ubmVjdGlvbi5zdHJlYW0uZGVzdHJveWVkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.mysql.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.mysql = [\"DATETIME\"];\n  BaseTypes.STRING.types.mysql = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mysql = [\"STRING\"];\n  BaseTypes.TEXT.types.mysql = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mysql = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mysql = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mysql = [\"INT24\"];\n  BaseTypes.INTEGER.types.mysql = [\"LONG\"];\n  BaseTypes.BIGINT.types.mysql = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mysql = [\"FLOAT\"];\n  BaseTypes.TIME.types.mysql = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mysql = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mysql = [\"TINY\"];\n  BaseTypes.BLOB.types.mysql = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mysql = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mysql = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mysql = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mysql = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  const SUPPORTED_GEOMETRY_TYPES = [\"POINT\", \"LINESTRING\", \"POLYGON\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(\", \")}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLGdEQUFLO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsT0FBTyxFQUFFLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9DQUFvQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2RhdGEtdHlwZXMuanM/ZGZjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHdreCA9IHJlcXVpcmUoXCJ3a3hcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgQmFzZVR5cGVzLkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSBcImh0dHBzOi8vZGV2Lm15c3FsLmNvbS9kb2MvcmVmbWFuLzUuNy9lbi9kYXRhLXR5cGVzLmh0bWxcIjtcbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMubXlzcWwgPSBbXCJEQVRFVElNRVwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5teXNxbCA9IFtcIlZBUl9TVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm15c3FsID0gW1wiU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5teXNxbCA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm15c3FsID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm15c3FsID0gW1wiU0hPUlRcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMubXlzcWwgPSBbXCJJTlQyNFwiXTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMubXlzcWwgPSBbXCJMT05HXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm15c3FsID0gW1wiTE9OR0xPTkdcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5teXNxbCA9IFtcIkZMT0FUXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5teXNxbCA9IFtcIlRJTUVcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5teXNxbCA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm15c3FsID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubXlzcWwgPSBbXCJUSU5ZQkxPQlwiLCBcIkJMT0JcIiwgXCJMT05HQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubXlzcWwgPSBbXCJORVdERUNJTUFMXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5teXNxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5teXNxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5teXNxbCA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5teXNxbCA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm15c3FsID0gW1wiR0VPTUVUUllcIl07XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLm15c3FsID0gW1wiSlNPTlwiXTtcbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gc3VwZXIudG9TcWwoKTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICBkZWZpbml0aW9uICs9IFwiIFVOU0lHTkVEXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbiArPSBcIiBaRVJPRklMTFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID8gYERBVEVUSU1FKCR7dGhpcy5fbGVuZ3RofSlgIDogXCJEQVRFVElNRVwiO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTU1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3NcIik7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudFR6LnR6KHZhbHVlLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYCR7dmFsdWV9ICR7b3B0aW9ucy50aW1lem9uZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZygpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0hBUigzNikgQklOQVJZXCI7XG4gICAgfVxuICB9XG4gIGNvbnN0IFNVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUyA9IFtcIlBPSU5UXCIsIFwiTElORVNUUklOR1wiLCBcIlBPTFlHT05cIl07XG4gIGNsYXNzIEdFT01FVFJZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT01FVFJZIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzcmlkKSB7XG4gICAgICBzdXBlcih0eXBlLCBzcmlkKTtcbiAgICAgIGlmIChfLmlzRW1wdHkodGhpcy50eXBlKSkge1xuICAgICAgICB0aGlzLnNxbFR5cGUgPSB0aGlzLmtleTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFNVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUy5pbmNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZXMgYXJlOiAke1NVUFBPUlRFRF9HRU9NRVRSWV9UWVBFUy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXIoKTtcbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSg0KTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UodmFsdWUpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNxbFR5cGU7XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwob3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBFTlVNKCR7dGhpcy52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gb3B0aW9ucy5lc2NhcGUodmFsdWUpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgfVxuICB9XG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gXCJ3aGVyZVwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIEVOVU0sXG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBVVUlELFxuICAgIEdFT01FVFJZLFxuICAgIERFQ0lNQUwsXG4gICAgSlNPTjogSlNPTlRZUEVcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mysql);\nconst { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nclass MysqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMysqlDialect.prototype.defaultVersion = \"5.7.0\";\nMysqlDialect.prototype.Query = Query;\nMysqlDialect.prototype.QueryGenerator = QueryGenerator;\nMysqlDialect.prototype.DataTypes = DataTypes;\nMysqlDialect.prototype.name = \"mysql\";\nMysqlDialect.prototype.TICK_CHAR = \"`\";\nMysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;\nMysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;\nmodule.exports = MysqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFtQjtBQUNsRCxrQkFBa0IsdUdBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9pbmRleC5qcz80MmY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm15c3FsO1xuY29uc3QgeyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBNeXNxbERpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBNeVNRTFF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbiAgY2FuQmFja3NsYXNoRXNjYXBlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIlZBTFVFUyAoKVwiOiB0cnVlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBmb3JTaGFyZTogXCJMT0NLIElOIFNIQVJFIE1PREVcIixcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IGZhbHNlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogXCIgSUdOT1JFXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IFwiIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFXCJcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcGFyc2VyOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IDFcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2UsXG4gICAgY2hlY2s6IGZhbHNlXG4gIH0sXG4gIGluZGV4VmlhQWx0ZXI6IHRydWUsXG4gIGluZGV4SGludHM6IHRydWUsXG4gIE5VTUVSSUM6IHRydWUsXG4gIEdFT01FVFJZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBSRUdFWFA6IHRydWVcbn0pO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiNS43LjBcIjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnlHZW5lcmF0b3IgPSBRdWVyeUdlbmVyYXRvcjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJteXNxbFwiO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSBcImBcIjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBNeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IE15c3FsRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT VERSION() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      engine: \"InnoDB\",\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')\";\n    }\n    return `${query};`;\n  }\n  tableExistsQuery(table) {\n    const tableName = this.escape(this.quoteTable(table).slice(1, -1));\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes(\"REFERENCES\")) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\"\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"CHANGE\",\n      attrString.join(\", \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        smth.type = \"char\";\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = \"decimal\";\n      } else if (/text/i.test(smth.type)) {\n        smth.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _toJSONValue(value) {\n    if (typeof value === \"boolean\") {\n      return value.toString();\n    }\n    if (value === null) {\n      return \"null\";\n    }\n    return value;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = \"\";\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n    where = this.getWhereConditions(where, null, model, options);\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n    return query + limit;\n  }\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" auto_increment\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = MySQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDcEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDcEMsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUY7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBLFFBQVE7QUFDUix3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxHQUFHLHlCQUF5QjtBQUN0RTtBQUNBLDBDQUEwQyxpQ0FBaUMsR0FBRyxzRUFBc0U7QUFDcEo7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsSUFBSSxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLGdCQUFnQixlQUFlO0FBQy9CLDJFQUEyRSw2QkFBNkI7QUFDeEcsNENBQTRDLGdCQUFnQjtBQUM1RCxvQ0FBb0MsZ0JBQWdCO0FBQ3BELHdEQUF3RCw2QkFBNkI7QUFDckYseUNBQXlDLGtCQUFrQjtBQUMzRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxXQUFXLHFCQUFxQiw0Q0FBNEM7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLElBQUksV0FBVztBQUN0RSxRQUFRO0FBQ1IsNkJBQTZCLGNBQWMsT0FBTyxjQUFjLEtBQUssV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRCx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxPQUFPLFNBQVMsS0FBSyxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0NBQWdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQixHQUFHLFNBQVM7QUFDN0Usd0NBQXdDLFFBQVEsZUFBZSxTQUFTO0FBQ3hFO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEYsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCx5REFBeUQsaUJBQWlCO0FBQzFFLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4Qyw4Q0FBOEMsaUJBQWlCO0FBQy9ELDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnktZ2VuZXJhdG9yLmpzPzkzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IE9wID0gcmVxdWlyZShcIi4uLy4uL29wZXJhdG9yc1wiKTtcbmNvbnN0IEpTT05fRlVOQ1RJT05fUkVHRVggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbmNvbnN0IEpTT05fT1BFUkFUT1JfUkVHRVggPSAvXlxccyooLT4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG5jb25zdCBUT0tFTl9DQVBUVVJFX1JFR0VYID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG5jb25zdCBGT1JFSUdOX0tFWV9GSUVMRFMgPSBbXG4gIFwiQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnRfbmFtZVwiLFxuICBcIkNPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50TmFtZVwiLFxuICBcIkNPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRTY2hlbWFcIixcbiAgXCJDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50Q2F0YWxvZ1wiLFxuICBcIlRBQkxFX05BTUUgYXMgdGFibGVOYW1lXCIsXG4gIFwiVEFCTEVfU0NIRU1BIGFzIHRhYmxlU2NoZW1hXCIsXG4gIFwiVEFCTEVfU0NIRU1BIGFzIHRhYmxlQ2F0YWxvZ1wiLFxuICBcIkNPTFVNTl9OQU1FIGFzIGNvbHVtbk5hbWVcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVTY2hlbWFcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSBhcyByZWZlcmVuY2VkVGFibGVDYXRhbG9nXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9OQU1FIGFzIHJlZmVyZW5jZWRUYWJsZU5hbWVcIixcbiAgXCJSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FIGFzIHJlZmVyZW5jZWRDb2x1bW5OYW1lXCJcbl0uam9pbihcIixcIik7XG5jb25zdCB0eXBlV2l0aG91dERlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJCTE9CXCIsIFwiVEVYVFwiLCBcIkdFT01FVFJZXCIsIFwiSlNPTlwiXSk7XG5jbGFzcyBNeVNRTFF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLk9wZXJhdG9yTWFwID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5PcGVyYXRvck1hcCksIHtcbiAgICAgIFtPcC5yZWdleHBdOiBcIlJFR0VYUFwiLFxuICAgICAgW09wLm5vdFJlZ2V4cF06IFwiTk9UIFJFR0VYUFwiXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBEQVRBQkFTRSBJRiBOT1QgRVhJU1RTXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJBQ1RFUiBTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNoYXJzZXQpfWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYERFRkFVTFQgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIERBVEFCQVNFIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSl9O2A7XG4gIH1cbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHJldHVybiBcIlNIT1cgVEFCTEVTXCI7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTSE9XIFRBQkxFU1wiO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgVkVSU0lPTigpIGFzIGB2ZXJzaW9uYFwiO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGVuZ2luZTogXCJJbm5vREJcIixcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICByb3dGb3JtYXQ6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdO1xuICAgIGNvbnN0IGZvcmVpZ25LZXlzID0ge307XG4gICAgY29uc3QgYXR0clN0ciA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICBsZXQgbWF0Y2g7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV19YCk7XG4gICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNDbGF1c2UgPSBhdHRyU3RyLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbihcIl9cIil9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBVTklRVUUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9yZWlnbktleXMsIGZrZXkpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFNcIixcbiAgICAgIHRhYmxlLFxuICAgICAgYCgke2F0dHJpYnV0ZXNDbGF1c2V9KWAsXG4gICAgICBgRU5HSU5FPSR7b3B0aW9ucy5lbmdpbmV9YCxcbiAgICAgIG9wdGlvbnMuY29tbWVudCAmJiB0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSBcInN0cmluZ1wiICYmIGBDT01NRU5UICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb21tZW50KX1gLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJTRVQ9JHtvcHRpb25zLmNoYXJzZXR9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgQ09MTEFURSAke29wdGlvbnMuY29sbGF0ZX1gLFxuICAgICAgb3B0aW9ucy5pbml0aWFsQXV0b0luY3JlbWVudCAmJiBgQVVUT19JTkNSRU1FTlQ9JHtvcHRpb25zLmluaXRpYWxBdXRvSW5jcmVtZW50fWAsXG4gICAgICBvcHRpb25zLnJvd0Zvcm1hdCAmJiBgUk9XX0ZPUk1BVD0ke29wdGlvbnMucm93Rm9ybWF0fWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEoe1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyXG4gICAgfSkpO1xuICAgIHJldHVybiBgU0hPVyBGVUxMIENPTFVNTlMgRlJPTSAke3RhYmxlfTtgO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeShkYXRhYmFzZSkge1xuICAgIGxldCBxdWVyeSA9IFwiU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSdcIjtcbiAgICBpZiAoZGF0YWJhc2UpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoZGF0YWJhc2UpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ICs9IFwiIEFORCBUQUJMRV9TQ0hFTUEgTk9UIElOICgnTVlTUUwnLCAnSU5GT1JNQVRJT05fU0NIRU1BJywgJ1BFUkZPUk1BTkNFX1NDSEVNQScsICdTWVMnLCAnbXlzcWwnLCAnaW5mb3JtYXRpb25fc2NoZW1hJywgJ3BlcmZvcm1hbmNlX3NjaGVtYScsICdzeXMnKVwiO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cXVlcnl9O2A7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZXNjYXBlKHRoaXMucXVvdGVUYWJsZSh0YWJsZSkuc2xpY2UoMSwgLTEpKTtcbiAgICByZXR1cm4gYFNFTEVDVCBUQUJMRV9OQU1FIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnIEFORCBUQUJMRV9OQU1FID0gJHt0YWJsZU5hbWV9IEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSl9YDtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIkFERFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgY29udGV4dDogXCJhZGRDb2x1bW5cIixcbiAgICAgICAgdGFibGVOYW1lOiB0YWJsZSxcbiAgICAgICAgZm9yZWlnbktleToga2V5XG4gICAgICB9KSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1BcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG4gICAgY29uc3QgY29uc3RyYWludFN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKTtcbiAgICAgICAgY29uc3RyYWludFN0cmluZy5wdXNoKGBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHJpbmcucHVzaChgXFxgJHthdHRyaWJ1dGVOYW1lfVxcYCBcXGAke2F0dHJpYnV0ZU5hbWV9XFxgICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyU3RyaW5nLmxlbmd0aCAmJiBgQ0hBTkdFICR7YXR0clN0cmluZy5qb2luKFwiLCBcIil9YCxcbiAgICAgIGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoICYmIGBBREQgJHtjb25zdHJhaW50U3RyaW5nLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICBhdHRyU3RyaW5nLnB1c2goYFxcYCR7YXR0ckJlZm9yZX1cXGAgXFxgJHthdHRyTmFtZX1cXGAgJHtkZWZpbml0aW9ufWApO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiQ0hBTkdFXCIsXG4gICAgICBhdHRyU3RyaW5nLmpvaW4oXCIsIFwiKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgaWYgKHNtdGguY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChzbXRoLmNvbmRpdGlvbnMpLm1hcCgoY29uZGl0aW9uKSA9PiBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2ApO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5wYXRoKSB7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzbXRoLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gc210aC5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoc210aC5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGgudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoXCIgPSAlc1wiLCB0aGlzLmVzY2FwZShzbXRoLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoL3RpbWVzdGFtcC9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSBcImRhdGV0aW1lXCI7XG4gICAgICB9IGVsc2UgaWYgKHNtdGguanNvbiAmJiAvYm9vbGVhbi9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSBcImNoYXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoL2RvdWJsZSBwcmVjaXNpb24vaS50ZXN0KHNtdGgudHlwZSkgfHwgL2Jvb2xlYW4vaS50ZXN0KHNtdGgudHlwZSkgfHwgL2ludGVnZXIvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gXCJkZWNpbWFsXCI7XG4gICAgICB9IGVsc2UgaWYgKC90ZXh0L2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9IFwiY2hhclwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgbGV0IGxpbWl0ID0gXCJcIjtcbiAgICBsZXQgcXVlcnkgPSBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBsaW1pdCA9IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX1gO1xuICAgIH1cbiAgICB3aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgaWYgKHdoZXJlKSB7XG4gICAgICBxdWVyeSArPSBgIFdIRVJFICR7d2hlcmV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5ICsgbGltaXQ7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgU0hPVyBJTkRFWCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5kYXRhYmFzZSAmJiBgRlJPTSBcXGAke29wdGlvbnMuZGF0YWJhc2V9XFxgYFxuICAgIF0pO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIENPTlNUUkFJTlRfQ0FUQUxPRyBBUyBjb25zdHJhaW50Q2F0YWxvZyxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9OQU1FIEFTIGNvbnN0cmFpbnROYW1lLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX1NDSEVNQSBBUyBjb25zdHJhaW50U2NoZW1hLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX1RZUEUgQVMgY29uc3RyYWludFR5cGUsXCIsXG4gICAgICBcIlRBQkxFX05BTUUgQVMgdGFibGVOYW1lLFwiLFxuICAgICAgXCJUQUJMRV9TQ0hFTUEgQVMgdGFibGVTY2hlbWFcIixcbiAgICAgIFwiZnJvbSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFNcIixcbiAgICAgIGBXSEVSRSB0YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nYCxcbiAgICAgIGNvbnN0cmFpbnROYW1lICYmIGBBTkQgY29uc3RyYWludF9uYW1lID0gJyR7Y29uc3RyYWludE5hbWV9J2AsXG4gICAgICBzY2hlbWFOYW1lICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJEUk9QIElOREVYXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpLFxuICAgICAgXCJPTlwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICBdKTtcbiAgfVxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYXR0cmlidXRlU3RyaW5nID0gYXR0cmlidXRlLnR5cGUudG9TdHJpbmcoeyBlc2NhcGU6IHRoaXMuZXNjYXBlLmJpbmQodGhpcykgfSk7XG4gICAgbGV0IHRlbXBsYXRlID0gYXR0cmlidXRlU3RyaW5nO1xuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBhdXRvX2luY3JlbWVudFwiO1xuICAgIH1cbiAgICBpZiAoIXR5cGVXaXRob3V0RGVmYXVsdC5oYXMoYXR0cmlidXRlU3RyaW5nKSAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlICYmIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmNvbW1lbnQpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuZmlyc3QpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIEZJUlNUXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYWZ0ZXIpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQUZURVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuYWZ0ZXIpfWA7XG4gICAgfVxuICAgIGlmICgoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cykgJiYgYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gXCJhZGRDb2x1bW5cIiAmJiBvcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICBjb25zdCBma05hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihgJHtvcHRpb25zLnRhYmxlTmFtZX1fJHthdHRyTmFtZX1fZm9yZWlnbl9pZHhgKTtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCwgQUREIENPTlNUUkFJTlQgJHtma05hbWV9IEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSlgO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIil9KWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBKU09OX0ZVTkNUSU9OX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKFwiKFwiKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBKU09OX09QRVJBVE9SX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gVE9LRU5fQ0FQVFVSRV9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSBcIihcIikge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIChoYXNJbnZhbGlkVG9rZW4gfHwgb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBzY2hlbWFOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICBgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSB3aGVyZSBUQUJMRV9OQU1FID0gJyR7dGFibGVOYW1lfSdgLFxuICAgICAgYEFORCBDT05TVFJBSU5UX05BTUUhPSdQUklNQVJZJyBBTkQgQ09OU1RSQUlOVF9TQ0hFTUE9JyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgIFwiQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTFwiLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hID8gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSkgOiBcIlwiO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIGNvbnN0IHF1b3RlZENvbHVtbk5hbWUgPSB3cmFwU2luZ2xlUXVvdGUoY29sdW1uTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgIFwiRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRVwiLFxuICAgICAgXCJXSEVSRSAoXCIsXG4gICAgICBbXG4gICAgICAgIGBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIFJFRkVSRU5DRURfQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YFxuICAgICAgXSxcbiAgICAgIFwiKSBPUiAoXCIsXG4gICAgICBbXG4gICAgICAgIGBUQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YCxcbiAgICAgICAgXCJBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXCJcbiAgICAgIF0sXG4gICAgICBcIilcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgRk9SRUlHTiBLRVlcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gVXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgXCJgXCIpLCBcImBcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIHJldHVybiBVdGlscy5hZGRUaWNrcyhpZGVudGlmaWVyLCBcIidcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IE15U1FMUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass MySQLQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = Object.values(options.model.primaryKeys).map((item) => item.field);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.MySQLQueryInterface = MySQLQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDRHQUE2QjtBQUNoRSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQ0FBZ0MsV0FBVztBQUNoRDtBQUNBLDBLQUEwSyxXQUFXO0FBQ3JMO0FBQ0EscUhBQXFILFdBQVc7QUFDaEk7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVGQUF1RjtBQUN2RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1pbnRlcmZhY2UuanM/NGI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY2xhc3MgTXlTUUxRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgIH0sIGNvbHVtbk5hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoICYmIHJlc3VsdHNbMF0uY29uc3RyYWludF9uYW1lICE9PSBcIlBSSU1BUllcIikge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoKGNvbnN0cmFpbnQpID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludF9uYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpKSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgY29sdW1uTmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IE9iamVjdC52YWx1ZXMob3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5cykubWFwKChpdGVtKSA9PiBpdGVtLmZpZWxkKTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgbW9kZWwucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICB9LCBjb25zdHJhaW50TmFtZSk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiB0aGlzLnNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UU1xuICAgIH0pKTtcbiAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludHNbMF07XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICghY29uc3RyYWludCB8fCAhY29uc3RyYWludC5jb25zdHJhaW50VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYENvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gb24gdGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludE5hbWUsXG4gICAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50VHlwZSA9PT0gXCJGT1JFSUdOIEtFWVwiKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUluZGV4UXVlcnkoY29uc3RyYWludC50YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICB9XG59XG5leHBvcnRzLk15U1FMUXVlcnlJbnRlcmZhY2UgPSBNeVNRTFF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mysql\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      if (parameters && parameters.length) {\n        results = await new Promise((resolve, reject) => {\n          connection.execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      } else {\n        results = await new Promise((resolve, reject) => {\n          connection.query({ sql }, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      }\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.Field] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MySQL Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2].split(\".\").pop() : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakUsMEJBQTBCLHFFQUFxRTtBQUMvRjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL3F1ZXJ5LmpzP2RkMzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBFUl9EVVBfRU5UUlkgPSAxMDYyO1xuY29uc3QgRVJfREVBRExPQ0sgPSAxMjEzO1xuY29uc3QgRVJfUk9XX0lTX1JFRkVSRU5DRUQgPSAxNDUxO1xuY29uc3QgRVJfTk9fUkVGRVJFTkNFRF9ST1cgPSAxNDUyO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOm15c3FsXCIpO1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBfX3NwcmVhZFZhbHVlcyh7IHNob3dXYXJuaW5nczogZmFsc2UgfSwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXNfKSA9PiB7XG4gICAgICBpZiAodmFsdWVzX1trZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYmluZFBhcmFtLnB1c2godmFsdWVzX1trZXldKTtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbS5sZW5ndGggPiAwID8gYmluZFBhcmFtIDogdm9pZCAwXTtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNob3dXYXJuaW5ncyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc2hvd1dhcm5pbmdzIHx8IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGRlYnVnKFwicGFyYW1ldGVycyglailcIiwgcGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzO1xuICAgIGNvbnN0IGVyckZvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwYXJhbWV0ZXJzICYmIHBhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdHMgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5leGVjdXRlKHNxbCwgcGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5KHsgc3FsIH0sIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpLnNldE1heExpc3RlbmVycygxMDApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgZXJyb3IuZXJybm8gPT09IEVSX0RFQURMT0NLKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgb3B0aW9ucy50cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcl8pIHtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkID0gXCJyb2xsYmFja1wiO1xuICAgICAgfVxuICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgZXJyb3IucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yLCBlcnJGb3JTdGFjay5zdGFjayk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGlmIChzaG93V2FybmluZ3MgJiYgcmVzdWx0cyAmJiByZXN1bHRzLndhcm5pbmdTdGF0dXMgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1dhcm5pbmdzKHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdHMpO1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gXCJSZXN1bHRTZXRIZWFkZXJcIiAmJiB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBkYXRhLmFmZmVjdGVkUm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IFt0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZF06IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZW51bVJlZ2V4ID0gL15lbnVtL2k7XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiBlbnVtUmVnZXgudGVzdChfcmVzdWx0LlR5cGUpID8gX3Jlc3VsdC5UeXBlLnJlcGxhY2UoZW51bVJlZ2V4LCBcIkVOVU1cIikgOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTnVsbCA9PT0gXCJZRVNcIixcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleSA9PT0gXCJQUklcIixcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwgXCJFeHRyYVwiKSAmJiBfcmVzdWx0LkV4dHJhLnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0b19pbmNyZW1lbnRcIixcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnQgPyBfcmVzdWx0LkNvbW1lbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YS5hZmZlY3RlZFJvd3M7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3MgPT09IDFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtkYXRhLCBkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBsb2dXYXJuaW5ncyhyZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FybmluZ1Jlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bihcIlNIT1cgV0FSTklOR1NcIik7XG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgTXlTUUwgV2FybmluZ3MgKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KTogYDtcbiAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgX3dhcm5pbmdSb3cgb2Ygd2FybmluZ1Jlc3VsdHMpIHtcbiAgICAgIGlmIChfd2FybmluZ1JvdyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBfd2FybmluZ1Jvd1tTeW1ib2wuaXRlcmF0b3JdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF93YXJuaW5nUmVzdWx0IG9mIF93YXJuaW5nUm93KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3dhcm5pbmdSZXN1bHQsIFwiTWVzc2FnZVwiKSkge1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goX3dhcm5pbmdSZXN1bHQuTWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBfb2JqZWN0S2V5IG9mIF93YXJuaW5nUmVzdWx0LmtleXMoKSkge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChbX29iamVjdEtleSwgX3dhcm5pbmdSZXN1bHRbX29iamVjdEtleV1dLmpvaW4oXCI6IFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2VxdWVsaXplLmxvZyh3YXJuaW5nTWVzc2FnZSArIG1lc3NhZ2VzLmpvaW4oXCI7IFwiKSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSB7XG4gICAgY29uc3QgZXJyQ29kZSA9IGVyci5lcnJubyB8fCBlcnIuY29kZTtcbiAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgIGNhc2UgRVJfRFVQX0VOVFJZOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0R1cGxpY2F0ZSBlbnRyeSAnKFtcXHNcXFNdKiknIGZvciBrZXkgJz8oKC58XFxzKSo/KSc/JC8pO1xuICAgICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoXCItXCIpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZEtleSA9IG1hdGNoID8gbWF0Y2hbMl0uc3BsaXQoXCIuXCIpLnBvcCgpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZFZhbCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW2ZpZWxkS2V5XTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGlmICh1bmlxdWVLZXkubXNnKVxuICAgICAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbZmllbGRLZXldID0gZmllbGRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIEVSX1JPV19JU19SRUZFUkVOQ0VEOlxuICAgICAgY2FzZSBFUl9OT19SRUZFUkVOQ0VEX1JPVzoge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9DT05TVFJBSU5UIChbYFwiXSkoLiopXFwxIEZPUkVJR04gS0VZIFxcKFxcMSguKilcXDFcXCkgUkVGRVJFTkNFUyBcXDEoLiopXFwxIFxcKFxcMSguKilcXDFcXCkvKTtcbiAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiYFwiO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBtYXRjaCA/IG1hdGNoWzNdLnNwbGl0KG5ldyBSZWdFeHAoYCR7cXVvdGVDaGFyfSwgKiR7cXVvdGVDaGFyfWApKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgcmVsdHlwZTogU3RyaW5nKGVyckNvZGUpID09PSBTdHJpbmcoRVJfUk9XX0lTX1JFRkVSRU5DRUQpID8gXCJwYXJlbnRcIiA6IFwiY2hpbGRcIixcbiAgICAgICAgICB0YWJsZTogbWF0Y2ggPyBtYXRjaFs0XSA6IHZvaWQgMCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoICYmIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZHNbMF1dIHx8IHZvaWQgMCxcbiAgICAgICAgICBpbmRleDogbWF0Y2ggPyBtYXRjaFsyXSA6IHZvaWQgMCxcbiAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoIShpdGVtLktleV9uYW1lIGluIGFjYykpIHtcbiAgICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdID0gaXRlbTtcbiAgICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjY1tpdGVtLktleV9uYW1lXS5maWVsZHNbaXRlbS5TZXFfaW5faW5kZXggLSAxXSA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBpdGVtLkNvbHVtbl9uYW1lLFxuICAgICAgICBsZW5ndGg6IGl0ZW0uU3ViX3BhcnQgfHwgdm9pZCAwLFxuICAgICAgICBvcmRlcjogaXRlbS5Db2xsYXRpb24gPT09IFwiQVwiID8gXCJBU0NcIiA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBpdGVtLmNvbHVtbl9uYW1lO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIF8ubWFwKGRhdGEsIChpdGVtKSA9PiAoe1xuICAgICAgcHJpbWFyeTogaXRlbS5LZXlfbmFtZSA9PT0gXCJQUklNQVJZXCIsXG4gICAgICBmaWVsZHM6IGl0ZW0uZmllbGRzLFxuICAgICAgbmFtZTogaXRlbS5LZXlfbmFtZSxcbiAgICAgIHRhYmxlTmFtZTogaXRlbS5UYWJsZSxcbiAgICAgIHVuaXF1ZTogaXRlbS5Ob25fdW5pcXVlICE9PSAxLFxuICAgICAgdHlwZTogaXRlbS5JbmRleF90eXBlXG4gICAgfSkpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/connection-manager.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleConnectionManager: () => OracleConnectionManager\n});\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst debug = logger.debugContext(\"connection:oracle\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").oracle);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass OracleConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1521;\n    this.lib = this._loadDialectModule(\"oracledb\");\n    this.extendLib();\n    this.refreshTypeParser(DataTypes);\n  }\n  extendLib() {\n    if (this.sequelize.config && \"dialectOptions\" in this.sequelize.config) {\n      const dialectOptions = this.sequelize.config.dialectOptions;\n      if (dialectOptions && \"maxRows\" in dialectOptions) {\n        this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;\n      }\n      if (dialectOptions && \"fetchAsString\" in dialectOptions) {\n        this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;\n      } else {\n        this.lib.fetchAsString = [this.lib.CLOB];\n      }\n    }\n    this.lib.fetchAsBuffer = [this.lib.BLOB];\n  }\n  buildConnectString(config) {\n    if (!config.host || config.host.length === 0)\n      return config.database;\n    let connectString = config.host;\n    if (config.port && config.port > 0) {\n      connectString += `:${config.port}`;\n    } else {\n      connectString += \":1521\";\n    }\n    if (config.database && config.database.length > 0) {\n      connectString += `/${config.database}`;\n    }\n    return connectString;\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      user: config.username,\n      password: config.password,\n      externalAuth: config.externalAuth,\n      stmtCacheSize: 0,\n      connectString: this.buildConnectString(config)\n    }, config.dialectOptions);\n    try {\n      const connection = await this.lib.getConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      let errorCode = err.message.split(\":\");\n      errorCode = errorCode[0];\n      switch (errorCode) {\n        case \"ORA-12560\":\n        case \"ORA-12154\":\n        case \"ORA-12505\":\n        case \"ORA-12514\":\n        case \"NJS-511\":\n        case \"NJS-516\":\n        case \"NJS-517\":\n        case \"NJS-520\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ORA-28000\":\n        case \"ORA-28040\":\n        case \"ORA-01017\":\n        case \"NJS-506\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ORA-12541\":\n        case \"NJS-503\":\n        case \"NJS-508\":\n        case \"NJS-507\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"NJS-512\":\n        case \"NJS-515\":\n        case \"NJS-518\":\n        case \"NJS-519\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        case \"ORA-12170\":\n        case \"NJS-510\":\n          throw new SequelizeErrors.ConnectionTimedOutError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isHealthy()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.close(callback))();\n  }\n  validate(connection) {\n    return connection && connection.isHealthy();\n  }\n}\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CO0FBQ0Esa0JBQWtCLHdHQUFrQztBQUNwRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9jb25uZWN0aW9uLW1hbmFnZXIuanM/NTkwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBPcmFjbGVDb25uZWN0aW9uTWFuYWdlcjogKCkgPT4gT3JhY2xlQ29ubmVjdGlvbk1hbmFnZXJcbn0pO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJvcmFjbGVcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOm9yYWNsZVwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm9yYWNsZTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbmNsYXNzIE9yYWNsZUNvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5zZXF1ZWxpemUuY29uZmlnLnBvcnQgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAxNTIxO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJvcmFjbGVkYlwiKTtcbiAgICB0aGlzLmV4dGVuZExpYigpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBleHRlbmRMaWIoKSB7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZyAmJiBcImRpYWxlY3RPcHRpb25zXCIgaW4gdGhpcy5zZXF1ZWxpemUuY29uZmlnKSB7XG4gICAgICBjb25zdCBkaWFsZWN0T3B0aW9ucyA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0T3B0aW9ucztcbiAgICAgIGlmIChkaWFsZWN0T3B0aW9ucyAmJiBcIm1heFJvd3NcIiBpbiBkaWFsZWN0T3B0aW9ucykge1xuICAgICAgICB0aGlzLmxpYi5tYXhSb3dzID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RPcHRpb25zLm1heFJvd3M7XG4gICAgICB9XG4gICAgICBpZiAoZGlhbGVjdE9wdGlvbnMgJiYgXCJmZXRjaEFzU3RyaW5nXCIgaW4gZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saWIuZmV0Y2hBc1N0cmluZyA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5saWIuZmV0Y2hBc1N0cmluZyA9IFt0aGlzLmxpYi5DTE9CXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5saWIuZmV0Y2hBc0J1ZmZlciA9IFt0aGlzLmxpYi5CTE9CXTtcbiAgfVxuICBidWlsZENvbm5lY3RTdHJpbmcoY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcuaG9zdCB8fCBjb25maWcuaG9zdC5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gY29uZmlnLmRhdGFiYXNlO1xuICAgIGxldCBjb25uZWN0U3RyaW5nID0gY29uZmlnLmhvc3Q7XG4gICAgaWYgKGNvbmZpZy5wb3J0ICYmIGNvbmZpZy5wb3J0ID4gMCkge1xuICAgICAgY29ubmVjdFN0cmluZyArPSBgOiR7Y29uZmlnLnBvcnR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29ubmVjdFN0cmluZyArPSBcIjoxNTIxXCI7XG4gICAgfVxuICAgIGlmIChjb25maWcuZGF0YWJhc2UgJiYgY29uZmlnLmRhdGFiYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbm5lY3RTdHJpbmcgKz0gYC8ke2NvbmZpZy5kYXRhYmFzZX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdFN0cmluZztcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGV4dGVybmFsQXV0aDogY29uZmlnLmV4dGVybmFsQXV0aCxcbiAgICAgIHN0bXRDYWNoZVNpemU6IDAsXG4gICAgICBjb25uZWN0U3RyaW5nOiB0aGlzLmJ1aWxkQ29ubmVjdFN0cmluZyhjb25maWcpXG4gICAgfSwgY29uZmlnLmRpYWxlY3RPcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMubGliLmdldENvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoY29ubmVjdGlvbi5vcmFjbGVTZXJ2ZXJWZXJzaW9uU3RyaW5nKS52ZXJzaW9uO1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICBjYXNlIFwiRVNPQ0tFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFQ09OTlJFU0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVQSVBFXCI6XG4gICAgICAgICAgY2FzZSBcIlBST1RPQ09MX0NPTk5FQ1RJT05fTE9TVFwiOlxuICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsZXQgZXJyb3JDb2RlID0gZXJyLm1lc3NhZ2Uuc3BsaXQoXCI6XCIpO1xuICAgICAgZXJyb3JDb2RlID0gZXJyb3JDb2RlWzBdO1xuICAgICAgc3dpdGNoIChlcnJvckNvZGUpIHtcbiAgICAgICAgY2FzZSBcIk9SQS0xMjU2MFwiOlxuICAgICAgICBjYXNlIFwiT1JBLTEyMTU0XCI6XG4gICAgICAgIGNhc2UgXCJPUkEtMTI1MDVcIjpcbiAgICAgICAgY2FzZSBcIk9SQS0xMjUxNFwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxMVwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxNlwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxN1wiOlxuICAgICAgICBjYXNlIFwiTkpTLTUyMFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiT1JBLTI4MDAwXCI6XG4gICAgICAgIGNhc2UgXCJPUkEtMjgwNDBcIjpcbiAgICAgICAgY2FzZSBcIk9SQS0wMTAxN1wiOlxuICAgICAgICBjYXNlIFwiTkpTLTUwNlwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIk9SQS0xMjU0MVwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUwM1wiOlxuICAgICAgICBjYXNlIFwiTkpTLTUwOFwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUwN1wiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJOSlMtNTEyXCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTE1XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTE4XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTE5XCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJPUkEtMTIxNzBcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTBcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25UaW1lZE91dEVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKCFjb25uZWN0aW9uLmlzSGVhbHRoeSgpKSB7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4gY29ubmVjdGlvbi5jbG9zZShjYWxsYmFjaykpKCk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uaXNIZWFsdGh5KCk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/data-types.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n    _stringify() {\n      return \"SYSDATE\";\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  DATE.prototype.escape = false;\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let result = \"\";\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n        result += \")\";\n      }\n      return `NUMBER${result}`;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"SMALLINT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT))\n        return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n      return value;\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"INTEGER\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n      return value;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE))\n        return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n      this.key = \"DOUBLE PRECISION\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n      return value;\n    }\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n    }\n  }\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLEtBQUssT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssS0FBSyxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvZGF0YS10eXBlcy5qcz8xMTcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh2b2lkIDAsIFwiaHR0cHM6Ly93d3cub3JhY2xlLmNvbS9wbHMvdG9waWMvbG9va3VwP2N0eD1kYmxhdGVzdCZpZD1HVUlELUQ0MjREMjNCLTA5MzMtNDI1Ri1CQzY5LTlDMEU2NzI0NjkzQ1wiKTtcbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMub3JhY2xlID0gW1wiVElNRVNUQU1QXCIsIFwiVElNRVNUQU1QIFdJVEggTE9DQUwgVElNRSBaT05FXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm9yYWNsZSA9IFtcIlZBUkNIQVIyXCIsIFwiTlZBUkNIQVIyXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5vcmFjbGUgPSBbXCJDSEFSXCIsIFwiUkFXXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5vcmFjbGUgPSBbXCJDTE9CXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5vcmFjbGUgPSBbXCJOVU1CRVJcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5vcmFjbGUgPSBbXCJOVU1CRVJcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMub3JhY2xlID0gW1wiTlVNQkVSXCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5vcmFjbGUgPSBbXCJJTlRFR0VSXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm9yYWNsZSA9IFtcIk5VTUJFUlwiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm9yYWNsZSA9IFtcIkJJTkFSWV9GTE9BVFwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm9yYWNsZSA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLm9yYWNsZSA9IFtcIkNIQVIoMSlcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm9yYWNsZSA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLm9yYWNsZSA9IFtcIk5VTUJFUlwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMub3JhY2xlID0gW1wiVkFSQ0hBUjJcIl07XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm9yYWNsZSA9IFtcIlZBUkNIQVIyXCJdO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5vcmFjbGUgPSBbXCJCSU5BUllfRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm9yYWNsZSA9IFtcIkJJTkFSWV9ET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLm9yYWNsZSA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5vcmFjbGUgPSBmYWxzZTtcbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiA0ZTMgfHwgdGhpcy5fYmluYXJ5ICYmIHRoaXMuX2xlbmd0aCA+IDJlMykge1xuICAgICAgICB3YXJuKFwiT3JhY2xlIHN1cHBvcnRzIGxlbmd0aCB1cCB0byAzMjc2NCBieXRlcyBvciBjaGFyYWN0ZXJzOyBCZSBzdXJlIHRoYXQgeW91ciBhZG1pbmlzdHJhdG9yIGhhcyBleHRlbmRlZCB0aGUgTUFYX1NUUklOR19TSVpFIHBhcmFtZXRlci4gQ2hlY2sgaHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vcGxzL3RvcGljL2xvb2t1cD9jdHg9ZGJsYXRlc3QmaWQ9R1VJRC03QjcyRTE1NC02NzdBLTQzNDItQTFFQS1DNzRDMUVBOTI4RTZcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYE5WQVJDSEFSMigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgUkFXKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZS50b1N0cmluZyhcImhleFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1JBVywgbWF4U2l6ZTogdGhpcy5fbGVuZ3RoIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1ZBUkNIQVIsIG1heFNpemU6IHRoaXMuX2xlbmd0aCB9O1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgfVxuICBTVFJJTkcucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBjbGFzcyBCT09MRUFOIGV4dGVuZHMgQmFzZVR5cGVzLkJPT0xFQU4ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0hBUigxKVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9DSEFSLCBtYXhTaXplOiAxIH07XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/IFwiMVwiIDogdmFsdWUgPT09IGZhbHNlID8gXCIwXCIgOiB2YWx1ZTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCIxXCIgfHwgdmFsdWUgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IHZhbHVlID09PSBcIjBcIiB8fCB2YWx1ZSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5fc2FuaXRpemUodmFsdWUpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVkFSQ0hBUjIoMzYpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1ZBUkNIQVIsIG1heFNpemU6IDM2IH07XG4gICAgfVxuICB9XG4gIGNsYXNzIE5PVyBleHRlbmRzIEJhc2VUeXBlcy5OT1cge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiU1lTREFURVwiO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KCkge1xuICAgICAgcmV0dXJuIFwiU1lTREFURVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVkFSQ0hBUjIoNTEyKVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9WQVJDSEFSLCBtYXhTaXplOiA1MTIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkNMT0JcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQ0xPQiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBDSEFSIGV4dGVuZHMgQmFzZVR5cGVzLkNIQVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICB3YXJuKFwiT3JhY2xlIENIQVIuQklOQVJZIGRhdGF0eXBlIGlzIG5vdCBvZiBGaXhlZCBMZW5ndGguXCIpO1xuICAgICAgICByZXR1cm4gYFJBVygke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1JBVywgbWF4U2l6ZTogdGhpcy5fbGVuZ3RoIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0NIQVIsIG1heFNpemU6IHRoaXMuX2xlbmd0aCB9O1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEUge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVElNRVNUQU1QIFdJVEggTE9DQUwgVElNRSBaT05FXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1RJTUVTVEFNUF9MVFogfTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBmb3JtYXQgPSBcIllZWVktTU0tREQgSEgyNDpNSTpTUy5GRlRaSDpUWk1cIjtcbiAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgZm9ybWF0ZWREYXRlID0gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBaXCIpO1xuICAgICAgcmV0dXJuIGBUT19USU1FU1RBTVBfVFooJyR7Zm9ybWF0ZWREYXRlfScsJyR7Zm9ybWF0fScpYDtcbiAgICB9XG4gICAgX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMudGltZXpvbmUpIHtcbiAgICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgICBkYXRlID0gbW9tZW50VHooZGF0ZSkudHoob3B0aW9ucy50aW1lem9uZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZSA9IG1vbWVudChkYXRlKS51dGNPZmZzZXQob3B0aW9ucy50aW1lem9uZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGUgPSBtb21lbnRUeihkYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAmJiBtb21lbnQudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudC50eih2YWx1ZS50b1N0cmluZygpLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgREFURS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9sZW5ndGh9YDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWNpbWFscyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fZGVjaW1hbHN9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xlbmd0aCAmJiB0aGlzLl9wcmVjaXNpb24pIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9wcmVjaXNpb259YDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9zY2FsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fc2NhbGV9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYE5VTUJFUiR7cmVzdWx0fWA7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiTlVNQkVSKDMpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBgTlVNQkVSKCR7dGhpcy5fbGVuZ3RofSwwKWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJTTUFMTElOVFwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTUVESVVNSU5UIGV4dGVuZHMgQmFzZVR5cGVzLk1FRElVTUlOVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJOVU1CRVIoOClcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCSUdJTlQpKVxuICAgICAgICByZXR1cm4gbmV3IEJJR0lOVChsZW5ndGgpO1xuICAgICAgQmFzZVR5cGVzLkJJR0lOVC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJPcmFjbGUgZG9lcyBub3Qgc3VwcG9ydCBCSUdJTlQgd2l0aCBvcHRpb25zXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJOVU1CRVIoMTkpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBOVU1CRVIgZXh0ZW5kcyBCYXNlVHlwZXMuTlVNQkVSIHtcbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGBOVU1CRVIoJHt0aGlzLl9sZW5ndGh9LDApYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIklOVEVHRVJcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJJTkFSWV9GTE9BVFwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9CSU5BUllfRkxPQVQgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJJTkFSWV9ET1VCTEVcIjtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgcmV0dXJuIFwiaW5mXCI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICByZXR1cm4gXCItaW5mXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0JJTkFSWV9ET1VCTEUgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgcmV0dXJuIGAnJHtoZXh9J2A7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQkxPQlwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9CTE9CIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQkxPQlwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9CTE9CIH07XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gXCJ3aGVyZVwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0oQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodmFsdWUpKSk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERPVUJMRSkpXG4gICAgICAgIHJldHVybiBuZXcgQmFzZVR5cGVzLkRPVUJMRShsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIEJhc2VUeXBlcy5ET1VCTEUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIk9yYWNsZSBkb2VzIG5vdCBzdXBwb3J0IERPVUJMRSB3aXRoIG9wdGlvbnMuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0gXCJET1VCTEUgUFJFQ0lTSU9OXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0JJTkFSWV9ET1VCTEUgfTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCSU5BUllfRE9VQkxFXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1vbWVudCh2YWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoZGF0ZSkge1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBcIllZWVkvTU0vRERcIjtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKGBUT19EQVRFKCcke2RhdGV9JywnJHtmb3JtYXR9JylgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZShkYXRlKTtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfREFURSB9O1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbShuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgREFURU9OTFkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIEJPT0xFQU4sXG4gICAgXCJET1VCTEUgUFJFQ0lTSU9OXCI6IERPVUJMRSxcbiAgICBET1VCTEUsXG4gICAgU1RSSU5HLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgTUVESVVNSU5ULFxuICAgIEJJR0lOVCxcbiAgICBOVU1CRVIsXG4gICAgSU5URUdFUixcbiAgICBGTE9BVCxcbiAgICBVVUlELFxuICAgIERBVEVPTkxZLFxuICAgIERBVEUsXG4gICAgTk9XLFxuICAgIEJMT0IsXG4gICAgRU5VTSxcbiAgICBURVhULFxuICAgIENIQVIsXG4gICAgSlNPTjogSlNPTlRZUEUsXG4gICAgUkVBTCxcbiAgICBERUNJTUFMXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { AbstractDialect } = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst { OracleConnectionManager } = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js\");\nconst { OracleQuery } = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js\");\nconst { OracleQueryGenerator } = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").oracle);\nconst { OracleQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js\");\nclass OracleDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new OracleConnectionManager(this, sequelize);\n    this.connectionManager.initPools();\n    this.queryGenerator = new OracleQueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new OracleQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nOracleDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  IGNORE: \" IGNORE\",\n  lock: true,\n  lockOuterJoinFailure: true,\n  forShare: \"FOR UPDATE\",\n  skipLocked: true,\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false\n  },\n  constraints: {\n    restrict: false\n  },\n  returnValues: false,\n  returnIntoValues: true,\n  \"ORDER NULLS\": true,\n  schemas: true,\n  updateOnDuplicate: false,\n  indexViaAlter: false,\n  NUMERIC: true,\n  JSON: true,\n  upserts: true,\n  bulkDefault: true,\n  topLevelOrderByRequired: true,\n  GEOMETRY: false\n});\nOracleDialect.prototype.defaultVersion = \"18.0.0\";\nOracleDialect.prototype.Query = OracleQuery;\nOracleDialect.prototype.queryGenerator = OracleQueryGenerator;\nOracleDialect.prototype.DataTypes = DataTypes;\nOracleDialect.prototype.name = \"oracle\";\nOracleDialect.prototype.TICK_CHAR = '\"';\nOracleDialect.prototype.TICK_CHAR_LEFT = OracleDialect.prototype.TICK_CHAR;\nOracleDialect.prototype.TICK_CHAR_RIGHT = OracleDialect.prototype.TICK_CHAR;\nmodule.exports = OracleDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGtGQUFhO0FBQ2pELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyxzR0FBc0I7QUFDbEUsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw0RUFBUztBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0dBQW1CO0FBQzVELGtCQUFrQix3R0FBa0M7QUFDcEQsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGdHQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9pbmRleC5qcz8wMTE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IEFic3RyYWN0RGlhbGVjdCB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgeyBPcmFjbGVDb25uZWN0aW9uTWFuYWdlciB9ID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgeyBPcmFjbGVRdWVyeSB9ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCB7IE9yYWNsZVF1ZXJ5R2VuZXJhdG9yIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5vcmFjbGU7XG5jb25zdCB7IE9yYWNsZVF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBPcmFjbGVEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IE9yYWNsZUNvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5pbml0UG9vbHMoKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IE9yYWNsZVF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBPcmFjbGVRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJWQUxVRVMgKClcIjogdHJ1ZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogdHJ1ZSxcbiAgSUdOT1JFOiBcIiBJR05PUkVcIixcbiAgbG9jazogdHJ1ZSxcbiAgbG9ja091dGVySm9pbkZhaWx1cmU6IHRydWUsXG4gIGZvclNoYXJlOiBcIkZPUiBVUERBVEVcIixcbiAgc2tpcExvY2tlZDogdHJ1ZSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgdXNpbmc6IGZhbHNlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IGZhbHNlXG4gIH0sXG4gIHJldHVyblZhbHVlczogZmFsc2UsXG4gIHJldHVybkludG9WYWx1ZXM6IHRydWUsXG4gIFwiT1JERVIgTlVMTFNcIjogdHJ1ZSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgdXBkYXRlT25EdXBsaWNhdGU6IGZhbHNlLFxuICBpbmRleFZpYUFsdGVyOiBmYWxzZSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgdXBzZXJ0czogdHJ1ZSxcbiAgYnVsa0RlZmF1bHQ6IHRydWUsXG4gIHRvcExldmVsT3JkZXJCeVJlcXVpcmVkOiB0cnVlLFxuICBHRU9NRVRSWTogZmFsc2Vcbn0pO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjE4LjAuMFwiO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBPcmFjbGVRdWVyeTtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLnF1ZXJ5R2VuZXJhdG9yID0gT3JhY2xlUXVlcnlHZW5lcmF0b3I7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJvcmFjbGVcIjtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IE9yYWNsZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IE9yYWNsZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gT3JhY2xlRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query-generator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      \"DECLARE\",\n      \"USER_FOUND BOOLEAN := FALSE;\",\n      \"BEGIN\",\n      \" BEGIN\",\n      \"   EXECUTE IMMEDIATE \",\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      \";\",\n      \"   EXCEPTION WHEN OTHERS THEN\",\n      \"     IF SQLCODE != -1920 THEN\",\n      \"       RAISE;\",\n      \"     ELSE\",\n      \"       USER_FOUND := TRUE;\",\n      \"     END IF;\",\n      \" END;\",\n      \" IF NOT USER_FOUND THEN\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      \";\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n  dropSchema(schema) {\n    return [\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE \",\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      \";\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"  IF SQLCODE != -1918 THEN\",\n      \"    RAISE;\",\n      \"  END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = Object.create(null), attrStr = [], checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey))\n        continue;\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map((field) => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n            return field.attribute;\n          });\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach((idx) => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach((primaryKey) => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach((field) => {\n          let currField = \"\";\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n    const query = Utils.joinSQLFragments([\n      \"CREATE TABLE\",\n      values.table,\n      `(${values.attributes})`\n    ]);\n    return Utils.joinSQLFragments([\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE\",\n      `${this.escape(query)};`,\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"IF SQLCODE != -955 THEN\",\n      \"RAISE;\",\n      \"END IF;\",\n      \"END;\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\n      \"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \",\n      \"FROM all_tab_columns atc \",\n      \"LEFT OUTER JOIN \",\n      \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \",\n      \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \",\n      schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \",\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"\n    ].join(\"\");\n  }\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(before),\n      \"RENAME TO\",\n      this.quoteTable(after)\n    ]);\n  }\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"BEGIN \",\n      \"EXECUTE IMMEDIATE 'DROP TABLE\",\n      this.quoteTable(tableName),\n      \"CASCADE CONSTRAINTS PURGE';\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \" IF SQLCODE != -942 THEN\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate) {\n      delete options.onUpdate;\n    }\n    if (options.onDelete && options.onDelete.toUpperCase() === \"NO ACTION\") {\n      delete options.onDelete;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: \"addColumn\"\n      })\n    ]);\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      attribute\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      \"SELECT constraint_name INTO cons_name\",\n      \"FROM (\",\n      \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\",\n      \"  FROM all_cons_columns cc, all_constraints c\",\n      \"  WHERE cc.owner = c.owner\",\n      \"  AND cc.table_name = c.table_name\",\n      \"  AND cc.constraint_name = c.constraint_name\",\n      \"  AND c.constraint_type = 'R'\",\n      \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\",\n      \")\",\n      \"WHERE owner =\",\n      schemaNameConstant,\n      \"AND table_name =\",\n      tableNameConstant,\n      \"AND cons_columns =\",\n      attributeNameConstant,\n      \";\"\n    ].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      \"ADD FOREIGN KEY\",\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, \"\")\n    ]);\n    return [\n      \"BEGIN\",\n      getConsNameQuery,\n      \"EXCEPTION\",\n      \"WHEN NO_DATA_FOUND THEN\",\n      \" CONS_NAME := NULL;\",\n      \"END;\",\n      \"IF CONS_NAME IS NOT NULL THEN\",\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      \"END IF;\",\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(\" \");\n  }\n  _modifyQuery(definition, table, attributeName) {\n    definition = definition.startsWith(\"BLOB\") ? definition.replace(\"BLOB \", \"\") : definition;\n    const query = Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"MODIFY\",\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\n      \"BEGIN\",\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      \"EXCEPTION\",\n      \"WHEN OTHERS THEN\",\n      \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\",\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      \" ELSE\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      \"DECLARE\",\n      \"CONS_NAME VARCHAR2(200);\",\n      \"BEGIN\"\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName))\n        continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(void 0, void 0, { context: \"INSERT\" }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\n      \"DECLARE \",\n      \"BEGIN \",\n      updateQuery.query ? [\n        updateQuery.query,\n        \"; \",\n        \" IF ( SQL%ROWCOUNT = 0 ) THEN \",\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"ELSE \",\n        \" :isUpdate := 1; \",\n        \" END IF; \"\n      ].join(\"\") : [\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"EXCEPTION WHEN OTHERS THEN\",\n        \" IF SQLCODE != -1 THEN\",\n        \"   RAISE;\",\n        \" END IF;\"\n      ].join(\"\"),\n      \"END;\"\n    ];\n    const query = sql.join(\"\");\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n    let inBindPosition;\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map((key) => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n          return \"DEFAULT\";\n        }\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" }, inbindParam);\n      });\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      tuples.push(tuple);\n    }\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n    let query = Utils.joinSQLFragments([\n      \"INSERT\",\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${insertColumns.join(\",\")})`,\n      \"VALUES\",\n      `(${inBindPosition})`\n    ]);\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        \"RETURNING\",\n        `${returnColumn.join(\",\")}`,\n        \"INTO\",\n        `${returnColumnBindPositions}`\n      ]);\n    }\n    const result = { query };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \",\n      \"FROM all_ind_columns i \",\n      \"INNER JOIN all_indexes u \",\n      \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \",\n      \"LEFT OUTER JOIN all_constraints c \",\n      \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \",\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      \" AND u.table_owner = \",\n      owner ? this.escape(owner) : \"USER\",\n      \" ORDER BY index_name, column_position\"\n    ];\n    return sql.join(\"\");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    attribute.onUpdate = \"\";\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n    let template;\n    template = attribute.type.toSql ? attribute.type.toSql() : \"\";\n    if (attribute.type instanceof DataTypes.JSON) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, (value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n      if (!attribute.autoIncrement) {\n        if (attribute.allowNull === false) {\n          template += \" NOT NULL\";\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += \" NULL\";\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({ attributeName }, options));\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      \"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \",\n      this.escape(tableName),\n      \" and OWNER = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" and COLUMN_NAME = \",\n      this.escape(column),\n      \" AND POSITION IS NOT NULL ORDER BY POSITION\"\n    ].join(\"\");\n    return sql;\n  }\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",',\n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      \" FROM all_cons_columns a\",\n      \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\",\n      \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\",\n      \" WHERE c.constraint_type  = 'R'\",\n      \" AND a.table_name = \",\n      this.escape(tableName),\n      \" AND a.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" ORDER BY a.table_name, a.constraint_name\"\n    ].join(\"\");\n    return sql;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT cols.column_name, atc.identity_column \",\n      \"FROM all_constraints cons, all_cons_columns cols \",\n      \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\",\n      \"WHERE cols.table_name = \",\n      this.escape(tableName),\n      \"AND cols.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER \",\n      \"AND cons.constraint_type = 'P' \",\n      \"AND cons.constraint_name = cols.constraint_name \",\n      \"AND cons.owner = cols.owner \",\n      \"ORDER BY cols.table_name, cols.position\"\n    ].join(\"\");\n    return sql;\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n  getAliasToken() {\n    return \"\";\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"BEGIN TRANSACTION\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"ROLLBACK TRANSACTION\";\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map((subPath) => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0, isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n  bindParam(bind, posOffset = 0) {\n    return (value) => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n}\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQW1CO0FBQy9DO0FBQ0EsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RCxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxRQUFRO0FBQ1I7QUFDQSxpREFBaUQsYUFBYTtBQUM5RCxRQUFRO0FBQ1I7QUFDQSxtREFBbUQsYUFBYTtBQUNoRSxRQUFRO0FBQ1I7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRCxRQUFRO0FBQ1I7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRCxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxRQUFRO0FBQ1IsZUFBZTtBQUNmLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLG9DQUFvQztBQUN0RTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsTUFBTSxFQUFFLDJDQUEyQztBQUM3RTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixNQUFNLEVBQUUsU0FBUztBQUN6QztBQUNBLFFBQVE7QUFDUix3QkFBd0IsTUFBTSxFQUFFLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixJQUFJLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0VBQXNFO0FBQ25ILFlBQVk7QUFDWixpREFBaUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2xLO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx3QkFBd0IsY0FBYyxnREFBZ0Q7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pELCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVcsTUFBTSxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFdBQVc7QUFDWDtBQUNBLHlDQUF5Qyx3QkFBd0IsbUNBQW1DO0FBQ3BHLGNBQWM7QUFDZCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQSxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixnQkFBZ0Isa0NBQWtDLEtBQUssOEJBQThCO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLHdCQUF3QjtBQUNySCxpQ0FBaUMsOEJBQThCLG1CQUFtQixnQkFBZ0I7QUFDbEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixpQkFBaUI7QUFDakI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxtQkFBbUI7QUFDakcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1Q0FBdUM7QUFDcEYsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUMsaUNBQWlDLHdCQUF3QixvQ0FBb0Msd0JBQXdCLGtCQUFrQiwyQkFBMkIsRUFBRSxVQUFVO0FBQzlLLE1BQU07QUFDTiwwQ0FBMEMsTUFBTTtBQUNoRCxpQ0FBaUMsdUJBQXVCLEVBQUUsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QyxLQUFLO0FBQy9FO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUE2QztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0NBQW9DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSx5QkFBeUIsK0NBQStDO0FBQ3hFLFFBQVE7QUFDUix5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxlQUFlO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixrQkFBa0IsZUFBZTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUNBQXVDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQyx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlIQUFpSCxNQUFNO0FBQ3ZILHlCQUF5QixhQUFhLEdBQUcsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywrQ0FBK0MsR0FBRyw0Q0FBNEM7QUFDakksaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0EsbUNBQW1DLDRCQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktZ2VuZXJhdG9yLmpzP2M3N2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3JhY2xlUXVlcnlHZW5lcmF0b3I6ICgpID0+IE9yYWNsZVF1ZXJ5R2VuZXJhdG9yXG59KTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBPUkFDTEVfUkVTRVJWRURfV09SRFMgPSBbXCJBQ0NFU1NcIiwgXCJBRERcIiwgXCJBTExcIiwgXCJBTFRFUlwiLCBcIkFORFwiLCBcIkFOWVwiLCBcIkFSUkFZTEVOXCIsIFwiQVNcIiwgXCJBU0NcIiwgXCJBVURJVFwiLCBcIkJFVFdFRU5cIiwgXCJCWVwiLCBcIkNIQVJcIiwgXCJDSEVDS1wiLCBcIkNMVVNURVJcIiwgXCJDT0xVTU5cIiwgXCJDT01NRU5UXCIsIFwiQ09NUFJFU1NcIiwgXCJDT05ORUNUXCIsIFwiQ1JFQVRFXCIsIFwiQ1VSUkVOVFwiLCBcIkRBVEVcIiwgXCJERUNJTUFMXCIsIFwiREVGQVVMVFwiLCBcIkRFTEVURVwiLCBcIkRFU0NcIiwgXCJESVNUSU5DVFwiLCBcIkRST1BcIiwgXCJFTFNFXCIsIFwiRVhDTFVTSVZFXCIsIFwiRVhJU1RTXCIsIFwiRklMRVwiLCBcIkZMT0FUXCIsIFwiRk9SXCIsIFwiRlJPTVwiLCBcIkdSQU5UXCIsIFwiR1JPVVBcIiwgXCJIQVZJTkdcIiwgXCJJREVOVElGSUVEXCIsIFwiSU1NRURJQVRFXCIsIFwiSU5cIiwgXCJJTkNSRU1FTlRcIiwgXCJJTkRFWFwiLCBcIklOSVRJQUxcIiwgXCJJTlNFUlRcIiwgXCJJTlRFR0VSXCIsIFwiSU5URVJTRUNUXCIsIFwiSU5UT1wiLCBcIklTXCIsIFwiTEVWRUxcIiwgXCJMSUtFXCIsIFwiTE9DS1wiLCBcIkxPTkdcIiwgXCJNQVhFWFRFTlRTXCIsIFwiTUlOVVNcIiwgXCJNT0RFXCIsIFwiTU9ESUZZXCIsIFwiTk9BVURJVFwiLCBcIk5PQ09NUFJFU1NcIiwgXCJOT1RcIiwgXCJOT1RGT1VORFwiLCBcIk5PV0FJVFwiLCBcIk5VTExcIiwgXCJOVU1CRVJcIiwgXCJPRlwiLCBcIk9GRkxJTkVcIiwgXCJPTlwiLCBcIk9OTElORVwiLCBcIk9QVElPTlwiLCBcIk9SXCIsIFwiT1JERVJcIiwgXCJQQ1RGUkVFXCIsIFwiUFJJT1JcIiwgXCJQUklWSUxFR0VTXCIsIFwiUFVCTElDXCIsIFwiUkFXXCIsIFwiUkVOQU1FXCIsIFwiUkVTT1VSQ0VcIiwgXCJSRVZPS0VcIiwgXCJST1dcIiwgXCJST1dJRFwiLCBcIlJPV0xBQkVMXCIsIFwiUk9XTlVNXCIsIFwiUk9XU1wiLCBcIlNFTEVDVFwiLCBcIlNFU1NJT05cIiwgXCJTRVRcIiwgXCJTSEFSRVwiLCBcIlNJWkVcIiwgXCJTTUFMTElOVFwiLCBcIlNRTEJVRlwiLCBcIlNUQVJUXCIsIFwiU1VDQ0VTU0ZVTFwiLCBcIlNZTk9OWU1cIiwgXCJTWVNEQVRFXCIsIFwiVEFCTEVcIiwgXCJUSEVOXCIsIFwiVE9cIiwgXCJUUklHR0VSXCIsIFwiVUlEXCIsIFwiVU5JT05cIiwgXCJVTklRVUVcIiwgXCJVUERBVEVcIiwgXCJVU0VSXCIsIFwiVkFMSURBVEVcIiwgXCJWQUxVRVNcIiwgXCJWQVJDSEFSXCIsIFwiVkFSQ0hBUjJcIiwgXCJWSUVXXCIsIFwiV0hFTkVWRVJcIiwgXCJXSEVSRVwiLCBcIldJVEhcIl07XG5jb25zdCBKU09OX0ZVTkNUSU9OX1JFR0VYID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG5jb25zdCBKU09OX09QRVJBVE9SX1JFR0VYID0gL15cXHMqKC0+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuY29uc3QgVE9LRU5fQ0FQVFVSRV9SRUdFWCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuY2xhc3MgT3JhY2xlUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIGdldENhdGFsb2dOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlZFZhbHVlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodmFsdWUpO1xuICAgICAgICBpZiAocXVvdGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRDYXRhbG9nTmFtZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlLnNjaGVtYSk7XG4gICAgcmV0dXJuIFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdO1xuICB9XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWEgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpO1xuICAgIHJldHVybiBbXG4gICAgICBcIkRFQ0xBUkVcIixcbiAgICAgIFwiVVNFUl9GT1VORCBCT09MRUFOIDo9IEZBTFNFO1wiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCIgQkVHSU5cIixcbiAgICAgIFwiICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgQ1JFQVRFIFVTRVIgJHtxdW90ZWRTY2hlbWF9IElERU5USUZJRUQgQlkgMTIzNDUgREVGQVVMVCBUQUJMRVNQQUNFIFVTRVJTYCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiICAgRVhDRVBUSU9OIFdIRU4gT1RIRVJTIFRIRU5cIixcbiAgICAgIFwiICAgICBJRiBTUUxDT0RFICE9IC0xOTIwIFRIRU5cIixcbiAgICAgIFwiICAgICAgIFJBSVNFO1wiLFxuICAgICAgXCIgICAgIEVMU0VcIixcbiAgICAgIFwiICAgICAgIFVTRVJfRk9VTkQgOj0gVFJVRTtcIixcbiAgICAgIFwiICAgICBFTkQgSUY7XCIsXG4gICAgICBcIiBFTkQ7XCIsXG4gICAgICBcIiBJRiBOT1QgVVNFUl9GT1VORCBUSEVOXCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBcIkNPTk5FQ1RcIiBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIFRBQkxFIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgVklFVyBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIEFOWSBUUklHR0VSIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgQU5ZIFBST0NFRFVSRSBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIFNFUVVFTkNFIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgU1lOT05ZTSBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgQUxURVIgVVNFUiAke3F1b3RlZFNjaGVtYX0gUVVPVEEgVU5MSU1JVEVEIE9OIFVTRVJTYCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiIEVORCBJRjtcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIFVTRVJOQU1FIEFTIFwic2NoZW1hX25hbWVcIiBGUk9NIEFMTF9VU0VSUyBXSEVSRSBDT01NT04gPSAoJ05PJykgQU5EIFVTRVJOQU1FICE9IHVzZXJgO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgRFJPUCBVU0VSICR7dGhpcy5xdW90ZVRhYmxlKHNjaGVtYSl9IENBU0NBREVgKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCIgIElGIFNRTENPREUgIT0gLTE5MTggVEhFTlwiLFxuICAgICAgXCIgICAgUkFJU0U7XCIsXG4gICAgICBcIiAgRU5EIElGO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgVkVSU0lPTl9GVUxMIEZST00gUFJPRFVDVF9DT01QT05FTlRfVkVSU0lPTiBXSEVSRSBQUk9EVUNUIExJS0UgJ09yYWNsZSUnXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdLCBmb3JlaWduS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksIGF0dHJTdHIgPSBbXSwgY2hlY2tTdHIgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICB9O1xuICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgYXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpO1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHthdHRyfSAke21hdGNoWzFdLnJlcGxhY2UoL1BSSU1BUlkgS0VZLywgXCJcIil9YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7YXR0cn0gJHtkYXRhVHlwZS5yZXBsYWNlKC9QUklNQVJZIEtFWS8sIFwiXCIpLnRyaW0oKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHthdHRyfSAke21hdGNoWzFdfWApO1xuICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke2F0dHJ9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1tcImF0dHJpYnV0ZXNcIl0gPSBhdHRyU3RyLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoZm9yZWlnbktleXNbZmtleV0uaW5kZXhPZihcIk9OIERFTEVURSBOTyBBQ1RJT05cIikgPiAtMSkge1xuICAgICAgICBmb3JlaWduS2V5c1tma2V5XSA9IGZvcmVpZ25LZXlzW2ZrZXldLnJlcGxhY2UoXCJPTiBERUxFVEUgTk8gQUNUSU9OXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCxGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICB9XG4gICAgaWYgKGNoZWNrU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsICR7Y2hlY2tTdHIuam9pbihcIiwgXCIpfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5kZXhlcyAmJiBvcHRpb25zLmluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaWR4VG9EZWxldGUgPSBbXTtcbiAgICAgIG9wdGlvbnMuaW5kZXhlcy5mb3JFYWNoKChpbmRleCwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChcInVuaXF1ZVwiIGluIGluZGV4ICYmIChpbmRleC51bmlxdWUgPT09IHRydWUgfHwgaW5kZXgudW5pcXVlLmxlbmd0aCA+IDAgJiYgaW5kZXgudW5pcXVlICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBpbmRleC5maWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBjYW5Db250aW51ZSA9IHRydWU7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMudW5pcXVlS2V5cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBmaWVsZElkeCA9IDA7IGZpZWxkSWR4IDwga2V5cy5sZW5ndGg7IGZpZWxkSWR4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyclVuaXF1ZSA9IG9wdGlvbnMudW5pcXVlS2V5c1trZXlzW2ZpZWxkSWR4XV07XG4gICAgICAgICAgICAgIGlmIChjdXJyVW5pcXVlLmZpZWxkcy5sZW5ndGggPT09IGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJVbmlxdWUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGN1cnJVbmlxdWUuZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXMoZmllbGRzLCBmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbkNvbnRpbnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gXCJuYW1lXCIgaW4gaW5kZXggPyBpbmRleC5uYW1lIDogXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludFRvQWRkID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGluZGV4TmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZHNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCEoXCJ1bmlxdWVLZXlzXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVuaXF1ZUtleXMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHRpb25zLnVuaXF1ZUtleXNbaW5kZXhOYW1lXSA9IGNvbnN0cmFpbnRUb0FkZDtcbiAgICAgICAgICAgICAgaWR4VG9EZWxldGUucHVzaChpZHgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWR4VG9EZWxldGUucHVzaChpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZHhUb0RlbGV0ZS5mb3JFYWNoKChpZHgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5pbmRleGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmICEhb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjYW5CZVVuaXEgPSBmYWxzZTtcbiAgICAgICAgcHJpbWFyeUtleXMuZm9yRWFjaCgocHJpbWFyeUtleSkgPT4ge1xuICAgICAgICAgIHByaW1hcnlLZXkgPSBwcmltYXJ5S2V5LnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgICAgICAgIGlmICghXy5pbmNsdWRlcyhjb2x1bW5zLmZpZWxkcywgcHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgIGNhbkJlVW5pcSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29sdW1ucy5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICBsZXQgY3VyckZpZWxkID0gXCJcIjtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgICAgICAgICBjdXJyRmllbGQgPSBmaWVsZC5hdHRyaWJ1dGUucmVwbGFjZSgvWy4sXCJcXHNdL2csIFwiXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyRmllbGQgPSBmaWVsZC5yZXBsYWNlKC9bLixcIlxcc10vZywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyRmllbGQgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbY3VyckZpZWxkXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJVTklRVUVcIikgPiAtMSAmJiBjYW5CZVVuaXEpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0clRvUmVwbGFjZSA9IGF0dHJpYnV0ZXNbY3VyckZpZWxkXS5yZXBsYWNlKFwiVU5JUVVFXCIsIFwiXCIpO1xuICAgICAgICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyA9IHZhbHVlcy5hdHRyaWJ1dGVzLnJlcGxhY2UoYXR0cmlidXRlc1tjdXJyRmllbGRdLCBhdHRyVG9SZXBsYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuQmVVbmlxKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvcHRpb25zLnVuaXF1ZUtleXNbY29sdW1ucy5uYW1lXTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy51bmlxdWVLZXlzW2NvbHVtbnMubmFtZV07XG4gICAgICAgICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lLnJlcGxhY2UoL1suLFxcc10vZywgXCJcIik7XG4gICAgICAgICAgY29sdW1ucy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgIG9wdGlvbnMudW5pcXVlS2V5c1tpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGluZGV4TmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLCBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBUQUJMRVwiLFxuICAgICAgdmFsdWVzLnRhYmxlLFxuICAgICAgYCgke3ZhbHVlcy5hdHRyaWJ1dGVzfSlgXG4gICAgXSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJFWEVDVVRFIElNTUVESUFURVwiLFxuICAgICAgYCR7dGhpcy5lc2NhcGUocXVlcnkpfTtgLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCJJRiBTUUxDT0RFICE9IC05NTUgVEhFTlwiLFxuICAgICAgXCJSQUlTRTtcIixcbiAgICAgIFwiRU5EIElGO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdKTtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgW3RhYmxlTmFtZSwgc2NoZW1hTmFtZV0gPSB0aGlzLmdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpO1xuICAgIHJldHVybiBgU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBBTExfVEFCTEVTIFdIRVJFIFRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9IEFORCBPV05FUiA9ICR7dGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkgOiBcIlVTRVJcIn1gO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGNvbnN0IGN1cnJUYWJsZU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlTmFtZS50YWJsZU5hbWUgfHwgdGFibGVOYW1lKTtcbiAgICBzY2hlbWEgPSB0aGlzLmdldENhdGFsb2dOYW1lKHNjaGVtYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiU0VMRUNUIGF0Yy5DT0xVTU5fTkFNRSwgYXRjLkRBVEFfVFlQRSwgYXRjLkRBVEFfTEVOR1RILCBhdGMuQ0hBUl9MRU5HVEgsIGF0Yy5ERUZBVUxUX0xFTkdUSCwgYXRjLk5VTExBQkxFLCB1Y2MuY29uc3RyYWludF90eXBlIFwiLFxuICAgICAgXCJGUk9NIGFsbF90YWJfY29sdW1ucyBhdGMgXCIsXG4gICAgICBcIkxFRlQgT1VURVIgSk9JTiBcIixcbiAgICAgIFwiKFNFTEVDVCBhY2MuY29sdW1uX25hbWUsIGFjYy50YWJsZV9uYW1lLCBhYy5jb25zdHJhaW50X3R5cGUgRlJPTSBhbGxfY29uc19jb2x1bW5zIGFjYyBJTk5FUiBKT0lOIGFsbF9jb25zdHJhaW50cyBhYyBPTiBhY2MuY29uc3RyYWludF9uYW1lID0gYWMuY29uc3RyYWludF9uYW1lKSB1Y2MgXCIsXG4gICAgICBcIk9OIChhdGMudGFibGVfbmFtZSA9IHVjYy50YWJsZV9uYW1lIEFORCBhdGMuQ09MVU1OX05BTUUgPSB1Y2MuQ09MVU1OX05BTUUpIFwiLFxuICAgICAgc2NoZW1hID8gYFdIRVJFIChhdGMuT1dORVIgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9KSBgIDogXCJXSEVSRSBhdGMuT1dORVIgPSBVU0VSIFwiLFxuICAgICAgYEFORCAoYXRjLlRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKGN1cnJUYWJsZU5hbWUpfSlgLFxuICAgICAgXCJPUkRFUiBCWSBhdGMuQ09MVU1OX05BTUUsIENPTlNUUkFJTlRfVFlQRSBERVNDXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKGJlZm9yZSksXG4gICAgICBcIlJFTkFNRSBUT1wiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKGFmdGVyKVxuICAgIF0pO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRDYXRhbG9nTmFtZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIHJldHVybiBgU0VMRUNUIENPTlNUUkFJTlRfTkFNRSBjb25zdHJhaW50X25hbWUgRlJPTSB1c2VyX2NvbnNfY29sdW1ucyBXSEVSRSB0YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIG93bmVyIGFzIHRhYmxlX3NjaGVtYSwgdGFibGVfbmFtZSwgMCBhcyBsdmwgRlJPTSBhbGxfdGFibGVzIHdoZXJlIE9XTkVSIElOKFNFTEVDVCBVU0VSTkFNRSBBUyBcInNjaGVtYV9uYW1lXCIgRlJPTSBBTExfVVNFUlMgV0hFUkUgT1JBQ0xFX01BSU5UQUlORUQgPSAnTicpYDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkJFR0lOIFwiLFxuICAgICAgXCJFWEVDVVRFIElNTUVESUFURSAnRFJPUCBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkNBU0NBREUgQ09OU1RSQUlOVFMgUFVSR0UnO1wiLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCIgSUYgU1FMQ09ERSAhPSAtOTQyIFRIRU5cIixcbiAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICBcIiBFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0pO1xuICB9XG4gIGFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiBhdHRyaWJ1dGVzLm5hbWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7YXR0cmlidXRlcy5uYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKTtcbiAgfVxuICBhZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbkRlbGV0ZSAmJiBvcHRpb25zLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCkgPT09IFwiTk8gQUNUSU9OXCIpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9uRGVsZXRlO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHRoaXMuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGFibGVOYW1lfSBBREQgJHtjb25zdHJhaW50U25pcHBldH07YDtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGRhdGFUeXBlLmZpZWxkID0ga2V5O1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZToga2V5LFxuICAgICAgICBjb250ZXh0OiBcImFkZENvbHVtblwiXG4gICAgICB9KVxuICAgIF0pO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIkFERFwiLFxuICAgICAgYXR0cmlidXRlXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgQ09MVU1OXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgX2FsdGVyRm9yZWlnbktleUNvbnN0cmFpbnQoZGVmaW5pdGlvbiwgdGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZUNvbnN0YW50ID0gdGhpcy5lc2NhcGUodGhpcy5nZXRDYXRhbG9nTmFtZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgY29uc3Qgc2NoZW1hTmFtZUNvbnN0YW50ID0gdGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUodGhpcy5nZXRDYXRhbG9nTmFtZShzY2hlbWFOYW1lKSkgOiBcIlVTRVJcIjtcbiAgICBjb25zdCB0YWJsZU5hbWVDb25zdGFudCA9IHRoaXMuZXNjYXBlKHRoaXMuZ2V0Q2F0YWxvZ05hbWUodGFibGVOYW1lKSk7XG4gICAgY29uc3QgZ2V0Q29uc05hbWVRdWVyeSA9IFtcbiAgICAgIFwiU0VMRUNUIGNvbnN0cmFpbnRfbmFtZSBJTlRPIGNvbnNfbmFtZVwiLFxuICAgICAgXCJGUk9NIChcIixcbiAgICAgIFwiICBTRUxFQ1QgRElTVElOQ1QgY2Mub3duZXIsIGNjLnRhYmxlX25hbWUsIGNjLmNvbnN0cmFpbnRfbmFtZSwgY2MuY29sdW1uX25hbWUgQVMgY29uc19jb2x1bW5zXCIsXG4gICAgICBcIiAgRlJPTSBhbGxfY29uc19jb2x1bW5zIGNjLCBhbGxfY29uc3RyYWludHMgY1wiLFxuICAgICAgXCIgIFdIRVJFIGNjLm93bmVyID0gYy5vd25lclwiLFxuICAgICAgXCIgIEFORCBjYy50YWJsZV9uYW1lID0gYy50YWJsZV9uYW1lXCIsXG4gICAgICBcIiAgQU5EIGNjLmNvbnN0cmFpbnRfbmFtZSA9IGMuY29uc3RyYWludF9uYW1lXCIsXG4gICAgICBcIiAgQU5EIGMuY29uc3RyYWludF90eXBlID0gJ1InXCIsXG4gICAgICBcIiAgR1JPVVAgQlkgY2Mub3duZXIsIGNjLnRhYmxlX25hbWUsIGNjLmNvbnN0cmFpbnRfbmFtZSwgY2MuY29sdW1uX25hbWVcIixcbiAgICAgIFwiKVwiLFxuICAgICAgXCJXSEVSRSBvd25lciA9XCIsXG4gICAgICBzY2hlbWFOYW1lQ29uc3RhbnQsXG4gICAgICBcIkFORCB0YWJsZV9uYW1lID1cIixcbiAgICAgIHRhYmxlTmFtZUNvbnN0YW50LFxuICAgICAgXCJBTkQgY29uc19jb2x1bW5zID1cIixcbiAgICAgIGF0dHJpYnV0ZU5hbWVDb25zdGFudCxcbiAgICAgIFwiO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBzZWNvbmRRdWVyeSA9IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVOYW1lKX1gLFxuICAgICAgXCJBREQgRk9SRUlHTiBLRVlcIixcbiAgICAgIGAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pYCxcbiAgICAgIGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBnZXRDb25zTmFtZVF1ZXJ5LFxuICAgICAgXCJFWENFUFRJT05cIixcbiAgICAgIFwiV0hFTiBOT19EQVRBX0ZPVU5EIFRIRU5cIixcbiAgICAgIFwiIENPTlNfTkFNRSA6PSBOVUxMO1wiLFxuICAgICAgXCJFTkQ7XCIsXG4gICAgICBcIklGIENPTlNfTkFNRSBJUyBOT1QgTlVMTCBUSEVOXCIsXG4gICAgICBgIEVYRUNVVEUgSU1NRURJQVRFICdBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZSl9IERST1AgQ09OU1RSQUlOVCBcIid8fENPTlNfTkFNRXx8J1wiJztgLFxuICAgICAgXCJFTkQgSUY7XCIsXG4gICAgICBgRVhFQ1VURSBJTU1FRElBVEUgJHt0aGlzLmVzY2FwZShzZWNvbmRRdWVyeSl9O2BcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIF9tb2RpZnlRdWVyeShkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnN0YXJ0c1dpdGgoXCJCTE9CXCIpID8gZGVmaW5pdGlvbi5yZXBsYWNlKFwiQkxPQiBcIiwgXCJcIikgOiBkZWZpbml0aW9uO1xuICAgIGNvbnN0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgXCJNT0RJRllcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgZGVmaW5pdGlvblxuICAgIF0pO1xuICAgIGNvbnN0IHNlY29uZFF1ZXJ5ID0gcXVlcnkucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpLnJlcGxhY2UoXCJOVUxMXCIsIFwiXCIpO1xuICAgIHJldHVybiBbXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBgRVhFQ1VURSBJTU1FRElBVEUgJHt0aGlzLmVzY2FwZShxdWVyeSl9O2AsXG4gICAgICBcIkVYQ0VQVElPTlwiLFxuICAgICAgXCJXSEVOIE9USEVSUyBUSEVOXCIsXG4gICAgICBcIiBJRiBTUUxDT0RFID0gLTE0NDIgT1IgU1FMQ09ERSA9IC0xNDUxIFRIRU5cIixcbiAgICAgIGAgICBFWEVDVVRFIElNTUVESUFURSAke3RoaXMuZXNjYXBlKHNlY29uZFF1ZXJ5KX07YCxcbiAgICAgIFwiIEVMU0VcIixcbiAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICBcIiBFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIkRFQ0xBUkVcIixcbiAgICAgIFwiQ09OU19OQU1FIFZBUkNIQVIyKDIwMCk7XCIsXG4gICAgICBcIkJFR0lOXCJcbiAgICBdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9SRUZFUkVOQ0VTLykpIHtcbiAgICAgICAgc3FsLnB1c2godGhpcy5fYWx0ZXJGb3JlaWduS2V5Q29uc3RyYWludChkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsLnB1c2godGhpcy5fbW9kaWZ5UXVlcnkoZGVmaW5pdGlvbiwgdGFibGUsIGF0dHJpYnV0ZU5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3FsLnB1c2goXCJFTkQ7XCIpO1xuICAgIHJldHVybiBzcWwuam9pbihcIiBcIik7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbmV3TmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIENPTFVNTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJCZWZvcmUpfSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKG5ld05hbWUpfWA7XG4gIH1cbiAgcG9wdWxhdGVJbnNlcnRRdWVyeVJldHVybkludG9CaW5kcyhyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMsIHJldHVyblR5cGVzLCBpbmJpbmRMZW5ndGgsIHJldHVybkF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcmFjbGVkYiA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYjtcbiAgICBjb25zdCBvdXRCaW5kQXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgb3V0YmluZCA9IFtdO1xuICAgIGNvbnN0IG91dGJpbmRQYXJhbSA9IHRoaXMuYmluZFBhcmFtKG91dGJpbmQsIGluYmluZExlbmd0aCk7XG4gICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnN1YnN0cmluZygxLCBlbGVtZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgb3V0QmluZEF0dHJpYnV0ZXNbZWxlbWVudF0gPSBPYmplY3QuYXNzaWduKHJldHVyblR5cGVzW2luZGV4XS5fZ2V0QmluZERlZihvcmFjbGVkYiksIHsgZGlyOiBvcmFjbGVkYi5CSU5EX09VVCB9KTtcbiAgICAgIGNvbnN0IHJldHVybkF0dHJpYnV0ZSA9IGAke3RoaXMuZm9ybWF0KHZvaWQgMCwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSwgb3V0YmluZFBhcmFtKX1gO1xuICAgICAgcmV0dXJuQXR0cmlidXRlcy5wdXNoKHJldHVybkF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyA9IG91dEJpbmRBdHRyaWJ1dGVzO1xuICB9XG4gIHVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhd0F0dHJpYnV0ZXMgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHVwZGF0ZVF1ZXJ5ID0gdGhpcy51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMsIHJhd0F0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMuYmluZCA9IHVwZGF0ZVF1ZXJ5LmJpbmQ7XG4gICAgY29uc3QgaW5zZXJ0UXVlcnkgPSB0aGlzLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCByYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIkRFQ0xBUkUgXCIsXG4gICAgICBcIkJFR0lOIFwiLFxuICAgICAgdXBkYXRlUXVlcnkucXVlcnkgPyBbXG4gICAgICAgIHVwZGF0ZVF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIjsgXCIsXG4gICAgICAgIFwiIElGICggU1FMJVJPV0NPVU5UID0gMCApIFRIRU4gXCIsXG4gICAgICAgIGluc2VydFF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIiA6aXNVcGRhdGUgOj0gMDsgXCIsXG4gICAgICAgIFwiRUxTRSBcIixcbiAgICAgICAgXCIgOmlzVXBkYXRlIDo9IDE7IFwiLFxuICAgICAgICBcIiBFTkQgSUY7IFwiXG4gICAgICBdLmpvaW4oXCJcIikgOiBbXG4gICAgICAgIGluc2VydFF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIiA6aXNVcGRhdGUgOj0gMDsgXCIsXG4gICAgICAgIFwiRVhDRVBUSU9OIFdIRU4gT1RIRVJTIFRIRU5cIixcbiAgICAgICAgXCIgSUYgU1FMQ09ERSAhPSAtMSBUSEVOXCIsXG4gICAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICAgIFwiIEVORCBJRjtcIlxuICAgICAgXS5qb2luKFwiXCIpLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdO1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3FsLmpvaW4oXCJcIik7XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gdXBkYXRlUXVlcnkuYmluZCB8fCBpbnNlcnRRdWVyeS5iaW5kO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGZpZWxkTWFwcGVkQXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuZXhlY3V0ZU1hbnkgPSB0cnVlO1xuICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IGZpZWxkTWFwcGVkQXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGxDb2x1bW5zID0ge307XG4gICAgY29uc3QgaW5CaW5kQmluZERlZk1hcCA9IHt9O1xuICAgIGNvbnN0IG91dEJpbmRCaW5kRGVmTWFwID0ge307XG4gICAgY29uc3Qgb3JhY2xlZGIgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5saWI7XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBfLmZvck93bihmaWVsZFZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgYWxsQ29sdW1uc1trZXldID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0gJiYgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaW5CaW5kUG9zaXRpb247XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBjb25zdCB0dXBsZSA9IFtdO1xuICAgICAgY29uc3QgaW5iaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdm9pZCAwID8gdGhpcy5iaW5kUGFyYW0odHVwbGUpIDogb3B0aW9ucy5iaW5kUGFyYW07XG4gICAgICBjb25zdCB0ZW1wQmluZFBvc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFsbENvbHVtbnMpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChhbGxDb2x1bW5zW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoZmllbGRWYWx1ZUhhc2hba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJGb3IgYW4gYXV0by1pbmNyZW1lbnQgY29sdW1uIGVpdGhlciBhbGwgcm93IG11c3QgYmUgbnVsbCBvciBub24tbnVsbCwgYSBtaXggb2YgbnVsbCBhbmQgbm9uLW51bGwgaXMgbm90IGFsbG93ZWQhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJERUZBVUxUXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGZpZWxkVmFsdWVIYXNoW2tleV0sIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSwgaW5iaW5kUGFyYW0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWluQmluZFBvc2l0aW9uKSB7XG4gICAgICAgIGluQmluZFBvc2l0aW9uID0gdGVtcEJpbmRQb3NpdGlvbnM7XG4gICAgICB9XG4gICAgICB0dXBsZXMucHVzaCh0dXBsZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybkNvbHVtbiA9IFtdO1xuICAgIGNvbnN0IHJldHVybkNvbHVtbkJpbmRQb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBpbnNlcnRDb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYWxsQ29sdW1ucykpIHtcbiAgICAgIGlmIChmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICBjb25zdCBiaW5kRGVmID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0udHlwZS5fZ2V0QmluZERlZihvcmFjbGVkYik7XG4gICAgICAgIGlmIChhbGxDb2x1bW5zW2tleV0pIHtcbiAgICAgICAgICBiaW5kRGVmLmRpciA9IG9yYWNsZWRiLkJJTkRfT1VUO1xuICAgICAgICAgIG91dEJpbmRCaW5kRGVmTWFwW2tleV0gPSBiaW5kRGVmO1xuICAgICAgICAgIHJldHVybkNvbHVtbi5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgICAgICAgIHJldHVybkNvbHVtbkJpbmRQb3NpdGlvbnMucHVzaChgOiR7dHVwbGVzWzBdLmxlbmd0aCArIHJldHVybkNvbHVtbi5sZW5ndGh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmluZERlZi5kaXIgPSBvcmFjbGVkYi5CSU5EX0lOO1xuICAgICAgICAgIGluQmluZEJpbmREZWZNYXBba2V5XSA9IGJpbmREZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydENvbHVtbnMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIklOU0VSVFwiLFxuICAgICAgXCJJTlRPXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGAoJHtpbnNlcnRDb2x1bW5zLmpvaW4oXCIsXCIpfSlgLFxuICAgICAgXCJWQUxVRVNcIixcbiAgICAgIGAoJHtpbkJpbmRQb3NpdGlvbn0pYFxuICAgIF0pO1xuICAgIGlmIChyZXR1cm5Db2x1bW4ubGVuZ3RoID4gMCkge1xuICAgICAgb3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyA9IG91dEJpbmRCaW5kRGVmTWFwO1xuICAgICAgcXVlcnkgPSBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIFwiUkVUVVJOSU5HXCIsXG4gICAgICAgIGAke3JldHVybkNvbHVtbi5qb2luKFwiLFwiKX1gLFxuICAgICAgICBcIklOVE9cIixcbiAgICAgICAgYCR7cmV0dXJuQ29sdW1uQmluZFBvc2l0aW9uc31gXG4gICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIHJlc3VsdC5iaW5kID0gdHVwbGVzO1xuICAgIG9wdGlvbnMuaW5iaW5kQXR0cmlidXRlcyA9IGluQmluZEJpbmREZWZNYXA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB0YWJsZSA9IHRhYmxlTmFtZTtcbiAgICB3aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgbGV0IHF1ZXJ5VG1wbDtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgY29uc3Qgd2hlcmVUbXBsID0gd2hlcmUgPyBgIEFORCAke3doZXJlfWAgOiBcIlwiO1xuICAgICAgcXVlcnlUbXBsID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gV0hFUkUgcm93bnVtIDw9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9JHt3aGVyZVRtcGx9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdoZXJlVG1wbCA9IHdoZXJlID8gYCBXSEVSRSAke3doZXJlfWAgOiBcIlwiO1xuICAgICAgcXVlcnlUbXBsID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0ke3doZXJlVG1wbH1gO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlUbXBsO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBvd25lcl0gPSB0aGlzLmdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUIGkuaW5kZXhfbmFtZSxpLnRhYmxlX25hbWUsIGkuY29sdW1uX25hbWUsIHUudW5pcXVlbmVzcywgaS5kZXNjZW5kLCBjLmNvbnN0cmFpbnRfdHlwZSBcIixcbiAgICAgIFwiRlJPTSBhbGxfaW5kX2NvbHVtbnMgaSBcIixcbiAgICAgIFwiSU5ORVIgSk9JTiBhbGxfaW5kZXhlcyB1IFwiLFxuICAgICAgXCJPTiAodS50YWJsZV9uYW1lID0gaS50YWJsZV9uYW1lIEFORCB1LmluZGV4X25hbWUgPSBpLmluZGV4X25hbWUpIFwiLFxuICAgICAgXCJMRUZUIE9VVEVSIEpPSU4gYWxsX2NvbnN0cmFpbnRzIGMgXCIsXG4gICAgICBcIk9OIChjLnRhYmxlX25hbWUgPSBpLnRhYmxlX25hbWUgQU5EIGMuaW5kZXhfbmFtZSA9IGkuaW5kZXhfbmFtZSkgXCIsXG4gICAgICBgV0hFUkUgaS50YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfWAsXG4gICAgICBcIiBBTkQgdS50YWJsZV9vd25lciA9IFwiLFxuICAgICAgb3duZXIgPyB0aGlzLmVzY2FwZShvd25lcikgOiBcIlVTRVJcIixcbiAgICAgIFwiIE9SREVSIEJZIGluZGV4X25hbWUsIGNvbHVtbl9wb3NpdGlvblwiXG4gICAgXTtcbiAgICByZXR1cm4gc3FsLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBEUk9QIElOREVYICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX1gO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5Nb2RlbCAmJiBhdHRyaWJ1dGUuTW9kZWwudGFibGVOYW1lID09PSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coXCJPcmFjbGUgZG9lcyBub3Qgc3VwcG9ydCBzZWxmIHJlZmVyZW5jaWFsIGNvbnN0cmFpbnRzLCB3ZSB3aWxsIHJlbW92ZSBpdCBidXQgd2UgcmVjb21tZW5kIHJlc3RydWN0dXJpbmcgeW91ciBxdWVyeVwiKTtcbiAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRlbXBsYXRlO1xuICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwgPyBhdHRyaWJ1dGUudHlwZS50b1NxbCgpIDogXCJcIjtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSBJUyBKU09OKWA7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuYXR0cmlidXRlTmFtZSl9IElOKCR7Xy5tYXAoYXR0cmlidXRlLnZhbHVlcywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KS5qb2luKFwiLCBcIil9KSlgO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQk9PTEVBTikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSBJTignMScsICcwJykpYDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSA9IFwiIE5VTUJFUigqLDApIEdFTkVSQVRFRCBCWSBERUZBVUxUIE9OIE5VTEwgQVMgSURFTlRJVFlcIjtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlICYmIGF0dHJpYnV0ZS50eXBlLmtleSA9PT0gRGF0YVR5cGVzLkRPVUJMRS5rZXkpIHtcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwoKTtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlKSB7XG4gICAgICBsZXQgdW5zaWduZWRUZW1wbGF0ZSA9IFwiXCI7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGF0dHJpYnV0ZS50eXBlLl91bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB1bnNpZ25lZFRlbXBsYXRlICs9IGAgY2hlY2soJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSA+PSAwKWA7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUgJiYgYXR0cmlidXRlLnR5cGUgIT09IFwiVEVYVFwiICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZS5wcmltYXJ5S2V5ICYmICFVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSArPSBcIiBOVUxMXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IHVuc2lnbmVkVGVtcGxhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUgJiYgIWF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpICYmIGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUgJiYgYXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCkgIT09IFwiTk8gQUNUSU9OXCIpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLmZpZWxkIHx8IGtleTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGVOYW1lXSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBfX3NwcmVhZFZhbHVlcyh7IGF0dHJpYnV0ZU5hbWUgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVUcmlnZ2VyXCIpO1xuICB9XG4gIGRyb3BUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcFRyaWdnZXJcIik7XG4gIH1cbiAgcmVuYW1lVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZVRyaWdnZXJcIik7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVGdW5jdGlvblwiKTtcbiAgfVxuICBkcm9wRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wRnVuY3Rpb25cIik7XG4gIH1cbiAgcmVuYW1lRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVGdW5jdGlvblwiKTtcbiAgfVxuICBnZXRDb25zdHJhaW50c09uQ29sdW1uKHRhYmxlLCBjb2x1bW4pIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29sdW1uID0gdGhpcy5nZXRDYXRhbG9nTmFtZShjb2x1bW4pO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUIENPTlNUUkFJTlRfTkFNRSBGUk9NIHVzZXJfY29uc19jb2x1bW5zIFdIRVJFIFRBQkxFX05BTUUgPSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKHRhYmxlTmFtZSksXG4gICAgICBcIiBhbmQgT1dORVIgPSBcIixcbiAgICAgIHRhYmxlLnNjaGVtYSA/IHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpIDogXCJVU0VSXCIsXG4gICAgICBcIiBhbmQgQ09MVU1OX05BTUUgPSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGNvbHVtbiksXG4gICAgICBcIiBBTkQgUE9TSVRJT04gSVMgTk9UIE5VTEwgT1JERVIgQlkgUE9TSVRJT05cIlxuICAgIF0uam9pbihcIlwiKTtcbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29uc3Qgc3FsID0gW1xuICAgICAgJ1NFTEVDVCBESVNUSU5DVCAgYS50YWJsZV9uYW1lIFwidGFibGVOYW1lXCIsIGEuY29uc3RyYWludF9uYW1lIFwiY29uc3RyYWludE5hbWVcIiwgYS5vd25lciBcIm93bmVyXCIsICBhLmNvbHVtbl9uYW1lIFwiY29sdW1uTmFtZVwiLCcsXG4gICAgICAnIGIudGFibGVfbmFtZSBcInJlZmVyZW5jZWRUYWJsZU5hbWVcIiwgYi5jb2x1bW5fbmFtZSBcInJlZmVyZW5jZWRDb2x1bW5OYW1lXCInLFxuICAgICAgXCIgRlJPTSBhbGxfY29uc19jb2x1bW5zIGFcIixcbiAgICAgIFwiIEpPSU4gYWxsX2NvbnN0cmFpbnRzIGMgT04gYS5vd25lciA9IGMub3duZXIgQU5EIGEuY29uc3RyYWludF9uYW1lID0gYy5jb25zdHJhaW50X25hbWVcIixcbiAgICAgIFwiIEpPSU4gYWxsX2NvbnNfY29sdW1ucyBiIE9OIGMub3duZXIgPSBiLm93bmVyIEFORCBjLnJfY29uc3RyYWludF9uYW1lID0gYi5jb25zdHJhaW50X25hbWVcIixcbiAgICAgIFwiIFdIRVJFIGMuY29uc3RyYWludF90eXBlICA9ICdSJ1wiLFxuICAgICAgXCIgQU5EIGEudGFibGVfbmFtZSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUodGFibGVOYW1lKSxcbiAgICAgIFwiIEFORCBhLm93bmVyID0gXCIsXG4gICAgICB0YWJsZS5zY2hlbWEgPyB0aGlzLmVzY2FwZShzY2hlbWFOYW1lKSA6IFwiVVNFUlwiLFxuICAgICAgXCIgT1JERVIgQlkgYS50YWJsZV9uYW1lLCBhLmNvbnN0cmFpbnRfbmFtZVwiXG4gICAgXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSk7XG4gIH1cbiAgZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdID0gdGhpcy5nZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKTtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIlNFTEVDVCBjb2xzLmNvbHVtbl9uYW1lLCBhdGMuaWRlbnRpdHlfY29sdW1uIFwiLFxuICAgICAgXCJGUk9NIGFsbF9jb25zdHJhaW50cyBjb25zLCBhbGxfY29uc19jb2x1bW5zIGNvbHMgXCIsXG4gICAgICBcIklOTkVSIEpPSU4gYWxsX3RhYl9jb2x1bW5zIGF0YyBPTihhdGMudGFibGVfbmFtZSA9IGNvbHMudGFibGVfbmFtZSBBTkQgYXRjLkNPTFVNTl9OQU1FID0gY29scy5DT0xVTU5fTkFNRSApXCIsXG4gICAgICBcIldIRVJFIGNvbHMudGFibGVfbmFtZSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUodGFibGVOYW1lKSxcbiAgICAgIFwiQU5EIGNvbHMub3duZXIgPSBcIixcbiAgICAgIHRhYmxlLnNjaGVtYSA/IHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpIDogXCJVU0VSIFwiLFxuICAgICAgXCJBTkQgY29ucy5jb25zdHJhaW50X3R5cGUgPSAnUCcgXCIsXG4gICAgICBcIkFORCBjb25zLmNvbnN0cmFpbnRfbmFtZSA9IGNvbHMuY29uc3RyYWludF9uYW1lIFwiLFxuICAgICAgXCJBTkQgY29ucy5vd25lciA9IGNvbHMub3duZXIgXCIsXG4gICAgICBcIk9SREVSIEJZIGNvbHMudGFibGVfbmFtZSwgY29scy5wb3NpdGlvblwiXG4gICAgXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBEUk9QIENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX1gO1xuICB9XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfVU5DT01NSVRURUQ6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiBcIlNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgUkVBRCBDT01NSVRURUQ7XCI7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVQRUFUQUJMRV9SRUFEOlxuICAgICAgICByZXR1cm4gXCJTRVQgVFJBTlNBQ1RJT04gSVNPTEFUSU9OIExFVkVMIFNFUklBTElaQUJMRTtcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaXNvbGF0aW9uIGxldmVsIFwiJHt2YWx1ZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIGdldEFsaWFzVG9rZW4oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX1gO1xuICAgIH1cbiAgICByZXR1cm4gXCJCRUdJTiBUUkFOU0FDVElPTlwiO1xuICB9XG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBcIkNPTU1JVCBUUkFOU0FDVElPTlwiO1xuICB9XG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVE8gU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT05cIjtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgbGV0IHN0cjtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoKGNvbmRpdGlvbikgPT4gYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KFwiID0gJXNcIiwgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKHNtdGgudmFsIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHN0ciA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgudmFsLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgICBpZiAoc210aC50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHN0ciA9IGAoQ0FTRSBXSEVOICR7c3RyfT0ndHJ1ZScgVEhFTiAxIEVMU0UgMCBFTkQpYDtcbiAgICAgICAgICByZXR1cm4gYENBU1QoJHtzdHJ9IEFTIE5VTUJFUilgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnR5cGUgPT09IFwidGltZXN0YW1wdHpcIiAmJiAvanNvbl92YWx1ZVxcKC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICByZXR1cm4gYCR7c3RyfSBSRVRVUk5JTkcgVElNRVNUQU1QIFdJVEggVElNRSBaT05FKWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0gSlNPTl9GVU5DVElPTl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0gSlNPTl9PUEVSQVRPUl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IFRPS0VOX0NBUFRVUkVfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiAoaGFzSW52YWxpZFRva2VuIHx8IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAganNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRoKSB7XG4gICAgbGV0IHBhdGhzID0gXy50b1BhdGgocGF0aCk7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uID0gdGhpcy5pc0lkZW50aWZpZXJRdW90ZWQoY29sdW1uKSA/IGNvbHVtbiA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbik7XG4gICAgcGF0aHMgPSBwYXRocy5tYXAoKHN1YlBhdGgpID0+IHtcbiAgICAgIHJldHVybiAvXFxELy50ZXN0KHN1YlBhdGgpID8gVXRpbHMuYWRkVGlja3Moc3ViUGF0aCwgJ1wiJykgOiBzdWJQYXRoO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhdGhTdHIgPSB0aGlzLmVzY2FwZShbXCIkXCJdLmNvbmNhdChwYXRocykuam9pbihcIi5cIikucmVwbGFjZSgvXFwuKFxcZCspKD86KD89XFwuKXwkKS9nLCAoX18sIGRpZ2l0KSA9PiBgWyR7ZGlnaXR9XWApKTtcbiAgICByZXR1cm4gYGpzb25fdmFsdWUoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pYDtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zLCBtb2RlbCkge1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMCwgaXNTdWJRdWVyeSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICBsZXQgb3JkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCB8fCBvcHRpb25zLm9mZnNldCkge1xuICAgICAgaWYgKCFvcmRlcnMubWFpblF1ZXJ5T3JkZXIgfHwgIW9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGggfHwgaXNTdWJRdWVyeSAmJiAoIW9yZGVycy5zdWJRdWVyeU9yZGVyIHx8ICFvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUGtGcmFnbWVudCA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlQXMgfHwgbW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwucHJpbWFyeUtleUZpZWxkKX1gO1xuICAgICAgICBmcmFnbWVudCArPSBgIE9SREVSIEJZICR7dGFibGVQa0ZyYWdtZW50fWA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9mZnNldCl9IFJPV1NgO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9wdEZvcmNlUXVvdGUgPSBmb3JjZTtcbiAgICBjb25zdCBvcHRRdW90ZUlkZW50aWZpZXJzID0gdGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHJhd0lkZW50aWZpZXIgPSBVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKTtcbiAgICBjb25zdCByZWdFeHAgPSAvXigoW1xcd11bXFx3XFxkX10qKSkkL2c7XG4gICAgaWYgKG9wdEZvcmNlUXVvdGUgIT09IHRydWUgJiYgb3B0UXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UgJiYgcmVnRXhwLnRlc3QocmF3SWRlbnRpZmllcikgJiYgIU9SQUNMRV9SRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyhyYXdJZGVudGlmaWVyLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4gcmF3SWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKHJhd0lkZW50aWZpZXIsICdcIicpO1xuICB9XG4gIGJpbmRQYXJhbShiaW5kLCBwb3NPZmZzZXQgPSAwKSB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgYmluZC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBgOiR7YmluZC5sZW5ndGggKyBwb3NPZmZzZXR9YDtcbiAgICB9O1xuICB9XG4gIGF1dGhUZXN0UXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIDErMSBBUyByZXN1bHQgRlJPTSBEVUFMXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93TWV0aG9kVW5kZWZpbmVkKG1ldGhvZE5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiIGlzIG5vdCBkZWZpbmVkISBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgc3FsIGRpYWxlY3QuYCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n    const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n      const indexKey = indexKeys.find((fields) => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach((element) => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvb3JhY2xlL3F1ZXJ5LWludGVyZmFjZS5qcz8xOTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIE9yYWNsZVF1ZXJ5SW50ZXJmYWNlOiAoKSA9PiBPcmFjbGVRdWVyeUludGVyZmFjZVxufSk7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY2xhc3MgT3JhY2xlUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKChpdGVtKSA9PiBpdGVtLmZpZWxkKTtcbiAgICBjb25zdCB1bmlxdWVLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5maWx0ZXIoKGMpID0+IGMuZmllbGRzLmxlbmd0aCA+IDApLm1hcCgoYykgPT4gYy5maWVsZHMpO1xuICAgIGNvbnN0IGluZGV4S2V5cyA9IE9iamVjdC52YWx1ZXMobW9kZWwuX2luZGV4ZXMpLmZpbHRlcigoYykgPT4gYy51bmlxdWUgJiYgYy5maWVsZHMubGVuZ3RoID4gMCkubWFwKChjKSA9PiBjLmZpZWxkcyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gW107XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBjb25zdCB1bmlxdWVLZXkgPSB1bmlxdWVLZXlzLmZpbmQoKGZpZWxkcykgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHVuaXF1ZUtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleEtleSA9IGluZGV4S2V5cy5maW5kKChmaWVsZHMpID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgaWYgKGluZGV4S2V5KSB7XG4gICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IGluZGV4S2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudXBzZXJ0S2V5cy5sZW5ndGggPT09IDAgfHwgXy5pbnRlcnNlY3Rpb24ob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSwgcHJpbWFyeUtleXMpLmxlbmd0aCkge1xuICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gcHJpbWFyeUtleXM7XG4gICAgfVxuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IF8udW5pcShvcHRpb25zLnVwc2VydEtleXMpO1xuICAgIGxldCB3aGVyZUhhc051bGwgPSBmYWxzZTtcbiAgICBwcmltYXJ5S2V5cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAod2hlcmVbZWxlbWVudF0gPT09IG51bGwpIHtcbiAgICAgICAgd2hlcmVIYXNOdWxsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAod2hlcmVIYXNOdWxsID09PSB0cnVlKSB7XG4gICAgICB3aGVyZSA9IG9wdGlvbnMudXBzZXJ0S2V5cy5yZWR1Y2UoKHJlc3VsdCwgYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGVdID0gaW5zZXJ0VmFsdWVzW2F0dHJpYnV0ZV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBpZiAoc3FsLmJpbmQpIHtcbiAgICAgIG9wdGlvbnMuYmluZCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:oracle\");\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n    const oracledb = this.sequelize.connectionManager.lib;\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n    this.bindParameters = outParameters;\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else if (this.isRawQuery()) {\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach((value) => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n          const mapping = Object.values(obj).find((element) => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping)\n            acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n      result = rows.map((row) => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n    if (this.model) {\n      result = result.map((row) => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n    return result;\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        const res = insertData.map((row) => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach((_result) => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result2 = this._processRows(rows);\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n    return result;\n  }\n  handleShowConstraintsQuery(data) {\n    return data.rows.map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [], message = \"Validation error\", uniqueKey = null;\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find((key) => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n        fields.forEach((field) => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n    return new SequelizeErrors.DatabaseError(err);\n  }\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach((indexRecord) => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null, id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0)\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWTtBQUM5RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHVCQUF1QjtBQUNsSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnkuanM/M2ZkZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIE9yYWNsZVF1ZXJ5OiAoKSA9PiBPcmFjbGVRdWVyeVxufSk7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwib3JhY2xlXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOm9yYWNsZVwiKTtcbmNsYXNzIE9yYWNsZVF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgbG9nZ2luZzogY29uc29sZS5sb2csXG4gICAgICBwbGFpbjogZmFsc2UsXG4gICAgICByYXc6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgdGhpcy5jaGVja0xvZ2dpbmdPcHRpb24oKTtcbiAgICB0aGlzLm91dEZvcm1hdCA9IG9wdGlvbnMub3V0Rm9ybWF0IHx8IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYi5PQkpFQ1Q7XG4gIH1cbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJpZFwiO1xuICB9XG4gIGdldEV4ZWNPcHRpb25zKCkge1xuICAgIGNvbnN0IGV4ZWNPcHRzID0geyBvdXRGb3JtYXQ6IHRoaXMub3V0Rm9ybWF0LCBhdXRvQ29tbWl0OiB0aGlzLmF1dG9Db21taXQgfTtcbiAgICBjb25zdCBvcmFjbGVkYiA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYjtcbiAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgY29uc3QgZkluZm8gPSB7fTtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleVZhbHVlID0gdGhpcy5tb2RlbC50YWJsZUF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgaWYgKGtleVZhbHVlLnR5cGUua2V5ID09PSBcIkRFQ0lNQUxcIikge1xuICAgICAgICAgIGZJbmZvW2tleV0gPSB7IHR5cGU6IG9yYWNsZWRiLlNUUklORyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlWYWx1ZS50eXBlLmtleSA9PT0gXCJCSUdJTlRcIikge1xuICAgICAgICAgIGZJbmZvW2tleV0gPSB7IHR5cGU6IG9yYWNsZWRiLlNUUklORyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZkluZm8pIHtcbiAgICAgICAgZXhlY09wdHMuZmV0Y2hJbmZvID0gZkluZm87XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleGVjT3B0cztcbiAgfVxuICBfY29udmVydEJpbmRBdHRyaWJ1dGVzKGJpbmRpbmdEaWN0aW9uYXJ5LCBvcmFjbGVkYikge1xuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMub3B0aW9uc1tiaW5kaW5nRGljdGlvbmFyeV0pIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGtleVZhbHVlID0gdGhpcy5tb2RlbC50YWJsZUF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgaWYgKGtleVZhbHVlLnR5cGUua2V5ID09PSBcIkJJR0lOVFwiKSB7XG4gICAgICAgICAgY29uc3Qgb2xkQmluZGluZyA9IHRoaXMub3B0aW9uc1tiaW5kaW5nRGljdGlvbmFyeV1ba2V5XTtcbiAgICAgICAgICBpZiAob2xkQmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2JpbmRpbmdEaWN0aW9uYXJ5XVtrZXldID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb2xkQmluZGluZyksIHtcbiAgICAgICAgICAgICAgdHlwZTogb3JhY2xlZGIuU1RSSU5HLFxuICAgICAgICAgICAgICBtYXhTaXplOiAxZTdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgb3JhY2xlZGIgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5saWI7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBvdXRQYXJhbWV0ZXJzID0gW107XG4gICAgY29uc3QgYmluZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBiaW5kRGVmID0gW107XG4gICAgaWYgKCFzcWwubWF0Y2goL0VORDskLykpIHtcbiAgICAgIHRoaXMuc3FsID0gc3FsLnJlcGxhY2UoLzsgKiQvLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub3V0QmluZEF0dHJpYnV0ZXMgJiYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgfHwgXy5pc1BsYWluT2JqZWN0KHBhcmFtZXRlcnMpKSkge1xuICAgICAgdGhpcy5fY29udmVydEJpbmRBdHRyaWJ1dGVzKFwib3V0QmluZEF0dHJpYnV0ZXNcIiwgb3JhY2xlZGIpO1xuICAgICAgb3V0UGFyYW1ldGVycy5wdXNoKC4uLk9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzKSk7XG4gICAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgICAgb3V0UGFyYW1ldGVycy5wdXNoKHsgZGlyOiBvcmFjbGVkYi5CSU5EX09VVCB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5iaW5kUGFyYW1ldGVycyA9IG91dFBhcmFtZXRlcnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykgfHwgXy5pc1BsYWluT2JqZWN0KHBhcmFtZXRlcnMpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4ZWN1dGVNYW55KSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRCaW5kQXR0cmlidXRlcyhcImluYmluZEF0dHJpYnV0ZXNcIiwgb3JhY2xlZGIpO1xuICAgICAgICBiaW5kRGVmLnB1c2goLi4uT2JqZWN0LnZhbHVlcyh0aGlzLm9wdGlvbnMuaW5iaW5kQXR0cmlidXRlcykpO1xuICAgICAgICBiaW5kRGVmLnB1c2goLi4ub3V0UGFyYW1ldGVycyk7XG4gICAgICAgIHRoaXMuYmluZFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgICB0aGlzLmJpbmRQYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMocGFyYW1ldGVycykuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICBiaW5kUGFyYW1ldGVycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJpbmRQYXJhbWV0ZXJzLnB1c2goLi4ub3V0UGFyYW1ldGVycyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iaW5kUGFyYW1ldGVycywgYmluZFBhcmFtZXRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIkJFR0lOIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICB0aGlzLmF1dG9jb21taXQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJTRVQgQVVUT0NPTU1JVCBPTlwiKSkge1xuICAgICAgdGhpcy5hdXRvY29tbWl0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJTRVQgQVVUT0NPTU1JVCBPRkZcIikpIHtcbiAgICAgIHRoaXMuYXV0b2NvbW1pdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIkRFQ0xBUkUgeCBOVU1CRVJcIikpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9Db21taXQgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnV1aWQpIHtcbiAgICAgICAgICB0aGlzLmF1dG9Db21taXQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmF1dG9Db21taXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZXhlY3V0ZSh0aGlzLnNxbCwgdGhpcy5iaW5kUGFyYW1ldGVycywgeyBhdXRvQ29tbWl0OiB0aGlzLmF1dG9Db21taXQgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIkJFR0lOXCIpKSB7XG4gICAgICBpZiAodGhpcy5hdXRvQ29tbWl0ID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi51dWlkKSB7XG4gICAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmV4ZWN1dGUodGhpcy5zcWwsIHRoaXMuYmluZFBhcmFtZXRlcnMsIHtcbiAgICAgICAgICBvdXRGb3JtYXQ6IHRoaXMub3V0Rm9ybWF0LFxuICAgICAgICAgIGF1dG9Db21taXQ6IHRoaXMuYXV0b0NvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5vdXRCaW5kcykpIHtcbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdC5vdXRCaW5kc107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5vdXRCaW5kcztcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJDT01NSVQgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5jb21taXQoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJTRVQgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5leGVjdXRlKHRoaXMuc3FsLCBbXSwgeyBhdXRvQ29tbWl0OiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmF1dG9Db21taXQgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi51dWlkKSB7XG4gICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwiaW5wdXRQYXJhbWV0ZXJzXCIgaW4gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5pbnB1dFBhcmFtZXRlcnMgIT09IG51bGwpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iaW5kUGFyYW1ldGVycywgdGhpcy5vcHRpb25zLmlucHV0UGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGV4ZWNPcHRzID0gdGhpcy5nZXRFeGVjT3B0aW9ucygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZXhlY3V0ZU1hbnkgJiYgYmluZERlZi5sZW5ndGggPiAwKSB7XG4gICAgICBleGVjT3B0cy5iaW5kRGVmcyA9IGJpbmREZWY7XG4gICAgfVxuICAgIGNvbnN0IGV4ZWN1dGVQcm9taXNlID0gdGhpcy5vcHRpb25zLmV4ZWN1dGVNYW55ID8gdGhpcy5jb25uZWN0aW9uLmV4ZWN1dGVNYW55KHRoaXMuc3FsLCB0aGlzLmJpbmRQYXJhbWV0ZXJzLCBleGVjT3B0cykgOiB0aGlzLmNvbm5lY3Rpb24uZXhlY3V0ZSh0aGlzLnNxbCwgdGhpcy5iaW5kUGFyYW1ldGVycywgZXhlY09wdHMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyKSA9PiB7XG4gICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIGA6JHtrZXl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCB2YWx1ZXNdO1xuICB9XG4gIF9nZXRBdHRyaWJ1dGVNYXAoYXR0cnNNYXAsIHJhd0F0dHJpYnV0ZXMpIHtcbiAgICBhdHRyc01hcCA9IE9iamVjdC5hc3NpZ24oYXR0cnNNYXAsIF8ucmVkdWNlKHJhd0F0dHJpYnV0ZXMsIChtcCwgXzIsIGtleSkgPT4ge1xuICAgICAgY29uc3QgY2F0YWxvZ0tleSA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5SW50ZXJmYWNlLnF1ZXJ5R2VuZXJhdG9yLmdldENhdGFsb2dOYW1lKGtleSk7XG4gICAgICBtcFtjYXRhbG9nS2V5XSA9IGtleTtcbiAgICAgIHJldHVybiBtcDtcbiAgICB9LCB7fSkpO1xuICB9XG4gIF9wcm9jZXNzUm93cyhyb3dzKSB7XG4gICAgbGV0IHJlc3VsdCA9IHJvd3M7XG4gICAgbGV0IGF0dHJzTWFwID0ge307XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UpIHtcbiAgICAgIGF0dHJzTWFwID0gXy5yZWR1Y2UodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXMsIChtcCwgdikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB2ID0gdlsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXRhbG9ndiA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5SW50ZXJmYWNlLnF1ZXJ5R2VuZXJhdG9yLmdldENhdGFsb2dOYW1lKHYpO1xuICAgICAgICBtcFtjYXRhbG9ndl0gPSB2O1xuICAgICAgICByZXR1cm4gbXA7XG4gICAgICB9LCB7fSk7XG4gICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICB0aGlzLl9nZXRBdHRyaWJ1dGVNYXAoYXR0cnNNYXAsIHRoaXMubW9kZWwucmF3QXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5mcm9tRW50cmllcyh0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcpO1xuICAgICAgICByb3dzID0gcm93cy5tYXAoKHJvdykgPT4gXy50b1BhaXJzKHJvdykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBPYmplY3QudmFsdWVzKG9iaikuZmluZCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2F0YWxvZ0VsZW1lbnQgPSB0aGlzLnNlcXVlbGl6ZS5xdWVyeUludGVyZmFjZS5xdWVyeUdlbmVyYXRvci5nZXRDYXRhbG9nTmFtZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjYXRhbG9nRWxlbWVudCA9PT0ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChtYXBwaW5nKVxuICAgICAgICAgICAgYWNjW21hcHBpbmcgfHwga2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgICAgIHJldHVybiBfLm1hcEtleXMocm93LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEF0dHIgPSBhdHRyc01hcFtrZXldO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0QXR0ciA9PT0gXCJzdHJpbmdcIiAmJiB0YXJnZXRBdHRyICE9PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRBdHRyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcCgocm93KSA9PiB7XG4gICAgICAgIHJldHVybiBfLm1hcFZhbHVlcyhyb3csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1trZXldICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1trZXldLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCB0eXBlaWQgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS50eXBlLnRvTG9jYWxlU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udHlwZS5rZXkgPT09IFwiSlNPTlwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZWlkLmluZGV4T2YoXCIoXCIpID4gLTEgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udHlwZS5rZXkgIT09IFwiQk9PTEVBTlwiKSB7XG4gICAgICAgICAgICAgIHR5cGVpZCA9IHR5cGVpZC5zdWJzdHIoMCwgdHlwZWlkLmluZGV4T2YoXCIoXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KHR5cGVpZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiAhIXBhcnNlKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgbGV0IGluc2VydERhdGE7XG4gICAgICBpZiAoZGF0YS5vdXRCaW5kcykge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzKTtcbiAgICAgICAgaW5zZXJ0RGF0YSA9IGRhdGEub3V0QmluZHM7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgaW5zZXJ0RGF0YSA9IFtpbnNlcnREYXRhXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBpbnNlcnREYXRhLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgcm93LmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBvYmpba2V5c1tpbmRleF1dID0gZWxlbWVudFswXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9KTtcbiAgICAgICAgaW5zZXJ0RGF0YSA9IHJlcztcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGluc2VydERhdGEpO1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEucm93c0FmZmVjdGVkXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YS5yb3dzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgY29uc3QgdGFibGUgPSBPYmplY3Qua2V5cyh0aGlzLnNlcXVlbGl6ZS5tb2RlbHMpO1xuICAgICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVzID0ge307XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUubW9kZWxzICYmIHRhYmxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fZ2V0QXR0cmlidXRlTWFwKG1vZGVsQXR0cmlidXRlcywgdGhpcy5zZXF1ZWxpemUubW9kZWxzW3RhYmxlWzBdXS5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucm93cy5mb3JFYWNoKChfcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChfcmVzdWx0LkRlZmF1bHQpIHtcbiAgICAgICAgICBfcmVzdWx0LkRlZmF1bHQgPSBfcmVzdWx0LkRlZmF1bHQucmVwbGFjZShcIignXCIsIFwiXCIpLnJlcGxhY2UoXCInKVwiLCBcIlwiKS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG1vZGVsQXR0cmlidXRlc1tfcmVzdWx0LkNPTFVNTl9OQU1FXSBpbiByZXN1bHQpKSB7XG4gICAgICAgICAgbGV0IGtleSA9IG1vZGVsQXR0cmlidXRlc1tfcmVzdWx0LkNPTFVNTl9OQU1FXTtcbiAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAga2V5ID0gX3Jlc3VsdC5DT0xVTU5fTkFNRTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB7XG4gICAgICAgICAgICB0eXBlOiBfcmVzdWx0LkRBVEFfVFlQRS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk5VTExBQkxFID09PSBcIk5cIiA/IGZhbHNlIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogdm9pZCAwLFxuICAgICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5DT05TVFJBSU5UX1RZUEUgPT09IFwiUFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YS5yb3dzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBjb25zdCByb3dzID0gZGF0YS5yb3dzO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IHRoaXMuX3Byb2Nlc3NSb3dzKHJvd3MpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0Mik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGEucm93c1swXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBbcmVzdWx0LCBkYXRhLnJvd3NBZmZlY3RlZF07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGEucm93c0FmZmVjdGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhLnJvd3NBZmZlY3RlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGRhdGEucm93c1swXS5WRVJTSU9OX0ZVTEw7XG4gICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IHZlcnNpb24uc3BsaXQoXCIuXCIpO1xuICAgICAgICByZXN1bHQgPSBgJHt2ZXJzaW9uc1swXX0uJHt2ZXJzaW9uc1sxXX0uJHt2ZXJzaW9uc1syXX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gXCIwLjAuMFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YS5yb3dzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIGRhdGEgPSBkYXRhLm91dEJpbmRzO1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgIGZvciAoY29uc3QgayBpbiBrZXlzKSB7XG4gICAgICAgIG9ialtrZXlzW2tdXSA9IGRhdGFba107XG4gICAgICB9XG4gICAgICBvYmouaXNVcGRhdGUgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICBkYXRhID0gb2JqO1xuICAgICAgcmVzdWx0ID0gW3sgaXNOZXdSZWNvcmQ6IGRhdGEuaXNVcGRhdGUsIHZhbHVlOiBkYXRhIH0sIGRhdGEuaXNVcGRhdGUgPT0gMF07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICBpZiAoZGF0YSAmJiBkYXRhLnJvd3MpIHtcbiAgICAgICAgcmV0dXJuIFtkYXRhLnJvd3MsIGRhdGEubWV0YURhdGFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtkYXRhLCBkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEucm93cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0cmFpbnRbXy5jYW1lbENhc2Uoa2V5KV0gPSByZXN1bHRba2V5XS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KHJlc3VsdHMpIHtcbiAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdFNldCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgICAgc2NoZW1hOiByZXN1bHRTZXQuVEFCTEVfU0NIRU1BXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIGxldCBtYXRjaDtcbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC91bmlxdWUgY29uc3RyYWludCAoW1xcc1xcU10qKSB2aW9sYXRlZC8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoXCIoXCIsIFwiXCIpLnJlcGxhY2UoXCIpXCIsIFwiXCIpLnNwbGl0KFwiLlwiKVsxXTtcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgbGV0IGZpZWxkcyA9IFtdLCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCIsIHVuaXF1ZUtleSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICBjb25zdCB1bmlxdWVLZXlzID0gT2JqZWN0LmtleXModGhpcy5tb2RlbC51bmlxdWVLZXlzKTtcbiAgICAgICAgY29uc3QgY3VycktleSA9IHVuaXF1ZUtleXMuZmluZCgoa2V5KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGtleS50b1VwcGVyQ2FzZSgpID09PSBtYXRjaFsxXS50b1VwcGVyQ2FzZSgpIHx8IGtleS50b1VwcGVyQ2FzZSgpID09PSBgXCIke21hdGNoWzFdLnRvVXBwZXJDYXNlKCl9XCJgO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1cnJLZXkpIHtcbiAgICAgICAgICB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbY3VycktleV07XG4gICAgICAgICAgZmllbGRzID0gdW5pcXVlS2V5LmZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pcXVlS2V5ICYmICEhdW5pcXVlS2V5Lm1zZykge1xuICAgICAgICAgIG1lc3NhZ2UgPSB1bmlxdWVLZXkubXNnO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBTZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGVycixcbiAgICAgICAgZmllbGRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvT1JBLTAyMjkxLykgfHwgZXJyLm1lc3NhZ2UubWF0Y2goL09SQS0wMjI5Mi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbmV3IFNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgZmllbGRzOiBudWxsLFxuICAgICAgICBpbmRleDogbWF0Y2hbMV0sXG4gICAgICAgIHBhcmVudDogZXJyXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvT1JBLTAyNDQzLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgU2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3IobWF0Y2hbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gIH1cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC5pbmRleE9mKFwiU0VMRUNUIGkuaW5kZXhfbmFtZSxpLnRhYmxlX25hbWUsIGkuY29sdW1uX25hbWUsIHUudW5pcXVlbmVzc1wiKSA+IC0xO1xuICB9XG4gIGlzU2VsZWN0Q291bnRRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zcWwudG9VcHBlckNhc2UoKS5pbmRleE9mKFwiU0VMRUNUIENPVU5UKFwiKSA+IC0xO1xuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGNvbnN0IGFjYyA9IFtdO1xuICAgIGRhdGEuZm9yRWFjaCgoaW5kZXhSZWNvcmQpID0+IHtcbiAgICAgIGlmICghYWNjW2luZGV4UmVjb3JkLklOREVYX05BTUVdKSB7XG4gICAgICAgIGFjY1tpbmRleFJlY29yZC5JTkRFWF9OQU1FXSA9IHtcbiAgICAgICAgICB1bmlxdWU6IGluZGV4UmVjb3JkLlVOSVFVRU5FU1MgPT09IFwiVU5JUVVFXCIgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgcHJpbWFyeTogaW5kZXhSZWNvcmQuQ09OU1RSQUlOVF9UWVBFID09PSBcIlBcIixcbiAgICAgICAgICBuYW1lOiBpbmRleFJlY29yZC5JTkRFWF9OQU1FLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgdGFibGVOYW1lOiBpbmRleFJlY29yZC5UQUJMRV9OQU1FLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgdHlwZTogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICAgIGFjY1tpbmRleFJlY29yZC5JTkRFWF9OQU1FXS5maWVsZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjY1tpbmRleFJlY29yZC5JTkRFWF9OQU1FXS5maWVsZHMucHVzaCh7XG4gICAgICAgIGF0dHJpYnV0ZTogaW5kZXhSZWNvcmQuQ09MVU1OX05BTUUsXG4gICAgICAgIGxlbmd0aDogdm9pZCAwLFxuICAgICAgICBvcmRlcjogaW5kZXhSZWNvcmQuREVTQ0VORCxcbiAgICAgICAgY29sbGF0ZTogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCByZXR1cm5JbmRleGVzID0gW107XG4gICAgY29uc3QgYWNjS2V5cyA9IE9iamVjdC5rZXlzKGFjYyk7XG4gICAgZm9yIChjb25zdCBhY2NLZXkgb2YgYWNjS2V5cykge1xuICAgICAgY29uc3QgY29sdW1ucyA9IHt9O1xuICAgICAgY29sdW1ucy5maWVsZHMgPSBhY2NbYWNjS2V5XS5maWVsZHM7XG4gICAgICBpZiAoYWNjW2FjY0tleV0ubmFtZS5tYXRjaCgvc3lzX2NbMC05XSovKSkge1xuICAgICAgICBhY2NbYWNjS2V5XS5uYW1lID0gVXRpbHMubmFtZUluZGV4KGNvbHVtbnMsIGFjY1thY2NLZXldLnRhYmxlTmFtZSkubmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybkluZGV4ZXMucHVzaChhY2NbYWNjS2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5JbmRleGVzO1xuICB9XG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgcmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoXCJwa1JldHVyblZhbFwiIGluIHJlc3VsdHNbMF0pIHtcbiAgICAgICAgcmVzdWx0c1swXVt0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdID0gcmVzdWx0c1swXS5wa1JldHVyblZhbDtcbiAgICAgICAgZGVsZXRlIHJlc3VsdHNbMF0ucGtSZXR1cm5WYWw7XG4gICAgICB9XG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50RmllbGQgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgYXV0b0luY3JlbWVudEZpZWxkQWxpYXMgPSBudWxsLCBpZCA9IG51bGw7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXV0b0luY3JlbWVudEZpZWxkKSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEZpZWxkXS5maWVsZCAhPT0gdm9pZCAwKVxuICAgICAgICBhdXRvSW5jcmVtZW50RmllbGRBbGlhcyA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50RmllbGRdLmZpZWxkO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCBtZXRhRGF0YSAmJiBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50RmllbGRdO1xuICAgICAgaWQgPSBpZCB8fCBhdXRvSW5jcmVtZW50RmllbGRBbGlhcyAmJiByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEZpZWxkQWxpYXNdO1xuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50RmllbGRdID0gaWQ7XG4gICAgfVxuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/parserStore.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst stores = /* @__PURE__ */ new Map();\nmodule.exports = (dialect) => {\n  if (!stores.has(dialect)) {\n    stores.set(dialect, /* @__PURE__ */ new Map());\n  }\n  return {\n    clear() {\n      stores.get(dialect).clear();\n    },\n    refresh(dataType) {\n      for (const type of dataType.types[dialect]) {\n        stores.get(dialect).set(type, dataType.parse);\n      }\n    },\n    get(type) {\n      return stores.get(dialect).get(type);\n    }\n  };\n};\n//# sourceMappingURL=parserStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcGFyc2VyU3RvcmUuanM/NDg1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHN0b3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5tb2R1bGUuZXhwb3J0cyA9IChkaWFsZWN0KSA9PiB7XG4gIGlmICghc3RvcmVzLmhhcyhkaWFsZWN0KSkge1xuICAgIHN0b3Jlcy5zZXQoZGlhbGVjdCwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIHN0b3Jlcy5nZXQoZGlhbGVjdCkuY2xlYXIoKTtcbiAgICB9LFxuICAgIHJlZnJlc2goZGF0YVR5cGUpIHtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBkYXRhVHlwZS50eXBlc1tkaWFsZWN0XSkge1xuICAgICAgICBzdG9yZXMuZ2V0KGRpYWxlY3QpLnNldCh0eXBlLCBkYXRhVHlwZS5wYXJzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQodHlwZSkge1xuICAgICAgcmV0dXJuIHN0b3Jlcy5nZXQoZGlhbGVjdCkuZ2V0KHR5cGUpO1xuICAgIH1cbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXJTdG9yZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:pg\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst dataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n    const pgLib = this._loadDialectModule(\"pg\");\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = (parser2) => {\n      return (value) => this.lib.types.arrayParser.create(value, parser2).parse();\n    };\n    const rangeParserBuilder = (parser2) => {\n      return (value) => dataType.parse(value, { parser: parser2 });\n    };\n    if (dataType.key.toLowerCase() === \"range\") {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid)\n          continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid)\n          continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n    const parser = (value) => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n    if (dataType.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach((oid) => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach((arrayOid) => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n    dataType.types.postgres.forEach((name) => {\n      if (!this.nameOidMap[name])\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid)\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n  _clearTypeParser() {\n    this.oidParserMap = /* @__PURE__ */ new Map();\n  }\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid))\n      return this.oidParserMap.get(oid);\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      \"user\",\n      \"password\",\n      \"host\",\n      \"database\",\n      \"port\"\n    ]);\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [\n        \"application_name\",\n        \"ssl\",\n        \"client_encoding\",\n        \"binary\",\n        \"keepAlive\",\n        \"statement_timeout\",\n        \"query_timeout\",\n        \"connectionTimeoutMillis\",\n        \"idle_in_transaction_session_timeout\",\n        \"lock_timeout\",\n        \"options\",\n        \"stream\"\n      ]));\n    }\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n      const connection2 = new this.lib.Client(connectionConfig);\n      const parameterHandler = (message) => {\n        switch (message.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;\n            }\n            break;\n          case \"standard_conforming_strings\":\n            connection2[\"standard_conforming_strings\"] = message.parameterValue;\n            break;\n        }\n      };\n      const endHandler = () => {\n        debug(\"connection timeout\");\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n        }\n      };\n      connection2.once(\"end\", endHandler);\n      if (!this.sequelize.config.native) {\n        connection2.connection.on(\"parameterStatus\", parameterHandler);\n      }\n      connection2.connect((err) => {\n        responded = true;\n        if (!this.sequelize.config.native) {\n          connection2.connection.removeListener(\"parameterStatus\", parameterHandler);\n        }\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case \"ECONNREFUSED\":\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case \"ENOTFOUND\":\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case \"EHOSTUNREACH\":\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case \"EINVAL\":\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug(\"connection acquired\");\n          connection2.removeListener(\"end\", endHandler);\n          resolve(connection2);\n        }\n      });\n    });\n    connection.on(\"error\", (error) => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n    let query = \"\";\n    if (this.sequelize.options.standardConformingStrings !== false && connection[\"standard_conforming_strings\"] !== \"on\") {\n      query += \"SET standard_conforming_strings=on;\";\n    }\n    if (this.sequelize.options.clientMinMessages !== void 0) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n    if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === \"ignore\" || this.sequelize.options.clientMinMessages === false)) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || \"warning\";\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n    }\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n    return connection;\n  }\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = \"8.3.0\";\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n    const results = await (connection || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let result = Array.isArray(results) ? results.pop() : results;\n    if (Array.isArray(result)) {\n      if (result[0].command === \"SET\") {\n        result = result.pop();\n      }\n    }\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n    for (const row of result.rows) {\n      if (row.typtype === \"e\") {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray)\n          newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray)\n        newNameOidMap[row.typname].arrayOid = row.typarray;\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray)\n          newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQyxFQUFFO0FBQ3JFLFFBQVE7QUFDUiw0Q0FBNEMsZ0NBQWdDLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2dCQUFzZ0I7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz8zMzBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpwZ1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgZGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZShcInV0aWxcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgNTQzMjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIGNvbnN0IHBnTGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJwZ1wiKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUgPyBwZ0xpYi5uYXRpdmUgOiBwZ0xpYjtcbiAgICB0aGlzLl9jbGVhckR5bmFtaWNPSURzKCk7XG4gICAgdGhpcy5fY2xlYXJUeXBlUGFyc2VyKCk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMucG9zdGdyZXMpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIGNvbnN0IGFycmF5UGFyc2VyQnVpbGRlciA9IChwYXJzZXIyKSA9PiB7XG4gICAgICByZXR1cm4gKHZhbHVlKSA9PiB0aGlzLmxpYi50eXBlcy5hcnJheVBhcnNlci5jcmVhdGUodmFsdWUsIHBhcnNlcjIpLnBhcnNlKCk7XG4gICAgfTtcbiAgICBjb25zdCByYW5nZVBhcnNlckJ1aWxkZXIgPSAocGFyc2VyMikgPT4ge1xuICAgICAgcmV0dXJuICh2YWx1ZSkgPT4gZGF0YVR5cGUucGFyc2UodmFsdWUsIHsgcGFyc2VyOiBwYXJzZXIyIH0pO1xuICAgIH07XG4gICAgaWYgKGRhdGFUeXBlLmtleS50b0xvd2VyQ2FzZSgpID09PSBcInJhbmdlXCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm5hbWVPaWRNYXApIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLm5hbWVPaWRNYXBbbmFtZV07XG4gICAgICAgIGlmICghZW50cnkucmFuZ2VPaWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHJhbmdlUGFyc2VyID0gcmFuZ2VQYXJzZXJCdWlsZGVyKHRoaXMuZ2V0VHlwZVBhcnNlcihlbnRyeS5vaWQpKTtcbiAgICAgICAgY29uc3QgYXJyYXlSYW5nZVBhcnNlciA9IGFycmF5UGFyc2VyQnVpbGRlcihyYW5nZVBhcnNlcik7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChlbnRyeS5yYW5nZU9pZCwgcmFuZ2VQYXJzZXIpO1xuICAgICAgICBpZiAoIWVudHJ5LmFycmF5UmFuZ2VPaWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChlbnRyeS5hcnJheVJhbmdlT2lkLCBhcnJheVJhbmdlUGFyc2VyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VyID0gKHZhbHVlKSA9PiBkYXRhVHlwZS5wYXJzZSh2YWx1ZSk7XG4gICAgY29uc3QgYXJyYXlQYXJzZXIgPSBhcnJheVBhcnNlckJ1aWxkZXIocGFyc2VyKTtcbiAgICBpZiAoZGF0YVR5cGUua2V5LnRvTG93ZXJDYXNlKCkgPT09IFwiZW51bVwiKSB7XG4gICAgICB0aGlzLmVudW1PaWRzLm9pZHMuZm9yRWFjaCgob2lkKSA9PiB7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChvaWQsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW51bU9pZHMuYXJyYXlPaWRzLmZvckVhY2goKGFycmF5T2lkKSA9PiB7XG4gICAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldChhcnJheU9pZCwgYXJyYXlQYXJzZXIpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFUeXBlLnR5cGVzLnBvc3RncmVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmICghdGhpcy5uYW1lT2lkTWFwW25hbWVdKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQodGhpcy5uYW1lT2lkTWFwW25hbWVdLm9pZCwgcGFyc2VyKTtcbiAgICAgIGlmICghdGhpcy5uYW1lT2lkTWFwW25hbWVdLmFycmF5T2lkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLm9pZFBhcnNlck1hcC5zZXQodGhpcy5uYW1lT2lkTWFwW25hbWVdLmFycmF5T2lkLCBhcnJheVBhcnNlcik7XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICB0aGlzLm9pZFBhcnNlck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0VHlwZVBhcnNlcihvaWQsIC4uLmFyZ3MpIHtcbiAgICBpZiAodGhpcy5vaWRQYXJzZXJNYXAuZ2V0KG9pZCkpXG4gICAgICByZXR1cm4gdGhpcy5vaWRQYXJzZXJNYXAuZ2V0KG9pZCk7XG4gICAgcmV0dXJuIHRoaXMubGliLnR5cGVzLmdldFR5cGVQYXJzZXIob2lkLCAuLi5hcmdzKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbmZpZy51c2VyID0gY29uZmlnLnVzZXJuYW1lO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfLnBpY2soY29uZmlnLCBbXG4gICAgICBcInVzZXJcIixcbiAgICAgIFwicGFzc3dvcmRcIixcbiAgICAgIFwiaG9zdFwiLFxuICAgICAgXCJkYXRhYmFzZVwiLFxuICAgICAgXCJwb3J0XCJcbiAgICBdKTtcbiAgICBjb25uZWN0aW9uQ29uZmlnLnR5cGVzID0ge1xuICAgICAgZ2V0VHlwZVBhcnNlcjogQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFR5cGVQYXJzZXIuYmluZCh0aGlzKVxuICAgIH07XG4gICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgXy5tZXJnZShjb25uZWN0aW9uQ29uZmlnLCBfLnBpY2soY29uZmlnLmRpYWxlY3RPcHRpb25zLCBbXG4gICAgICAgIFwiYXBwbGljYXRpb25fbmFtZVwiLFxuICAgICAgICBcInNzbFwiLFxuICAgICAgICBcImNsaWVudF9lbmNvZGluZ1wiLFxuICAgICAgICBcImJpbmFyeVwiLFxuICAgICAgICBcImtlZXBBbGl2ZVwiLFxuICAgICAgICBcInN0YXRlbWVudF90aW1lb3V0XCIsXG4gICAgICAgIFwicXVlcnlfdGltZW91dFwiLFxuICAgICAgICBcImNvbm5lY3Rpb25UaW1lb3V0TWlsbGlzXCIsXG4gICAgICAgIFwiaWRsZV9pbl90cmFuc2FjdGlvbl9zZXNzaW9uX3RpbWVvdXRcIixcbiAgICAgICAgXCJsb2NrX3RpbWVvdXRcIixcbiAgICAgICAgXCJvcHRpb25zXCIsXG4gICAgICAgIFwic3RyZWFtXCJcbiAgICAgIF0pKTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCByZXNwb25kZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24yID0gbmV3IHRoaXMubGliLkNsaWVudChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIGNvbnN0IHBhcmFtZXRlckhhbmRsZXIgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucGFyYW1ldGVyTmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzZXJ2ZXJfdmVyc2lvblwiOlxuICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBzZW12ZXIuY29lcmNlKG1lc3NhZ2UucGFyYW1ldGVyVmFsdWUpLnZlcnNpb247XG4gICAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLnZhbGlkKHZlcnNpb24pID8gdmVyc2lvbiA6IHRoaXMuZGlhbGVjdC5kZWZhdWx0VmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3NcIjpcbiAgICAgICAgICAgIGNvbm5lY3Rpb24yW1wic3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzXCJdID0gbWVzc2FnZS5wYXJhbWV0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZW5kSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRpbWVvdXRcIik7XG4gICAgICAgIGlmICghcmVzcG9uZGVkKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IobmV3IEVycm9yKFwiQ29ubmVjdGlvbiB0aW1lZCBvdXRcIikpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbm5lY3Rpb24yLm9uY2UoXCJlbmRcIiwgZW5kSGFuZGxlcik7XG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUpIHtcbiAgICAgICAgY29ubmVjdGlvbjIuY29ubmVjdGlvbi5vbihcInBhcmFtZXRlclN0YXR1c1wiLCBwYXJhbWV0ZXJIYW5kbGVyKTtcbiAgICAgIH1cbiAgICAgIGNvbm5lY3Rpb24yLmNvbm5lY3QoKGVycikgPT4ge1xuICAgICAgICByZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5uYXRpdmUpIHtcbiAgICAgICAgICBjb25uZWN0aW9uMi5jb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwicGFyYW1ldGVyU3RhdHVzXCIsIHBhcmFtZXRlckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIkVDT05OUkVGVVNFRFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJFTk9URk9VTkRcIjpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkVIT1NUVU5SRUFDSFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkVJTlZBTFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgICAgICBjb25uZWN0aW9uMi5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgY29ubmVjdGlvbi5faW52YWxpZCA9IHRydWU7XG4gICAgICBkZWJ1ZyhgY29ubmVjdGlvbiBlcnJvciAke2Vycm9yLmNvZGUgfHwgZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgIH0pO1xuICAgIGxldCBxdWVyeSA9IFwiXCI7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RhbmRhcmRDb25mb3JtaW5nU3RyaW5ncyAhPT0gZmFsc2UgJiYgY29ubmVjdGlvbltcInN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5nc1wiXSAhPT0gXCJvblwiKSB7XG4gICAgICBxdWVyeSArPSBcIlNFVCBzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3M9b247XCI7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnNvbGUud2FybignVXNhZ2Ugb2YgXCJvcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzXCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY3LicpO1xuICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgdXNlIHRoZSBzZXF1ZWxpemUgb3B0aW9uIFwiZGlhbGVjdE9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXNcIiBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBpZiAoIShjb25maWcuZGlhbGVjdE9wdGlvbnMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcy50b0xvd2VyQ2FzZSgpID09PSBcImlnbm9yZVwiIHx8IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgPT09IGZhbHNlKSkge1xuICAgICAgY29uc3QgY2xpZW50TWluTWVzc2FnZXMgPSBjb25maWcuZGlhbGVjdE9wdGlvbnMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzIHx8IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgfHwgXCJ3YXJuaW5nXCI7XG4gICAgICBxdWVyeSArPSBgU0VUIGNsaWVudF9taW5fbWVzc2FnZXMgVE8gJHtjbGllbnRNaW5NZXNzYWdlc307YDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgY29uc3QgaXNab25lID0gISFtb21lbnRUei50ei56b25lKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgaWYgKGlzWm9uZSkge1xuICAgICAgICBxdWVyeSArPSBgU0VUIFRJTUUgWk9ORSAnJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lfSc7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5ICs9IGBTRVQgVElNRSBaT05FIElOVEVSVkFMICcke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmV9JyBIT1VSIFRPIE1JTlVURTtgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24ucXVlcnkocXVlcnkpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5uYW1lT2lkTWFwKS5sZW5ndGggPT09IDAgJiYgdGhpcy5lbnVtT2lkcy5vaWRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmVudW1PaWRzLmFycmF5T2lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuX3JlZnJlc2hEeW5hbWljT0lEcyhjb25uZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uX2VuZGluZykge1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IEVORElORyBzdGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSgoY2FsbGJhY2spID0+IGNvbm5lY3Rpb24uZW5kKGNhbGxiYWNrKSkoKTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuICFjb25uZWN0aW9uLl9pbnZhbGlkICYmICFjb25uZWN0aW9uLl9lbmRpbmc7XG4gIH1cbiAgYXN5bmMgX3JlZnJlc2hEeW5hbWljT0lEcyhjb25uZWN0aW9uKSB7XG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb247XG4gICAgY29uc3Qgc3VwcG9ydGVkVmVyc2lvbiA9IFwiOC4zLjBcIjtcbiAgICBpZiAoKGRhdGFiYXNlVmVyc2lvbiAmJiBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgc3VwcG9ydGVkVmVyc2lvbikpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgKGNvbm5lY3Rpb24gfHwgdGhpcy5zZXF1ZWxpemUpLnF1ZXJ5KFwiV0lUSCByYW5nZXMgQVMgKCAgU0VMRUNUIHBnX3JhbmdlLnJuZ3R5cGlkLCBwZ190eXBlLnR5cG5hbWUgQVMgcm5ndHlwbmFtZSwgICAgICAgICBwZ190eXBlLnR5cGFycmF5IEFTIHJuZ3R5cGFycmF5LCBwZ19yYW5nZS5ybmdzdWJ0eXBlICAgIEZST00gcGdfcmFuZ2UgTEVGVCBPVVRFUiBKT0lOIHBnX3R5cGUgT04gcGdfdHlwZS5vaWQgPSBwZ19yYW5nZS5ybmd0eXBpZClTRUxFQ1QgcGdfdHlwZS50eXBuYW1lLCBwZ190eXBlLnR5cHR5cGUsIHBnX3R5cGUub2lkLCBwZ190eXBlLnR5cGFycmF5LCAgICAgICByYW5nZXMucm5ndHlwbmFtZSwgcmFuZ2VzLnJuZ3R5cGlkLCByYW5nZXMucm5ndHlwYXJyYXkgIEZST00gcGdfdHlwZSBMRUZUIE9VVEVSIEpPSU4gcmFuZ2VzIE9OIHBnX3R5cGUub2lkID0gcmFuZ2VzLnJuZ3N1YnR5cGUgV0hFUkUgKHBnX3R5cGUudHlwdHlwZSBJTignYicsICdlJykpO1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShyZXN1bHRzKSA/IHJlc3VsdHMucG9wKCkgOiByZXN1bHRzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgIGlmIChyZXN1bHRbMF0uY29tbWFuZCA9PT0gXCJTRVRcIikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld05hbWVPaWRNYXAgPSB7fTtcbiAgICBjb25zdCBuZXdFbnVtT2lkcyA9IHsgb2lkczogW10sIGFycmF5T2lkczogW10gfTtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiByZXN1bHQucm93cykge1xuICAgICAgaWYgKHJvdy50eXB0eXBlID09PSBcImVcIikge1xuICAgICAgICBuZXdFbnVtT2lkcy5vaWRzLnB1c2gocm93Lm9pZCk7XG4gICAgICAgIGlmIChyb3cudHlwYXJyYXkpXG4gICAgICAgICAgbmV3RW51bU9pZHMuYXJyYXlPaWRzLnB1c2gocm93LnR5cGFycmF5KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXSA9IHsgb2lkOiByb3cub2lkIH07XG4gICAgICBpZiAocm93LnR5cGFycmF5KVxuICAgICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5hcnJheU9pZCA9IHJvdy50eXBhcnJheTtcbiAgICAgIGlmIChyb3cucm5ndHlwaWQpIHtcbiAgICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0ucmFuZ2VPaWQgPSByb3cucm5ndHlwaWQ7XG4gICAgICAgIGlmIChyb3cucm5ndHlwYXJyYXkpXG4gICAgICAgICAgbmV3TmFtZU9pZE1hcFtyb3cudHlwbmFtZV0uYXJyYXlSYW5nZU9pZCA9IHJvdy5ybmd0eXBhcnJheTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uYW1lT2lkTWFwID0gbmV3TmFtZU9pZE1hcDtcbiAgICB0aGlzLmVudW1PaWRzID0gbmV3RW51bU9pZHM7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMucG9zdGdyZXMpO1xuICB9XG4gIF9jbGVhckR5bmFtaWNPSURzKCkge1xuICAgIHRoaXMubmFtZU9pZE1hcCA9IHt9O1xuICAgIHRoaXMuZW51bU9pZHMgPSB7IG9pZHM6IFtdLCBhcnJheU9pZHM6IFtdIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.UUID.types.postgres = [\"uuid\"];\n  BaseTypes.CIDR.types.postgres = [\"cidr\"];\n  BaseTypes.INET.types.postgres = [\"inet\"];\n  BaseTypes.MACADDR.types.postgres = [\"macaddr\"];\n  BaseTypes.TSVECTOR.types.postgres = [\"tsvector\"];\n  BaseTypes.JSON.types.postgres = [\"json\"];\n  BaseTypes.JSONB.types.postgres = [\"jsonb\"];\n  BaseTypes.TIME.types.postgres = [\"time\"];\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === \"infinity\") {\n        return Infinity;\n      }\n      if (value === \"-infinity\") {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATEONLY.types.postgres = [\"date\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.DECIMAL.types.postgres = [\"numeric\"];\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.STRING.types.postgres = [\"varchar\"];\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  BaseTypes.TEXT.types.postgres = [\"text\"];\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.CITEXT.types.postgres = [\"citext\"];\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.CHAR.types.postgres = [\"char\", \"bpchar\"];\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          return [\"true\", \"t\"].includes(value) ? true : [\"false\", \"f\"].includes(value) ? false : value;\n        }\n        if (typeof value === \"number\") {\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = [\"bool\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATE.types.postgres = [\"timestamptz\"];\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.TINYINT.types.postgres = [\"int2\"];\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.SMALLINT.types.postgres = [\"int2\"];\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n  BaseTypes.INTEGER.types.postgres = [\"int4\"];\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.BIGINT.types.postgres = [\"int8\"];\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.REAL.types.postgres = [\"float4\"];\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.DOUBLE.types.postgres = [\"float8\"];\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._decimals = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  delete FLOAT.parse;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"BYTEA\";\n    }\n    _hexify(hex) {\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n  BaseTypes.BLOB.types.postgres = [\"bytea\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOMETRY.types.postgres = [\"geometry\"];\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = \"GEOGRAPHY\";\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOGRAPHY.types.postgres = [\"geography\"];\n  let hstore;\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.parse(value);\n    }\n  }\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = [\"hstore\"];\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\")) {\n          if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: (val) => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = __webpack_require__(/*! ./range */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js\");\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  };\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map((value) => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(\",\")}]`;\n    if (this.type) {\n      const Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\n      let castKey = this.toSql();\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== void 0;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : \"\";\n        castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '\"')}[]`;\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyxnREFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhLDhDQUE4QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQSxtQ0FBbUMsc0NBQXNDO0FBQ3pFO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sS0FBSyxrQkFBa0I7QUFDaEQ7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUIsSUFBSSxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQyxFQUFFLGdCQUFnQjtBQUN2RyxxQkFBcUIsc0dBQXNHO0FBQzNILG9CQUFvQixvQkFBb0IsRUFBRSxRQUFRO0FBQ2xELFFBQVE7QUFDUixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvZGF0YS10eXBlcy5qcz8zYWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB3a3ggPSByZXF1aXJlKFwid2t4XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHZvaWQgMCwgXCJodHRwOi8vd3d3LnBvc3RncmVzcWwub3JnL2RvY3MvOS40L3N0YXRpYy9kYXRhdHlwZS5odG1sXCIpO1xuICBmdW5jdGlvbiByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLl9sZW5ndGggfHwgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggfHwgZGF0YVR5cGUuX3Vuc2lnbmVkIHx8IGRhdGFUeXBlLl96ZXJvZmlsbCkge1xuICAgICAgd2FybihgUG9zdGdyZXNTUUwgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIExFTkdUSCwgVU5TSUdORUQgb3IgWkVST0ZJTEwuIFBsYWluICcke2RhdGFUeXBlLmtleX0nIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgZGF0YVR5cGUuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUuX3plcm9maWxsID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5wb3N0Z3JlcyA9IFtcInV1aWRcIl07XG4gIEJhc2VUeXBlcy5DSURSLnR5cGVzLnBvc3RncmVzID0gW1wiY2lkclwiXTtcbiAgQmFzZVR5cGVzLklORVQudHlwZXMucG9zdGdyZXMgPSBbXCJpbmV0XCJdO1xuICBCYXNlVHlwZXMuTUFDQUREUi50eXBlcy5wb3N0Z3JlcyA9IFtcIm1hY2FkZHJcIl07XG4gIEJhc2VUeXBlcy5UU1ZFQ1RPUi50eXBlcy5wb3N0Z3JlcyA9IFtcInRzdmVjdG9yXCJdO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5wb3N0Z3JlcyA9IFtcImpzb25cIl07XG4gIEJhc2VUeXBlcy5KU09OQi50eXBlcy5wb3N0Z3JlcyA9IFtcImpzb25iXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5wb3N0Z3JlcyA9IFtcInRpbWVcIl07XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci5fc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMgJiYgIW9wdGlvbnMucmF3KSAmJiB2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3QgbG93ZXIgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGlmIChsb3dlciA9PT0gXCJpbmZpbml0eVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gXCItaW5maW5pdHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcImluZmluaXR5XCIpIHtcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBcIi1pbmZpbml0eVwiKSB7XG4gICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5wb3N0Z3JlcyA9IFtcImRhdGVcIl07XG4gIGNsYXNzIERFQ0lNQUwgZXh0ZW5kcyBCYXNlVHlwZXMuREVDSU1BTCB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLnBvc3RncmVzID0gW1wibnVtZXJpY1wiXTtcbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBcIkJZVEVBXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwoKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5wb3N0Z3JlcyA9IFtcInZhcmNoYXJcIl07XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXCJQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgVEVYVCB3aXRoIG9wdGlvbnMuIFBsYWluIGBURVhUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlRFWFRcIjtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMucG9zdGdyZXMgPSBbXCJ0ZXh0XCJdO1xuICBjbGFzcyBDSVRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuQ0lURVhUIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkNJVEVYVC50eXBlcy5wb3N0Z3JlcyA9IFtcImNpdGV4dFwiXTtcbiAgY2xhc3MgQ0hBUiBleHRlbmRzIEJhc2VUeXBlcy5DSEFSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQllURUFcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5wb3N0Z3JlcyA9IFtcImNoYXJcIiwgXCJicGNoYXJcIl07XG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCT09MRUFOXCI7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIFtcInRydWVcIiwgXCJ0XCJdLmluY2x1ZGVzKHZhbHVlKSA/IHRydWUgOiBbXCJmYWxzZVwiLCBcImZcIl0uaW5jbHVkZXModmFsdWUpID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxID8gdHJ1ZSA6IHZhbHVlID09PSAwID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCT09MRUFOLnBhcnNlID0gQk9PTEVBTi5wcm90b3R5cGUuX3Nhbml0aXplO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5wb3N0Z3JlcyA9IFtcImJvb2xcIl07XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJUSU1FU1RBTVAgV0lUSCBUSU1FIFpPTkVcIjtcbiAgICB9XG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gSW5maW5pdHkgJiYgdmFsdWUgIT09IC1JbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gc3VwZXIudmFsaWRhdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhIXZhbHVlICYmIHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGxvd2VyID09PSBcImluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID09PSBcIi1pbmZpbml0eVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuREFURS50eXBlcy5wb3N0Z3JlcyA9IFtcInRpbWVzdGFtcHR6XCJdO1xuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLnBvc3RncmVzID0gW1wiaW50MlwiXTtcbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5wb3N0Z3JlcyA9IFtcImludDJcIl07XG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgSU5URUdFUi5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLnBvc3RncmVzID0gW1wiaW50NFwiXTtcbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkJJR0lOVC50eXBlcy5wb3N0Z3JlcyA9IFtcImludDhcIl07XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMucG9zdGdyZXMgPSBbXCJmbG9hdDRcIl07XG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMucG9zdGdyZXMgPSBbXCJmbG9hdDhcIl07XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9kZWNpbWFscykge1xuICAgICAgICB3YXJuKFwiUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHdpdGggZGVjaW1hbHMuIFBsYWluIGBGTE9BVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX2RlY2ltYWxzID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHdhcm4oXCJQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgdW5zaWduZWQuIGBVTlNJR05FRGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEZMT0FUIHplcm9maWxsLiBgWkVST0ZJTExgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlbGV0ZSBGTE9BVC5wYXJzZTtcbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybihcIlBvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBCTE9CIChCWVRFQSkgd2l0aCBvcHRpb25zLiBQbGFpbiBgQllURUFgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiQllURUFcIjtcbiAgICB9XG4gICAgX2hleGlmeShoZXgpIHtcbiAgICAgIHJldHVybiBgRSdcXFxcXFxcXHgke2hleH0nYDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMucG9zdGdyZXMgPSBbXCJieXRlYVwiXTtcbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMudHlwZX1gO1xuICAgICAgICBpZiAodGhpcy5zcmlkKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLnNyaWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJoZXhcIik7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKGIpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuZXNjYXBlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSl9KWA7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfSlgO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMucG9zdGdyZXMgPSBbXCJnZW9tZXRyeVwiXTtcbiAgY2xhc3MgR0VPR1JBUEhZIGV4dGVuZHMgQmFzZVR5cGVzLkdFT0dSQVBIWSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gXCJHRU9HUkFQSFlcIjtcbiAgICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLnR5cGV9YDtcbiAgICAgICAgaWYgKHRoaXMuc3JpZCkge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5zcmlkfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBjb25zdCBiID0gQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZShiKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmVzY2FwZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpfSlgO1xuICAgIH1cbiAgICBiaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfSlgO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuR0VPR1JBUEhZLnR5cGVzLnBvc3RncmVzID0gW1wiZ2VvZ3JhcGh5XCJdO1xuICBsZXQgaHN0b3JlO1xuICBjbGFzcyBIU1RPUkUgZXh0ZW5kcyBCYXNlVHlwZXMuSFNUT1JFIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKFwiLi9oc3RvcmVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIF92YWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZShcIi4vaHN0b3JlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhzdG9yZS5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gYCcke3RoaXMuX3ZhbHVlKHZhbHVlKX0nYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKCFoc3RvcmUpIHtcbiAgICAgICAgaHN0b3JlID0gcmVxdWlyZShcIi4vaHN0b3JlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhzdG9yZS5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIEhTVE9SRS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5IU1RPUkUudHlwZXMucG9zdGdyZXMgPSBbXCJoc3RvcmVcIl07XG4gIGNsYXNzIFJBTkdFIGV4dGVuZHMgQmFzZVR5cGVzLlJBTkdFIHtcbiAgICBfdmFsdWUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUluY2x1c2l2aXR5ID0gW3RydWUsIGZhbHNlXTtcbiAgICAgIGNvbnN0IHZhbHVlc1N0cmluZ2lmaWVkID0gdmFsdWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwidmFsdWVcIikpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImluY2x1c2l2ZVwiKSkge1xuICAgICAgICAgICAgdmFsdWVJbmNsdXNpdml0eVtpbmRleF0gPSB2YWx1ZS5pbmNsdXNpdmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN1YnR5cGUuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgICB2YWx1ZXNTdHJpbmdpZmllZC5pbmNsdXNpdmUgPSB2YWx1ZUluY2x1c2l2aXR5O1xuICAgICAgcmV0dXJuIHJhbmdlLnN0cmluZ2lmeSh2YWx1ZXNTdHJpbmdpZmllZCk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gYCcke3ZhbHVlfSc6OiR7dGhpcy50b0Nhc3RUeXBlKCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJyR7dmFsdWV9J2A7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWVzLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gYCR7b3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpfTo6JHt0aGlzLnRvQ2FzdFR5cGUoKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHZhbHVlKTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzLnN1YnR5cGVzW3RoaXMuX3N1YnR5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHRvQ2FzdFR5cGUoKSB7XG4gICAgICByZXR1cm4gQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzLmNhc3RUeXBlc1t0aGlzLl9zdWJ0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMgPSB7IHBhcnNlcjogKHZhbCkgPT4gdmFsIH0pIHtcbiAgICAgIHJldHVybiByYW5nZS5wYXJzZSh2YWx1ZSwgb3B0aW9ucy5wYXJzZXIpO1xuICAgIH1cbiAgfVxuICBjb25zdCByYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpO1xuICBSQU5HRS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SQU5HRS50eXBlcy5wb3N0Z3JlcyA9IHtcbiAgICBzdWJ0eXBlczoge1xuICAgICAgaW50ZWdlcjogXCJpbnQ0cmFuZ2VcIixcbiAgICAgIGRlY2ltYWw6IFwibnVtcmFuZ2VcIixcbiAgICAgIGRhdGU6IFwidHN0enJhbmdlXCIsXG4gICAgICBkYXRlb25seTogXCJkYXRlcmFuZ2VcIixcbiAgICAgIGJpZ2ludDogXCJpbnQ4cmFuZ2VcIlxuICAgIH0sXG4gICAgY2FzdFR5cGVzOiB7XG4gICAgICBpbnRlZ2VyOiBcImludDRcIixcbiAgICAgIGRlY2ltYWw6IFwibnVtZXJpY1wiLFxuICAgICAgZGF0ZTogXCJ0aW1lc3RhbXB0elwiLFxuICAgICAgZGF0ZW9ubHk6IFwiZGF0ZVwiLFxuICAgICAgYmlnaW50OiBcImludDhcIlxuICAgIH1cbiAgfTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkFSUkFZLnByb3RvdHlwZS5fdmFsdWUgPSBmdW5jdGlvbiBfdmFsdWUodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmJpbmRQYXJhbSAmJiB0aGlzLnR5cGUgJiYgdGhpcy50eXBlLl92YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlLl92YWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnR5cGUuc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5lc2NhcGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUodmFsdWUpO1xuICAgIH0sIHRoaXMpO1xuICB9O1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl9zdHJpbmdpZnkgPSBmdW5jdGlvbiBfc3RyaW5naWZ5KHZhbHVlcywgb3B0aW9ucykge1xuICAgIGxldCBzdHIgPSBgQVJSQVlbJHt0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpLmpvaW4oXCIsXCIpfV1gO1xuICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgIGNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuICAgICAgbGV0IGNhc3RLZXkgPSB0aGlzLnRvU3FsKCk7XG4gICAgICBpZiAodGhpcy50eXBlIGluc3RhbmNlb2YgQmFzZVR5cGVzLkVOVU0pIHtcbiAgICAgICAgY29uc3QgdGFibGUgPSBvcHRpb25zLmZpZWxkLk1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgICAgICBjb25zdCB1c2VTY2hlbWEgPSB0YWJsZS5zY2hlbWEgIT09IHZvaWQgMDtcbiAgICAgICAgY29uc3Qgc2NoZW1hV2l0aERlbGltaXRlciA9IHVzZVNjaGVtYSA/IGAke1V0aWxzLmFkZFRpY2tzKHRhYmxlLnNjaGVtYSwgJ1wiJyl9JHt0YWJsZS5kZWxpbWl0ZXJ9YCA6IFwiXCI7XG4gICAgICAgIGNhc3RLZXkgPSBgJHtVdGlscy5hZGRUaWNrcyhVdGlscy5nZW5lcmF0ZUVudW1OYW1lKHVzZVNjaGVtYSA/IHRhYmxlLnRhYmxlTmFtZSA6IHRhYmxlLCBvcHRpb25zLmZpZWxkLmZpZWxkKSwgJ1wiJyl9W11gO1xuICAgICAgICBzdHIgKz0gYDo6JHtzY2hlbWFXaXRoRGVsaW1pdGVyfSR7Y2FzdEtleX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGA6OiR7Y2FzdEtleX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl9iaW5kUGFyYW0gPSBmdW5jdGlvbiBfYmluZFBhcmFtKHZhbHVlcywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLl92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpKTtcbiAgfTtcbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMucG9zdGdyZXMgPSBbbnVsbF07XG4gIHJldHVybiB7XG4gICAgREVDSU1BTCxcbiAgICBCTE9CLFxuICAgIFNUUklORyxcbiAgICBDSEFSLFxuICAgIFRFWFQsXG4gICAgQ0lURVhULFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgQk9PTEVBTixcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFJFQUwsXG4gICAgXCJET1VCTEUgUFJFQ0lTSU9OXCI6IERPVUJMRSxcbiAgICBGTE9BVCxcbiAgICBHRU9NRVRSWSxcbiAgICBHRU9HUkFQSFksXG4gICAgSFNUT1JFLFxuICAgIFJBTkdFLFxuICAgIEVOVU1cbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst hstore = __webpack_require__(/*! pg-hstore */ \"?9973\")({ sanitize: true });\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  return hstore.stringify(data);\n}\nexports.stringify = stringify;\nfunction parse(value) {\n  if (value === null)\n    return null;\n  return hstore.parse(value);\n}\nexports.parse = parse;\n//# sourceMappingURL=hstore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0JBQVcsSUFBSSxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvaHN0b3JlLmpzP2QzNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBoc3RvcmUgPSByZXF1aXJlKFwicGctaHN0b3JlXCIpKHsgc2FuaXRpemU6IHRydWUgfSk7XG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGhzdG9yZS5zdHJpbmdpZnkoZGF0YSk7XG59XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbmZ1bmN0aW9uIHBhcnNlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGhzdG9yZS5wYXJzZSh2YWx1ZSk7XG59XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oc3RvcmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").postgres);\nconst { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js\");\nclass PostgresDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return !this.sequelize.options.standardConformingStrings;\n  }\n}\nPostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT VALUES\": true,\n  EXCEPTION: true,\n  \"ON DUPLICATE KEY\": false,\n  \"ORDER NULLS\": true,\n  returnValues: {\n    returning: true\n  },\n  bulkDefault: true,\n  schemas: true,\n  lock: true,\n  lockOf: true,\n  lockKey: true,\n  lockOuterJoinFailure: true,\n  skipLocked: true,\n  forShare: \"FOR SHARE\",\n  index: {\n    concurrently: true,\n    using: 2,\n    where: true,\n    functionBased: true,\n    operator: true\n  },\n  inserts: {\n    onConflictDoNothing: \" ON CONFLICT DO NOTHING\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  NUMERIC: true,\n  ARRAY: true,\n  RANGE: true,\n  GEOMETRY: true,\n  REGEXP: true,\n  GEOGRAPHY: true,\n  JSON: true,\n  JSONB: true,\n  HSTORE: true,\n  TSVECTOR: true,\n  deferrableConstraints: true,\n  searchPath: true,\n  escapeStringConstants: true\n});\nPostgresDialect.prototype.defaultVersion = \"9.5.0\";\nPostgresDialect.prototype.Query = Query;\nPostgresDialect.prototype.DataTypes = DataTypes;\nPostgresDialect.prototype.name = \"postgres\";\nPostgresDialect.prototype.TICK_CHAR = '\"';\nPostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;\nPostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;\nmodule.exports = PostgresDialect;\nmodule.exports[\"default\"] = PostgresDialect;\nmodule.exports.PostgresDialect = PostgresDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDhFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRCxrQkFBa0IsMEdBQW9DO0FBQ3RELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcz9iZTgzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLnBvc3RncmVzO1xuY29uc3QgeyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBQb3N0Z3Jlc0RpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbiAgY2FuQmFja3NsYXNoRXNjYXBlKCkge1xuICAgIHJldHVybiAhdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzO1xuICB9XG59XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIkRFRkFVTFQgVkFMVUVTXCI6IHRydWUsXG4gIEVYQ0VQVElPTjogdHJ1ZSxcbiAgXCJPTiBEVVBMSUNBVEUgS0VZXCI6IGZhbHNlLFxuICBcIk9SREVSIE5VTExTXCI6IHRydWUsXG4gIHJldHVyblZhbHVlczoge1xuICAgIHJldHVybmluZzogdHJ1ZVxuICB9LFxuICBidWxrRGVmYXVsdDogdHJ1ZSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgbG9ja09mOiB0cnVlLFxuICBsb2NrS2V5OiB0cnVlLFxuICBsb2NrT3V0ZXJKb2luRmFpbHVyZTogdHJ1ZSxcbiAgc2tpcExvY2tlZDogdHJ1ZSxcbiAgZm9yU2hhcmU6IFwiRk9SIFNIQVJFXCIsXG4gIGluZGV4OiB7XG4gICAgY29uY3VycmVudGx5OiB0cnVlLFxuICAgIHVzaW5nOiAyLFxuICAgIHdoZXJlOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IHRydWUsXG4gICAgb3BlcmF0b3I6IHRydWVcbiAgfSxcbiAgaW5zZXJ0czoge1xuICAgIG9uQ29uZmxpY3REb05vdGhpbmc6IFwiIE9OIENPTkZMSUNUIERPIE5PVEhJTkdcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogXCIgT04gQ09ORkxJQ1QgRE8gVVBEQVRFIFNFVFwiLFxuICAgIGNvbmZsaWN0RmllbGRzOiB0cnVlLFxuICAgIG9uQ29uZmxpY3RXaGVyZTogdHJ1ZVxuICB9LFxuICBOVU1FUklDOiB0cnVlLFxuICBBUlJBWTogdHJ1ZSxcbiAgUkFOR0U6IHRydWUsXG4gIEdFT01FVFJZOiB0cnVlLFxuICBSRUdFWFA6IHRydWUsXG4gIEdFT0dSQVBIWTogdHJ1ZSxcbiAgSlNPTjogdHJ1ZSxcbiAgSlNPTkI6IHRydWUsXG4gIEhTVE9SRTogdHJ1ZSxcbiAgVFNWRUNUT1I6IHRydWUsXG4gIGRlZmVycmFibGVDb25zdHJhaW50czogdHJ1ZSxcbiAgc2VhcmNoUGF0aDogdHJ1ZSxcbiAgZXNjYXBlU3RyaW5nQ29uc3RhbnRzOiB0cnVlXG59KTtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjkuNS4wXCI7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5Qb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwicG9zdGdyZXNcIjtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBQb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IFBvc3RncmVzRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5Qb3N0Z3Jlc0RpYWxlY3QgPSBQb3N0Z3Jlc0RpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst POSTGRES_RESERVED_WORDS = \"all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with\".split(\",\");\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      encoding: null,\n      collate: null\n    }, options);\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : \"\",\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : \"\",\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : \"\",\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : \"\"\n    };\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n  createSchema(schema) {\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    if (databaseVersion && semver.gte(databaseVersion, \"9.2.0\")) {\n      return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;\n    }\n    return `CREATE SCHEMA ${this.quoteIdentifier(schema)};`;\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;\n  }\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n  versionQuery() {\n    return \"SHOW SERVER_VERSION\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({}, options);\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    const attrStr = [];\n    let comments = \"\";\n    let columnComments = \"\";\n    const quotedTable = this.quoteTable(tableName);\n    if (options.comment && typeof options.comment === \"string\") {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf(\"COMMENT \");\n      if (i !== -1) {\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n    let attributesClause = attrStr.join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes(\"PRIMARY KEY\")) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(\",\");\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, \"9.1.0\") ? \"IF NOT EXISTS \" : \"\"}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? \" CASCADE\" : \"\"};`;\n  }\n  showTablesQuery() {\n    const schema = this.options.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;\n  }\n  tableExistsQuery(tableName) {\n    const table = tableName.tableName || tableName;\n    const schema = tableName.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;\n  }\n  describeTableQuery(tableName, schema) {\n    schema = schema || this.options.schema || \"public\";\n    return `SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, { context: \"addColumn\", table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n    return query;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (subQuery) => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = \"\";\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n      if (attributes[attributeName].startsWith(\"ENUM(\")) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(\"ALTER COLUMN\", \"\");\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace(\"ALTER COLUMN\", \"\");\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n      sql.push(attrSql);\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(\", \")};`;\n  }\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || \"testfunc\";\n    language = language || \"plpgsql\";\n    returns = returns ? `RETURNS ${returns}` : \"\";\n    parameters = parameters || \"\";\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? \" RESTART IDENTITY\" : \"\",\n      options.cascade ? \" CASCADE\" : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : \"\";\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n  showIndexesQuery(tableName) {\n    let schemaJoin = \"\";\n    let schemaWhere = \"\";\n    if (typeof tableName !== \"string\") {\n      schemaJoin = \", pg_namespace s\";\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n    return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;\n  }\n  showConstraintsQuery(tableName) {\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      \"from INFORMATION_SCHEMA.table_constraints\",\n      `WHERE table_name='${tableName}';`\n    ].join(\" \");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes, options) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return [\n      \"DROP INDEX\",\n      options && options.concurrently && \"CONCURRENTLY\",\n      `IF EXISTS ${this.quoteIdentifiers(indexName)}`\n    ].filter(Boolean).join(\" \");\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.limit != null) {\n      fragment += \" LIMIT \" + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += \" OFFSET \" + this.escape(options.offset);\n    }\n    return fragment;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let type;\n    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map((value) => this.escape(value)).join(\", \")})`;\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += \"[]\";\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n    if (!type) {\n      type = attribute.type;\n    }\n    let sql = type.toString();\n    if (Object.prototype.hasOwnProperty.call(attribute, \"allowNull\") && !attribute.allowNull) {\n      sql += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += \" GENERATED BY DEFAULT AS IDENTITY\";\n      } else {\n        sql += \" SERIAL\";\n      }\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n    if (attribute.unique === true) {\n      sql += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      sql += \" PRIMARY KEY\";\n    }\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n      if (options.schema) {\n        schema = options.schema;\n      } else if ((!attribute.references.model || typeof attribute.references.model == \"string\") && options.table && options.table.schema) {\n        schema = options.table.schema;\n      }\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n      let referencesKey;\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier(\"id\");\n        }\n        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n        if (attribute.references.deferrable) {\n          sql += ` ${attribute.references.deferrable.toString(this)}`;\n        }\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      if (options && [\"addColumn\", \"changeColumn\"].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n    return sql;\n  }\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n  setConstraintQuery(columns, type) {\n    let columnFragment = \"ALL\";\n    if (columns) {\n      columnFragment = columns.map((column) => this.quoteIdentifier(column)).join(\", \");\n    }\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, \"DEFERRED\");\n  }\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, \"IMMEDIATE\");\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({ key }, options));\n    }\n    return result;\n  }\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : \"\"} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body)\n      throw new Error(\"createFunction missing some parameters. Did you pass functionName, returnType, language and body?\");\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : \"\";\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n    const statement = options && options.force ? \"CREATE OR REPLACE FUNCTION\" : \"CREATE FUNCTION\";\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n  dropFunction(functionName, params) {\n    if (!functionName)\n      throw new Error(\"requires functionName\");\n    const paramList = this._expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n  _expandFunctionParamList(params) {\n    if (params === void 0 || !Array.isArray(params)) {\n      throw new Error(\"_expandFunctionParamList: function parameters array required, including an empty one for no arguments\");\n    }\n    const paramList = [];\n    params.forEach((curParam) => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error(\"function or trigger used with a parameter without any type\");\n      }\n      const joined = paramDef.join(\" \");\n      if (joined)\n        paramList.push(joined);\n    });\n    return paramList.join(\", \");\n  }\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error(\"_expandFunctionVariableList: function variables must be an array\");\n    }\n    const variableDefinitions = [];\n    variables.forEach((variable) => {\n      if (!variable.name || !variable.type) {\n        throw new Error(\"function variable must have a name and type\");\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += \";\";\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(\" \");\n  }\n  expandOptions(options) {\n    return options === void 0 || _.isEmpty(options) ? \"\" : options.join(\" \");\n  }\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      \"after\": \"AFTER\",\n      \"before\": \"BEFORE\",\n      \"instead_of\": \"INSTEAD OF\",\n      \"after_constraint\": \"AFTER\"\n    };\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n    return EVENT_DECODER[eventSpecifier];\n  }\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === \"after_constraint\" ? \"CONSTRAINT \" : \"\";\n  }\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error(\"no table change events specified to trigger on\");\n    }\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        \"insert\": \"INSERT\",\n        \"update\": \"UPDATE\",\n        \"delete\": \"DELETE\",\n        \"truncate\": \"TRUNCATE\"\n      };\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === \"UPDATE\") {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(\", \")}`;\n        }\n      }\n      return eventSpec;\n    }).join(\" OR \");\n  }\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n    return enumName;\n  }\n  pgListEnums(tableName, attrName, options) {\n    let enumName = \"\";\n    const tableDetails = this.extractTableDetails(tableName, options);\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n    return `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map((value) => this.escape(value)).join(\", \")})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n    let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n    if (semver.gte(this.sequelize.options.databaseVersion, \"9.3.0\")) {\n      sql += \"IF NOT EXISTS \";\n    }\n    sql += this.escape(value);\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n    return sql;\n  }\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n  fromArray(text) {\n    text = text.replace(/^{/, \"\").replace(/}$/, \"\");\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n    if (matches.length < 1) {\n      return [];\n    }\n    matches = matches.map((m) => m.replace(/\",$/, \"\").replace(/,$/, \"\").replace(/(^\"|\"$)/g, \"\"));\n    return matches.slice(0, -1);\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    if (dataType.startsWith(\"ENUM(\")) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(tableName) {\n    return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n  _getForeignKeyReferencesQueryPrefix() {\n    return \"SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name \";\n  }\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : \"\"}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : \"\"}`;\n  }\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : \"\"}`;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nmodule.exports = PostgresQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRixvREFBb0QsNkJBQTZCO0FBQ2pGLDRDQUE0QywyQkFBMkI7QUFDdkUsa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBLDhCQUE4QixnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQSxzQ0FBc0MsK0JBQStCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEIsUUFBUTtBQUMxRTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQixhQUFhLEtBQUssNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0IsWUFBWSxHQUFHLFlBQVksS0FBSyxtQkFBbUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksRUFBRSxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0VBQXNFO0FBQ2pIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0EsMkJBQTJCLHNGQUFzRixFQUFFLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxTQUFTLEVBQUUsZ0JBQWdCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkIsRUFBRSxtQ0FBbUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFCQUFxQixpRUFBaUU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YscUJBQXFCLG1CQUFtQixtQkFBbUI7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsZ3BDQUFncEMsd0JBQXdCLHVCQUF1QixvQkFBb0I7QUFDbnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxrQkFBa0IsSUFBSTtBQUMxRSwrREFBK0QsRUFBRTtBQUNqRSw0REFBNEQsRUFBRSxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYseUVBQXlFLEtBQUssZ0JBQWdCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYSxhQUFhLFdBQVcsRUFBRSxZQUFZO0FBQ2xGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLGNBQWMscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCLGVBQWUsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDLGNBQWMsOEJBQThCLFNBQVM7QUFDdEgsb0RBQW9EO0FBQ3BELFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xILGlDQUFpQyxvQ0FBb0MsSUFBSSwwQ0FBMEM7QUFDbkg7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hELHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQyxJQUFJLFdBQVc7QUFDaEcsUUFBUTtBQUNSLDRCQUE0QixxQ0FBcUMsT0FBTyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssb0NBQW9DO0FBQ3BHO0FBQ0EsMEJBQTBCLDRCQUE0QixnQkFBZ0IsdUJBQXVCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpREFBaUQsT0FBTyxHQUFHLFdBQVcsSUFBSSxTQUFTLGtCQUFrQixNQUFNLEtBQUssa0JBQWtCLFdBQVcsd0JBQXdCLE9BQU8sR0FBRztBQUMvSztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQSw0QkFBNEIsT0FBTyxRQUFRLGFBQWEsYUFBYSxzQkFBc0IsT0FBTyxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU07QUFDOUg7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0EscVNBQXFTLFlBQVksa0hBQWtILFVBQVUsR0FBRyxhQUFhLGlHQUFpRztBQUM5aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUIsR0FBRyxjQUFjO0FBQ2hFO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0IsK0JBQStCLEdBQUcsWUFBWSxLQUFLLG1CQUFtQjtBQUM1RyxRQUFRO0FBQ1IsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCLEVBQUUsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBNkMsVUFBVSxtQ0FBbUMsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLEtBQUssMkJBQTJCLEVBQUUsc0JBQXNCLGdCQUFnQixRQUFRLG9CQUFvQixhQUFhLEdBQUcsVUFBVSxFQUFFO0FBQ2hSO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DLEtBQUssNEJBQTRCLFNBQVM7QUFDeEc7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0MsS0FBSyw0QkFBNEIsWUFBWSxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxFQUFFLGFBQWEsR0FBRyxVQUFVLFlBQVksWUFBWSxZQUFZLGNBQWMsUUFBUSxNQUFNLEtBQUssbUJBQW1CLFNBQVMsR0FBRyxzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsVUFBVSxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxVQUFVLGNBQWMsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLEVBQUUsY0FBYztBQUN6RTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQW9ELGVBQWUscUJBQXFCO0FBQzNIO0FBQ0Esb09BQW9PLG9CQUFvQixHQUFHLFVBQVU7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBOEQ7QUFDckYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDLFVBQVUsS0FBSyxTQUFTLDJDQUEyQyxPQUFPO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsTUFBTTtBQUNOLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLFVBQVUsMENBQTBDO0FBQzFQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQyw2REFBNkQsVUFBVSxHQUFHLDBDQUEwQyxZQUFZLFFBQVEsRUFBRSx3Q0FBd0MsV0FBVyxRQUFRO0FBQzlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkMsMkRBQTJELFVBQVUsNEJBQTRCLFdBQVcsR0FBRyxvQ0FBb0MsT0FBTyxRQUFRO0FBQzNOO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLGtCQUFrQixrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1nZW5lcmF0b3IuanM/MDk2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFBPU1RHUkVTX1JFU0VSVkVEX1dPUkRTID0gXCJhbGwsYW5hbHlzZSxhbmFseXplLGFuZCxhbnksYXJyYXksYXMsYXNjLGFzeW1tZXRyaWMsYXV0aG9yaXphdGlvbixiaW5hcnksYm90aCxjYXNlLGNhc3QsY2hlY2ssY29sbGF0ZSxjb2xsYXRpb24sY29sdW1uLGNvbmN1cnJlbnRseSxjb25zdHJhaW50LGNyZWF0ZSxjcm9zcyxjdXJyZW50X2NhdGFsb2csY3VycmVudF9kYXRlLGN1cnJlbnRfcm9sZSxjdXJyZW50X3NjaGVtYSxjdXJyZW50X3RpbWUsY3VycmVudF90aW1lc3RhbXAsY3VycmVudF91c2VyLGRlZmF1bHQsZGVmZXJyYWJsZSxkZXNjLGRpc3RpbmN0LGRvLGVsc2UsZW5kLGV4Y2VwdCxmYWxzZSxmZXRjaCxmb3IsZm9yZWlnbixmcmVlemUsZnJvbSxmdWxsLGdyYW50LGdyb3VwLGhhdmluZyxpbGlrZSxpbixpbml0aWFsbHksaW5uZXIsaW50ZXJzZWN0LGludG8saXMsaXNudWxsLGpvaW4sbGF0ZXJhbCxsZWFkaW5nLGxlZnQsbGlrZSxsaW1pdCxsb2NhbHRpbWUsbG9jYWx0aW1lc3RhbXAsbmF0dXJhbCxub3Qsbm90bnVsbCxudWxsLG9mZnNldCxvbixvbmx5LG9yLG9yZGVyLG91dGVyLG92ZXJsYXBzLHBsYWNpbmcscHJpbWFyeSxyZWZlcmVuY2VzLHJldHVybmluZyxyaWdodCxzZWxlY3Qsc2Vzc2lvbl91c2VyLHNpbWlsYXIsc29tZSxzeW1tZXRyaWMsdGFibGUsdGFibGVzYW1wbGUsdGhlbix0byx0cmFpbGluZyx0cnVlLHVuaW9uLHVuaXF1ZSx1c2VyLHVzaW5nLHZhcmlhZGljLHZlcmJvc2Usd2hlbix3aGVyZSx3aW5kb3csd2l0aFwiLnNwbGl0KFwiLFwiKTtcbmNsYXNzIFBvc3RncmVzUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgc2V0U2VhcmNoUGF0aChzZWFyY2hQYXRoKSB7XG4gICAgcmV0dXJuIGBTRVQgc2VhcmNoX3BhdGggdG8gJHtzZWFyY2hQYXRofTtgO1xuICB9XG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIGRhdGFiYXNlOiB0aGlzLnF1b3RlVGFibGUoZGF0YWJhc2VOYW1lKSxcbiAgICAgIGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nID8gYCBFTkNPRElORyA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5lbmNvZGluZyl9YCA6IFwiXCIsXG4gICAgICBjb2xsYXRpb246IG9wdGlvbnMuY29sbGF0ZSA/IGAgTENfQ09MTEFURSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gIDogXCJcIixcbiAgICAgIGN0eXBlOiBvcHRpb25zLmN0eXBlID8gYCBMQ19DVFlQRSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jdHlwZSl9YCA6IFwiXCIsXG4gICAgICB0ZW1wbGF0ZTogb3B0aW9ucy50ZW1wbGF0ZSA/IGAgVEVNUExBVEUgPSAke3RoaXMuZXNjYXBlKG9wdGlvbnMudGVtcGxhdGUpfWAgOiBcIlwiXG4gICAgfTtcbiAgICByZXR1cm4gYENSRUFURSBEQVRBQkFTRSAke3ZhbHVlcy5kYXRhYmFzZX0ke3ZhbHVlcy5lbmNvZGluZ30ke3ZhbHVlcy5jb2xsYXRpb259JHt2YWx1ZXMuY3R5cGV9JHt2YWx1ZXMudGVtcGxhdGV9O2A7XG4gIH1cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIERBVEFCQVNFIElGIEVYSVNUUyAke3RoaXMucXVvdGVUYWJsZShkYXRhYmFzZU5hbWUpfTtgO1xuICB9XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSBfLmdldCh0aGlzLCBcInNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvblwiLCAwKTtcbiAgICBpZiAoZGF0YWJhc2VWZXJzaW9uICYmIHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCBcIjkuMi4wXCIpKSB7XG4gICAgICByZXR1cm4gYENSRUFURSBTQ0hFTUEgSUYgTk9UIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSl9O2A7XG4gICAgfVxuICAgIHJldHVybiBgQ1JFQVRFIFNDSEVNQSAke3RoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSl9O2A7XG4gIH1cbiAgZHJvcFNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gYERST1AgU0NIRU1BIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKHNjaGVtYSl9IENBU0NBREU7YDtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBzY2hlbWFfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YSBXSEVSRSBzY2hlbWFfbmFtZSA8PiAnaW5mb3JtYXRpb25fc2NoZW1hJyBBTkQgc2NoZW1hX25hbWUgIT0gJ3B1YmxpYycgQU5EIHNjaGVtYV9uYW1lICF+IEUnXnBnXyc7XCI7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNIT1cgU0VSVkVSX1ZFUlNJT05cIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YWJhc2VWZXJzaW9uID0gXy5nZXQodGhpcywgXCJzZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb25cIiwgMCk7XG4gICAgY29uc3QgYXR0clN0ciA9IFtdO1xuICAgIGxldCBjb21tZW50cyA9IFwiXCI7XG4gICAgbGV0IGNvbHVtbkNvbW1lbnRzID0gXCJcIjtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGlmIChvcHRpb25zLmNvbW1lbnQgJiYgdHlwZW9mIG9wdGlvbnMuY29tbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29tbWVudHMgKz0gYDsgQ09NTUVOVCBPTiBUQUJMRSAke3F1b3RlZFRhYmxlfSBJUyAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29tbWVudCl9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHF1b3RlZEF0dHIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKTtcbiAgICAgIGNvbnN0IGkgPSBhdHRyaWJ1dGVzW2F0dHJdLmluZGV4T2YoXCJDT01NRU5UIFwiKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBlc2NhcGVkQ29tbWVudFRleHQgPSB0aGlzLmVzY2FwZShhdHRyaWJ1dGVzW2F0dHJdLnN1YnN0cmluZyhpICsgOCkpO1xuICAgICAgICBjb2x1bW5Db21tZW50cyArPSBgOyBDT01NRU5UIE9OIENPTFVNTiAke3F1b3RlZFRhYmxlfS4ke3F1b3RlZEF0dHJ9IElTICR7ZXNjYXBlZENvbW1lbnRUZXh0fWA7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cl0gPSBhdHRyaWJ1dGVzW2F0dHJdLnN1YnN0cmluZygwLCBpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyLCBhdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIGF0dHJTdHIucHVzaChgJHtxdW90ZWRBdHRyfSAke2RhdGFUeXBlfWApO1xuICAgIH1cbiAgICBsZXQgYXR0cmlidXRlc0NsYXVzZSA9IGF0dHJTdHIuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwa3MgPSBfLnJlZHVjZShhdHRyaWJ1dGVzLCAoYWNjLCBhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSkuam9pbihcIixcIik7XG4gICAgaWYgKHBrcy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFBSSU1BUlkgS0VZICgke3Brc30pYDtcbiAgICB9XG4gICAgcmV0dXJuIGBDUkVBVEUgVEFCTEUgJHtkYXRhYmFzZVZlcnNpb24gPT09IDAgfHwgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sIFwiOS4xLjBcIikgPyBcIklGIE5PVCBFWElTVFMgXCIgOiBcIlwifSR7cXVvdGVkVGFibGV9ICgke2F0dHJpYnV0ZXNDbGF1c2V9KSR7Y29tbWVudHN9JHtjb2x1bW5Db21tZW50c307YDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JHtvcHRpb25zLmNhc2NhZGUgPyBcIiBDQVNDQURFXCIgOiBcIlwifTtgO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICBjb25zdCBzY2hlbWEgPSB0aGlzLm9wdGlvbnMuc2NoZW1hIHx8IFwicHVibGljXCI7XG4gICAgcmV0dXJuIGBTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgV0hFUkUgdGFibGVfc2NoZW1hID0gJHt0aGlzLmVzY2FwZShzY2hlbWEpfSBBTkQgdGFibGVfdHlwZSBMSUtFICclVEFCTEUnIEFORCB0YWJsZV9uYW1lICE9ICdzcGF0aWFsX3JlZl9zeXMnO2A7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRhYmxlTmFtZS50YWJsZU5hbWUgfHwgdGFibGVOYW1lO1xuICAgIGNvbnN0IHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWEgfHwgXCJwdWJsaWNcIjtcbiAgICByZXR1cm4gYFNFTEVDVCB0YWJsZV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBXSEVSRSB0YWJsZV9zY2hlbWEgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9IEFORCB0YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZSl9YDtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEpIHtcbiAgICBzY2hlbWEgPSBzY2hlbWEgfHwgdGhpcy5vcHRpb25zLnNjaGVtYSB8fCBcInB1YmxpY1wiO1xuICAgIHJldHVybiBgU0VMRUNUIHBrLmNvbnN0cmFpbnRfdHlwZSBhcyBcIkNvbnN0cmFpbnRcIixjLmNvbHVtbl9uYW1lIGFzIFwiRmllbGRcIiwgYy5jb2x1bW5fZGVmYXVsdCBhcyBcIkRlZmF1bHRcIixjLmlzX251bGxhYmxlIGFzIFwiTnVsbFwiLCAoQ0FTRSBXSEVOIGMudWR0X25hbWUgPSAnaHN0b3JlJyBUSEVOIGMudWR0X25hbWUgRUxTRSBjLmRhdGFfdHlwZSBFTkQpIHx8IChDQVNFIFdIRU4gYy5jaGFyYWN0ZXJfbWF4aW11bV9sZW5ndGggSVMgTk9UIE5VTEwgVEhFTiAnKCcgfHwgYy5jaGFyYWN0ZXJfbWF4aW11bV9sZW5ndGggfHwgJyknIEVMU0UgJycgRU5EKSBhcyBcIlR5cGVcIiwgKFNFTEVDVCBhcnJheV9hZ2coZS5lbnVtbGFiZWwpIEZST00gcGdfY2F0YWxvZy5wZ190eXBlIHQgSk9JTiBwZ19jYXRhbG9nLnBnX2VudW0gZSBPTiB0Lm9pZD1lLmVudW10eXBpZCBXSEVSRSB0LnR5cG5hbWU9Yy51ZHRfbmFtZSkgQVMgXCJzcGVjaWFsXCIsIChTRUxFQ1QgcGdkLmRlc2NyaXB0aW9uIEZST00gcGdfY2F0YWxvZy5wZ19zdGF0aW9fYWxsX3RhYmxlcyBBUyBzdCBJTk5FUiBKT0lOIHBnX2NhdGFsb2cucGdfZGVzY3JpcHRpb24gcGdkIG9uIChwZ2Qub2Jqb2lkPXN0LnJlbGlkKSBXSEVSRSBjLm9yZGluYWxfcG9zaXRpb249cGdkLm9ianN1YmlkIEFORCBjLnRhYmxlX25hbWU9c3QucmVsbmFtZSkgQVMgXCJDb21tZW50XCIgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuY29sdW1ucyBjIExFRlQgSk9JTiAoU0VMRUNUIHRjLnRhYmxlX3NjaGVtYSwgdGMudGFibGVfbmFtZSwgY3UuY29sdW1uX25hbWUsIHRjLmNvbnN0cmFpbnRfdHlwZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5UQUJMRV9DT05TVFJBSU5UUyB0YyBKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5LRVlfQ09MVU1OX1VTQUdFICBjdSBPTiB0Yy50YWJsZV9zY2hlbWE9Y3UudGFibGVfc2NoZW1hIGFuZCB0Yy50YWJsZV9uYW1lPWN1LnRhYmxlX25hbWUgYW5kIHRjLmNvbnN0cmFpbnRfbmFtZT1jdS5jb25zdHJhaW50X25hbWUgYW5kIHRjLmNvbnN0cmFpbnRfdHlwZT0nUFJJTUFSWSBLRVknKSBwayBPTiBway50YWJsZV9zY2hlbWE9Yy50YWJsZV9zY2hlbWEgQU5EIHBrLnRhYmxlX25hbWU9Yy50YWJsZV9uYW1lIEFORCBway5jb2x1bW5fbmFtZT1jLmNvbHVtbl9uYW1lIFdIRVJFIGMudGFibGVfbmFtZSA9ICR7dGhpcy5lc2NhcGUodGFibGVOYW1lKX0gQU5EIGMudGFibGVfc2NoZW1hID0gJHt0aGlzLmVzY2FwZShzY2hlbWEpfWA7XG4gIH1cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QganNvbkZ1bmN0aW9uUmVnZXggPSAvXlxccyooKD86W2Etel0rXyl7MCwyfWpzb25iPyg/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbiAgICBjb25zdCBqc29uT3BlcmF0b3JSZWdleCA9IC9eXFxzKigtPj4/fCM+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuICAgIGNvbnN0IHRva2VuQ2FwdHVyZVJlZ2V4ID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBqc29uRnVuY3Rpb25SZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0ganNvbk9wZXJhdG9yUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG9wZXJhdG9yTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gb3BlcmF0b3JNYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSB0b2tlbkNhcHR1cmVSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSBcIihcIikge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoYXNJbnZhbGlkVG9rZW4gfD0gb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHM7XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiBoYXNJbnZhbGlkVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoKGNvbmRpdGlvbikgPT4gYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KFwiID0gJXNcIiwgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2QuY2FsbCh0aGlzLCBzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGF0dHJpYnV0ZSkge1xuICAgIGNvbnN0IGRiRGF0YVR5cGUgPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgeyBjb250ZXh0OiBcImFkZENvbHVtblwiLCB0YWJsZSwga2V5IH0pO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlLnR5cGUgfHwgYXR0cmlidXRlO1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZSwga2V5LCBkYkRhdGFUeXBlKTtcbiAgICBjb25zdCBxdW90ZWRLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZSkpO1xuICAgIGxldCBxdWVyeSA9IGBBTFRFUiBUQUJMRSAke3F1b3RlZFRhYmxlfSBBREQgQ09MVU1OICR7cXVvdGVkS2V5fSAke2RlZmluaXRpb259O2A7XG4gICAgaWYgKGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5wZ0VudW0odGFibGUsIGtleSwgZGF0YVR5cGUpICsgcXVlcnk7XG4gICAgfSBlbHNlIGlmIChkYXRhVHlwZS50eXBlICYmIGRhdGFUeXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgcXVlcnkgPSB0aGlzLnBnRW51bSh0YWJsZSwga2V5LCBkYXRhVHlwZS50eXBlKSArIHF1ZXJ5O1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUpKTtcbiAgICBjb25zdCBxdW90ZWRBdHRyaWJ1dGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX0gRFJPUCBDT0xVTU4gJHtxdW90ZWRBdHRyaWJ1dGVOYW1lfTtgO1xuICB9XG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gKHN1YlF1ZXJ5KSA9PiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gQUxURVIgQ09MVU1OICR7c3ViUXVlcnl9O2A7XG4gICAgY29uc3Qgc3FsID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5kYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgIGxldCBhdHRyU3FsID0gXCJcIjtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiTk9UIE5VTExcIikpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gU0VUIE5PVCBOVUxMYCk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoXCJOT1QgTlVMTFwiLCBcIlwiKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBEUk9QIE5PVCBOVUxMYCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIkRFRkFVTFRcIikpIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gU0VUIERFRkFVTFQgJHtkZWZpbml0aW9uLm1hdGNoKC9ERUZBVUxUIChbXjtdKykvKVsxXX1gKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvKERFRkFVTFRbXjtdKykvLCBcIlwiKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBEUk9QIERFRkFVTFRgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdLnN0YXJ0c1dpdGgoXCJFTlVNKFwiKSkge1xuICAgICAgICBhdHRyU3FsICs9IHRoaXMucGdFbnVtKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoL15FTlVNXFwoLitcXCkvLCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCB7IHNjaGVtYTogZmFsc2UgfSkpO1xuICAgICAgICBkZWZpbml0aW9uICs9IGAgVVNJTkcgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9Ojoke3RoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24ubWF0Y2goL1VOSVFVRTsqJC8pKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoL1VOSVFVRTsqJC8sIFwiXCIpO1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGBBREQgVU5JUVVFICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSlgKS5yZXBsYWNlKFwiQUxURVIgQ09MVU1OXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoLy4rPyg/PVJFRkVSRU5DRVMpLywgXCJcIik7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYEFERCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pICR7ZGVmaW5pdGlvbn1gKS5yZXBsYWNlKFwiQUxURVIgQ09MVU1OXCIsIFwiXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0gVFlQRSAke2RlZmluaXRpb259YCk7XG4gICAgICB9XG4gICAgICBzcWwucHVzaChhdHRyU3FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbC5qb2luKFwiXCIpO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgYXR0clN0cmluZy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJCZWZvcmUpfSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFTkFNRSBDT0xVTU4gJHthdHRyU3RyaW5nLmpvaW4oXCIsIFwiKX07YDtcbiAgfVxuICBmbihmbk5hbWUsIHRhYmxlTmFtZSwgcGFyYW1ldGVycywgYm9keSwgcmV0dXJucywgbGFuZ3VhZ2UpIHtcbiAgICBmbk5hbWUgPSBmbk5hbWUgfHwgXCJ0ZXN0ZnVuY1wiO1xuICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2UgfHwgXCJwbHBnc3FsXCI7XG4gICAgcmV0dXJucyA9IHJldHVybnMgPyBgUkVUVVJOUyAke3JldHVybnN9YCA6IFwiXCI7XG4gICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwgXCJcIjtcbiAgICByZXR1cm4gYENSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OIHBnX3RlbXAuJHtmbk5hbWV9KCR7cGFyYW1ldGVyc30pICR7cmV0dXJuc30gQVMgJGZ1bmMkIEJFR0lOICR7Ym9keX0gRU5EOyAkZnVuYyQgTEFOR1VBR0UgJHtsYW5ndWFnZX07IFNFTEVDVCAqIEZST00gcGdfdGVtcC4ke2ZuTmFtZX0oKTtgO1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICBgVFJVTkNBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucy5yZXN0YXJ0SWRlbnRpdHkgPyBcIiBSRVNUQVJUIElERU5USVRZXCIgOiBcIlwiLFxuICAgICAgb3B0aW9ucy5jYXNjYWRlID8gXCIgQ0FTQ0FERVwiIDogXCJcIlxuICAgIF0uam9pbihcIlwiKTtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdCA/IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX1gIDogXCJcIjtcbiAgICBsZXQgcHJpbWFyeUtleXMgPSBcIlwiO1xuICAgIGxldCBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9IFwiXCI7XG4gICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGAgV0hFUkUgJHt3aGVyZUNsYXVzZX1gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgTElNSVQgZGVsZXRlIHdpdGhvdXQgYSBtb2RlbC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBwa3MgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihway5maWVsZCkpLmpvaW4oXCIsXCIpO1xuICAgICAgcHJpbWFyeUtleXMgPSBtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGggPiAxID8gYCgke3Brc30pYCA6IHBrcztcbiAgICAgIHByaW1hcnlLZXlzU2VsZWN0aW9uID0gcGtzO1xuICAgICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RhYmxlfSBXSEVSRSAke3ByaW1hcnlLZXlzfSBJTiAoU0VMRUNUICR7cHJpbWFyeUtleXNTZWxlY3Rpb259IEZST00gJHt0YWJsZX0ke3doZXJlQ2xhdXNlfSR7bGltaXR9KWA7XG4gICAgfVxuICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0YWJsZX0ke3doZXJlQ2xhdXNlfWA7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBsZXQgc2NoZW1hSm9pbiA9IFwiXCI7XG4gICAgbGV0IHNjaGVtYVdoZXJlID0gXCJcIjtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgc2NoZW1hSm9pbiA9IFwiLCBwZ19uYW1lc3BhY2Ugc1wiO1xuICAgICAgc2NoZW1hV2hlcmUgPSBgIEFORCBzLm9pZCA9IHQucmVsbmFtZXNwYWNlIEFORCBzLm5zcG5hbWUgPSAnJHt0YWJsZU5hbWUuc2NoZW1hfSdgO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGBTRUxFQ1QgaS5yZWxuYW1lIEFTIG5hbWUsIGl4LmluZGlzcHJpbWFyeSBBUyBwcmltYXJ5LCBpeC5pbmRpc3VuaXF1ZSBBUyB1bmlxdWUsIGl4LmluZGtleSBBUyBpbmRrZXksIGFycmF5X2FnZyhhLmF0dG51bSkgYXMgY29sdW1uX2luZGV4ZXMsIGFycmF5X2FnZyhhLmF0dG5hbWUpIEFTIGNvbHVtbl9uYW1lcywgcGdfZ2V0X2luZGV4ZGVmKGl4LmluZGV4cmVsaWQpIEFTIGRlZmluaXRpb24gRlJPTSBwZ19jbGFzcyB0LCBwZ19jbGFzcyBpLCBwZ19pbmRleCBpeCwgcGdfYXR0cmlidXRlIGEke3NjaGVtYUpvaW59IFdIRVJFIHQub2lkID0gaXguaW5kcmVsaWQgQU5EIGkub2lkID0gaXguaW5kZXhyZWxpZCBBTkQgYS5hdHRyZWxpZCA9IHQub2lkIEFORCB0LnJlbGtpbmQgPSAncicgYW5kIHQucmVsbmFtZSA9ICcke3RhYmxlTmFtZX0nJHtzY2hlbWFXaGVyZX0gR1JPVVAgQlkgaS5yZWxuYW1lLCBpeC5pbmRleHJlbGlkLCBpeC5pbmRpc3ByaW1hcnksIGl4LmluZGlzdW5pcXVlLCBpeC5pbmRrZXkgT1JERVIgQlkgaS5yZWxuYW1lO2A7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICdTRUxFQ1QgY29uc3RyYWludF9jYXRhbG9nIEFTIFwiY29uc3RyYWludENhdGFsb2dcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfc2NoZW1hIEFTIFwiY29uc3RyYWludFNjaGVtYVwiLCcsXG4gICAgICAnY29uc3RyYWludF9uYW1lIEFTIFwiY29uc3RyYWludE5hbWVcIiwnLFxuICAgICAgJ3RhYmxlX2NhdGFsb2cgQVMgXCJ0YWJsZUNhdGFsb2dcIiwnLFxuICAgICAgJ3RhYmxlX3NjaGVtYSBBUyBcInRhYmxlU2NoZW1hXCIsJyxcbiAgICAgICd0YWJsZV9uYW1lIEFTIFwidGFibGVOYW1lXCIsJyxcbiAgICAgICdjb25zdHJhaW50X3R5cGUgQVMgXCJjb25zdHJhaW50VHlwZVwiLCcsXG4gICAgICAnaXNfZGVmZXJyYWJsZSBBUyBcImlzRGVmZXJyYWJsZVwiLCcsXG4gICAgICAnaW5pdGlhbGx5X2RlZmVycmVkIEFTIFwiaW5pdGlhbGx5RGVmZXJyZWRcIicsXG4gICAgICBcImZyb20gSU5GT1JNQVRJT05fU0NIRU1BLnRhYmxlX2NvbnN0cmFpbnRzXCIsXG4gICAgICBgV0hFUkUgdGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9JztgXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgXCJEUk9QIElOREVYXCIsXG4gICAgICBvcHRpb25zICYmIG9wdGlvbnMuY29uY3VycmVudGx5ICYmIFwiQ09OQ1VSUkVOVExZXCIsXG4gICAgICBgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXJzKGluZGV4TmFtZSl9YFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICB9XG4gIGFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMpIHtcbiAgICBsZXQgZnJhZ21lbnQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9IFwiIExJTUlUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSBcIiBPRkZTRVQgXCIgKyB0aGlzLmVzY2FwZShvcHRpb25zLm9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBhdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7XG4gICAgICAgIHR5cGU6IGF0dHJpYnV0ZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHwgYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgYXR0cmlidXRlLnR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBjb25zdCBlbnVtVHlwZSA9IGF0dHJpYnV0ZS50eXBlLnR5cGUgfHwgYXR0cmlidXRlLnR5cGU7XG4gICAgICBsZXQgdmFsdWVzID0gYXR0cmlidXRlLnZhbHVlcztcbiAgICAgIGlmIChlbnVtVHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gZW51bVR5cGUudmFsdWVzO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0eXBlID0gYEVOVU0oJHt2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gdGhpcy5lc2NhcGUodmFsdWUpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgICAgIHR5cGUgKz0gXCJbXVwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZXMgZm9yIEVOVU0gaGF2ZW4ndCBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcbiAgICB9XG4gICAgbGV0IHNxbCA9IHR5cGUudG9TdHJpbmcoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgXCJhbGxvd051bGxcIikgJiYgIWF0dHJpYnV0ZS5hbGxvd051bGwpIHtcbiAgICAgIHNxbCArPSBcIiBOT1QgTlVMTFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudElkZW50aXR5KSB7XG4gICAgICAgIHNxbCArPSBcIiBHRU5FUkFURUQgQlkgREVGQVVMVCBBUyBJREVOVElUWVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsICs9IFwiIFNFUklBTFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICBzcWwgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSwgYXR0cmlidXRlKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgc3FsICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHNxbCArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGxldCByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpO1xuICAgICAgbGV0IHNjaGVtYTtcbiAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkge1xuICAgICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYTtcbiAgICAgIH0gZWxzZSBpZiAoKCFhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCB8fCB0eXBlb2YgYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwgPT0gXCJzdHJpbmdcIikgJiYgb3B0aW9ucy50YWJsZSAmJiBvcHRpb25zLnRhYmxlLnNjaGVtYSkge1xuICAgICAgICBzY2hlbWEgPSBvcHRpb25zLnRhYmxlLnNjaGVtYTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgcmVmZXJlbmNlc1RhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgICAgICB0YWJsZU5hbWU6IHJlZmVyZW5jZXNUYWJsZSxcbiAgICAgICAgICBfc2NoZW1hOiBzY2hlbWFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgbGV0IHJlZmVyZW5jZXNLZXk7XG4gICAgICBpZiAoIW9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50cykge1xuICAgICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyhhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNxbCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VzVGFibGV9ICgke3JlZmVyZW5jZXNLZXl9KWA7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgICBzcWwgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgICBzcWwgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5kZWZlcnJhYmxlKSB7XG4gICAgICAgICAgc3FsICs9IGAgJHthdHRyaWJ1dGUucmVmZXJlbmNlcy5kZWZlcnJhYmxlLnRvU3RyaW5nKHRoaXMpfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50ICYmIHR5cGVvZiBhdHRyaWJ1dGUuY29tbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgW1wiYWRkQ29sdW1uXCIsIFwiY2hhbmdlQ29sdW1uXCJdLmluY2x1ZGVzKG9wdGlvbnMuY29udGV4dCkpIHtcbiAgICAgICAgY29uc3QgcXVvdGVkQXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMua2V5KTtcbiAgICAgICAgY29uc3QgZXNjYXBlZENvbW1lbnRUZXh0ID0gdGhpcy5lc2NhcGUoYXR0cmlidXRlLmNvbW1lbnQpO1xuICAgICAgICBzcWwgKz0gYDsgQ09NTUVOVCBPTiBDT0xVTU4gJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy50YWJsZSl9LiR7cXVvdGVkQXR0cn0gSVMgJHtlc2NhcGVkQ29tbWVudFRleHR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNxbCArPSBgIENPTU1FTlQgJHthdHRyaWJ1dGUuY29tbWVudH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIGRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZGVmZXJyYWJsZS50b1N0cmluZyh0aGlzKTtcbiAgfVxuICBzZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgdHlwZSkge1xuICAgIGxldCBjb2x1bW5GcmFnbWVudCA9IFwiQUxMXCI7XG4gICAgaWYgKGNvbHVtbnMpIHtcbiAgICAgIGNvbHVtbkZyYWdtZW50ID0gY29sdW1ucy5tYXAoKGNvbHVtbikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoY29sdW1uKSkuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYFNFVCBDT05TVFJBSU5UUyAke2NvbHVtbkZyYWdtZW50fSAke3R5cGV9YDtcbiAgfVxuICBzZXREZWZlcnJlZFF1ZXJ5KGNvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgXCJERUZFUlJFRFwiKTtcbiAgfVxuICBzZXRJbW1lZGlhdGVRdWVyeShjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Q29uc3RyYWludFF1ZXJ5KGNvbHVtbnMsIFwiSU1NRURJQVRFXCIpO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5maWVsZCB8fCBrZXldID0gdGhpcy5hdHRyaWJ1dGVUb1NRTChhdHRyaWJ1dGUsIF9fc3ByZWFkVmFsdWVzKHsga2V5IH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIGV2ZW50VHlwZSwgZmlyZU9uU3BlYywgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgb3B0aW9uc0FycmF5KSB7XG4gICAgY29uc3QgZGVjb2RlZEV2ZW50VHlwZSA9IHRoaXMuZGVjb2RlVHJpZ2dlckV2ZW50VHlwZShldmVudFR5cGUpO1xuICAgIGNvbnN0IGV2ZW50U3BlYyA9IHRoaXMuZXhwYW5kVHJpZ2dlckV2ZW50U3BlYyhmaXJlT25TcGVjKTtcbiAgICBjb25zdCBleHBhbmRlZE9wdGlvbnMgPSB0aGlzLmV4cGFuZE9wdGlvbnMob3B0aW9uc0FycmF5KTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChmdW5jdGlvblBhcmFtcyk7XG4gICAgcmV0dXJuIGBDUkVBVEUgJHt0aGlzLnRyaWdnZXJFdmVudFR5cGVJc0NvbnN0cmFpbnQoZXZlbnRUeXBlKX1UUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJpZ2dlck5hbWUpfSAke2RlY29kZWRFdmVudFR5cGV9ICR7ZXZlbnRTcGVjfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSR7ZXhwYW5kZWRPcHRpb25zID8gYCAke2V4cGFuZGVkT3B0aW9uc31gIDogXCJcIn0gRVhFQ1VURSBQUk9DRURVUkUgJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSk7YDtcbiAgfVxuICBkcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIFRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmlnZ2VyTmFtZSl9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFJFU1RSSUNUO2A7XG4gIH1cbiAgcmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSkge1xuICAgIHJldHVybiBgQUxURVIgVFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKG9sZFRyaWdnZXJOYW1lKX0gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIFRPICR7dGhpcy5xdW90ZUlkZW50aWZpZXIobmV3VHJpZ2dlck5hbWUpfTtgO1xuICB9XG4gIGNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKSB7XG4gICAgaWYgKCFmdW5jdGlvbk5hbWUgfHwgIXJldHVyblR5cGUgfHwgIWxhbmd1YWdlIHx8ICFib2R5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3JlYXRlRnVuY3Rpb24gbWlzc2luZyBzb21lIHBhcmFtZXRlcnMuIERpZCB5b3UgcGFzcyBmdW5jdGlvbk5hbWUsIHJldHVyblR5cGUsIGxhbmd1YWdlIGFuZCBib2R5P1wiKTtcbiAgICBjb25zdCBwYXJhbUxpc3QgPSB0aGlzLl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpO1xuICAgIGNvbnN0IHZhcmlhYmxlTGlzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy52YXJpYWJsZXMgPyB0aGlzLl9leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdChvcHRpb25zLnZhcmlhYmxlcykgOiBcIlwiO1xuICAgIGNvbnN0IGV4cGFuZGVkT3B0aW9uc0FycmF5ID0gdGhpcy5leHBhbmRPcHRpb25zKG9wdGlvbnNBcnJheSk7XG4gICAgY29uc3Qgc3RhdGVtZW50ID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlID8gXCJDUkVBVEUgT1IgUkVQTEFDRSBGVU5DVElPTlwiIDogXCJDUkVBVEUgRlVOQ1RJT05cIjtcbiAgICByZXR1cm4gYCR7c3RhdGVtZW50fSAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRVRVUk5TICR7cmV0dXJuVHlwZX0gQVMgJGZ1bmMkICR7dmFyaWFibGVMaXN0fSBCRUdJTiAke2JvZHl9IEVORDsgJGZ1bmMkIGxhbmd1YWdlICcke2xhbmd1YWdlfScke2V4cGFuZGVkT3B0aW9uc0FycmF5fTtgO1xuICB9XG4gIGRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcykge1xuICAgIGlmICghZnVuY3Rpb25OYW1lKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVxdWlyZXMgZnVuY3Rpb25OYW1lXCIpO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgcmV0dXJuIGBEUk9QIEZVTkNUSU9OICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFU1RSSUNUO2A7XG4gIH1cbiAgcmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSkge1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgcmV0dXJuIGBBTFRFUiBGVU5DVElPTiAke29sZEZ1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KSBSRU5BTUUgVE8gJHtuZXdGdW5jdGlvbk5hbWV9O2A7XG4gIH1cbiAgcGdFc2NhcGVBbmRRdW90ZSh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoVXRpbHMucmVtb3ZlVGlja3ModGhpcy5lc2NhcGUodmFsKSwgXCInXCIpKTtcbiAgfVxuICBfZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwIHx8ICFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9leHBhbmRGdW5jdGlvblBhcmFtTGlzdDogZnVuY3Rpb24gcGFyYW1ldGVycyBhcnJheSByZXF1aXJlZCwgaW5jbHVkaW5nIGFuIGVtcHR5IG9uZSBmb3Igbm8gYXJndW1lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbUxpc3QgPSBbXTtcbiAgICBwYXJhbXMuZm9yRWFjaCgoY3VyUGFyYW0pID0+IHtcbiAgICAgIGNvbnN0IHBhcmFtRGVmID0gW107XG4gICAgICBpZiAoY3VyUGFyYW0udHlwZSkge1xuICAgICAgICBpZiAoY3VyUGFyYW0uZGlyZWN0aW9uKSB7XG4gICAgICAgICAgcGFyYW1EZWYucHVzaChjdXJQYXJhbS5kaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJQYXJhbS5uYW1lKSB7XG4gICAgICAgICAgcGFyYW1EZWYucHVzaChjdXJQYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbURlZi5wdXNoKGN1clBhcmFtLnR5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gb3IgdHJpZ2dlciB1c2VkIHdpdGggYSBwYXJhbWV0ZXIgd2l0aG91dCBhbnkgdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZCA9IHBhcmFtRGVmLmpvaW4oXCIgXCIpO1xuICAgICAgaWYgKGpvaW5lZClcbiAgICAgICAgcGFyYW1MaXN0LnB1c2goam9pbmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1MaXN0LmpvaW4oXCIsIFwiKTtcbiAgfVxuICBfZXhwYW5kRnVuY3Rpb25WYXJpYWJsZUxpc3QodmFyaWFibGVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhcmlhYmxlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdDogZnVuY3Rpb24gdmFyaWFibGVzIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHZhcmlhYmxlRGVmaW5pdGlvbnMgPSBbXTtcbiAgICB2YXJpYWJsZXMuZm9yRWFjaCgodmFyaWFibGUpID0+IHtcbiAgICAgIGlmICghdmFyaWFibGUubmFtZSB8fCAhdmFyaWFibGUudHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiB2YXJpYWJsZSBtdXN0IGhhdmUgYSBuYW1lIGFuZCB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHZhcmlhYmxlRGVmaW5pdGlvbiA9IGBERUNMQVJFICR7dmFyaWFibGUubmFtZX0gJHt2YXJpYWJsZS50eXBlfWA7XG4gICAgICBpZiAodmFyaWFibGUuZGVmYXVsdCkge1xuICAgICAgICB2YXJpYWJsZURlZmluaXRpb24gKz0gYCA6PSAke3ZhcmlhYmxlLmRlZmF1bHR9YDtcbiAgICAgIH1cbiAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbiArPSBcIjtcIjtcbiAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbnMucHVzaCh2YXJpYWJsZURlZmluaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB2YXJpYWJsZURlZmluaXRpb25zLmpvaW4oXCIgXCIpO1xuICB9XG4gIGV4cGFuZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID09PSB2b2lkIDAgfHwgXy5pc0VtcHR5KG9wdGlvbnMpID8gXCJcIiA6IG9wdGlvbnMuam9pbihcIiBcIik7XG4gIH1cbiAgZGVjb2RlVHJpZ2dlckV2ZW50VHlwZShldmVudFNwZWNpZmllcikge1xuICAgIGNvbnN0IEVWRU5UX0RFQ09ERVIgPSB7XG4gICAgICBcImFmdGVyXCI6IFwiQUZURVJcIixcbiAgICAgIFwiYmVmb3JlXCI6IFwiQkVGT1JFXCIsXG4gICAgICBcImluc3RlYWRfb2ZcIjogXCJJTlNURUFEIE9GXCIsXG4gICAgICBcImFmdGVyX2NvbnN0cmFpbnRcIjogXCJBRlRFUlwiXG4gICAgfTtcbiAgICBpZiAoIUVWRU5UX0RFQ09ERVJbZXZlbnRTcGVjaWZpZXJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHJpZ2dlciBldmVudCBzcGVjaWZpZWQ6ICR7ZXZlbnRTcGVjaWZpZXJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBFVkVOVF9ERUNPREVSW2V2ZW50U3BlY2lmaWVyXTtcbiAgfVxuICB0cmlnZ2VyRXZlbnRUeXBlSXNDb25zdHJhaW50KGV2ZW50U3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIGV2ZW50U3BlY2lmaWVyID09PSBcImFmdGVyX2NvbnN0cmFpbnRcIiA/IFwiQ09OU1RSQUlOVCBcIiA6IFwiXCI7XG4gIH1cbiAgZXhwYW5kVHJpZ2dlckV2ZW50U3BlYyhmaXJlT25TcGVjKSB7XG4gICAgaWYgKF8uaXNFbXB0eShmaXJlT25TcGVjKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gdGFibGUgY2hhbmdlIGV2ZW50cyBzcGVjaWZpZWQgdG8gdHJpZ2dlciBvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF8ubWFwKGZpcmVPblNwZWMsIChmaXJlVmFsdWUsIGZpcmVLZXkpID0+IHtcbiAgICAgIGNvbnN0IEVWRU5UX01BUCA9IHtcbiAgICAgICAgXCJpbnNlcnRcIjogXCJJTlNFUlRcIixcbiAgICAgICAgXCJ1cGRhdGVcIjogXCJVUERBVEVcIixcbiAgICAgICAgXCJkZWxldGVcIjogXCJERUxFVEVcIixcbiAgICAgICAgXCJ0cnVuY2F0ZVwiOiBcIlRSVU5DQVRFXCJcbiAgICAgIH07XG4gICAgICBpZiAoIUVWRU5UX01BUFtmaXJlVmFsdWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyc2VUcmlnZ2VyRXZlbnRTcGVjOiB1bmRlZmluZWQgdHJpZ2dlciBldmVudCAke2ZpcmVLZXl9YCk7XG4gICAgICB9XG4gICAgICBsZXQgZXZlbnRTcGVjID0gRVZFTlRfTUFQW2ZpcmVWYWx1ZV07XG4gICAgICBpZiAoZXZlbnRTcGVjID09PSBcIlVQREFURVwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpcmVWYWx1ZSkgJiYgZmlyZVZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBldmVudFNwZWMgKz0gYCBPRiAke2ZpcmVWYWx1ZS5qb2luKFwiLCBcIil9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50U3BlYztcbiAgICB9KS5qb2luKFwiIE9SIFwiKTtcbiAgfVxuICBwZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0ciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHRhYmxlRGV0YWlscyA9IHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGxldCBlbnVtTmFtZSA9IFV0aWxzLmFkZFRpY2tzKFV0aWxzLmdlbmVyYXRlRW51bU5hbWUodGFibGVEZXRhaWxzLnRhYmxlTmFtZSwgYXR0ciksICdcIicpO1xuICAgIGlmIChvcHRpb25zLnNjaGVtYSAhPT0gZmFsc2UgJiYgdGFibGVEZXRhaWxzLnNjaGVtYSkge1xuICAgICAgZW51bU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZURldGFpbHMuc2NoZW1hKSArIHRhYmxlRGV0YWlscy5kZWxpbWl0ZXIgKyBlbnVtTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1OYW1lO1xuICB9XG4gIHBnTGlzdEVudW1zKHRhYmxlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgZW51bU5hbWUgPSBcIlwiO1xuICAgIGNvbnN0IHRhYmxlRGV0YWlscyA9IHRoaXMuZXh0cmFjdFRhYmxlRGV0YWlscyh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGlmICh0YWJsZURldGFpbHMudGFibGVOYW1lICYmIGF0dHJOYW1lKSB7XG4gICAgICBlbnVtTmFtZSA9IGAgQU5EIHQudHlwbmFtZT0ke3RoaXMucGdFbnVtTmFtZSh0YWJsZURldGFpbHMudGFibGVOYW1lLCBhdHRyTmFtZSwgeyBzY2hlbWE6IGZhbHNlIH0pLnJlcGxhY2UoL1wiL2csIFwiJ1wiKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYFNFTEVDVCB0LnR5cG5hbWUgZW51bV9uYW1lLCBhcnJheV9hZ2coZS5lbnVtbGFiZWwgT1JERVIgQlkgZW51bXNvcnRvcmRlcikgZW51bV92YWx1ZSBGUk9NIHBnX3R5cGUgdCBKT0lOIHBnX2VudW0gZSBPTiB0Lm9pZCA9IGUuZW51bXR5cGlkIEpPSU4gcGdfY2F0YWxvZy5wZ19uYW1lc3BhY2UgbiBPTiBuLm9pZCA9IHQudHlwbmFtZXNwYWNlIFdIRVJFIG4ubnNwbmFtZSA9ICcke3RhYmxlRGV0YWlscy5zY2hlbWF9JyR7ZW51bU5hbWV9IEdST1VQIEJZIDFgO1xuICB9XG4gIHBnRW51bSh0YWJsZU5hbWUsIGF0dHIsIGRhdGFUeXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyLCBvcHRpb25zKTtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGlmIChkYXRhVHlwZS52YWx1ZXMpIHtcbiAgICAgIHZhbHVlcyA9IGBFTlVNKCR7ZGF0YVR5cGUudmFsdWVzLm1hcCgodmFsdWUpID0+IHRoaXMuZXNjYXBlKHZhbHVlKSkuam9pbihcIiwgXCIpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBkYXRhVHlwZS50b1N0cmluZygpLm1hdGNoKC9eRU5VTVxcKC4rXFwpLylbMF07XG4gICAgfVxuICAgIGxldCBzcWwgPSBgRE8gJHt0aGlzLmVzY2FwZShgQkVHSU4gQ1JFQVRFIFRZUEUgJHtlbnVtTmFtZX0gQVMgJHt2YWx1ZXN9OyBFWENFUFRJT04gV0hFTiBkdXBsaWNhdGVfb2JqZWN0IFRIRU4gbnVsbDsgRU5EYCl9O2A7XG4gICAgaWYgKCEhb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlID09PSB0cnVlKSB7XG4gICAgICBzcWwgPSB0aGlzLnBnRW51bURyb3AodGFibGVOYW1lLCBhdHRyKSArIHNxbDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBwZ0VudW1BZGQodGFibGVOYW1lLCBhdHRyLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVudW1OYW1lID0gdGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cik7XG4gICAgbGV0IHNxbCA9IGBBTFRFUiBUWVBFICR7ZW51bU5hbWV9IEFERCBWQUxVRSBgO1xuICAgIGlmIChzZW12ZXIuZ3RlKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCBcIjkuMy4wXCIpKSB7XG4gICAgICBzcWwgKz0gXCJJRiBOT1QgRVhJU1RTIFwiO1xuICAgIH1cbiAgICBzcWwgKz0gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgIGlmIChvcHRpb25zLmJlZm9yZSkge1xuICAgICAgc3FsICs9IGAgQkVGT1JFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5iZWZvcmUpfWA7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmFmdGVyKSB7XG4gICAgICBzcWwgKz0gYCBBRlRFUiAke3RoaXMuZXNjYXBlKG9wdGlvbnMuYWZ0ZXIpfWA7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgcGdFbnVtRHJvcCh0YWJsZU5hbWUsIGF0dHIsIGVudW1OYW1lKSB7XG4gICAgZW51bU5hbWUgPSBlbnVtTmFtZSB8fCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKTtcbiAgICByZXR1cm4gYERST1AgVFlQRSBJRiBFWElTVFMgJHtlbnVtTmFtZX07IGA7XG4gIH1cbiAgZnJvbUFycmF5KHRleHQpIHtcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eey8sIFwiXCIpLnJlcGxhY2UoL30kLywgXCJcIik7XG4gICAgbGV0IG1hdGNoZXMgPSB0ZXh0Lm1hdGNoKC8oXCIoPzpcXFxcLnxbXlwiXFxcXFxcXFxdKSpcInxbXixdKikoPzpcXHMqLFxccyp8XFxzKiQpL2lnKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIG1hdGNoZXMgPSBtYXRjaGVzLm1hcCgobSkgPT4gbS5yZXBsYWNlKC9cIiwkLywgXCJcIikucmVwbGFjZSgvLCQvLCBcIlwiKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCJcIikpO1xuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKDAsIC0xKTtcbiAgfVxuICBkYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyLCBkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiU0VSSUFMXCIpKSB7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJCSUdJTlRcIikpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU0VSSUFMXCIsIFwiQklHU0VSSUFMXCIpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJCSUdJTlRcIiwgXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiU01BTExJTlRcIikpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU0VSSUFMXCIsIFwiU01BTExTRVJJQUxcIik7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNNQUxMSU5UXCIsIFwiXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiSU5URUdFUlwiLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUuc3RhcnRzV2l0aChcIkVOVU0oXCIpKSB7XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoL15FTlVNXFwoLitcXCkvLCB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhVHlwZTtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgU0VMRUNUIGNvbm5hbWUgYXMgY29uc3RyYWludF9uYW1lLCBwZ19jYXRhbG9nLnBnX2dldF9jb25zdHJhaW50ZGVmKHIub2lkLCB0cnVlKSBhcyBjb25kZWYgRlJPTSBwZ19jYXRhbG9nLnBnX2NvbnN0cmFpbnQgciBXSEVSRSByLmNvbnJlbGlkID0gKFNFTEVDVCBvaWQgRlJPTSBwZ19jbGFzcyBXSEVSRSByZWxuYW1lID0gJyR7dGFibGVOYW1lfScgTElNSVQgMSkgQU5EIHIuY29udHlwZSA9ICdmJyBPUkRFUiBCWSAxO2A7XG4gIH1cbiAgX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIERJU1RJTkNUIHRjLmNvbnN0cmFpbnRfbmFtZSBhcyBjb25zdHJhaW50X25hbWUsIHRjLmNvbnN0cmFpbnRfc2NoZW1hIGFzIGNvbnN0cmFpbnRfc2NoZW1hLCB0Yy5jb25zdHJhaW50X2NhdGFsb2cgYXMgY29uc3RyYWludF9jYXRhbG9nLCB0Yy50YWJsZV9uYW1lIGFzIHRhYmxlX25hbWUsdGMudGFibGVfc2NoZW1hIGFzIHRhYmxlX3NjaGVtYSx0Yy50YWJsZV9jYXRhbG9nIGFzIHRhYmxlX2NhdGFsb2csdGMuaW5pdGlhbGx5X2RlZmVycmVkIGFzIGluaXRpYWxseV9kZWZlcnJlZCx0Yy5pc19kZWZlcnJhYmxlIGFzIGlzX2RlZmVycmFibGUsa2N1LmNvbHVtbl9uYW1lIGFzIGNvbHVtbl9uYW1lLGNjdS50YWJsZV9zY2hlbWEgIEFTIHJlZmVyZW5jZWRfdGFibGVfc2NoZW1hLGNjdS50YWJsZV9jYXRhbG9nICBBUyByZWZlcmVuY2VkX3RhYmxlX2NhdGFsb2csY2N1LnRhYmxlX25hbWUgIEFTIHJlZmVyZW5jZWRfdGFibGVfbmFtZSxjY3UuY29sdW1uX25hbWUgQVMgcmVmZXJlbmNlZF9jb2x1bW5fbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZV9jb25zdHJhaW50cyBBUyB0YyBKT0lOIGluZm9ybWF0aW9uX3NjaGVtYS5rZXlfY29sdW1uX3VzYWdlIEFTIGtjdSBPTiB0Yy5jb25zdHJhaW50X25hbWUgPSBrY3UuY29uc3RyYWludF9uYW1lIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLmNvbnN0cmFpbnRfY29sdW1uX3VzYWdlIEFTIGNjdSBPTiBjY3UuY29uc3RyYWludF9uYW1lID0gdGMuY29uc3RyYWludF9uYW1lIFwiO1xuICB9XG4gIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnkodGFibGVOYW1lLCBjYXRhbG9nTmFtZSwgc2NoZW1hTmFtZSkge1xuICAgIHJldHVybiBgJHt0aGlzLl9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KCl9V0hFUkUgY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJyBBTkQgdGMudGFibGVfbmFtZSA9ICcke3RhYmxlTmFtZX0nJHtjYXRhbG9nTmFtZSA/IGAgQU5EIHRjLnRhYmxlX2NhdGFsb2cgPSAnJHtjYXRhbG9nTmFtZX0nYCA6IFwiXCJ9JHtzY2hlbWFOYW1lID8gYCBBTkQgdGMudGFibGVfc2NoZW1hID0gJyR7c2NoZW1hTmFtZX0nYCA6IFwiXCJ9YDtcbiAgfVxuICBnZXRGb3JlaWduS2V5UmVmZXJlbmNlUXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgIHJldHVybiBgJHt0aGlzLl9nZXRGb3JlaWduS2V5UmVmZXJlbmNlc1F1ZXJ5UHJlZml4KCl9V0hFUkUgY29uc3RyYWludF90eXBlID0gJ0ZPUkVJR04gS0VZJyBBTkQgdGMudGFibGVfbmFtZT0nJHt0YWJsZU5hbWV9JyBBTkQgIGtjdS5jb2x1bW5fbmFtZSA9ICcke2NvbHVtbk5hbWV9JyR7c2NoZW1hID8gYCBBTkQgdGMudGFibGVfc2NoZW1hID0gJyR7c2NoZW1hfSdgIDogXCJcIn1gO1xuICB9XG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBEUk9QIENPTlNUUkFJTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KX07YDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICBjb25zdCBvcHRGb3JjZVF1b3RlID0gZm9yY2UgfHwgZmFsc2U7XG4gICAgY29uc3Qgb3B0UXVvdGVJZGVudGlmaWVycyA9IHRoaXMub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzICE9PSBmYWxzZTtcbiAgICBjb25zdCByYXdJZGVudGlmaWVyID0gVXRpbHMucmVtb3ZlVGlja3MoaWRlbnRpZmllciwgJ1wiJyk7XG4gICAgaWYgKG9wdEZvcmNlUXVvdGUgPT09IHRydWUgfHwgb3B0UXVvdGVJZGVudGlmaWVycyAhPT0gZmFsc2UgfHwgaWRlbnRpZmllci5pbmNsdWRlcyhcIi5cIikgfHwgaWRlbnRpZmllci5pbmNsdWRlcyhcIi0+XCIpIHx8IFBPU1RHUkVTX1JFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHJhd0lkZW50aWZpZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhyYXdJZGVudGlmaWVyLCAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0lkZW50aWZpZXI7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUG9zdGdyZXNRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Deferrable = __webpack_require__(/*! ../../deferrable */ \"(rsc)/./node_modules/sequelize/lib/deferrable.js\");\nclass PostgresQueryInterface extends QueryInterface {\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = \"\";\n    let promises = [];\n    let i = 0;\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: true, raw: true, type: QueryTypes.SELECT })));\n      }\n    }\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n    const addEnumValue = (field, value, relativeValue, position = \"before\", spliceStart = promises.length) => {\n      const valueOptions = __spreadValues({}, options);\n      valueOptions.before = null;\n      valueOptions.after = null;\n      switch (position) {\n        case \"after\":\n          valueOptions.after = relativeValue;\n          break;\n        case \"before\":\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), { raw: true }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n            if (newIdx === -1) {\n              continue;\n            }\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, \"before\", promisesLength);\n            }\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, \"after\");\n            }\n          }\n          enumIdx++;\n        }\n      }\n    }\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database, table.schema);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map((fkMeta) => {\n      const _a = Utils.camelizeObjectKeys(fkMeta), { initiallyDeferred, isDeferrable } = _a, remaining = __objRest(_a, [\"initiallyDeferred\", \"isDeferrable\"]);\n      return __spreadProps(__spreadValues({}, remaining), {\n        deferrable: isDeferrable === \"NO\" ? Deferrable.NOT : initiallyDeferred === \"NO\" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED\n      });\n    });\n  }\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), { raw: true }));\n  }\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map((result) => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), { raw: true }))));\n  }\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: false, raw: true, type: QueryTypes.SELECT }));\n  }\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: \"tableName\" });\n    if (!instanceTable) {\n      return;\n    }\n    const getTableName = (!options || !options.schema || options.schema === \"public\" ? \"\" : `${options.schema}_`) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { raw: true })));\n      }\n    }\n    await Promise.all(promises);\n  }\n}\nexports.PostgresQueryInterface = PostgresQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjLGlEQUFpRDtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxjQUFjLFdBQVc7QUFDakssV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDO0FBQ3ZGLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkpBQTJKLGNBQWMsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJNQUEyTSxjQUFjLFdBQVc7QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyxrREFBa0Q7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxXQUFXO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1pbnRlcmZhY2UuanM/MjBhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBEZWZlcnJhYmxlID0gcmVxdWlyZShcIi4uLy4uL2RlZmVycmFibGVcIik7XG5jbGFzcyBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyBlbnN1cmVFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGtleUxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBzcWwgPSBcIlwiO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5c1tpXV07XG4gICAgICBjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNIHx8IHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkgJiYgdHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0xpc3RFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZS5maWVsZCB8fCBrZXlzW2ldLCBvcHRpb25zKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHBsYWluOiB0cnVlLCByYXc6IHRydWUsIHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNUIH0pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgcHJvbWlzZXMgPSBbXTtcbiAgICBsZXQgZW51bUlkeCA9IDA7XG4gICAgY29uc3QgYWRkRW51bVZhbHVlID0gKGZpZWxkLCB2YWx1ZSwgcmVsYXRpdmVWYWx1ZSwgcG9zaXRpb24gPSBcImJlZm9yZVwiLCBzcGxpY2VTdGFydCA9IHByb21pc2VzLmxlbmd0aCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWVPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgICAgdmFsdWVPcHRpb25zLmJlZm9yZSA9IG51bGw7XG4gICAgICB2YWx1ZU9wdGlvbnMuYWZ0ZXIgPSBudWxsO1xuICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwiYWZ0ZXJcIjpcbiAgICAgICAgICB2YWx1ZU9wdGlvbnMuYWZ0ZXIgPSByZWxhdGl2ZVZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYmVmb3JlXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWVPcHRpb25zLmJlZm9yZSA9IHJlbGF0aXZlVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwcm9taXNlcy5zcGxpY2Uoc3BsaWNlU3RhcnQsIDAsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtQWRkKHRhYmxlTmFtZSwgZmllbGQsIHZhbHVlLCB2YWx1ZU9wdGlvbnMpLCB2YWx1ZU9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5TGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5c1tpXV07XG4gICAgICBjb25zdCB0eXBlID0gYXR0cmlidXRlLnR5cGU7XG4gICAgICBjb25zdCBlbnVtVHlwZSA9IHR5cGUudHlwZSB8fCB0eXBlO1xuICAgICAgY29uc3QgZmllbGQgPSBhdHRyaWJ1dGUuZmllbGQgfHwga2V5c1tpXTtcbiAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHwgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiBlbnVtVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICAgIGlmICghcmVzdWx0c1tlbnVtSWR4XSkge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtKHRhYmxlTmFtZSwgZmllbGQsIGVudW1UeXBlLCBvcHRpb25zKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcmF3OiB0cnVlIH0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghIXJlc3VsdHNbZW51bUlkeF0gJiYgISFtb2RlbCkge1xuICAgICAgICAgIGNvbnN0IGVudW1WYWxzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocmVzdWx0c1tlbnVtSWR4XS5lbnVtX3ZhbHVlKTtcbiAgICAgICAgICBjb25zdCB2YWxzID0gZW51bVR5cGUudmFsdWVzO1xuICAgICAgICAgIGxldCBsYXN0T2xkRW51bVZhbHVlO1xuICAgICAgICAgIGxldCByaWdodGVzdFBvc2l0aW9uID0gLTE7XG4gICAgICAgICAgZm9yIChsZXQgb2xkSW5kZXggPSAwOyBvbGRJbmRleCA8IGVudW1WYWxzLmxlbmd0aDsgb2xkSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgZW51bVZhbCA9IGVudW1WYWxzW29sZEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0lkeCA9IHZhbHMuaW5kZXhPZihlbnVtVmFsKTtcbiAgICAgICAgICAgIGxhc3RPbGRFbnVtVmFsdWUgPSBlbnVtVmFsO1xuICAgICAgICAgICAgaWYgKG5ld0lkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZXNCZWZvcmUgPSB2YWxzLnNsaWNlKDAsIG5ld0lkeCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlc0xlbmd0aCA9IHByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IHJldmVyc2VJZHggPSBuZXdWYWx1ZXNCZWZvcmUubGVuZ3RoIC0gMTsgcmV2ZXJzZUlkeCA+PSAwOyByZXZlcnNlSWR4LS0pIHtcbiAgICAgICAgICAgICAgaWYgKH5lbnVtVmFscy5pbmRleE9mKG5ld1ZhbHVlc0JlZm9yZVtyZXZlcnNlSWR4XSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRFbnVtVmFsdWUoZmllbGQsIG5ld1ZhbHVlc0JlZm9yZVtyZXZlcnNlSWR4XSwgbGFzdE9sZEVudW1WYWx1ZSwgXCJiZWZvcmVcIiwgcHJvbWlzZXNMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld0lkeCA+IHJpZ2h0ZXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgcmlnaHRlc3RQb3NpdGlvbiA9IG5ld0lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxhc3RPbGRFbnVtVmFsdWUgJiYgcmlnaHRlc3RQb3NpdGlvbiA8IHZhbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRW51bVZhbHVlcyA9IHZhbHMuc2xpY2UocmlnaHRlc3RQb3NpdGlvbiArIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgcmV2ZXJzZUlkeCA9IHJlbWFpbmluZ0VudW1WYWx1ZXMubGVuZ3RoIC0gMTsgcmV2ZXJzZUlkeCA+PSAwOyByZXZlcnNlSWR4LS0pIHtcbiAgICAgICAgICAgICAgYWRkRW51bVZhbHVlKGZpZWxkLCByZW1haW5pbmdFbnVtVmFsdWVzW3JldmVyc2VJZHhdLCBsYXN0T2xkRW51bVZhbHVlLCBcImFmdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbnVtSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZXMucmVkdWNlKGFzeW5jIChwcm9taXNlLCBhc3luY0Z1bmN0aW9uKSA9PiBhd2FpdCBhc3luY0Z1bmN0aW9uKGF3YWl0IHByb21pc2UpLCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgaWYgKHByb21pc2VzLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5fcmVmcmVzaER5bmFtaWNPSURzKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTXG4gICAgfSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnkodGFibGUudGFibGVOYW1lIHx8IHRhYmxlLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UsIHRhYmxlLnNjaGVtYSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIHF1ZXJ5T3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAoKGZrTWV0YSkgPT4ge1xuICAgICAgY29uc3QgX2EgPSBVdGlscy5jYW1lbGl6ZU9iamVjdEtleXMoZmtNZXRhKSwgeyBpbml0aWFsbHlEZWZlcnJlZCwgaXNEZWZlcnJhYmxlIH0gPSBfYSwgcmVtYWluaW5nID0gX19vYmpSZXN0KF9hLCBbXCJpbml0aWFsbHlEZWZlcnJlZFwiLCBcImlzRGVmZXJyYWJsZVwiXSk7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVtYWluaW5nKSwge1xuICAgICAgICBkZWZlcnJhYmxlOiBpc0RlZmVycmFibGUgPT09IFwiTk9cIiA/IERlZmVycmFibGUuTk9UIDogaW5pdGlhbGx5RGVmZXJyZWQgPT09IFwiTk9cIiA/IERlZmVycmFibGUuSU5JVElBTExZX0lNTUVESUFURSA6IERlZmVycmFibGUuSU5JVElBTExZX0RFRkVSUkVEXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkcm9wRW51bShlbnVtTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AobnVsbCwgbnVsbCwgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VzY2FwZUFuZFF1b3RlKGVudW1OYW1lKSksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHJhdzogdHJ1ZSB9KSk7XG4gIH1cbiAgYXN5bmMgZHJvcEFsbEVudW1zKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBlbnVtcyA9IGF3YWl0IHRoaXMucGdMaXN0RW51bXMobnVsbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKGVudW1zLm1hcCgocmVzdWx0KSA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AobnVsbCwgbnVsbCwgdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VzY2FwZUFuZFF1b3RlKHJlc3VsdC5lbnVtX25hbWUpKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcmF3OiB0cnVlIH0pKSkpO1xuICB9XG4gIGFzeW5jIHBnTGlzdEVudW1zKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucGdMaXN0RW51bXModGFibGVOYW1lKTtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBwbGFpbjogZmFsc2UsIHJhdzogdHJ1ZSwgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QgfSkpO1xuICB9XG4gIGFzeW5jIGRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCBzdXBlci5kcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IGluc3RhbmNlVGFibGUgPSB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwodGFibGVOYW1lLCB7IGF0dHJpYnV0ZTogXCJ0YWJsZU5hbWVcIiB9KTtcbiAgICBpZiAoIWluc3RhbmNlVGFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2V0VGFibGVOYW1lID0gKCFvcHRpb25zIHx8ICFvcHRpb25zLnNjaGVtYSB8fCBvcHRpb25zLnNjaGVtYSA9PT0gXCJwdWJsaWNcIiA/IFwiXCIgOiBgJHtvcHRpb25zLnNjaGVtYX1fYCkgKyB0YWJsZU5hbWU7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGluc3RhbmNlVGFibGUucmF3QXR0cmlidXRlcyk7XG4gICAgY29uc3Qga2V5TGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgaWYgKGluc3RhbmNlVGFibGUucmF3QXR0cmlidXRlc1trZXlzW2ldXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1Ecm9wKGdldFRhYmxlTmFtZSwga2V5c1tpXSk7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydHNTZWFyY2hQYXRoID0gZmFsc2U7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyByYXc6IHRydWUgfSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG59XG5leHBvcnRzLlBvc3RncmVzUXVlcnlJbnRlcmZhY2UgPSBQb3N0Z3Jlc1F1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:pg\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const stringReplaceFunc = (value) => typeof value === \"string\" ? value.replace(/\\0/g, \"\\\\0\") : value;\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = values.map(stringReplaceFunc);\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = [];\n      let i = 0;\n      const seen = {};\n      const replacementFunc = (match, key, values2) => {\n        if (seen[key] !== void 0) {\n          return seen[key];\n        }\n        if (values2[key] !== void 0) {\n          i = i + 1;\n          bindParam.push(stringReplaceFunc(values2[key]));\n          seen[key] = `$${i}`;\n          return `$${i}`;\n        }\n        return void 0;\n      };\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n    return [sql, bindParam];\n  }\n  async run(sql, parameters) {\n    const { connection } = this;\n    if (!_.isEmpty(this.options.searchPath)) {\n      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {\n      _.toPairs(this.options.includeAliases).sort((a, b) => b[1].length - a[1].length).forEach(([alias, original]) => {\n        const reg = new RegExp(_.escapeRegExp(original), \"g\");\n        sql = sql.replace(reg, alias);\n      });\n    }\n    this.sql = sql;\n    const query = parameters && parameters.length ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result))) : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));\n    const complete = this._logQuery(sql, debug, parameters);\n    let queryResult;\n    const errForStack = new Error();\n    try {\n      queryResult = await query;\n    } catch (error) {\n      if (error.code === \"ECONNRESET\" || /Unable to set non-blocking to true/i.test(error) || /SSL SYSCALL error: EOF detected/i.test(error) || /Local: Authentication failure/i.test(error) || error.message === \"Query read timeout\") {\n        connection._invalid = true;\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    }\n    complete();\n    let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), []) : queryResult.rows;\n    const rowCount = Array.isArray(queryResult) ? queryResult.reduce((count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count, 0) : queryResult.rowCount || 0;\n    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {\n      rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n        const mapping = this.options.aliasesMapping.get(key);\n        acc[mapping || key] = value;\n        return acc;\n      }, {}));\n    }\n    const isTableNameQuery = sql.startsWith(\"SELECT table_name FROM information_schema.tables\");\n    const isRelNameQuery = sql.startsWith(\"SELECT relname FROM pg_class WHERE oid IN\");\n    if (isRelNameQuery) {\n      return rows.map((row) => ({\n        name: row.relname,\n        tableName: row.relname.split(\"_\")[0]\n      }));\n    }\n    if (isTableNameQuery) {\n      return rows.map((row) => Object.values(row));\n    }\n    if (rows[0] && rows[0].sequelize_caught_exception !== void 0) {\n      if (rows[0].sequelize_caught_exception !== null) {\n        throw this.formatError({\n          sql,\n          parameters,\n          code: \"23505\",\n          detail: rows[0].sequelize_caught_exception\n        });\n      }\n      for (const row of rows) {\n        delete row.sequelize_caught_exception;\n      }\n    }\n    if (this.isShowIndexesQuery()) {\n      for (const row of rows) {\n        const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(\",\");\n        const columns = _.zipObject(row.column_indexes, this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names));\n        delete row.column_indexes;\n        delete row.column_names;\n        let field;\n        let attribute;\n        row.fields = row.indkey.split(\" \").map((indKey, index) => {\n          field = columns[indKey];\n          if (!field) {\n            return null;\n          }\n          attribute = attributes[index];\n          return {\n            attribute: field,\n            collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : void 0,\n            order: attribute.includes(\"DESC\") ? \"DESC\" : attribute.includes(\"ASC\") ? \"ASC\" : void 0,\n            length: void 0\n          };\n        }).filter((n) => n !== null);\n        delete row.columns;\n      }\n      return rows;\n    }\n    if (this.isForeignKeysQuery()) {\n      const result = [];\n      for (const row of rows) {\n        let defParts;\n        if (row.condef !== void 0 && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n          row.id = row.constraint_name;\n          row.table = defParts[2];\n          row.from = defParts[1];\n          row.to = defParts[3];\n          let i;\n          for (i = 5; i <= 8; i += 3) {\n            if (/(UPDATE|DELETE)/.test(defParts[i])) {\n              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];\n            }\n          }\n        }\n        result.push(row);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      let result = rows;\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toLowerCase()] = k;\n          return m;\n        }, {});\n        result = rows.map((row) => {\n          return _.mapKeys(row, (value, key) => {\n            const targetAttr = attrsMap[key];\n            if (typeof targetAttr === \"string\" && targetAttr !== key) {\n              return targetAttr;\n            }\n            return key;\n          });\n        });\n      }\n      return this.handleSelectQuery(result);\n    }\n    if (QueryTypes.DESCRIBE === this.options.type) {\n      const result = {};\n      for (const row of rows) {\n        result[row.Field] = {\n          type: row.Type.toUpperCase(),\n          allowNull: row.Null === \"YES\",\n          defaultValue: row.Default,\n          comment: row.Comment,\n          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],\n          primaryKey: row.Constraint === \"PRIMARY KEY\"\n        };\n        if (result[row.Field].type === \"BOOLEAN\") {\n          result[row.Field].defaultValue = { \"false\": false, \"true\": true }[result[row.Field].defaultValue];\n          if (result[row.Field].defaultValue === void 0) {\n            result[row.Field].defaultValue = null;\n          }\n        }\n        if (typeof result[row.Field].defaultValue === \"string\") {\n          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, \"\");\n          if (result[row.Field].defaultValue.includes(\"::\")) {\n            const split = result[row.Field].defaultValue.split(\"::\");\n            if (split[1].toLowerCase() !== \"regclass)\") {\n              result[row.Field].defaultValue = split[0];\n            }\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return rows[0].server_version;\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return rows;\n    }\n    if (QueryTypes.BULKUPDATE === this.options.type) {\n      if (!this.options.returning) {\n        return parseInt(rowCount, 10);\n      }\n      return this.handleSelectQuery(rows);\n    }\n    if (QueryTypes.BULKDELETE === this.options.type) {\n      return parseInt(rowCount, 10);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {\n      if (this.instance && this.instance.dataValues) {\n        if (this.isInsertQuery() && !this.isUpsertQuery() && rowCount === 0) {\n          throw new sequelizeErrors.EmptyResultError();\n        }\n        for (const key in rows[0]) {\n          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n            const record = rows[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n      if (this.isUpsertQuery()) {\n        return [\n          this.instance,\n          null\n        ];\n      }\n      return [\n        this.instance || rows && (this.options.plain && rows[0] || rows) || void 0,\n        rowCount\n      ];\n    }\n    if (this.isRawQuery()) {\n      return [rows, queryResult];\n    }\n    return rows;\n  }\n  formatError(err, errStack) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n    switch (code) {\n      case \"23503\":\n        index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n        index = index ? index[1] : void 0;\n        table = errMessage.match(/on table \"(.+?)\"/);\n        table = table ? table[1] : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          message: errMessage,\n          fields: null,\n          index,\n          table,\n          parent: err,\n          stack: errStack\n        });\n      case \"23505\":\n        if (errDetail && (match = errDetail.replace(/\"/g, \"\").match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n          errors = [];\n          message = \"Validation error\";\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n          });\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, (constraint) => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n        }\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err,\n          stack: errStack\n        });\n      case \"23P01\":\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n        if (match) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n        }\n        message = \"Exclusion constraint error\";\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err,\n          stack: errStack\n        });\n      case \"42704\":\n        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n          message = \"Unknown constraint error\";\n          index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n          index = index ? index[1] : void 0;\n          table = errMessage.match(/relation \"(.+?)\"/i);\n          table = table ? table[1] : void 0;\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: index,\n            fields,\n            table,\n            parent: err,\n            stack: errStack\n          });\n        }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QjtBQUMvRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QixxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2REFBNkQsdURBQXVEO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx5UEFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LmpzP2ExOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOnBnXCIpO1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3Qgc3RyaW5nUmVwbGFjZUZ1bmMgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnJlcGxhY2UoL1xcMC9nLCBcIlxcXFwwXCIpIDogdmFsdWU7XG4gICAgbGV0IGJpbmRQYXJhbTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBiaW5kUGFyYW0gPSB2YWx1ZXMubWFwKHN0cmluZ1JlcGxhY2VGdW5jKTtcbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmluZFBhcmFtID0gW107XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCBzZWVuID0ge307XG4gICAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMikgPT4ge1xuICAgICAgICBpZiAoc2VlbltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gc2VlbltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgICBiaW5kUGFyYW0ucHVzaChzdHJpbmdSZXBsYWNlRnVuYyh2YWx1ZXMyW2tleV0pKTtcbiAgICAgICAgICBzZWVuW2tleV0gPSBgJCR7aX1gO1xuICAgICAgICAgIHJldHVybiBgJCR7aX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiB9ID0gdGhpcztcbiAgICBpZiAoIV8uaXNFbXB0eSh0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCkpIHtcbiAgICAgIHNxbCA9IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3Iuc2V0U2VhcmNoUGF0aCh0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCkgKyBzcWw7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgdGhpcy5vcHRpb25zLmluY2x1ZGVBbGlhc2VzKSB7XG4gICAgICBfLnRvUGFpcnModGhpcy5vcHRpb25zLmluY2x1ZGVBbGlhc2VzKS5zb3J0KChhLCBiKSA9PiBiWzFdLmxlbmd0aCAtIGFbMV0ubGVuZ3RoKS5mb3JFYWNoKChbYWxpYXMsIG9yaWdpbmFsXSkgPT4ge1xuICAgICAgICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKF8uZXNjYXBlUmVnRXhwKG9yaWdpbmFsKSwgXCJnXCIpO1xuICAgICAgICBzcWwgPSBzcWwucmVwbGFjZShyZWcsIGFsaWFzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCBxdWVyeSA9IHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycy5sZW5ndGggPyBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uZWN0aW9uLnF1ZXJ5KHNxbCwgcGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkpIDogbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gY29ubmVjdGlvbi5xdWVyeShzcWwsIChlcnJvciwgcmVzdWx0KSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKHJlc3VsdCkpKTtcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGxldCBxdWVyeVJlc3VsdDtcbiAgICBjb25zdCBlcnJGb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgIHRyeSB7XG4gICAgICBxdWVyeVJlc3VsdCA9IGF3YWl0IHF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFQ09OTlJFU0VUXCIgfHwgL1VuYWJsZSB0byBzZXQgbm9uLWJsb2NraW5nIHRvIHRydWUvaS50ZXN0KGVycm9yKSB8fCAvU1NMIFNZU0NBTEwgZXJyb3I6IEVPRiBkZXRlY3RlZC9pLnRlc3QoZXJyb3IpIHx8IC9Mb2NhbDogQXV0aGVudGljYXRpb24gZmFpbHVyZS9pLnRlc3QoZXJyb3IpIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiUXVlcnkgcmVhZCB0aW1lb3V0XCIpIHtcbiAgICAgICAgY29ubmVjdGlvbi5faW52YWxpZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IsIGVyckZvclN0YWNrLnN0YWNrKTtcbiAgICB9XG4gICAgY29tcGxldGUoKTtcbiAgICBsZXQgcm93cyA9IEFycmF5LmlzQXJyYXkocXVlcnlSZXN1bHQpID8gcXVlcnlSZXN1bHQucmVkdWNlKChhbGxSb3dzLCByKSA9PiBhbGxSb3dzLmNvbmNhdChyLnJvd3MgfHwgW10pLCBbXSkgOiBxdWVyeVJlc3VsdC5yb3dzO1xuICAgIGNvbnN0IHJvd0NvdW50ID0gQXJyYXkuaXNBcnJheShxdWVyeVJlc3VsdCkgPyBxdWVyeVJlc3VsdC5yZWR1Y2UoKGNvdW50LCByKSA9PiBOdW1iZXIuaXNGaW5pdGUoci5yb3dDb3VudCkgPyBjb3VudCArIHIucm93Q291bnQgOiBjb3VudCwgMCkgOiBxdWVyeVJlc3VsdC5yb3dDb3VudCB8fCAwO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgdGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nKSB7XG4gICAgICByb3dzID0gcm93cy5tYXAoKHJvdykgPT4gXy50b1BhaXJzKHJvdykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBtYXBwaW5nID0gdGhpcy5vcHRpb25zLmFsaWFzZXNNYXBwaW5nLmdldChrZXkpO1xuICAgICAgICBhY2NbbWFwcGluZyB8fCBrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSkpO1xuICAgIH1cbiAgICBjb25zdCBpc1RhYmxlTmFtZVF1ZXJ5ID0gc3FsLnN0YXJ0c1dpdGgoXCJTRUxFQ1QgdGFibGVfbmFtZSBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXNcIik7XG4gICAgY29uc3QgaXNSZWxOYW1lUXVlcnkgPSBzcWwuc3RhcnRzV2l0aChcIlNFTEVDVCByZWxuYW1lIEZST00gcGdfY2xhc3MgV0hFUkUgb2lkIElOXCIpO1xuICAgIGlmIChpc1JlbE5hbWVRdWVyeSkge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+ICh7XG4gICAgICAgIG5hbWU6IHJvdy5yZWxuYW1lLFxuICAgICAgICB0YWJsZU5hbWU6IHJvdy5yZWxuYW1lLnNwbGl0KFwiX1wiKVswXVxuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAoaXNUYWJsZU5hbWVRdWVyeSkge1xuICAgICAgcmV0dXJuIHJvd3MubWFwKChyb3cpID0+IE9iamVjdC52YWx1ZXMocm93KSk7XG4gICAgfVxuICAgIGlmIChyb3dzWzBdICYmIHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHJvd3NbMF0uc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcih7XG4gICAgICAgICAgc3FsLFxuICAgICAgICAgIHBhcmFtZXRlcnMsXG4gICAgICAgICAgY29kZTogXCIyMzUwNVwiLFxuICAgICAgICAgIGRldGFpbDogcm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgZGVsZXRlIHJvdy5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IC9PTiAuKj8gKD86VVNJTkcgLio/XFxzKT9cXCgoW15dKilcXCkvZ2kuZXhlYyhyb3cuZGVmaW5pdGlvbilbMV0uc3BsaXQoXCIsXCIpO1xuICAgICAgICBjb25zdCBjb2x1bW5zID0gXy56aXBPYmplY3Qocm93LmNvbHVtbl9pbmRleGVzLCB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyb3cuY29sdW1uX25hbWVzKSk7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1uX2luZGV4ZXM7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1uX25hbWVzO1xuICAgICAgICBsZXQgZmllbGQ7XG4gICAgICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgICAgIHJvdy5maWVsZHMgPSByb3cuaW5ka2V5LnNwbGl0KFwiIFwiKS5tYXAoKGluZEtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBmaWVsZCA9IGNvbHVtbnNbaW5kS2V5XTtcbiAgICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogZmllbGQsXG4gICAgICAgICAgICBjb2xsYXRlOiBhdHRyaWJ1dGUubWF0Y2goL0NPTExBVEUgXCIoLio/KVwiLykgPyAvQ09MTEFURSBcIiguKj8pXCIvLmV4ZWMoYXR0cmlidXRlKVsxXSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG9yZGVyOiBhdHRyaWJ1dGUuaW5jbHVkZXMoXCJERVNDXCIpID8gXCJERVNDXCIgOiBhdHRyaWJ1dGUuaW5jbHVkZXMoXCJBU0NcIikgPyBcIkFTQ1wiIDogdm9pZCAwLFxuICAgICAgICAgICAgbGVuZ3RoOiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpO1xuICAgICAgICBkZWxldGUgcm93LmNvbHVtbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBsZXQgZGVmUGFydHM7XG4gICAgICAgIGlmIChyb3cuY29uZGVmICE9PSB2b2lkIDAgJiYgKGRlZlBhcnRzID0gcm93LmNvbmRlZi5tYXRjaCgvRk9SRUlHTiBLRVkgXFwoKC4rKVxcKSBSRUZFUkVOQ0VTICguKylcXCgoLispXFwpKCBPTiAoVVBEQVRFfERFTEVURSkgKENBU0NBREV8UkVTVFJJQ1QpKT8oIE9OIChVUERBVEV8REVMRVRFKSAoQ0FTQ0FERXxSRVNUUklDVCkpPy8pKSkge1xuICAgICAgICAgIHJvdy5pZCA9IHJvdy5jb25zdHJhaW50X25hbWU7XG4gICAgICAgICAgcm93LnRhYmxlID0gZGVmUGFydHNbMl07XG4gICAgICAgICAgcm93LmZyb20gPSBkZWZQYXJ0c1sxXTtcbiAgICAgICAgICByb3cudG8gPSBkZWZQYXJ0c1szXTtcbiAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICBmb3IgKGkgPSA1OyBpIDw9IDg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKC8oVVBEQVRFfERFTEVURSkvLnRlc3QoZGVmUGFydHNbaV0pKSB7XG4gICAgICAgICAgICAgIHJvd1tgb25fJHtkZWZQYXJ0c1tpXS50b0xvd2VyQ2FzZSgpfWBdID0gZGVmUGFydHNbaSArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcm93cztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmF3ID09PSBmYWxzZSAmJiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzTWFwID0gXy5yZWR1Y2UodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAobSwgdiwgaykgPT4ge1xuICAgICAgICAgIG1bay50b0xvd2VyQ2FzZSgpXSA9IGs7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmVzdWx0ID0gcm93cy5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIHJldHVybiBfLm1hcEtleXMocm93LCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXR0ciA9IGF0dHJzTWFwW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldEF0dHIgPT09IFwic3RyaW5nXCIgJiYgdGFyZ2V0QXR0ciAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRBdHRyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5ERVNDUklCRSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICByZXN1bHRbcm93LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiByb3cuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogcm93Lk51bGwgPT09IFwiWUVTXCIsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiByb3cuRGVmYXVsdCxcbiAgICAgICAgICBjb21tZW50OiByb3cuQ29tbWVudCxcbiAgICAgICAgICBzcGVjaWFsOiByb3cuc3BlY2lhbCA/IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJvdy5zcGVjaWFsKSA6IFtdLFxuICAgICAgICAgIHByaW1hcnlLZXk6IHJvdy5Db25zdHJhaW50ID09PSBcIlBSSU1BUlkgS0VZXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLnR5cGUgPT09IFwiQk9PTEVBTlwiKSB7XG4gICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0geyBcImZhbHNlXCI6IGZhbHNlLCBcInRydWVcIjogdHJ1ZSB9W3Jlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZV07XG4gICAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgICAgIGlmIChyZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUuaW5jbHVkZXMoXCI6OlwiKSkge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUuc3BsaXQoXCI6OlwiKTtcbiAgICAgICAgICAgIGlmIChzcGxpdFsxXS50b0xvd2VyQ2FzZSgpICE9PSBcInJlZ2NsYXNzKVwiKSB7XG4gICAgICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IHNwbGl0WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJvd3NbMF0uc2VydmVyX3ZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd09yRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9XG4gICAgaWYgKFF1ZXJ5VHlwZXMuQlVMS1VQREFURSA9PT0gdGhpcy5vcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJldHVybmluZykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocm93Q291bnQsIDEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJvd3MpO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5CVUxLREVMRVRFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHJvd0NvdW50LCAxMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSAmJiAhdGhpcy5pc1Vwc2VydFF1ZXJ5KCkgJiYgcm93Q291bnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVtcHR5UmVzdWx0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByb3dzWzBdKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyb3dzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSByb3dzWzBdW2tleV07XG4gICAgICAgICAgICBjb25zdCBhdHRyID0gXy5maW5kKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyICYmIGF0dHIuZmllbGROYW1lIHx8IGtleV0gPSByZWNvcmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmluc3RhbmNlLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgfHwgcm93cyAmJiAodGhpcy5vcHRpb25zLnBsYWluICYmIHJvd3NbMF0gfHwgcm93cykgfHwgdm9pZCAwLFxuICAgICAgICByb3dDb3VudFxuICAgICAgXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jvd3MsIHF1ZXJ5UmVzdWx0XTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykge1xuICAgIGxldCBtYXRjaDtcbiAgICBsZXQgdGFibGU7XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBmaWVsZHM7XG4gICAgbGV0IGVycm9ycztcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBjb25zdCBjb2RlID0gZXJyLmNvZGUgfHwgZXJyLnNxbFN0YXRlO1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnIubWVzc2FnZSB8fCBlcnIubWVzc2FnZVByaW1hcnk7XG4gICAgY29uc3QgZXJyRGV0YWlsID0gZXJyLmRldGFpbCB8fCBlcnIubWVzc2FnZURldGFpbDtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgXCIyMzUwM1wiOlxuICAgICAgICBpbmRleCA9IGVyck1lc3NhZ2UubWF0Y2goL3Zpb2xhdGVzIGZvcmVpZ24ga2V5IGNvbnN0cmFpbnQgXCIoLis/KVwiLyk7XG4gICAgICAgIGluZGV4ID0gaW5kZXggPyBpbmRleFsxXSA6IHZvaWQgMDtcbiAgICAgICAgdGFibGUgPSBlcnJNZXNzYWdlLm1hdGNoKC9vbiB0YWJsZSBcIiguKz8pXCIvKTtcbiAgICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJNZXNzYWdlLFxuICAgICAgICAgIGZpZWxkczogbnVsbCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiMjM1MDVcIjpcbiAgICAgICAgaWYgKGVyckRldGFpbCAmJiAobWF0Y2ggPSBlcnJEZXRhaWwucmVwbGFjZSgvXCIvZywgXCJcIikubWF0Y2goL0tleSBcXCgoLio/KVxcKT1cXCgoLio/KVxcKS8pKSkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KG1hdGNoWzFdLnNwbGl0KFwiLCBcIiksIG1hdGNoWzJdLnNwbGl0KFwiLCBcIikpO1xuICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICAgIG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgXy5mb3JPd24odGhpcy5tb2RlbC51bmlxdWVLZXlzLCAoY29uc3RyYWludCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoXy5pc0VxdWFsKGNvbnN0cmFpbnQuZmllbGRzLCBPYmplY3Qua2V5cyhmaWVsZHMpKSAmJiAhIWNvbnN0cmFpbnQubXNnKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGNvbnN0cmFpbnQubXNnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiMjNQMDFcIjpcbiAgICAgICAgbWF0Y2ggPSBlcnJEZXRhaWwubWF0Y2goL0tleSBcXCgoLio/KVxcKT1cXCgoLio/KVxcKS8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdChtYXRjaFsxXS5zcGxpdChcIiwgXCIpLCBtYXRjaFsyXS5zcGxpdChcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlID0gXCJFeGNsdXNpb24gY29uc3RyYWludCBlcnJvclwiO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5FeGNsdXNpb25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgY29uc3RyYWludDogZXJyLmNvbnN0cmFpbnQsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHRhYmxlOiBlcnIudGFibGUsXG4gICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIjQyNzA0XCI6XG4gICAgICAgIGlmIChlcnIuc3FsICYmIC8oQ09OU1RSQUlOVHxJTkRFWCkvZ2kudGVzdChlcnIuc3FsKSkge1xuICAgICAgICAgIG1lc3NhZ2UgPSBcIlVua25vd24gY29uc3RyYWludCBlcnJvclwiO1xuICAgICAgICAgIGluZGV4ID0gZXJyTWVzc2FnZS5tYXRjaCgvKD86Y29uc3RyYWludHxpbmRleCkgXCIoLis/KVwiL2kpO1xuICAgICAgICAgIGluZGV4ID0gaW5kZXggPyBpbmRleFsxXSA6IHZvaWQgMDtcbiAgICAgICAgICB0YWJsZSA9IGVyck1lc3NhZ2UubWF0Y2goL3JlbGF0aW9uIFwiKC4rPylcIi9pKTtcbiAgICAgICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB2b2lkIDA7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBpbmRleCxcbiAgICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgfVxuICBpc0ZvcmVpZ25LZXlzUXVlcnkoKSB7XG4gICAgcmV0dXJuIC9TRUxFQ1QgY29ubmFtZSBhcyBjb25zdHJhaW50X25hbWUsIHBnX2NhdGFsb2dcXC5wZ19nZXRfY29uc3RyYWludGRlZlxcKHJcXC5vaWQsIHRydWVcXCkgYXMgY29uZGVmIEZST00gcGdfY2F0YWxvZ1xcLnBnX2NvbnN0cmFpbnQgciBXSEVSRSByXFwuY29ucmVsaWQgPSBcXChTRUxFQ1Qgb2lkIEZST00gcGdfY2xhc3MgV0hFUkUgcmVsbmFtZSA9ICcuKicgTElNSVQgMVxcKSBBTkQgclxcLmNvbnR5cGUgPSAnZicgT1JERVIgQlkgMTsvLnRlc3QodGhpcy5zcWwpO1xuICB9XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwiaWRcIjtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n  return parseType(bound);\n}\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  if (!Array.isArray(data))\n    throw new Error(\"range must be an array\");\n  if (!data.length)\n    return \"empty\";\n  if (data.length !== 2)\n    throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false)\n      data.inclusive = [false, false];\n    else if (!data.inclusive)\n      data.inclusive = [true, false];\n    else if (data.inclusive === true)\n      data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\"))\n        data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\"))\n        data[index] = value.value;\n    }\n  });\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\nexports.stringify = stringify;\nfunction parse(value, parser) {\n  if (value === null)\n    return null;\n  if (value === \"empty\") {\n    return [];\n  }\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2)\n    return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\nexports.parse = parse;\n//# sourceMappingURL=range.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9yYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksNkNBQTZDLEdBQUcsV0FBVyxFQUFFLDhCQUE4QjtBQUN2RztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9yYW5nZS5qcz9lMDVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5mdW5jdGlvbiBzdHJpbmdpZnlSYW5nZUJvdW5kKGJvdW5kKSB7XG4gIGlmIChib3VuZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGlmIChib3VuZCA9PT0gSW5maW5pdHkgfHwgYm91bmQgPT09IC1JbmZpbml0eSkge1xuICAgIHJldHVybiBib3VuZC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvdW5kKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmFuZ2VCb3VuZChib3VuZCwgcGFyc2VUeXBlKSB7XG4gIGlmICghYm91bmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoYm91bmQgPT09IFwiaW5maW5pdHlcIikge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuICBpZiAoYm91bmQgPT09IFwiLWluZmluaXR5XCIpIHtcbiAgICByZXR1cm4gLUluZmluaXR5O1xuICB9XG4gIHJldHVybiBwYXJzZVR5cGUoYm91bmQpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5nZSBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgIHJldHVybiBcImVtcHR5XCI7XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5nZSBhcnJheSBsZW5ndGggbXVzdCBiZSAwIChlbXB0eSkgb3IgMiAobG93ZXIgYW5kIHVwcGVyIGJvdW5kcylcIik7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJpbmNsdXNpdmVcIikpIHtcbiAgICBpZiAoZGF0YS5pbmNsdXNpdmUgPT09IGZhbHNlKVxuICAgICAgZGF0YS5pbmNsdXNpdmUgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBlbHNlIGlmICghZGF0YS5pbmNsdXNpdmUpXG4gICAgICBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCBmYWxzZV07XG4gICAgZWxzZSBpZiAoZGF0YS5pbmNsdXNpdmUgPT09IHRydWUpXG4gICAgICBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCB0cnVlXTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLmluY2x1c2l2ZSA9IFt0cnVlLCBmYWxzZV07XG4gIH1cbiAgXy5lYWNoKGRhdGEsICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwiaW5jbHVzaXZlXCIpKVxuICAgICAgICBkYXRhLmluY2x1c2l2ZVtpbmRleF0gPSAhIXZhbHVlLmluY2x1c2l2ZTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwidmFsdWVcIikpXG4gICAgICAgIGRhdGFbaW5kZXhdID0gdmFsdWUudmFsdWU7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbG93ZXJCb3VuZCA9IHN0cmluZ2lmeVJhbmdlQm91bmQoZGF0YVswXSk7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBzdHJpbmdpZnlSYW5nZUJvdW5kKGRhdGFbMV0pO1xuICByZXR1cm4gYCR7KGRhdGEuaW5jbHVzaXZlWzBdID8gXCJbXCIgOiBcIihcIikgKyBsb3dlckJvdW5kfSwke3VwcGVyQm91bmR9JHtkYXRhLmluY2x1c2l2ZVsxXSA/IFwiXVwiIDogXCIpXCJ9YDtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gcGFyc2UodmFsdWUsIHBhcnNlcikge1xuICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmICh2YWx1ZSA9PT0gXCJlbXB0eVwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCByZXN1bHQgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSkuc3BsaXQoXCIsXCIsIDIpO1xuICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMilcbiAgICByZXR1cm4gdmFsdWU7XG4gIHJlc3VsdCA9IHJlc3VsdC5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBwYXJzZVJhbmdlQm91bmQoaXRlbSwgcGFyc2VyKSxcbiAgICAgIGluY2x1c2l2ZTogaW5kZXggPT09IDAgPyB2YWx1ZVswXSA9PT0gXCJbXCIgOiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gXCJdXCJcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJhbmdlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").snowflake);\nconst debug = logger.debugContext(\"connection:snowflake\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"snowflake\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      connection.destroy((err) => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n  validate(connection) {\n    return connection.isUp();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQyxrQkFBa0IsMkdBQXFDO0FBQ3ZEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBLFVBQVU7QUFDViwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzE2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLnNub3dmbGFrZTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246c25vd2ZsYWtlXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJzbm93Zmxha2VcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJzbm93Zmxha2Utc2RrXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGFjY291bnQ6IGNvbmZpZy5ob3N0LFxuICAgICAgdXNlcm5hbWU6IGNvbmZpZy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQsXG4gICAgICBkYXRhYmFzZTogY29uZmlnLmRhdGFiYXNlLFxuICAgICAgd2FyZWhvdXNlOiBjb25maWcud2FyZWhvdXNlLFxuICAgICAgcm9sZTogY29uZmlnLnJvbGVcbiAgICB9LCBjb25maWcuZGlhbGVjdE9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmxpYi5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpLmNvbm5lY3QoKGVyciwgY29ubikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjb25uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICAgIGNvbnN0IHR6T2Zmc2V0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSA9PT0gXCIrMDA6MDBcIiA/IFwiRXRjL1VUQ1wiIDogdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZTtcbiAgICAgICAgY29uc3QgaXNOYW1lZFR6T2Zmc2V0ID0gL1xcLy8udGVzdCh0ek9mZnNldCk7XG4gICAgICAgIGlmIChpc05hbWVkVHpPZmZzZXQpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmV4ZWN1dGUoe1xuICAgICAgICAgICAgICBzcWxUZXh0OiBgQUxURVIgU0VTU0lPTiBTRVQgdGltZXpvbmUgPSAnJHt0ek9mZnNldH0nYCxcbiAgICAgICAgICAgICAgY29tcGxldGUoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIm9ubHkgc3VwcG9ydCB0aW1lIHpvbmUgbmFtZSBmb3Igc25vd2ZsYWtlIVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJFQ09OTlJFRlVTRURcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVSX0FDQ0VTU19ERU5JRURfRVJST1JcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFTk9URk9VTkRcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSE9TVFVOUkVBQ0hcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUlOVkFMXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKCFjb25uZWN0aW9uLmlzVXAoKSkge1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIHRyaWVkIHRvIGRpc2Nvbm5lY3QgYnV0IHdhcyBhbHJlYWR5IGF0IENMT1NFRCBzdGF0ZVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbm5lY3Rpb24uZGVzdHJveSgoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmFibGUgdG8gZGlzY29ubmVjdDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGlzY29ubmVjdGVkIGNvbm5lY3Rpb24gd2l0aCBpZDogJHtjb25uZWN0aW9uLmdldElkKCl9YCk7XG4gICAgICAgICAgcmVzb2x2ZShjb25uZWN0aW9uLmdldElkKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24uaXNVcCgpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/data-types.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.snowflake.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.snowflake = [\"DATETIME\"];\n  BaseTypes.STRING.types.snowflake = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.snowflake = [\"STRING\"];\n  BaseTypes.TEXT.types.snowflake = [\"BLOB\"];\n  BaseTypes.TINYINT.types.snowflake = [\"TINY\"];\n  BaseTypes.SMALLINT.types.snowflake = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.snowflake = [\"INT24\"];\n  BaseTypes.INTEGER.types.snowflake = [\"LONG\"];\n  BaseTypes.BIGINT.types.snowflake = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.snowflake = [\"FLOAT\"];\n  BaseTypes.TIME.types.snowflake = [\"TIME\"];\n  BaseTypes.DATEONLY.types.snowflake = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.snowflake = [\"TINY\"];\n  BaseTypes.BLOB.types.snowflake = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.snowflake = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.snowflake = false;\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.snowflake = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.snowflake = [\"JSON\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR(36)\";\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCLE9BQU8sRUFBRSxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL2RhdGEtdHlwZXMuanM/YTIyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgQmFzZVR5cGVzLkFCU1RSQUNULnByb3RvdHlwZS5kaWFsZWN0VHlwZXMgPSBcImh0dHBzOi8vZGV2LnNub3dmbGFrZS5jb20vZG9jL3JlZm1hbi81LjcvZW4vZGF0YS10eXBlcy5odG1sXCI7XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLnNub3dmbGFrZSA9IFtcIkRBVEVUSU1FXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLnNub3dmbGFrZSA9IFtcIlZBUl9TVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLnNub3dmbGFrZSA9IFtcIlNUUklOR1wiXTtcbiAgQmFzZVR5cGVzLlRFWFQudHlwZXMuc25vd2ZsYWtlID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMuc25vd2ZsYWtlID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLnNub3dmbGFrZSA9IFtcIlNIT1JUXCJdO1xuICBCYXNlVHlwZXMuTUVESVVNSU5ULnR5cGVzLnNub3dmbGFrZSA9IFtcIklOVDI0XCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5zbm93Zmxha2UgPSBbXCJMT05HXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLnNub3dmbGFrZSA9IFtcIkxPTkdMT05HXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMuc25vd2ZsYWtlID0gW1wiRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLnNub3dmbGFrZSA9IFtcIlRJTUVcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5zbm93Zmxha2UgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5zbm93Zmxha2UgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5zbm93Zmxha2UgPSBbXCJUSU5ZQkxPQlwiLCBcIkJMT0JcIiwgXCJMT05HQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMuc25vd2ZsYWtlID0gW1wiTkVXREVDSU1BTFwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMuc25vd2ZsYWtlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLnNub3dmbGFrZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5zbm93Zmxha2UgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMuc25vd2ZsYWtlID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMuc25vd2ZsYWtlID0gW1wiR0VPTUVUUllcIl07XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLnNub3dmbGFrZSA9IFtcIkpTT05cIl07XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJUSU1FU1RBTVBcIjtcbiAgICB9XG4gICAgX3N0cmluZ2lmeShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgICBkYXRlID0gdGhpcy5fYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1NcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1vbWVudFR6LnR6LnpvbmUob3B0aW9ucy50aW1lem9uZSkpIHtcbiAgICAgICAgdmFsdWUgPSBtb21lbnRUei50eih2YWx1ZSwgb3B0aW9ucy50aW1lem9uZSkudG9EYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKGAke3ZhbHVlfSAke29wdGlvbnMudGltZXpvbmV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zdHJpbmcoKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVVVJRCBleHRlbmRzIEJhc2VUeXBlcy5VVUlEIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlZBUkNIQVIoMzYpXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJURVhUXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCT09MRUFOXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9wZXJhdGlvbiA9PT0gXCJ3aGVyZVwiICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIFRFWFQsXG4gICAgREFURSxcbiAgICBCT09MRUFOLFxuICAgIERBVEVPTkxZLFxuICAgIFVVSUQsXG4gICAgSlNPTjogSlNPTlRZUEVcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").snowflake);\nconst { SnowflakeQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js\");\nclass SnowflakeDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SnowflakeQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSnowflakeDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: false\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: false,\n  JSON: false,\n  REGEXP: true,\n  schemas: true\n});\nSnowflakeDialect.prototype.defaultVersion = \"5.7.0\";\nSnowflakeDialect.prototype.Query = Query;\nSnowflakeDialect.prototype.QueryGenerator = QueryGenerator;\nSnowflakeDialect.prototype.DataTypes = DataTypes;\nSnowflakeDialect.prototype.name = \"snowflake\";\nSnowflakeDialect.prototype.TICK_CHAR = '\"';\nSnowflakeDialect.prototype.TICK_CHAR_LEFT = SnowflakeDialect.prototype.TICK_CHAR;\nSnowflakeDialect.prototype.TICK_CHAR_RIGHT = SnowflakeDialect.prototype.TICK_CHAR;\nmodule.exports = SnowflakeDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMseUdBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDbEQsa0JBQWtCLDJHQUFxQztBQUN2RCxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsbUdBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvaW5kZXguanM/YjZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5zbm93Zmxha2U7XG5jb25zdCB7IFNub3dmbGFrZVF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBTbm93Zmxha2VEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgU25vd2ZsYWtlUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiVkFMVUVTICgpXCI6IHRydWUsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGZvclNoYXJlOiBcIkxPQ0sgSU4gU0hBUkUgTU9ERVwiLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogZmFsc2UsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiBcIiBJR05PUkVcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogZmFsc2VcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcGFyc2VyOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IDFcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2UsXG4gICAgY2hlY2s6IGZhbHNlXG4gIH0sXG4gIGluZGV4VmlhQWx0ZXI6IHRydWUsXG4gIGluZGV4SGludHM6IHRydWUsXG4gIE5VTUVSSUM6IHRydWUsXG4gIEdFT01FVFJZOiBmYWxzZSxcbiAgSlNPTjogZmFsc2UsXG4gIFJFR0VYUDogdHJ1ZSxcbiAgc2NoZW1hczogdHJ1ZVxufSk7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiNS43LjBcIjtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5RdWVyeUdlbmVyYXRvciA9IFF1ZXJ5R2VuZXJhdG9yO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwic25vd2ZsYWtlXCI7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBTbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBTbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IFNub3dmbGFrZURpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query-generator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\",\n      \";\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      `AND TABLE_SCHEMA = ${schema !== void 0 ? this.escape(schema) : \"CURRENT_SCHEMA()\"}`,\n      `AND TABLE_NAME = ${this.escape(tableName)}`,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"ALTER COLUMN\",\n      ...subQuerys,\n      \";\"\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n      sql.push(attrSql.join(\"\"));\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"RENAME COLUMN\",\n      attrString.join(\" to \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (attr.path) {\n        let str;\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"TRUNCATE\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\n        \"DELETE FROM\",\n        table,\n        \"WHERE\",\n        primaryKeys,\n        \"IN (SELECT\",\n        primaryKeysSelection,\n        \"FROM\",\n        table,\n        whereClause,\n        limit,\n        \")\",\n        \";\"\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"DELETE FROM\",\n      table,\n      whereClause,\n      \";\"\n    ]);\n  }\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName),\n      \";\"\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n    return fragment.join(\"\");\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDLDhDQUE4QyxJQUFJLGtCQUFrQixJQUFJO0FBQ3hFLHdEQUF3RCxFQUFFO0FBQzFELDBEQUEwRCxFQUFFLHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLG9DQUFvQztBQUM1RjtBQUNBLFVBQVU7QUFDViwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwwQ0FBMEMsaUNBQWlDLEdBQUcsc0VBQXNFO0FBQ3BKO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLElBQUksa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQiwyRUFBMkUsNkJBQTZCO0FBQ3hHLDRDQUE0QyxnQkFBZ0I7QUFDNUQsb0NBQW9DLGdCQUFnQjtBQUNwRCx5Q0FBeUMsa0JBQWtCO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUE2RDtBQUN6RiwwQkFBMEIsdUJBQXVCO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RyxvREFBb0Q7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxLQUFLLFNBQVMsSUFBSSxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0IsR0FBRyxTQUFTO0FBQzdFLHdDQUF3QyxRQUFRLGVBQWUsU0FBUztBQUN4RTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSx5QkFBeUIsK0NBQStDO0FBQ3hFLFFBQVE7QUFDUix5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRiwrREFBK0QsV0FBVztBQUMxRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHlEQUF5RCxpQkFBaUI7QUFDMUUsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDhDQUE4QyxpQkFBaUI7QUFDL0QsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9xdWVyeS1nZW5lcmF0b3IuanM/OTBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgSlNPTl9GVU5DVElPTl9SRUdFWCA9IC9eXFxzKigoPzpbYS16XStfKXswLDJ9anNvbmI/KD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuY29uc3QgSlNPTl9PUEVSQVRPUl9SRUdFWCA9IC9eXFxzKigtPj4/fEA+fDxAfFxcP1t8Jl0/fFxcfHsyfXwjLSkvaTtcbmNvbnN0IFRPS0VOX0NBUFRVUkVfUkVHRVggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcbmNvbnN0IEZPUkVJR05fS0VZX0ZJRUxEUyA9IFtcbiAgXCJDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludF9uYW1lXCIsXG4gIFwiQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnROYW1lXCIsXG4gIFwiQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludFNjaGVtYVwiLFxuICBcIkNPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRDYXRhbG9nXCIsXG4gIFwiVEFCTEVfTkFNRSBhcyB0YWJsZU5hbWVcIixcbiAgXCJUQUJMRV9TQ0hFTUEgYXMgdGFibGVTY2hlbWFcIixcbiAgXCJUQUJMRV9TQ0hFTUEgYXMgdGFibGVDYXRhbG9nXCIsXG4gIFwiQ09MVU1OX05BTUUgYXMgY29sdW1uTmFtZVwiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZVNjaGVtYVwiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2dcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX05BTUUgYXMgcmVmZXJlbmNlZFRhYmxlTmFtZVwiLFxuICBcIlJFRkVSRU5DRURfQ09MVU1OX05BTUUgYXMgcmVmZXJlbmNlZENvbHVtbk5hbWVcIlxuXS5qb2luKFwiLFwiKTtcbmNvbnN0IFNOT1dGTEFLRV9SRVNFUlZFRF9XT1JEUyA9IFwiYWNjb3VudCxhbGwsYWx0ZXIsYW5kLGFueSxhcyxiZXR3ZWVuLGJ5LGNhc2UsY2FzdCxjaGVjayxjb2x1bW4sY29ubmVjdCxjb25uZWN0aW9ucyxjb25zdHJhaW50LGNyZWF0ZSxjcm9zcyxjdXJyZW50LGN1cnJlbnRfZGF0ZSxjdXJyZW50X3RpbWUsY3VycmVudF90aW1lc3RhbXAsY3VycmVudF91c2VyLGRhdGFiYXNlLGRlbGV0ZSxkaXN0aW5jdCxkcm9wLGVsc2UsZXhpc3RzLGZhbHNlLGZvbGxvd2luZyxmb3IsZnJvbSxmdWxsLGdyYW50LGdyb3VwLGdzY2x1c3RlcixoYXZpbmcsaWxpa2UsaW4saW5jcmVtZW50LGlubmVyLGluc2VydCxpbnRlcnNlY3QsaW50byxpcyxpc3N1ZSxqb2luLGxhdGVyYWwsbGVmdCxsaWtlLGxvY2FsdGltZSxsb2NhbHRpbWVzdGFtcCxtaW51cyxuYXR1cmFsLG5vdCxudWxsLG9mLG9uLG9yLG9yZGVyLG9yZ2FuaXphdGlvbixxdWFsaWZ5LHJlZ2V4cCxyZXZva2UscmlnaHQscmxpa2Uscm93LHJvd3Msc2FtcGxlLHNjaGVtYSxzZWxlY3Qsc2V0LHNvbWUsc3RhcnQsdGFibGUsdGFibGVzYW1wbGUsdGhlbix0byx0cmlnZ2VyLHRydWUsdHJ5X2Nhc3QsdW5pb24sdW5pcXVlLHVwZGF0ZSx1c2luZyx2YWx1ZXMsdmlldyx3aGVuLHdoZW5ldmVyLHdoZXJlLHdpdGhcIi5zcGxpdChcIixcIik7XG5jb25zdCB0eXBlV2l0aG91dERlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJCTE9CXCIsIFwiVEVYVFwiLCBcIkdFT01FVFJZXCIsIFwiSlNPTlwiXSk7XG5jbGFzcyBTbm93Zmxha2VRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5PcGVyYXRvck1hcCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuT3BlcmF0b3JNYXApLCB7XG4gICAgICBbT3AucmVnZXhwXTogXCJSRUdFWFBcIixcbiAgICAgIFtPcC5ub3RSZWdleHBdOiBcIk5PVCBSRUdFWFBcIlxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZURhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGNoYXJzZXQ6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJDUkVBVEUgREFUQUJBU0UgSUYgTk9UIEVYSVNUU1wiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKSxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSQUNURVIgU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jaGFyc2V0KX1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBERUZBVUxUIENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBEQVRBQkFTRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpfTtgO1xuICB9XG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gXCJTSE9XIFRBQkxFU1wiO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0hPVyBUQUJMRVNcIjtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIENVUlJFTlRfVkVSU0lPTigpXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIHJvd0Zvcm1hdDogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW107XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSB7fTtcbiAgICBjb25zdCBhdHRyU3RyID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgYXR0cmlidXRlc0NsYXVzZSA9IGF0dHJTdHIuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKFwiX1wiKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFVOSVFVRSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9ICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1wiLFxuICAgICAgdGFibGUsXG4gICAgICBgKCR7YXR0cmlidXRlc0NsYXVzZX0pYCxcbiAgICAgIG9wdGlvbnMuY29tbWVudCAmJiB0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSBcInN0cmluZ1wiICYmIGBDT01NRU5UICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb21tZW50KX1gLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJTRVQ9JHtvcHRpb25zLmNoYXJzZXR9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgQ09MTEFURSAke29wdGlvbnMuY29sbGF0ZX1gLFxuICAgICAgb3B0aW9ucy5yb3dGb3JtYXQgJiYgYFJPV19GT1JNQVQ9JHtvcHRpb25zLnJvd0Zvcm1hdH1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcikge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlclxuICAgIH0pKTtcbiAgICByZXR1cm4gYFNIT1cgRlVMTCBDT0xVTU5TIEZST00gJHt0YWJsZX07YDtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoZGF0YWJhc2UpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBUQUJMRV9OQU1FIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnXCIsXG4gICAgICBkYXRhYmFzZSA/IGBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShkYXRhYmFzZSl9YCA6IFwiQU5EIFRBQkxFX1NDSEVNQSBOT1QgSU4gKCAnSU5GT1JNQVRJT05fU0NIRU1BJywgJ1BFUkZPUk1BTkNFX1NDSEVNQScsICdTWVMnKVwiLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYSA9IHRhYmxlLnNjaGVtYTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVCBUQUJMRV9OQU1FIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnXCIsXG4gICAgICBgQU5EIFRBQkxFX1NDSEVNQSA9ICR7c2NoZW1hICE9PSB2b2lkIDAgPyB0aGlzLmVzY2FwZShzY2hlbWEpIDogXCJDVVJSRU5UX1NDSEVNQSgpXCJ9YCxcbiAgICAgIGBBTkQgVEFCTEVfTkFNRSA9ICR7dGhpcy5lc2NhcGUodGFibGVOYW1lKX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIkFERFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgY29udGV4dDogXCJhZGRDb2x1bW5cIixcbiAgICAgICAgdGFibGVOYW1lOiB0YWJsZSxcbiAgICAgICAgZm9yZWlnbktleToga2V5XG4gICAgICB9KSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1BcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBjaGFuZ2VDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdWVyeSA9ICguLi5zdWJRdWVyeXMpID0+IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkFMVEVSIENPTFVNTlwiLFxuICAgICAgLi4uc3ViUXVlcnlzLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgICBjb25zdCBzcWwgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgY29uc3QgYXR0clNxbCA9IFtdO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJOT1QgTlVMTFwiKSkge1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkodGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiU0VUIE5PVCBOVUxMXCIpKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeSh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCJEUk9QIE5PVCBOVUxMXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiREVGQVVMVFwiKSkge1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkodGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiU0VUIERFRkFVTFRcIiwgZGVmaW5pdGlvbi5tYXRjaCgvREVGQVVMVCAoW147XSspLylbMV0pKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvKERFRkFVTFRbXjtdKykvLCBcIlwiKS50cmltKCk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkodGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiRFJPUCBERUZBVUxUXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9VTklRVUU7KiQvKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC9VTklRVUU7KiQvLCBcIlwiKTtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KFwiQUREIFVOSVFVRSAoXCIsIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIilcIikucmVwbGFjZShcIkFMVEVSIENPTFVNTlwiLCBcIlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKTtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KFwiQUREIEZPUkVJR04gS0VZIChcIiwgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiKVwiLCBkZWZpbml0aW9uKS5yZXBsYWNlKFwiQUxURVIgQ09MVU1OXCIsIFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeSh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCJUWVBFXCIsIGRlZmluaXRpb24pKTtcbiAgICAgIH1cbiAgICAgIHNxbC5wdXNoKGF0dHJTcWwuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBzcWwuam9pbihcIlwiKTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICBhdHRyU3RyaW5nLnB1c2goYCcke2F0dHJCZWZvcmV9JyAnJHthdHRyTmFtZX0nICR7ZGVmaW5pdGlvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIlJFTkFNRSBDT0xVTU5cIixcbiAgICAgIGF0dHJTdHJpbmcuam9pbihcIiB0byBcIiksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIGlmIChhdHRyLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3QoYXR0ci5jb25kaXRpb25zKS5tYXAoKGNvbmRpdGlvbikgPT4gYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHIucGF0aCkge1xuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoYXR0ci5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IGF0dHIucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKGF0dHIucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KFwiID0gJXNcIiwgdGhpcy5lc2NhcGUoYXR0ci52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKC90aW1lc3RhbXAvaS50ZXN0KGF0dHIudHlwZSkpIHtcbiAgICAgICAgYXR0ci50eXBlID0gXCJkYXRldGltZVwiO1xuICAgICAgfSBlbHNlIGlmIChhdHRyLmpzb24gJiYgL2Jvb2xlYW4vaS50ZXN0KGF0dHIudHlwZSkpIHtcbiAgICAgICAgYXR0ci50eXBlID0gXCJjaGFyXCI7XG4gICAgICB9IGVsc2UgaWYgKC9kb3VibGUgcHJlY2lzaW9uL2kudGVzdChhdHRyLnR5cGUpIHx8IC9ib29sZWFuL2kudGVzdChhdHRyLnR5cGUpIHx8IC9pbnRlZ2VyL2kudGVzdChhdHRyLnR5cGUpKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IFwiZGVjaW1hbFwiO1xuICAgICAgfSBlbHNlIGlmICgvdGV4dC9pLnRlc3QoYXR0ci50eXBlKSkge1xuICAgICAgICBhdHRyLnR5cGUgPSBcImNoYXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlRSVU5DQVRFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKVxuICAgIF0pO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0ICYmIGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX1gO1xuICAgIGxldCBwcmltYXJ5S2V5cyA9IFwiXCI7XG4gICAgbGV0IHByaW1hcnlLZXlzU2VsZWN0aW9uID0gXCJcIjtcbiAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYFdIRVJFICR7d2hlcmVDbGF1c2V9YDtcbiAgICB9XG4gICAgaWYgKGxpbWl0KSB7XG4gICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBMSU1JVCBkZWxldGUgd2l0aG91dCBhIG1vZGVsLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBrcyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrLmZpZWxkKSkuam9pbihcIixcIik7XG4gICAgICBwcmltYXJ5S2V5cyA9IG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCA+IDEgPyBgKCR7cGtzfSlgIDogcGtzO1xuICAgICAgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSBwa3M7XG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgIFwiREVMRVRFIEZST01cIixcbiAgICAgICAgdGFibGUsXG4gICAgICAgIFwiV0hFUkVcIixcbiAgICAgICAgcHJpbWFyeUtleXMsXG4gICAgICAgIFwiSU4gKFNFTEVDVFwiLFxuICAgICAgICBwcmltYXJ5S2V5c1NlbGVjdGlvbixcbiAgICAgICAgXCJGUk9NXCIsXG4gICAgICAgIHRhYmxlLFxuICAgICAgICB3aGVyZUNsYXVzZSxcbiAgICAgICAgbGltaXQsXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBcIjtcIlxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiREVMRVRFIEZST01cIixcbiAgICAgIHRhYmxlLFxuICAgICAgd2hlcmVDbGF1c2UsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUICcnIEZST00gRFVBTFwiO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIENPTlNUUkFJTlRfQ0FUQUxPRyBBUyBjb25zdHJhaW50Q2F0YWxvZyxcIixcbiAgICAgIFwiQ09OU1RSQUlOVF9OQU1FIEFTIGNvbnN0cmFpbnROYW1lLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX1NDSEVNQSBBUyBjb25zdHJhaW50U2NoZW1hLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX1RZUEUgQVMgY29uc3RyYWludFR5cGUsXCIsXG4gICAgICBcIlRBQkxFX05BTUUgQVMgdGFibGVOYW1lLFwiLFxuICAgICAgXCJUQUJMRV9TQ0hFTUEgQVMgdGFibGVTY2hlbWFcIixcbiAgICAgIFwiZnJvbSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFNcIixcbiAgICAgIGBXSEVSRSB0YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nYCxcbiAgICAgIGNvbnN0cmFpbnROYW1lICYmIGBBTkQgY29uc3RyYWludF9uYW1lID0gJyR7Y29uc3RyYWludE5hbWV9J2AsXG4gICAgICBzY2hlbWFOYW1lICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJEUk9QIElOREVYXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpLFxuICAgICAgXCJPTlwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmcgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZyh7IGVzY2FwZTogdGhpcy5lc2NhcGUuYmluZCh0aGlzKSB9KTtcbiAgICBsZXQgdGVtcGxhdGUgPSBhdHRyaWJ1dGVTdHJpbmc7XG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIEFVVE9JTkNSRU1FTlRcIjtcbiAgICB9XG4gICAgaWYgKCF0eXBlV2l0aG91dERlZmF1bHQuaGFzKGF0dHJpYnV0ZVN0cmluZykgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5jb21tZW50KX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmZpcnN0KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBGSVJTVFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmFmdGVyKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIEFGVEVSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmFmdGVyKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gXCJhZGRDb2x1bW5cIiAmJiBvcHRpb25zLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmZvcmVpZ25LZXkpO1xuICAgICAgICBjb25zdCBma05hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihgJHtvcHRpb25zLnRhYmxlTmFtZX1fJHthdHRyTmFtZX1fZm9yZWlnbl9pZHhgKTtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCwgQUREIENPTlNUUkFJTlQgJHtma05hbWV9IEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSlgO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGUgKz0gYCBSRUZFUkVOQ0VTICR7dGhpcy5xdW90ZVRhYmxlKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsKX1gO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSl9KWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgICgke3RoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIil9KWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uRGVsZXRlKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gREVMRVRFICR7YXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25VcGRhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBVUERBVEUgJHthdHRyaWJ1dGUub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBKU09OX0ZVTkNUSU9OX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKFwiKFwiKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBKU09OX09QRVJBVE9SX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChvcGVyYXRvck1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IG9wZXJhdG9yTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gVE9LRU5fQ0FQVFVSRV9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAodG9rZW5NYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkVG9rZW4gPSB0b2tlbk1hdGNoZXNbMV07XG4gICAgICAgIGlmIChjYXB0dXJlZFRva2VuID09PSBcIihcIikge1xuICAgICAgICAgIG9wZW5pbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgICAgY2xvc2luZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCI7XCIpIHtcbiAgICAgICAgICBoYXNJbnZhbGlkVG9rZW4gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSB0b2tlbk1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIChoYXNJbnZhbGlkVG9rZW4gfHwgb3BlbmluZ0JyYWNrZXRzICE9PSBjbG9zaW5nQnJhY2tldHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuICBkYXRhVHlwZU1hcHBpbmcodGFibGVOYW1lLCBhdHRyLCBkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiU0VSSUFMXCIpKSB7XG4gICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJCSUdJTlRcIikpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU0VSSUFMXCIsIFwiQklHU0VSSUFMXCIpO1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJCSUdJTlRcIiwgXCJcIik7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiU01BTExJTlRcIikpIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU0VSSUFMXCIsIFwiU01BTExTRVJJQUxcIik7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlNNQUxMSU5UXCIsIFwiXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiSU5URUdFUlwiLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVR5cGU7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZSwgc2NoZW1hTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgYEZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0Ugd2hlcmUgVEFCTEVfTkFNRSA9ICcke3RhYmxlTmFtZX0nYCxcbiAgICAgIGBBTkQgQ09OU1RSQUlOVF9OQU1FIT0nUFJJTUFSWScgQU5EIENPTlNUUkFJTlRfU0NIRU1BPScke3NjaGVtYU5hbWV9J2AsXG4gICAgICBcIkFORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTExcIixcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgcXVvdGVkU2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSA/IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpIDogXCJcIjtcbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICBjb25zdCBxdW90ZWRDb2x1bW5OYW1lID0gd3JhcFNpbmdsZVF1b3RlKGNvbHVtbk5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICBcIkZST00gSU5GT1JNQVRJT05fU0NIRU1BLktFWV9DT0xVTU5fVVNBR0VcIixcbiAgICAgIFwiV0hFUkUgKFwiLFxuICAgICAgW1xuICAgICAgICBgUkVGRVJFTkNFRF9UQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBSRUZFUkVOQ0VEX0NPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWBcbiAgICAgIF0sXG4gICAgICBcIikgT1IgKFwiLFxuICAgICAgW1xuICAgICAgICBgVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFRBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIENPTFVNTl9OQU1FID0gJHtxdW90ZWRDb2x1bW5OYW1lfWAsXG4gICAgICAgIFwiQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTFwiXG4gICAgICBdLFxuICAgICAgXCIpXCJcbiAgICBdKTtcbiAgfVxuICBkcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QIEZPUkVJR04gS0VZXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9IFtdO1xuICAgIGlmIChvcHRpb25zLm9mZnNldCAhPT0gbnVsbCAmJiBvcHRpb25zLm9mZnNldCAhPT0gdm9pZCAwICYmIG9wdGlvbnMub2Zmc2V0ICE9PSAwKSB7XG4gICAgICBmcmFnbWVudCA9IGZyYWdtZW50LmNvbmNhdChbXCIgTElNSVQgXCIsIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpLCBcIiBPRkZTRVQgXCIsIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KV0pO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5saW1pdCAhPT0gbnVsbCAmJiBvcHRpb25zLmxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIGZyYWdtZW50ID0gW1wiIExJTUlUIFwiLCB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KV07XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudC5qb2luKFwiXCIpO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIGNvbnN0IG9wdEZvcmNlUXVvdGUgPSBmb3JjZSB8fCBmYWxzZTtcbiAgICBjb25zdCBvcHRRdW90ZUlkZW50aWZpZXJzID0gdGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHJhd0lkZW50aWZpZXIgPSBVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKTtcbiAgICBpZiAob3B0Rm9yY2VRdW90ZSA9PT0gdHJ1ZSB8fCBvcHRRdW90ZUlkZW50aWZpZXJzICE9PSBmYWxzZSB8fCBpZGVudGlmaWVyLmluY2x1ZGVzKFwiLlwiKSB8fCBpZGVudGlmaWVyLmluY2x1ZGVzKFwiLT5cIikgfHwgU05PV0ZMQUtFX1JFU0VSVkVEX1dPUkRTLmluY2x1ZGVzKHJhd0lkZW50aWZpZXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhyYXdJZGVudGlmaWVyLCAnXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0lkZW50aWZpZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIHJldHVybiBVdGlscy5hZGRUaWNrcyhpZGVudGlmaWVyLCBcIidcIik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNub3dmbGFrZVF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query-interface.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass SnowflakeQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.SnowflakeQueryInterface = SnowflakeQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDLFdBQVc7QUFDaEQ7QUFDQSwwS0FBMEssV0FBVztBQUNyTDtBQUNBLHFIQUFxSCxXQUFXO0FBQ2hJO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUZBQXVGO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixXQUFXLFdBQVc7QUFDckU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9xdWVyeS1pbnRlcmZhY2UuanM/MWViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY2xhc3MgU25vd2ZsYWtlUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICB9LCBjb2x1bW5OYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCAmJiByZXN1bHRzWzBdLmNvbnN0cmFpbnRfbmFtZSAhPT0gXCJQUklNQVJZXCIpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHMubWFwKChjb25zdHJhaW50KSA9PiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50LmNvbnN0cmFpbnRfbmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGNvbHVtbk5hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5pbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgbW9kZWwucmF3QXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUudGFibGVOYW1lID8gdGFibGVOYW1lIDoge1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2VcbiAgICB9LCBjb25zdHJhaW50TmFtZSk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiB0aGlzLnNlcXVlbGl6ZS5RdWVyeVR5cGVzLlNIT1dDT05TVFJBSU5UU1xuICAgIH0pKTtcbiAgICBjb25zdCBjb25zdHJhaW50ID0gY29uc3RyYWludHNbMF07XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICghY29uc3RyYWludCB8fCAhY29uc3RyYWludC5jb25zdHJhaW50VHlwZSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYENvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gb24gdGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludE5hbWUsXG4gICAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludC5jb25zdHJhaW50VHlwZSA9PT0gXCJGT1JFSUdOIEtFWVwiKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUluZGV4UXVlcnkoY29uc3RyYWludC50YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICB9XG59XG5leHBvcnRzLlNub3dmbGFrZVF1ZXJ5SW50ZXJmYWNlID0gU25vd2ZsYWtlUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:snowflake\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (_match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    try {\n      results = await new Promise((resolve, reject) => {\n        connection.execute({\n          sqlText: sql,\n          binds: parameters,\n          complete(err, _stmt, rows) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(rows);\n            }\n          }\n        });\n      });\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const sfAttrMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toUpperCase()] = k;\n          return m;\n        }, {});\n        data = data.map((data2) => _.reduce(data2, (prev, value, key) => {\n          if (value !== void 0 && sfAttrMap[key]) {\n            prev[sfAttrMap[key]] = value;\n            delete prev[key];\n          }\n          return prev;\n        }, data2));\n      }\n      this.options.fieldMap = _.mapKeys(this.options.fieldMap, (v, k) => {\n        return k.toUpperCase();\n      });\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data[0][\"number of rows updated\"];\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `Snowflake Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRSwwQkFBMEIscUVBQXFFO0FBQy9GO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRCxzQ0FBc0M7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLEtBQUssVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL3F1ZXJ5LmpzPzA3ODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBFUl9EVVBfRU5UUlkgPSAxMDYyO1xuY29uc3QgRVJfREVBRExPQ0sgPSAxMjEzO1xuY29uc3QgRVJfUk9XX0lTX1JFRkVSRU5DRUQgPSAxNDUxO1xuY29uc3QgRVJfTk9fUkVGRVJFTkNFRF9ST1cgPSAxNDUyO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOnNub3dmbGFrZVwiKTtcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IFtdO1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChfbWF0Y2gsIGtleSwgdmFsdWVzXykgPT4ge1xuICAgICAgaWYgKHZhbHVlc19ba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGJpbmRQYXJhbS5wdXNoKHZhbHVlc19ba2V5XSk7XG4gICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW0ubGVuZ3RoID4gMCA/IGJpbmRQYXJhbSA6IHZvaWQgMF07XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnNob3dXYXJuaW5ncyB8fCBvcHRpb25zLnNob3dXYXJuaW5ncztcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBkZWJ1ZyhcInBhcmFtZXRlcnMoJWopXCIsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cztcbiAgICB0cnkge1xuICAgICAgcmVzdWx0cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29ubmVjdGlvbi5leGVjdXRlKHtcbiAgICAgICAgICBzcWxUZXh0OiBzcWwsXG4gICAgICAgICAgYmluZHM6IHBhcmFtZXRlcnMsXG4gICAgICAgICAgY29tcGxldGUoZXJyLCBfc3RtdCwgcm93cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBlcnJvci5lcnJubyA9PT0gRVJfREVBRExPQ0spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvcHRpb25zLnRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yXykge1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgPSBcInJvbGxiYWNrXCI7XG4gICAgICB9XG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgICBpZiAoc2hvd1dhcm5pbmdzICYmIHJlc3VsdHMgJiYgcmVzdWx0cy53YXJuaW5nU3RhdHVzID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dXYXJuaW5ncyhyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHRzKTtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICB0aGlzLmhhbmRsZUluc2VydFF1ZXJ5KGRhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIGlmIChkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiUmVzdWx0U2V0SGVhZGVyXCIgJiYgdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgZGF0YS5hZmZlY3RlZFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBbdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGRdOiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmF3ID09PSBmYWxzZSAmJiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHNmQXR0ck1hcCA9IF8ucmVkdWNlKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgKG0sIHYsIGspID0+IHtcbiAgICAgICAgICBtW2sudG9VcHBlckNhc2UoKV0gPSBrO1xuICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGRhdGEgPSBkYXRhLm1hcCgoZGF0YTIpID0+IF8ucmVkdWNlKGRhdGEyLCAocHJldiwgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwICYmIHNmQXR0ck1hcFtrZXldKSB7XG4gICAgICAgICAgICBwcmV2W3NmQXR0ck1hcFtrZXldXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGVsZXRlIHByZXZba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIGRhdGEyKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMuZmllbGRNYXAgPSBfLm1hcEtleXModGhpcy5vcHRpb25zLmZpZWxkTWFwLCAodiwgaykgPT4ge1xuICAgICAgICByZXR1cm4gay50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICByZXN1bHRbX3Jlc3VsdC5GaWVsZF0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lk51bGwgPT09IFwiWUVTXCIsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXkgPT09IFwiUFJJXCIsXG4gICAgICAgICAgYXV0b0luY3JlbWVudDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9yZXN1bHQsIFwiRXh0cmFcIikgJiYgX3Jlc3VsdC5FeHRyYS50b0xvd2VyQ2FzZSgpID09PSBcImF1dG9faW5jcmVtZW50XCIsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50ID8gX3Jlc3VsdC5Db21tZW50IDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF1bXCJudW1iZXIgb2Ygcm93cyB1cGRhdGVkXCJdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzID09PSAxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbZGF0YSwgZGF0YV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbG9nV2FybmluZ3MocmVzdWx0cykge1xuICAgIGNvbnN0IHdhcm5pbmdSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW4oXCJTSE9XIFdBUk5JTkdTXCIpO1xuICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYFNub3dmbGFrZSBXYXJuaW5ncyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiBgO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBfd2FybmluZ1JvdyBvZiB3YXJuaW5nUmVzdWx0cykge1xuICAgICAgaWYgKF93YXJuaW5nUm93ID09PSB2b2lkIDAgfHwgdHlwZW9mIF93YXJuaW5nUm93W1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX3dhcm5pbmdSZXN1bHQgb2YgX3dhcm5pbmdSb3cpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfd2FybmluZ1Jlc3VsdCwgXCJNZXNzYWdlXCIpKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChfd2FybmluZ1Jlc3VsdC5NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IF9vYmplY3RLZXkgb2YgX3dhcm5pbmdSZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFtfb2JqZWN0S2V5LCBfd2FybmluZ1Jlc3VsdFtfb2JqZWN0S2V5XV0uam9pbihcIjogXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXF1ZWxpemUubG9nKHdhcm5pbmdNZXNzYWdlICsgbWVzc2FnZXMuam9pbihcIjsgXCIpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGZvcm1hdEVycm9yKGVycikge1xuICAgIGNvbnN0IGVyckNvZGUgPSBlcnIuZXJybm8gfHwgZXJyLmNvZGU7XG4gICAgc3dpdGNoIChlcnJDb2RlKSB7XG4gICAgICBjYXNlIEVSX0RVUF9FTlRSWToge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9EdXBsaWNhdGUgZW50cnkgJyhbXFxzXFxTXSopJyBmb3Iga2V5ICc/KCgufFxccykqPyknPyQvKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KFwiLVwiKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRLZXkgPSBtYXRjaCA/IG1hdGNoWzJdIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZFZhbCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW2ZpZWxkS2V5XTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGlmICh1bmlxdWVLZXkubXNnKVxuICAgICAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbZmllbGRLZXldID0gZmllbGRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBFUl9ST1dfSVNfUkVGRVJFTkNFRDpcbiAgICAgIGNhc2UgRVJfTk9fUkVGRVJFTkNFRF9ST1c6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvQ09OU1RSQUlOVCAoW2BcIl0pKC4qKVxcMSBGT1JFSUdOIEtFWSBcXChcXDEoLiopXFwxXFwpIFJFRkVSRU5DRVMgXFwxKC4qKVxcMSBcXChcXDEoLiopXFwxXFwpLyk7XG4gICAgICAgIGNvbnN0IHF1b3RlQ2hhciA9IG1hdGNoID8gbWF0Y2hbMV0gOiBcImBcIjtcbiAgICAgICAgY29uc3QgZmllbGRzID0gbWF0Y2ggPyBtYXRjaFszXS5zcGxpdChuZXcgUmVnRXhwKGAke3F1b3RlQ2hhcn0sICoke3F1b3RlQ2hhcn1gKSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIHJlbHR5cGU6IFN0cmluZyhlcnJDb2RlKSA9PT0gU3RyaW5nKEVSX1JPV19JU19SRUZFUkVOQ0VEKSA/IFwicGFyZW50XCIgOiBcImNoaWxkXCIsXG4gICAgICAgICAgdGFibGU6IG1hdGNoID8gbWF0Y2hbNF0gOiB2b2lkIDAsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCAmJiB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRzWzBdXSB8fCB2b2lkIDAsXG4gICAgICAgICAgaW5kZXg6IG1hdGNoID8gbWF0Y2hbMl0gOiB2b2lkIDAsXG4gICAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICBpZiAoIShpdGVtLktleV9uYW1lIGluIGFjYykpIHtcbiAgICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdID0gaXRlbTtcbiAgICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGFjY1tpdGVtLktleV9uYW1lXS5maWVsZHNbaXRlbS5TZXFfaW5faW5kZXggLSAxXSA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBpdGVtLkNvbHVtbl9uYW1lLFxuICAgICAgICBsZW5ndGg6IGl0ZW0uU3ViX3BhcnQgfHwgdm9pZCAwLFxuICAgICAgICBvcmRlcjogaXRlbS5Db2xsYXRpb24gPT09IFwiQVwiID8gXCJBU0NcIiA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBpdGVtLmNvbHVtbl9uYW1lO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIF8ubWFwKGRhdGEsIChpdGVtKSA9PiAoe1xuICAgICAgcHJpbWFyeTogaXRlbS5LZXlfbmFtZSA9PT0gXCJQUklNQVJZXCIsXG4gICAgICBmaWVsZHM6IGl0ZW0uZmllbGRzLFxuICAgICAgbmFtZTogaXRlbS5LZXlfbmFtZSxcbiAgICAgIHRhYmxlTmFtZTogaXRlbS5UYWJsZSxcbiAgICAgIHVuaXF1ZTogaXRlbS5Ob25fdW5pcXVlICE9PSAxLFxuICAgICAgdHlwZTogaXRlbS5JbmRleF90eXBlXG4gICAgfSkpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:sqlite\");\nconst dataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").sqlite);\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map((connection) => promisify((callback) => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, (err) => {\n        if (err)\n          return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n    return connection;\n  }\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true)\n      return;\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQztBQUNBLGtCQUFrQix3R0FBa0M7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsc0RBQXNEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz8wODU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpzcWxpdGVcIik7XG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5zcWxpdGU7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJzcWxpdGVcIik7XG5jb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZShcInV0aWxcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3QgPT09IFwibG9jYWxob3N0XCIpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwic3FsaXRlM1wiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcyk7XG4gIH1cbiAgYXN5bmMgX29uUHJvY2Vzc0V4aXQoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5jb25uZWN0aW9ucykubWFwKChjb25uZWN0aW9uKSA9PiBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25dLmNsb3NlKGNhbGxiYWNrKSkoKSkpO1xuICAgIHJldHVybiBzdXBlci5fb25Qcm9jZXNzRXhpdC5jYWxsKHRoaXMpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBhc3luYyBnZXRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnV1aWQgPSBvcHRpb25zLnV1aWQgfHwgXCJkZWZhdWx0XCI7XG4gICAgaWYgKCEhdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdG9yYWdlICE9PSBudWxsICYmIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RvcmFnZSAhPT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zLnN0b3JhZ2UgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0b3JhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdCB8fCBcIjptZW1vcnk6XCI7XG4gICAgfVxuICAgIG9wdGlvbnMuaW5NZW1vcnkgPSBvcHRpb25zLnN0b3JhZ2UgPT09IFwiOm1lbW9yeTpcIiA/IDEgOiAwO1xuICAgIGNvbnN0IGRpYWxlY3RPcHRpb25zID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0T3B0aW9ucztcbiAgICBjb25zdCBkZWZhdWx0UmVhZFdyaXRlTW9kZSA9IHRoaXMubGliLk9QRU5fUkVBRFdSSVRFIHwgdGhpcy5saWIuT1BFTl9DUkVBVEU7XG4gICAgb3B0aW9ucy5yZWFkV3JpdGVNb2RlID0gZGlhbGVjdE9wdGlvbnMgJiYgZGlhbGVjdE9wdGlvbnMubW9kZSB8fCBkZWZhdWx0UmVhZFdyaXRlTW9kZTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluTWVtb3J5ICYmIChvcHRpb25zLnJlYWRXcml0ZU1vZGUgJiB0aGlzLmxpYi5PUEVOX0NSRUFURSkgIT09IDApIHtcbiAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmRpcm5hbWUob3B0aW9ucy5zdG9yYWdlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSA9IG5ldyB0aGlzLmxpYi5EYXRhYmFzZShvcHRpb25zLnN0b3JhZ2UsIG9wdGlvbnMucmVhZFdyaXRlTW9kZSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgIGRlYnVnKGBjb25uZWN0aW9uIGFjcXVpcmVkICR7b3B0aW9ucy51dWlkfWApO1xuICAgICAgICByZXNvbHZlKHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcucGFzc3dvcmQpIHtcbiAgICAgIGNvbm5lY3Rpb24ucnVuKGBQUkFHTUEgS0VZPSR7dGhpcy5zZXF1ZWxpemUuZXNjYXBlKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wYXNzd29yZCl9YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmZvcmVpZ25LZXlzICE9PSBmYWxzZSkge1xuICAgICAgY29ubmVjdGlvbi5ydW4oXCJQUkFHTUEgRk9SRUlHTl9LRVlTPU9OXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuICByZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uLCBmb3JjZSkge1xuICAgIGlmIChjb25uZWN0aW9uLmZpbGVuYW1lID09PSBcIjptZW1vcnk6XCIgJiYgZm9yY2UgIT09IHRydWUpXG4gICAgICByZXR1cm47XG4gICAgaWYgKGNvbm5lY3Rpb24udXVpZCkge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgZGVidWcoYGNvbm5lY3Rpb24gcmVsZWFzZWQgJHtjb25uZWN0aW9uLnV1aWR9YCk7XG4gICAgICBkZWxldGUgdGhpcy5jb25uZWN0aW9uc1tjb25uZWN0aW9uLnV1aWRdO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.sqlite.org/datatype3.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.sqlite = [\"DATETIME\"];\n  BaseTypes.STRING.types.sqlite = [\"VARCHAR\", \"VARCHAR BINARY\"];\n  BaseTypes.CHAR.types.sqlite = [\"CHAR\", \"CHAR BINARY\"];\n  BaseTypes.TEXT.types.sqlite = [\"TEXT\"];\n  BaseTypes.TINYINT.types.sqlite = [\"TINYINT\"];\n  BaseTypes.SMALLINT.types.sqlite = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.sqlite = [\"MEDIUMINT\"];\n  BaseTypes.INTEGER.types.sqlite = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.sqlite = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.sqlite = [\"FLOAT\"];\n  BaseTypes.TIME.types.sqlite = [\"TIME\"];\n  BaseTypes.DATEONLY.types.sqlite = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.sqlite = [\"TINYINT\"];\n  BaseTypes.BLOB.types.sqlite = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.sqlite = [\"DECIMAL\"];\n  BaseTypes.UUID.types.sqlite = [\"UUID\"];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = [\"REAL\"];\n  BaseTypes.DOUBLE.types.sqlite = [\"DOUBLE PRECISION\"];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = [\"JSON\", \"JSONB\"];\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes(\"+\")) {\n        return new Date(date + options.timezone);\n      }\n      return new Date(date);\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n      return super.toSql(this);\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"SQLite does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return \"TEXT COLLATE NOCASE\";\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n      return super.toSql();\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n      if (this._unsigned) {\n        result += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        result += \" ZEROFILL\";\n      }\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n  }\n  class REAL extends BaseTypes.REAL {\n  }\n  function parseFloating(value) {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    if (value === \"NaN\") {\n      return NaN;\n    }\n    if (value === \"Infinity\") {\n      return Infinity;\n    }\n    if (value === \"-Infinity\") {\n      return -Infinity;\n    }\n  }\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsc0NBQXNDLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9kYXRhLXR5cGVzLmpzPzJiM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodm9pZCAwLCBcImh0dHBzOi8vd3d3LnNxbGl0ZS5vcmcvZGF0YXR5cGUzLmh0bWxcIik7XG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX3plcm9maWxsIHx8IGRhdGFUeXBlLl91bnNpZ25lZCkge1xuICAgICAgd2FybihgU1FMaXRlIGRvZXMgbm90IHN1cHBvcnQgJyR7ZGF0YVR5cGUua2V5fScgd2l0aCBVTlNJR05FRCBvciBaRVJPRklMTC4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLnNxbGl0ZSA9IFtcIkRBVEVUSU1FXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLnNxbGl0ZSA9IFtcIlZBUkNIQVJcIiwgXCJWQVJDSEFSIEJJTkFSWVwiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMuc3FsaXRlID0gW1wiQ0hBUlwiLCBcIkNIQVIgQklOQVJZXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5zcWxpdGUgPSBbXCJURVhUXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5zcWxpdGUgPSBbXCJUSU5ZSU5UXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMuc3FsaXRlID0gW1wiU01BTExJTlRcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMuc3FsaXRlID0gW1wiTUVESVVNSU5UXCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5zcWxpdGUgPSBbXCJJTlRFR0VSXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLnNxbGl0ZSA9IFtcIkJJR0lOVFwiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLnNxbGl0ZSA9IFtcIkZMT0FUXCJdO1xuICBCYXNlVHlwZXMuVElNRS50eXBlcy5zcWxpdGUgPSBbXCJUSU1FXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMuc3FsaXRlID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMuc3FsaXRlID0gW1wiVElOWUlOVFwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMuc3FsaXRlID0gW1wiVElOWUJMT0JcIiwgXCJCTE9CXCIsIFwiTE9OR0JMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLnNxbGl0ZSA9IFtcIkRFQ0lNQUxcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLnNxbGl0ZSA9IFtcIlVVSURcIl07XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLnNxbGl0ZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5zcWxpdGUgPSBbXCJSRUFMXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLnNxbGl0ZSA9IFtcIkRPVUJMRSBQUkVDSVNJT05cIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5zcWxpdGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMuc3FsaXRlID0gW1wiSlNPTlwiLCBcIkpTT05CXCJdO1xuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghZGF0ZS5pbmNsdWRlcyhcIitcIikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUgKyBvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZShkYXRlKSB7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgVkFSQ0hBUiBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIudG9TcWwodGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuVEVYVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHdhcm4oXCJTUUxpdGUgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggb3B0aW9ucy4gUGxhaW4gYFRFWFRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiVEVYVFwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBDSVRFWFQgZXh0ZW5kcyBCYXNlVHlwZXMuQ0lURVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRFWFQgQ09MTEFURSBOT0NBU0VcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQ0hBUiBleHRlbmRzIEJhc2VUeXBlcy5DSEFSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBDSEFSIEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBOVU1CRVIgZXh0ZW5kcyBCYXNlVHlwZXMuTlVNQkVSIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSB0aGlzLmtleTtcbiAgICAgIGlmICh0aGlzLl91bnNpZ25lZCkge1xuICAgICAgICByZXN1bHQgKz0gXCIgVU5TSUdORURcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICByZXN1bHQgKz0gXCIgWkVST0ZJTExcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9sZW5ndGh9YDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWNpbWFscyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJlc3VsdCArPSBgLCR7dGhpcy5fZGVjaW1hbHN9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBjbGFzcyBUSU5ZSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlRJTllJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBNRURJVU1JTlQgZXh0ZW5kcyBCYXNlVHlwZXMuTUVESVVNSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgfVxuICBjbGFzcyBET1VCTEUgZXh0ZW5kcyBCYXNlVHlwZXMuRE9VQkxFIHtcbiAgfVxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRmxvYXRpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCJOYU5cIikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBcIkluZmluaXR5XCIpIHtcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBcIi1JbmZpbml0eVwiKSB7XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGZsb2F0aW5nIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMXSkge1xuICAgIGZsb2F0aW5nLnBhcnNlID0gcGFyc2VGbG9hdGluZztcbiAgfVxuICBmb3IgKGNvbnN0IG51bSBvZiBbRkxPQVQsIERPVUJMRSwgUkVBTCwgVElOWUlOVCwgU01BTExJTlQsIE1FRElVTUlOVCwgSU5URUdFUiwgQklHSU5UXSkge1xuICAgIG51bS5wcm90b3R5cGUudG9TcWwgPSBOVU1CRVIucHJvdG90eXBlLnRvU3FsO1xuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJURVhUXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgREFURSxcbiAgICBEQVRFT05MWSxcbiAgICBTVFJJTkcsXG4gICAgQ0hBUixcbiAgICBOVU1CRVIsXG4gICAgRkxPQVQsXG4gICAgUkVBTCxcbiAgICBcIkRPVUJMRSBQUkVDSVNJT05cIjogRE9VQkxFLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgTUVESVVNSU5ULFxuICAgIElOVEVHRVIsXG4gICAgQklHSU5ULFxuICAgIFRFWFQsXG4gICAgRU5VTSxcbiAgICBKU09OOiBKU09OVFlQRSxcbiAgICBDSVRFWFRcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").sqlite);\nconst { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js\");\nclass SqliteDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: false,\n  \"DEFAULT VALUES\": true,\n  \"UNION ALL\": false,\n  \"RIGHT JOIN\": false,\n  inserts: {\n    ignoreDuplicates: \" OR IGNORE\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  index: {\n    using: false,\n    where: true,\n    functionBased: true\n  },\n  transactionOptions: {\n    type: true\n  },\n  constraints: {\n    addConstraint: false,\n    dropConstraint: false\n  },\n  groupedLimit: false,\n  JSON: true\n});\nSqliteDialect.prototype.defaultVersion = \"3.8.0\";\nSqliteDialect.prototype.Query = Query;\nSqliteDialect.prototype.DataTypes = DataTypes;\nSqliteDialect.prototype.name = \"sqlite\";\nSqliteDialect.prototype.TICK_CHAR = \"`\";\nSqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;\nSqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;\nmodule.exports = SqliteDialect;\nmodule.exports.SqliteDialect = SqliteDialect;\nmodule.exports[\"default\"] = SqliteDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsc0dBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyw0RUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbEQsa0JBQWtCLHdHQUFrQztBQUNwRCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0dBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9pbmRleC5qcz9iODcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLnNxbGl0ZTtcbmNvbnN0IHsgU1FMaXRlUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIFNxbGl0ZURpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBTUUxpdGVRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgREVGQVVMVDogZmFsc2UsXG4gIFwiREVGQVVMVCBWQUxVRVNcIjogdHJ1ZSxcbiAgXCJVTklPTiBBTExcIjogZmFsc2UsXG4gIFwiUklHSFQgSk9JTlwiOiBmYWxzZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6IFwiIE9SIElHTk9SRVwiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBcIiBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUXCIsXG4gICAgY29uZmxpY3RGaWVsZHM6IHRydWUsXG4gICAgb25Db25mbGljdFdoZXJlOiB0cnVlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgdXNpbmc6IGZhbHNlLFxuICAgIHdoZXJlOiB0cnVlLFxuICAgIGZ1bmN0aW9uQmFzZWQ6IHRydWVcbiAgfSxcbiAgdHJhbnNhY3Rpb25PcHRpb25zOiB7XG4gICAgdHlwZTogdHJ1ZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGFkZENvbnN0cmFpbnQ6IGZhbHNlLFxuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZVxuICB9LFxuICBncm91cGVkTGltaXQ6IGZhbHNlLFxuICBKU09OOiB0cnVlXG59KTtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCIzLjguMFwiO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcInNxbGl0ZVwiO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gXCJgXCI7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gU3FsaXRlRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLlNxbGl0ZURpYWxlY3QgPSBTcWxpdGVEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFNxbGl0ZURpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter((definition) => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map((val) => val.toISOString());\n    }\n    return value;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: \"addColumn\" });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n    return { query, bind };\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n    return result;\n  }\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n    return `${sql};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map((attr) => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = SQLiteQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDL0MsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLDRCQUE0QixtQkFBTyxDQUFDLHNHQUEwQjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDcEU7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzRUFBc0U7QUFDeEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0EsOENBQThDLE9BQU8sR0FBRyxRQUFRLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQsNERBQTRELEVBQUUsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUUseUJBQXlCLDJCQUEyQixFQUFFLFlBQVk7QUFDbEUsK0JBQStCLHdCQUF3QixNQUFNLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsV0FBVztBQUNqRjtBQUNBLHdCQUF3Qiw0QkFBNEIsTUFBTSxrQkFBa0Isb0NBQW9DLDRCQUE0QixFQUFFLHNDQUFzQyxRQUFRLDJCQUEyQjtBQUN2TixNQUFNO0FBQ04sd0JBQXdCLDRCQUE0QixNQUFNLGtCQUFrQixFQUFFLHFDQUFxQztBQUNuSDtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsbUNBQW1DLGNBQWMsb0NBQW9DLFFBQVEsOEJBQThCLElBQUkseUVBQXlFO0FBQ3hNO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBLHlEQUF5RCw0QkFBNEIsRUFBRSxhQUFhLFFBQVEsMkJBQTJCO0FBQ3ZJO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsR0FBRyxjQUFjO0FBQ2xFO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUMsRUFBRTtBQUN6RTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1EQUFtRCxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixFQUFFLDZDQUE2QyxjQUFjLGlCQUFpQixTQUFTLGdCQUFnQixPQUFPLHVCQUF1QixhQUFhLHVCQUF1QjtBQUM5VjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QyxnQkFBZ0IsbUJBQW1CLHNCQUFzQiwyQkFBMkIsbUNBQW1DLG1CQUFtQixzQkFBc0IsR0FBRyxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixjQUFjLHVCQUF1QixZQUFZLGlCQUFpQjtBQUM5WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHNDQUFzQyxLQUFLLDJCQUEyQjtBQUN6SztBQUNBLGNBQWMsbURBQW1ELGNBQWMsdUJBQXVCLFNBQVMsc0JBQXNCLE9BQU8saUJBQWlCLGFBQWEsaUJBQWlCLEVBQUUsNkNBQTZDLGNBQWMsaUJBQWlCLFNBQVMsc0JBQXNCLE9BQU8sdUJBQXVCLGFBQWEsdUJBQXVCO0FBQzFXO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQSxvQkFBb0IsMEJBQTBCLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBLHlFQUF5RSx3Q0FBd0M7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzPzdhYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IE15U3FsUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vbXlzcWwvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jbGFzcyBTUUxpdGVRdWVyeUdlbmVyYXRvciBleHRlbmRzIE15U3FsUXVlcnlHZW5lcmF0b3Ige1xuICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT0ndGFibGUnIGFuZCBuYW1lIT0nc3FsaXRlX3NlcXVlbmNlJztcIjtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9J3RhYmxlJyBhbmQgbmFtZSE9J3NxbGl0ZV9zZXF1ZW5jZSc7XCI7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBzcWxpdGVfdmVyc2lvbigpIGFzIGB2ZXJzaW9uYFwiO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXTtcbiAgICBjb25zdCBuZWVkc011bHRpcGxlUHJpbWFyeUtleXMgPSBPYmplY3QudmFsdWVzKGF0dHJpYnV0ZXMpLmZpbHRlcigoZGVmaW5pdGlvbikgPT4gZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKS5sZW5ndGggPiAxO1xuICAgIGNvbnN0IGF0dHJBcnJheSA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBdXRvSW5jcmVtZW50ID0gZGF0YVR5cGUuaW5jbHVkZXMoXCJBVVRPSU5DUkVNRU5UXCIpO1xuICAgICAgICBsZXQgZGF0YVR5cGVTdHJpbmcgPSBkYXRhVHlwZTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJJTlRcIikpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gY29udGFpbnNBdXRvSW5jcmVtZW50ID8gXCJJTlRFR0VSIFBSSU1BUlkgS0VZIEFVVE9JTkNSRU1FTlRcIiA6IFwiSU5URUdFUiBQUklNQVJZIEtFWVwiO1xuICAgICAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiIFJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgKz0gZGF0YVR5cGUuc3Vic3RyKGRhdGFUeXBlLmluZGV4T2YoXCIgUkVGRVJFTkNFU1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWVkc011bHRpcGxlUHJpbWFyeUtleXMpIHtcbiAgICAgICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJOT1QgTlVMTFwiKSkge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlLnJlcGxhY2UoXCIgUFJJTUFSWSBLRVlcIiwgXCJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIk5PVCBOVUxMXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyQXJyYXkucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZVN0cmluZ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgYXR0clN0ciA9IGF0dHJBcnJheS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucykgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGF0dHJTdHIgKz0gYCwgVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJTdHIgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuICAgIGNvbnN0IHNxbCA9IGBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAke3RhYmxlfSAoJHthdHRyU3RyfSk7YDtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCk7XG4gIH1cbiAgYm9vbGVhblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gIH1cbiAgX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHN0bXQpIHtcbiAgICBpZiAodHlwZW9mIHN0bXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QganNvbkZ1bmN0aW9uUmVnZXggPSAvXlxccyooanNvbig/Ol9bYS16XSspezAsMn0pXFwoW14pXSpcXCkvaTtcbiAgICBjb25zdCB0b2tlbkNhcHR1cmVSZWdleCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0ganNvbkZ1bmN0aW9uUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IHRva2VuQ2FwdHVyZVJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIjtcIikge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGhhc0ludmFsaWRUb2tlbiB8PSBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cztcbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIGhhc0ludmFsaWRUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAgX3RvSlNPTlZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZVswXSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHZhbCkgPT4gdmFsLnRvSVNPU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmICgvdGltZXN0YW1wL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9IFwiZGF0ZXRpbWVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFic3RyYWN0UXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZC5jYWxsKHRoaXMsIHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgYXR0cmlidXRlc1trZXldID0gZGF0YVR5cGU7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgeyBjb250ZXh0OiBcImFkZENvbHVtblwiIH0pO1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9ICR7ZmllbGRzW2tleV19YDtcbiAgICBjb25zdCBzcWwgPSBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGUpfSBBREQgJHthdHRyaWJ1dGV9O2A7XG4gICAgcmV0dXJuIHRoaXMucmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPSd0YWJsZScgYW5kIG5hbWUhPSdzcWxpdGVfc2VxdWVuY2UnO1wiO1xuICB9XG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgYXR0clZhbHVlSGFzaCA9IFV0aWxzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChhdHRyVmFsdWVIYXNoLCBvcHRpb25zLm9taXROdWxsLCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSB8fCB0aGlzLmJpbmRQYXJhbShiaW5kKTtcbiAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgXy5lYWNoKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldID0gYXR0cmlidXRlO1xuICAgICAgICBpZiAoYXR0cmlidXRlLmZpZWxkKSB7XG4gICAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBbYXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJWYWx1ZUhhc2gpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0clZhbHVlSGFzaFtrZXldO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8IG9wdGlvbnMuYmluZFBhcmFtID09PSBmYWxzZSkge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZXNjYXBlKHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0pfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmZvcm1hdCh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9LCBiaW5kUGFyYW0pfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcXVlcnk7XG4gICAgY29uc3Qgd2hlcmVPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgYmluZFBhcmFtIH0pO1xuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBxdWVyeSA9IGBVUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oXCIsXCIpfSBXSEVSRSByb3dpZCBJTiAoU0VMRUNUIHJvd2lkIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9IExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gYFVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbihcIixcIil9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfWA7XG4gICAgfVxuICAgIHJldHVybiB7IHF1ZXJ5LCBiaW5kIH07XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zLnJlc3RhcnRJZGVudGl0eSA/IGA7IERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKFwic3FsaXRlX3NlcXVlbmNlXCIpfSBXSEVSRSAke3RoaXMucXVvdGVJZGVudGlmaWVyKFwibmFtZVwiKX0gPSAke1V0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLCBcImBcIiksIFwiJ1wiKX07YCA6IFwiXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICBsZXQgd2hlcmVDbGF1c2UgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGlmICh3aGVyZUNsYXVzZSkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgV0hFUkUgJHt3aGVyZUNsYXVzZX1gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9ICR7d2hlcmVDbGF1c2V9IExJTUlUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgfVxuICAgIHJldHVybiBgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt3aGVyZUNsYXVzZX1gO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGRhdGFUeXBlLmZpZWxkIHx8IG5hbWU7XG4gICAgICBpZiAoXy5pc09iamVjdChkYXRhVHlwZSkpIHtcbiAgICAgICAgbGV0IHNxbCA9IGRhdGFUeXBlLnR5cGUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhVHlwZSwgXCJhbGxvd051bGxcIikgJiYgIWRhdGFUeXBlLmFsbG93TnVsbCkge1xuICAgICAgICAgIHNxbCArPSBcIiBOT1QgTlVMTFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoZGF0YVR5cGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICAgIHNxbCArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShkYXRhVHlwZS5kZWZhdWx0VmFsdWUsIGRhdGFUeXBlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhVHlwZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgICAgICBzcWwgKz0gXCIgVU5JUVVFXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlLnByaW1hcnlLZXkpIHtcbiAgICAgICAgICBzcWwgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgICAgICAgc3FsICs9IFwiIEFVVE9JTkNSRU1FTlRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUoZGF0YVR5cGUucmVmZXJlbmNlcy5tb2RlbCk7XG4gICAgICAgICAgbGV0IHJlZmVyZW5jZXNLZXk7XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YVR5cGUucmVmZXJlbmNlcy5rZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3FsICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNUYWJsZX0gKCR7cmVmZXJlbmNlc0tleX0pYDtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUub25EZWxldGUpIHtcbiAgICAgICAgICAgIHNxbCArPSBgIE9OIERFTEVURSAke2RhdGFUeXBlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFUeXBlLm9uVXBkYXRlKSB7XG4gICAgICAgICAgICBzcWwgKz0gYCBPTiBVUERBVEUgJHtkYXRhVHlwZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gc3FsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBkYXRhVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgUFJBR01BIElOREVYX0xJU1QoJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0pYDtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgbGV0IHNxbCA9IGBTRUxFQ1Qgc3FsIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0nJHt0YWJsZU5hbWV9J2A7XG4gICAgaWYgKGNvbnN0cmFpbnROYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgc3FsIExJS0UgJyUke2NvbnN0cmFpbnROYW1lfSUnYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NxbH07YDtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gYERST1AgSU5ERVggSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX1gO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB7XG4gICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXIsXG4gICAgICB0YWJsZU5hbWVcbiAgICB9O1xuICAgIHJldHVybiBgUFJBR01BIFRBQkxFX0lORk8oJHt0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEodGFibGUpKX0pO2A7XG4gIH1cbiAgZGVzY3JpYmVDcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgU0VMRUNUIHNxbCBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdGJsX25hbWU9JyR7dGFibGVOYW1lfSc7YDtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsIFwiKTtcbiAgICByZXR1cm4gYCR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KGJhY2t1cFRhYmxlTmFtZSwgYXR0cmlidXRlcyl9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTske3RoaXMuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpfUlOU0VSVCBJTlRPICR7cXVvdGVkVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07RFJPUCBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YDtcbiAgfVxuICBfYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVUYWJsZVNxbCkge1xuICAgIGxldCBiYWNrdXBUYWJsZU5hbWU7XG4gICAgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBgJHtjcmVhdGVUYWJsZVNxbC5yZXBsYWNlKGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9YCwgYENSRUFURSBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX1gKS5yZXBsYWNlKGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWUucmVwbGFjZSgvYC9nLCAnXCInKX1gLCBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfWApfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc30gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07RFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07QUxURVIgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFJFTkFNRSBUTyAke3F1b3RlZFRhYmxlTmFtZX07YDtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBhdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXNJbXBvcnQgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGF0dHIpID0+IGF0dHJOYW1lQWZ0ZXIgPT09IGF0dHIgPyBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyTmFtZUJlZm9yZSl9IEFTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXNFeHBvcnQgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIGAke3RoaXMuY3JlYXRlVGFibGVRdWVyeShiYWNrdXBUYWJsZU5hbWUsIGF0dHJpYnV0ZXMpfUlOU0VSVCBJTlRPICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc0ltcG9ydH0gRlJPTSAke3F1b3RlZFRhYmxlTmFtZX07RFJPUCBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX07JHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKX1JTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXNFeHBvcnR9IEZST00gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O0RST1AgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9O2A7XG4gIH1cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIGBCRUdJTiAke3RyYW5zYWN0aW9uLm9wdGlvbnMudHlwZX0gVFJBTlNBQ1RJT047YDtcbiAgfVxuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFUEVBVEFCTEVfUkVBRDpcbiAgICAgICAgcmV0dXJuIFwiLS0gU1FMaXRlIGlzIG5vdCBhYmxlIHRvIGNob29zZSB0aGUgaXNvbGF0aW9uIGxldmVsIFJFUEVBVEFCTEUgUkVBRC5cIjtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5SRUFEX1VOQ09NTUlUVEVEOlxuICAgICAgICByZXR1cm4gXCJQUkFHTUEgcmVhZF91bmNvbW1pdHRlZCA9IE9OO1wiO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfQ09NTUlUVEVEOlxuICAgICAgICByZXR1cm4gXCJQUkFHTUEgcmVhZF91bmNvbW1pdHRlZCA9IE9GRjtcIjtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb24uSVNPTEFUSU9OX0xFVkVMUy5TRVJJQUxJWkFCTEU6XG4gICAgICAgIHJldHVybiBcIi0tIFNRTGl0ZSdzIGRlZmF1bHQgaXNvbGF0aW9uIGxldmVsIGlzIFNFUklBTElaQUJMRS4gTm90aGluZyB0byBkby5cIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBpc29sYXRpb24gbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKSB7XG4gICAgcmV0dXJuIHNxbC5yZXBsYWNlKC9ERUZBVUxUICc/ZmFsc2UnPy9nLCBcIkRFRkFVTFQgMFwiKS5yZXBsYWNlKC9ERUZBVUxUICc/dHJ1ZSc/L2csIFwiREVGQVVMVCAxXCIpO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBQUkFHTUEgZm9yZWlnbl9rZXlfbGlzdCgke3RoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh0YWJsZU5hbWUpKX0pYDtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZT0ke3RoaXMuZXNjYXBlKHRoaXMuYWRkU2NoZW1hKHRhYmxlTmFtZSkpfTtgO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCBcImBcIiksIFwiYFwiKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBTUUxpdGVRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { cloneDeep } = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass SQLiteQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName);\n    const constraint = constraints.find((constaint) => constaint.constraintName === constraintName);\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map((columnName) => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(\", \");\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n    createTableSql = createTableSql.replace(constraintSnippet, \"\");\n    createTableSql += \";\";\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SELECT, raw: true }));\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map((row) => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== void 0) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n}\nexports.SQLiteQueryInterface = SQLiteQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsZ0VBQWE7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0MsVUFBVSxvQkFBb0IsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFLDJCQUEyQixFQUFFLCtCQUErQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDcEYseUNBQXlDLHdCQUF3QjtBQUNqRSx5Q0FBeUMsd0JBQXdCO0FBQ2pFO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsY0FBYyxvQ0FBb0M7QUFDNUo7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUIsSUFBSSxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDbkc7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYywyQkFBMkI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL3F1ZXJ5LWludGVyZmFjZS5qcz83OWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCB7IGNsb25lRGVlcCB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jbGFzcyBTUUxpdGVRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGZpZWxkcyA9IGF3YWl0IHRoaXMuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSBmaWVsZHNbYXR0cmlidXRlTmFtZV07XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdChcIjtcIikuZmlsdGVyKChxKSA9PiBxICE9PSBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpXG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIGNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGRhdGFUeXBlT3JPcHRpb25zLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgT2JqZWN0LmFzc2lnbihmaWVsZHNbYXR0cmlidXRlTmFtZV0sIHRoaXMubm9ybWFsaXplQXR0cmlidXRlKGRhdGFUeXBlT3JPcHRpb25zKSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdChcIjtcIikuZmlsdGVyKChxKSA9PiBxICE9PSBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpXG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIHJlbmFtZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5hc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBvcHRpb25zKTtcbiAgICBmaWVsZHNbYXR0ck5hbWVBZnRlcl0gPSBfX3NwcmVhZFZhbHVlcyh7fSwgZmllbGRzW2F0dHJOYW1lQmVmb3JlXSk7XG4gICAgZGVsZXRlIGZpZWxkc1thdHRyTmFtZUJlZm9yZV07XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBhdHRyTmFtZUFmdGVyLCBmaWVsZHMpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoXCI7XCIpLmZpbHRlcigocSkgPT4gcSAhPT0gXCJcIik7XG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKVxuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgY3JlYXRlVGFibGVTcWw7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCB0aGlzLnNob3dDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50cy5maW5kKChjb25zdGFpbnQpID0+IGNvbnN0YWludC5jb25zdHJhaW50TmFtZSA9PT0gY29uc3RyYWludE5hbWUpO1xuICAgIGlmICghY29uc3RyYWludCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Vbmtub3duQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYENvbnN0cmFpbnQgJHtjb25zdHJhaW50TmFtZX0gb24gdGFibGUgJHt0YWJsZU5hbWV9IGRvZXMgbm90IGV4aXN0YCxcbiAgICAgICAgY29uc3RyYWludDogY29uc3RyYWludE5hbWUsXG4gICAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUYWJsZVNxbCA9IGNvbnN0cmFpbnQuc3FsO1xuICAgIGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcihjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lKTtcbiAgICBsZXQgY29uc3RyYWludFNuaXBwZXQgPSBgLCBDT05TVFJBSU5UICR7Y29uc3RyYWludC5jb25zdHJhaW50TmFtZX0gJHtjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlfSAke2NvbnN0cmFpbnQuY29uc3RyYWludENvbmRpdGlvbn1gO1xuICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSBcIkZPUkVJR04gS0VZXCIpIHtcbiAgICAgIGNvbnN0IHJlZmVyZW5jZVRhYmxlTmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVUYWJsZShjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlTmFtZSk7XG4gICAgICBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cyA9IGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzLm1hcCgoY29sdW1uTmFtZSkgPT4gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoY29sdW1uTmFtZSkpO1xuICAgICAgY29uc3QgcmVmZXJlbmNlVGFibGVLZXlzID0gY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMuam9pbihcIiwgXCIpO1xuICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlVGFibGVOYW1lfSAoJHtyZWZlcmVuY2VUYWJsZUtleXN9KWA7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIFVQREFURSAke2NvbnN0cmFpbnQudXBkYXRlQWN0aW9ufWA7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIERFTEVURSAke2NvbnN0cmFpbnQuZGVsZXRlQWN0aW9ufWA7XG4gICAgfVxuICAgIGNyZWF0ZVRhYmxlU3FsID0gY3JlYXRlVGFibGVTcWwucmVwbGFjZShjb25zdHJhaW50U25pcHBldCwgXCJcIik7XG4gICAgY3JlYXRlVGFibGVTcWwgKz0gXCI7XCI7XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5fYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmaWVsZHMsIGNyZWF0ZVRhYmxlU3FsKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KFwiO1wiKS5maWx0ZXIoKHEpID0+IHEgIT09IFwiXCIpO1xuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcylcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgYWRkQ29uc3RyYWludCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZHMgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLmZpZWxkc1wiKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnN0cmFpbnQgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMudHlwZVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IGNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBkZXNjcmliZUNyZWF0ZVRhYmxlU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRlc2NyaWJlQ3JlYXRlVGFibGVTcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuU0VMRUNULCByYXc6IHRydWUgfSkpO1xuICAgIGxldCBzcWwgPSBjb25zdHJhaW50c1swXS5zcWw7XG4gICAgY29uc3QgaW5kZXggPSBzcWwubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjcmVhdGVUYWJsZVNxbCA9IGAke3NxbC5zdWJzdHIoMCwgaW5kZXgpfSwgJHtjb25zdHJhaW50U25pcHBldH0pJHtzcWwuc3Vic3RyKGluZGV4ICsgMSl9O2A7XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5fYWx0ZXJDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBmaWVsZHMsIGNyZWF0ZVRhYmxlU3FsKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KFwiO1wiKS5maWx0ZXIoKHEpID0+IHEgIT09IFwiXCIpO1xuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcylcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkYXRhYmFzZSA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIGRhdGFiYXNlKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdC5tYXAoKHJvdykgPT4gKHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIGNvbHVtbk5hbWU6IHJvdy5mcm9tLFxuICAgICAgcmVmZXJlbmNlZFRhYmxlTmFtZTogcm93LnRhYmxlLFxuICAgICAgcmVmZXJlbmNlZENvbHVtbk5hbWU6IHJvdy50byxcbiAgICAgIHRhYmxlQ2F0YWxvZzogZGF0YWJhc2UsXG4gICAgICByZWZlcmVuY2VkVGFibGVDYXRhbG9nOiBkYXRhYmFzZVxuICAgIH0pKTtcbiAgfVxuICBhc3luYyBkcm9wQWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBza2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNob3dBbGxUYWJsZXMob3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXCJQUkFHTUEgZm9yZWlnbl9rZXlzID0gT0ZGXCIsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuX2Ryb3BBbGxUYWJsZXModGFibGVOYW1lcywgc2tpcCwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoXCJQUkFHTUEgZm9yZWlnbl9rZXlzID0gT05cIiwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgc2NoZW1hID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hRGVsaW1pdGVyID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSBvcHRpb25zLnNjaGVtYSB8fCBudWxsO1xuICAgICAgc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwib2JqZWN0XCIgJiYgdGFibGVOYW1lICE9PSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSB0YWJsZU5hbWUuc2NoZW1hO1xuICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEsIHNjaGVtYURlbGltaXRlcik7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuREVTQ1JJQkUgfSk7XG4gICAgY29uc3Qgc3FsSW5kZXhlcyA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICAgIGlmIChfLmlzRW1wdHkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkZXNjcmlwdGlvbiBmb3VuZCBmb3IgXCIke3RhYmxlTmFtZX1cIiB0YWJsZS4gQ2hlY2sgdGhlIHRhYmxlIG5hbWUgYW5kIHNjaGVtYTsgcmVtZW1iZXIsIHRoZXkgX2FyZV8gY2FzZSBzZW5zaXRpdmUuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleGVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsSW5kZXhlcywgb3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW3Byb3BdLnVuaXF1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXguZmllbGRzKSB7XG4gICAgICAgICAgaWYgKGluZGV4LnVuaXF1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkYXRhW2ZpZWxkLmF0dHJpYnV0ZV0udW5pcXVlID0gaW5kZXgudW5pcXVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZm9yZWlnbktleXMgPSBhd2FpdCB0aGlzLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleSBvZiBmb3JlaWduS2V5cykge1xuICAgICAgICBkYXRhW2ZvcmVpZ25LZXkuY29sdW1uTmFtZV0ucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgICBtb2RlbDogZm9yZWlnbktleS5yZWZlcmVuY2VkVGFibGVOYW1lLFxuICAgICAgICAgIGtleTogZm9yZWlnbktleS5yZWZlcmVuY2VkQ29sdW1uTmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUub3JpZ2luYWwgJiYgZS5vcmlnaW5hbC5jb2RlID09PSBcIkVSX05PX1NVQ0hfVEFCTEVcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlNRTGl0ZVF1ZXJ5SW50ZXJmYWNlID0gU1FMaXRlUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:sqlite\");\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n  _collectModels(include, prefix) {\n    const ret = {};\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n    return ret;\n  }\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      return results.map((row) => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      const prefixes = this._collectModels(this.options.include);\n      results = results.map((result2) => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = { \"0\": false, \"1\": true }[result[_result.name].defaultValue];\n        }\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n        const query = this;\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n        if (!parameters)\n          parameters = [];\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n        tableNames = tableNames.filter((tableName) => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map((tableName) => new Promise((resolve2) => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n            resolve2();\n          });\n        })));\n      }\n      return executeSql();\n    }));\n  }\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map((constraintSql) => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map((column) => Utils.removeTicks(column));\n      }\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\": {\n        if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n        let fields = [];\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(\", \");\n        } else {\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \").map((columnWithTable) => columnWithTable.split(\".\")[1]);\n          }\n        }\n        const errors = [];\n        let message = \"Validation error\";\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n        }\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, (constraint) => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async (item) => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n      return item;\n    }));\n  }\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n    return \"all\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsT0FBTztBQUNQLHVFQUF1RSx3QkFBd0I7QUFDL0YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSx1RUFBdUUsd0JBQXdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1CQUFtQixPQUFPLEdBQUcsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLDBCQUEwQixxRUFBcUU7QUFDL0Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxFQUFFO0FBQzFHLHdHQUF3RyxFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDJEQUEyRCx1REFBdUQ7QUFDbEg7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQSx3REFBd0QsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnkuanM/YzgxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcInNxbGl0ZVwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwic3FsOnNxbGl0ZVwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeUlmQmlnaW50KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImxhc3RJRFwiO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGxldCBiaW5kUGFyYW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgYmluZFBhcmFtID0ge307XG4gICAgICB2YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBiaW5kUGFyYW1bYCQke2kgKyAxfWBdID0gdjtcbiAgICAgIH0pO1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaW5kUGFyYW0gPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgICAgYmluZFBhcmFtW2AkJHtrfWBdID0gdmFsdWVzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfVxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG4gIF9jb2xsZWN0TW9kZWxzKGluY2x1ZGUsIHByZWZpeCkge1xuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IF9pbmNsdWRlIG9mIGluY2x1ZGUpIHtcbiAgICAgICAgbGV0IGtleTtcbiAgICAgICAgaWYgKCFwcmVmaXgpIHtcbiAgICAgICAgICBrZXkgPSBfaW5jbHVkZS5hcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBgJHtwcmVmaXh9LiR7X2luY2x1ZGUuYXN9YDtcbiAgICAgICAgfVxuICAgICAgICByZXRba2V5XSA9IF9pbmNsdWRlLm1vZGVsO1xuICAgICAgICBpZiAoX2luY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgICAgIF8ubWVyZ2UocmV0LCB0aGlzLl9jb2xsZWN0TW9kZWxzKF9pbmNsdWRlLmluY2x1ZGUsIGtleSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgX2hhbmRsZVF1ZXJ5UmVzcG9uc2UobWV0YURhdGEsIGNvbHVtblR5cGVzLCBlcnIsIHJlc3VsdHMsIGVyclN0YWNrKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyLnNxbCA9IHRoaXMuc3FsO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkgfHwgdGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpO1xuICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgIGlmIChtZXRhRGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlN0YXRlbWVudFwiICYmIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXSAtIG1ldGFEYXRhLmNoYW5nZXMgKyAxO1xuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkOyBpIDwgc3RhcnRJZCArIG1ldGFEYXRhLmNoYW5nZXM7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBbdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGRdOiBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBtZXRhRGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHMubWFwKChyb3cpID0+IHJvdy5uYW1lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRzO1xuICAgICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLnNxbCkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQ29uc3RyYWludHNGcm9tU3FsKHJlc3VsdHNbMF0uc3FsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcmVmaXhlcyA9IHRoaXMuX2NvbGxlY3RNb2RlbHModGhpcy5vcHRpb25zLmluY2x1ZGUpO1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiBfLm1hcFZhbHVlcyhyZXN1bHQyLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAgICAgICBsZXQgbW9kZWw7XG4gICAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0aW5kID0gbmFtZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgICAgICBtb2RlbCA9IHByZWZpeGVzW25hbWUuc3Vic3RyKDAsIGxhc3RpbmQpXTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihsYXN0aW5kICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsID0gdGhpcy5vcHRpb25zLm1vZGVsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0YWJsZU5hbWUgPSBtb2RlbC5nZXRUYWJsZU5hbWUoKS50b1N0cmluZygpLnJlcGxhY2UoL2AvZywgXCJcIik7XG4gICAgICAgICAgY29uc3QgdGFibGVUeXBlcyA9IGNvbHVtblR5cGVzW3RhYmxlTmFtZV0gfHwge307XG4gICAgICAgICAgaWYgKHRhYmxlVHlwZXMgJiYgIShuYW1lIGluIHRhYmxlVHlwZXMpKSB7XG4gICAgICAgICAgICBfLmZvck93bihtb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGtleSAmJiBhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gYXR0cmlidXRlLmZpZWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFibGVUeXBlcywgbmFtZSkgPyB0aGlzLmFwcGx5UGFyc2Vycyh0YWJsZVR5cGVzW25hbWVdLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dPckRlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBJTkRFWF9MSVNUXCIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KHJlc3VsdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgSU5ERVhfSU5GT1wiKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBUQUJMRV9JTkZPXCIpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGxldCBkZWZhdWx0VmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAoX3Jlc3VsdC5kZmx0X3ZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gdm9pZCAwO1xuICAgICAgICB9IGVsc2UgaWYgKF9yZXN1bHQuZGZsdF92YWx1ZSA9PT0gXCJOVUxMXCIpIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IF9yZXN1bHQuZGZsdF92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LnR5cGUsXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0Lm5vdG51bGwgPT09IDAsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQucGsgIT09IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3VsdFtfcmVzdWx0Lm5hbWVdLnR5cGUgPT09IFwiVElOWUlOVCgxKVwiKSB7XG4gICAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID0geyBcIjBcIjogZmFsc2UsIFwiMVwiOiB0cnVlIH1bcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZSA9IHJlc3VsdFtfcmVzdWx0Lm5hbWVdLmRlZmF1bHRWYWx1ZS5yZXBsYWNlKC8nL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgZm9yZWlnbl9rZXlzO1wiKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBmb3JlaWduX2tleXNcIikpIHtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuaW5jbHVkZXMoXCJQUkFHTUEgZm9yZWlnbl9rZXlfbGlzdFwiKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmIChbUXVlcnlUeXBlcy5CVUxLVVBEQVRFLCBRdWVyeVR5cGVzLkJVTEtERUxFVEVdLmluY2x1ZGVzKHRoaXMub3B0aW9ucy50eXBlKSkge1xuICAgICAgcmV0dXJuIG1ldGFEYXRhLmNoYW5nZXM7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5WRVJTSU9OKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuUkFXKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdHMsIG1ldGFEYXRhXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgbnVsbF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzSW5zZXJ0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIG1ldGFEYXRhLmNoYW5nZXNdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0RGF0YWJhc2VNZXRob2QoKTtcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uLnNlcmlhbGl6ZShhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5UeXBlcyA9IHt9O1xuICAgICAgY29uc3QgZXJyRm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICAgIGNvbnN0IGV4ZWN1dGVTcWwgPSAoKSA9PiB7XG4gICAgICAgIGlmIChzcWwuc3RhcnRzV2l0aChcIi0tIFwiKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBhZnRlckV4ZWN1dGUoZXhlY3V0aW9uRXJyb3IsIHJlc3VsdHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJlc29sdmUocXVlcnkuX2hhbmRsZVF1ZXJ5UmVzcG9uc2UodGhpcywgY29sdW1uVHlwZXMsIGV4ZWN1dGlvbkVycm9yLCByZXN1bHRzLCBlcnJGb3JTdGFjay5zdGFjaykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtZXRlcnMpXG4gICAgICAgICAgcGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyYW1ldGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIG5ld1BhcmFtZXRlcnNbYCR7a2V5fWBdID0gc3RyaW5naWZ5SWZCaWdpbnQocGFyYW1ldGVyc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1ldGVycyA9IG5ld1BhcmFtZXRlcnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMubWFwKHN0cmluZ2lmeUlmQmlnaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uW21ldGhvZF0oc3FsLCBwYXJhbWV0ZXJzLCBhZnRlckV4ZWN1dGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5nZXREYXRhYmFzZU1ldGhvZCgpID09PSBcImFsbFwiKSB7XG4gICAgICAgIGxldCB0YWJsZU5hbWVzID0gW107XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnRhYmxlTmFtZXMpIHtcbiAgICAgICAgICB0YWJsZU5hbWVzID0gdGhpcy5vcHRpb25zLnRhYmxlTmFtZXM7XG4gICAgICAgIH0gZWxzZSBpZiAoL0ZST00gYCguKj8pYC9pLmV4ZWModGhpcy5zcWwpKSB7XG4gICAgICAgICAgdGFibGVOYW1lcy5wdXNoKC9GUk9NIGAoLio/KWAvaS5leGVjKHRoaXMuc3FsKVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGVOYW1lcyA9IHRhYmxlTmFtZXMuZmlsdGVyKCh0YWJsZU5hbWUpID0+ICEodGFibGVOYW1lIGluIGNvbHVtblR5cGVzKSAmJiB0YWJsZU5hbWUgIT09IFwic3FsaXRlX21hc3RlclwiKTtcbiAgICAgICAgaWYgKCF0YWJsZU5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBleGVjdXRlU3FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGFibGVOYW1lcy5tYXAoKHRhYmxlTmFtZSkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiB7XG4gICAgICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnJlcGxhY2UoL2AvZywgXCJcIik7XG4gICAgICAgICAgY29sdW1uVHlwZXNbdGFibGVOYW1lXSA9IHt9O1xuICAgICAgICAgIGNvbm4uYWxsKGBQUkFHTUEgdGFibGVfaW5mbyhcXGAke3RhYmxlTmFtZX1cXGApYCwgKGVyciwgcmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNvbHVtblR5cGVzW3RhYmxlTmFtZV1bcmVzdWx0Lm5hbWVdID0gcmVzdWx0LnR5cGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhlY3V0ZVNxbCgpO1xuICAgIH0pKTtcbiAgfVxuICBwYXJzZUNvbnN0cmFpbnRzRnJvbVNxbChzcWwpIHtcbiAgICBsZXQgY29uc3RyYWludHMgPSBzcWwuc3BsaXQoXCJDT05TVFJBSU5UIFwiKTtcbiAgICBsZXQgcmVmZXJlbmNlVGFibGVOYW1lLCByZWZlcmVuY2VUYWJsZUtleXMsIHVwZGF0ZUFjdGlvbiwgZGVsZXRlQWN0aW9uO1xuICAgIGNvbnN0cmFpbnRzLnNwbGljZSgwLCAxKTtcbiAgICBjb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLm1hcCgoY29uc3RyYWludFNxbCkgPT4ge1xuICAgICAgaWYgKGNvbnN0cmFpbnRTcWwuaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIHVwZGF0ZUFjdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL09OIFVQREFURSAoQ0FTQ0FERXxTRVQgTlVMTHxSRVNUUklDVHxOTyBBQ1RJT058U0VUIERFRkFVTFQpezF9Lyk7XG4gICAgICAgIGRlbGV0ZUFjdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL09OIERFTEVURSAoQ0FTQ0FERXxTRVQgTlVMTHxSRVNUUklDVHxOTyBBQ1RJT058U0VUIERFRkFVTFQpezF9Lyk7XG4gICAgICAgIGlmICh1cGRhdGVBY3Rpb24pIHtcbiAgICAgICAgICB1cGRhdGVBY3Rpb24gPSB1cGRhdGVBY3Rpb25bMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGV0ZUFjdGlvbikge1xuICAgICAgICAgIGRlbGV0ZUFjdGlvbiA9IGRlbGV0ZUFjdGlvblsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZlcmVuY2VzUmVnZXggPSAvUkVGRVJFTkNFUy4rXFwoKD86W14pKF0rfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqXFwpLztcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlQ29uZGl0aW9ucyA9IGNvbnN0cmFpbnRTcWwubWF0Y2gocmVmZXJlbmNlc1JlZ2V4KVswXS5zcGxpdChcIiBcIik7XG4gICAgICAgIHJlZmVyZW5jZVRhYmxlTmFtZSA9IFV0aWxzLnJlbW92ZVRpY2tzKHJlZmVyZW5jZUNvbmRpdGlvbnNbMV0pO1xuICAgICAgICBsZXQgY29sdW1uTmFtZXMgPSByZWZlcmVuY2VDb25kaXRpb25zWzJdO1xuICAgICAgICBjb2x1bW5OYW1lcyA9IGNvbHVtbk5hbWVzLnJlcGxhY2UoL1xcKHxcXCkvZywgXCJcIikuc3BsaXQoXCIsIFwiKTtcbiAgICAgICAgcmVmZXJlbmNlVGFibGVLZXlzID0gY29sdW1uTmFtZXMubWFwKChjb2x1bW4pID0+IFV0aWxzLnJlbW92ZVRpY2tzKGNvbHVtbikpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uc3RyYWludENvbmRpdGlvbiA9IGNvbnN0cmFpbnRTcWwubWF0Y2goL1xcKCg/OlteKShdK3xcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKlxcKS8pWzBdO1xuICAgICAgY29uc3RyYWludFNxbCA9IGNvbnN0cmFpbnRTcWwucmVwbGFjZSgvXFwoLitcXCkvLCBcIlwiKTtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50U3FsLnNwbGl0KFwiIFwiKTtcbiAgICAgIGlmIChbXCJQUklNQVJZXCIsIFwiRk9SRUlHTlwiXS5pbmNsdWRlcyhjb25zdHJhaW50WzFdKSkge1xuICAgICAgICBjb25zdHJhaW50WzFdICs9IFwiIEtFWVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RyYWludE5hbWU6IFV0aWxzLnJlbW92ZVRpY2tzKGNvbnN0cmFpbnRbMF0pLFxuICAgICAgICBjb25zdHJhaW50VHlwZTogY29uc3RyYWludFsxXSxcbiAgICAgICAgdXBkYXRlQWN0aW9uLFxuICAgICAgICBkZWxldGVBY3Rpb24sXG4gICAgICAgIHNxbDogc3FsLnJlcGxhY2UoL1wiL2csIFwiYFwiKSxcbiAgICAgICAgY29uc3RyYWludENvbmRpdGlvbixcbiAgICAgICAgcmVmZXJlbmNlVGFibGVOYW1lLFxuICAgICAgICByZWZlcmVuY2VUYWJsZUtleXNcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICB9XG4gIGFwcGx5UGFyc2Vycyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlLmluY2x1ZGVzKFwiKFwiKSkge1xuICAgICAgdHlwZSA9IHR5cGUuc3Vic3RyKDAsIHR5cGUuaW5kZXhPZihcIihcIikpO1xuICAgIH1cbiAgICB0eXBlID0gdHlwZS5yZXBsYWNlKFwiVU5TSUdORURcIiwgXCJcIikucmVwbGFjZShcIlpFUk9GSUxMXCIsIFwiXCIpO1xuICAgIHR5cGUgPSB0eXBlLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KHR5cGUpO1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBwYXJzZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHZhbHVlLCB7IHRpbWV6b25lOiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykge1xuICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgIGNhc2UgXCJTUUxJVEVfQ09OU1RSQUlOVF9VTklRVUVcIjpcbiAgICAgIGNhc2UgXCJTUUxJVEVfQ09OU1RSQUlOVF9QUklNQVJZS0VZXCI6XG4gICAgICBjYXNlIFwiU1FMSVRFX0NPTlNUUkFJTlRfVFJJR0dFUlwiOlxuICAgICAgY2FzZSBcIlNRTElURV9DT05TVFJBSU5UX0ZPUkVJR05LRVlcIjpcbiAgICAgIGNhc2UgXCJTUUxJVEVfQ09OU1RSQUlOVFwiOiB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIkZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL2NvbHVtbnMgKC4qPykgYXJlLyk7XG4gICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBtYXRjaC5sZW5ndGggPj0gMikge1xuICAgICAgICAgIGZpZWxkcyA9IG1hdGNoWzFdLnNwbGl0KFwiLCBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvVU5JUVVFIGNvbnN0cmFpbnQgZmFpbGVkOiAoLiopLyk7XG4gICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBmaWVsZHMgPSBtYXRjaFsxXS5zcGxpdChcIiwgXCIpLm1hcCgoY29sdW1uV2l0aFRhYmxlKSA9PiBjb2x1bW5XaXRoVGFibGUuc3BsaXQoXCIuXCIpWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkXSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICAgIF8uZm9yT3duKHRoaXMubW9kZWwudW5pcXVlS2V5cywgKGNvbnN0cmFpbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChfLmlzRXF1YWwoY29uc3RyYWludC5maWVsZHMsIGZpZWxkcykgJiYgISFjb25zdHJhaW50Lm1zZykge1xuICAgICAgICAgICAgICBtZXNzYWdlID0gY29uc3RyYWludC5tc2c7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJTUUxJVEVfQlVTWVwiOlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5UaW1lb3V0RXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGRhdGEucmV2ZXJzZSgpLm1hcChhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIGl0ZW0ucHJpbWFyeSA9IGZhbHNlO1xuICAgICAgaXRlbS51bmlxdWUgPSAhIWl0ZW0udW5pcXVlO1xuICAgICAgaXRlbS5jb25zdHJhaW50TmFtZSA9IGl0ZW0ubmFtZTtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBhd2FpdCB0aGlzLnJ1bihgUFJBR01BIElOREVYX0lORk8oXFxgJHtpdGVtLm5hbWV9XFxgKWApO1xuICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgICBpdGVtLmZpZWxkc1tjb2x1bW4uc2Vxbm9dID0ge1xuICAgICAgICAgIGF0dHJpYnV0ZTogY29sdW1uLm5hbWUsXG4gICAgICAgICAgbGVuZ3RoOiB2b2lkIDAsXG4gICAgICAgICAgb3JkZXI6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICB9XG4gIGdldERhdGFiYXNlTWV0aG9kKCkge1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSB8fCB0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIkNSRUFURSBURU1QT1JBUlkgVEFCTEVcIi50b0xvd2VyQ2FzZSgpKSB8fCB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5CVUxLREVMRVRFKSB7XG4gICAgICByZXR1cm4gXCJydW5cIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiYWxsXCI7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  withSqliteForeignKeysOff: () => withSqliteForeignKeysOff\n});\nasync function withSqliteForeignKeysOff(sequelize, options, cb) {\n  try {\n    await sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    return await cb();\n  } finally {\n    await sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n}\n//# sourceMappingURL=sqlite-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvc3FsaXRlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvc3FsaXRlLXV0aWxzLmpzP2MzOWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmY6ICgpID0+IHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZlxufSk7XG5hc3luYyBmdW5jdGlvbiB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmYoc2VxdWVsaXplLCBvcHRpb25zLCBjYikge1xuICB0cnkge1xuICAgIGF3YWl0IHNlcXVlbGl6ZS5xdWVyeShcIlBSQUdNQSBmb3JlaWduX2tleXMgPSBPRkZcIiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IGNiKCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KFwiUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9OXCIsIG9wdGlvbnMpO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcWxpdGUtdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => aggregate_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass AggregateError extends import_base_error.default {\n  constructor(errors) {\n    super();\n    __publicField(this, \"errors\");\n    this.errors = errors;\n    this.name = \"AggregateError\";\n  }\n  toString() {\n    const message = `AggregateError of:\n${this.errors.map((error) => error === this ? \"[Circular AggregateError]\" : error instanceof AggregateError ? String(error).replace(/\\n$/, \"\").replace(/^/gm, \"  \") : String(error).replace(/^/gm, \"    \").substring(2)).join(\"\\n\")}\n`;\n    return message;\n  }\n}\nvar aggregate_error_default = AggregateError;\n//# sourceMappingURL=aggregate-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYWdncmVnYXRlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYWdncmVnYXRlLWVycm9yLmpzP2UzZWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gYWdncmVnYXRlX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGVycm9ycykge1xuICAgIHN1cGVyKCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVycm9yc1wiKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm5hbWUgPSBcIkFnZ3JlZ2F0ZUVycm9yXCI7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBBZ2dyZWdhdGVFcnJvciBvZjpcbiR7dGhpcy5lcnJvcnMubWFwKChlcnJvcikgPT4gZXJyb3IgPT09IHRoaXMgPyBcIltDaXJjdWxhciBBZ2dyZWdhdGVFcnJvcl1cIiA6IGVycm9yIGluc3RhbmNlb2YgQWdncmVnYXRlRXJyb3IgPyBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKS5yZXBsYWNlKC9eL2dtLCBcIiAgXCIpIDogU3RyaW5nKGVycm9yKS5yZXBsYWNlKC9eL2dtLCBcIiAgICBcIikuc3Vic3RyaW5nKDIpKS5qb2luKFwiXFxuXCIpfVxuYDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxufVxudmFyIGFnZ3JlZ2F0ZV9lcnJvcl9kZWZhdWx0ID0gQWdncmVnYXRlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2dyZWdhdGUtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/association-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/association-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => association_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass AssociationError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAssociationError\";\n  }\n}\nvar association_error_default = AssociationError;\n//# sourceMappingURL=association-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Fzc29jaWF0aW9uLWVycm9yLmpzPzExMjMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGFzc29jaWF0aW9uX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEFzc29jaWF0aW9uRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQXNzb2NpYXRpb25FcnJvclwiO1xuICB9XG59XG52YXIgYXNzb2NpYXRpb25fZXJyb3JfZGVmYXVsdCA9IEFzc29jaWF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NvY2lhdGlvbi1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/association-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/base-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/base-error.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  default: () => base_error_default\n});\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeBaseError\";\n  }\n}\nvar base_error_default = BaseError;\n//# sourceMappingURL=base-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcz80MzBiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gYmFzZV9lcnJvcl9kZWZhdWx0XG59KTtcbmNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQmFzZUVycm9yXCI7XG4gIH1cbn1cbnZhciBiYXNlX2Vycm9yX2RlZmF1bHQgPSBCYXNlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/base-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => bulk_record_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass BulkRecordError extends import_base_error.default {\n  constructor(error, record) {\n    super(error.message);\n    __publicField(this, \"errors\");\n    __publicField(this, \"record\");\n    this.name = \"SequelizeBulkRecordError\";\n    this.errors = error;\n    this.record = record;\n  }\n}\nvar bulk_record_error_default = BulkRecordError;\n//# sourceMappingURL=bulk-record-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYnVsay1yZWNvcmQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2J1bGstcmVjb3JkLWVycm9yLmpzPzM4OTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gYnVsa19yZWNvcmRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgQnVsa1JlY29yZEVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKGVycm9yLCByZWNvcmQpIHtcbiAgICBzdXBlcihlcnJvci5tZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXJyb3JzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWNvcmRcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVCdWxrUmVjb3JkRXJyb3JcIjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yO1xuICAgIHRoaXMucmVjb3JkID0gcmVjb3JkO1xuICB9XG59XG52YXIgYnVsa19yZWNvcmRfZXJyb3JfZGVmYXVsdCA9IEJ1bGtSZWNvcmRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bGstcmVjb3JkLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection-error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => connection_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass ConnectionError extends import_base_error.default {\n  constructor(parent) {\n    super(parent ? parent.message : \"\");\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    this.name = \"SequelizeConnectionError\";\n    this.parent = parent;\n    this.original = parent;\n  }\n}\nvar connection_error_default = ConnectionError;\n//# sourceMappingURL=connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvci5qcz8yYmEzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGNvbm5lY3Rpb25fZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCA/IHBhcmVudC5tZXNzYWdlIDogXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3JpZ2luYWxcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVDb25uZWN0aW9uRXJyb3JcIjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLm9yaWdpbmFsID0gcGFyZW50O1xuICB9XG59XG52YXIgY29ubmVjdGlvbl9lcnJvcl9kZWZhdWx0ID0gQ29ubmVjdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => access_denied_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AccessDeniedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeAccessDeniedError\";\n  }\n}\nvar access_denied_error_default = AccessDeniedError;\n//# sourceMappingURL=access-denied-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDLG1CQUFPLENBQUMsMEZBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yLmpzPzE2MjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGFjY2Vzc19kZW5pZWRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIEFjY2Vzc0RlbmllZEVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVBY2Nlc3NEZW5pZWRFcnJvclwiO1xuICB9XG59XG52YXIgYWNjZXNzX2RlbmllZF9lcnJvcl9kZWZhdWx0ID0gQWNjZXNzRGVuaWVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3MtZGVuaWVkLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_acquire_timeout_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionAcquireTimeoutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionAcquireTimeoutError\";\n  }\n}\nvar connection_acquire_timeout_error_default = ConnectionAcquireTimeoutError;\n//# sourceMappingURL=connection-acquire-timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1hY3F1aXJlLXRpbWVvdXQtZXJyb3IuanM/OGQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gY29ubmVjdGlvbl9hY3F1aXJlX3RpbWVvdXRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVDb25uZWN0aW9uQWNxdWlyZVRpbWVvdXRFcnJvclwiO1xuICB9XG59XG52YXIgY29ubmVjdGlvbl9hY3F1aXJlX3RpbWVvdXRfZXJyb3JfZGVmYXVsdCA9IENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1hY3F1aXJlLXRpbWVvdXQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_refused_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionRefusedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionRefusedError\";\n  }\n}\nvar connection_refused_error_default = ConnectionRefusedError;\n//# sourceMappingURL=connection-refused-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2Nvbm5lY3Rpb24tcmVmdXNlZC1lcnJvci5qcz81OTJlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBjb25uZWN0aW9uX3JlZnVzZWRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIENvbm5lY3Rpb25SZWZ1c2VkRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUNvbm5lY3Rpb25SZWZ1c2VkRXJyb3JcIjtcbiAgfVxufVxudmFyIGNvbm5lY3Rpb25fcmVmdXNlZF9lcnJvcl9kZWZhdWx0ID0gQ29ubmVjdGlvblJlZnVzZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tcmVmdXNlZC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_timed_out_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionTimedOutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionTimedOutError\";\n  }\n}\nvar connection_timed_out_error_default = ConnectionTimedOutError;\n//# sourceMappingURL=connection-timed-out-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3IuanM/YThiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gY29ubmVjdGlvbl90aW1lZF9vdXRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIENvbm5lY3Rpb25UaW1lZE91dEVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVDb25uZWN0aW9uVGltZWRPdXRFcnJvclwiO1xuICB9XG59XG52YXIgY29ubmVjdGlvbl90aW1lZF9vdXRfZXJyb3JfZGVmYXVsdCA9IENvbm5lY3Rpb25UaW1lZE91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_found_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotFoundError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotFoundError\";\n  }\n}\nvar host_not_found_error_default = HostNotFoundError;\n//# sourceMappingURL=host-not-found-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vaG9zdC1ub3QtZm91bmQtZXJyb3IuanM/ZDE5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gaG9zdF9ub3RfZm91bmRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIEhvc3ROb3RGb3VuZEVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVIb3N0Tm90Rm91bmRFcnJvclwiO1xuICB9XG59XG52YXIgaG9zdF9ub3RfZm91bmRfZXJyb3JfZGVmYXVsdCA9IEhvc3ROb3RGb3VuZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9zdC1ub3QtZm91bmQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_reachable_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotReachableError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotReachableError\";\n  }\n}\nvar host_not_reachable_error_default = HostNotReachableError;\n//# sourceMappingURL=host-not-reachable-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvci5qcz9kNzhkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBob3N0X25vdF9yZWFjaGFibGVfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIEhvc3ROb3RSZWFjaGFibGVFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplSG9zdE5vdFJlYWNoYWJsZUVycm9yXCI7XG4gIH1cbn1cbnZhciBob3N0X25vdF9yZWFjaGFibGVfZXJyb3JfZGVmYXVsdCA9IEhvc3ROb3RSZWFjaGFibGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvc3Qtbm90LXJlYWNoYWJsZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => invalid_connection_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass InvalidConnectionError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeInvalidConnectionError\";\n  }\n}\nvar invalid_connection_error_default = InvalidConnectionError;\n//# sourceMappingURL=invalid-connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2ludmFsaWQtY29ubmVjdGlvbi1lcnJvci5qcz9mZTI0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBpbnZhbGlkX2Nvbm5lY3Rpb25fZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIEludmFsaWRDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUludmFsaWRDb25uZWN0aW9uRXJyb3JcIjtcbiAgfVxufVxudmFyIGludmFsaWRfY29ubmVjdGlvbl9lcnJvcl9kZWZhdWx0ID0gSW52YWxpZENvbm5lY3Rpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFsaWQtY29ubmVjdGlvbi1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database-error.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => database_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass DatabaseError extends import_base_error.default {\n  constructor(parent, options = {}) {\n    super(parent.message);\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"sql\");\n    __publicField(this, \"parameters\");\n    var _a;\n    this.name = \"SequelizeDatabaseError\";\n    this.parent = parent;\n    this.original = parent;\n    this.sql = parent.sql;\n    this.parameters = (_a = parent.parameters) != null ? _a : {};\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n}\nvar database_error_default = DatabaseError;\n//# sourceMappingURL=database-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlLWVycm9yLmpzPzVkZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gZGF0YWJhc2VfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgRGF0YWJhc2VFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmVudC5tZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcmlnaW5hbFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3FsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJhbWV0ZXJzXCIpO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZURhdGFiYXNlRXJyb3JcIjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLm9yaWdpbmFsID0gcGFyZW50O1xuICAgIHRoaXMuc3FsID0gcGFyZW50LnNxbDtcbiAgICB0aGlzLnBhcmFtZXRlcnMgPSAoX2EgPSBwYXJlbnQucGFyYW1ldGVycykgIT0gbnVsbCA/IF9hIDoge307XG4gICAgaWYgKG9wdGlvbnMuc3RhY2spIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xuICAgIH1cbiAgfVxufVxudmFyIGRhdGFiYXNlX2Vycm9yX2RlZmF1bHQgPSBEYXRhYmFzZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YWJhc2UtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => exclusion_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass ExclusionConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeExclusionConstraintError\";\n    this.message = options.message || options.parent.message || \"\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar exclusion_constraint_error_default = ExclusionConstraintError;\n//# sourceMappingURL=exclusion-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLG1CQUFPLENBQUMsc0ZBQW1CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS9leGNsdXNpb24tY29uc3RyYWludC1lcnJvci5qcz9iMDQ3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGV4Y2x1c2lvbl9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9kYXRhYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2RhdGFiYXNlLWVycm9yXCIpKTtcbmNsYXNzIEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvciBleHRlbmRzIGltcG9ydF9kYXRhYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6IFwiXCIsIG5hbWU6IFwiXCIsIG1lc3NhZ2U6IFwiXCIgfTtcbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCwgeyBzdGFjazogb3B0aW9ucy5zdGFjayB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uc3RyYWludFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWJsZVwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8IFwiXCI7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gb3B0aW9ucy5jb25zdHJhaW50O1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gIH1cbn1cbnZhciBleGNsdXNpb25fY29uc3RyYWludF9lcnJvcl9kZWZhdWx0ID0gRXhjbHVzaW9uQ29uc3RyYWludEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  RelationshipType: () => RelationshipType,\n  default: () => foreign_key_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nvar RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {\n  RelationshipType2[\"parent\"] = \"parent\";\n  RelationshipType2[\"child\"] = \"child\";\n  return RelationshipType2;\n})(RelationshipType || {});\nclass ForeignKeyConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"table\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"value\");\n    __publicField(this, \"index\");\n    __publicField(this, \"reltype\");\n    this.name = \"SequelizeForeignKeyConstraintError\";\n    this.message = options.message || options.parent.message || \"Database Error\";\n    this.fields = options.fields;\n    this.table = options.table;\n    this.value = options.value;\n    this.index = options.index;\n    this.reltype = options.reltype;\n  }\n}\nvar foreign_key_constraint_error_default = ForeignKeyConstraintError;\n//# sourceMappingURL=foreign-key-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL2ZvcmVpZ24ta2V5LWNvbnN0cmFpbnQtZXJyb3IuanM/ZGJjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBSZWxhdGlvbnNoaXBUeXBlOiAoKSA9PiBSZWxhdGlvbnNoaXBUeXBlLFxuICBkZWZhdWx0OiAoKSA9PiBmb3JlaWduX2tleV9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9kYXRhYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2RhdGFiYXNlLWVycm9yXCIpKTtcbnZhciBSZWxhdGlvbnNoaXBUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVsYXRpb25zaGlwVHlwZTIpID0+IHtcbiAgUmVsYXRpb25zaGlwVHlwZTJbXCJwYXJlbnRcIl0gPSBcInBhcmVudFwiO1xuICBSZWxhdGlvbnNoaXBUeXBlMltcImNoaWxkXCJdID0gXCJjaGlsZFwiO1xuICByZXR1cm4gUmVsYXRpb25zaGlwVHlwZTI7XG59KShSZWxhdGlvbnNoaXBUeXBlIHx8IHt9KTtcbmNsYXNzIEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3IgZXh0ZW5kcyBpbXBvcnRfZGF0YWJhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiBcIlwiLCBuYW1lOiBcIlwiLCBtZXNzYWdlOiBcIlwiIH07XG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQsIHsgc3RhY2s6IG9wdGlvbnMuc3RhY2sgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhYmxlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWVsZHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmRleFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVsdHlwZVwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCBcIkRhdGFiYXNlIEVycm9yXCI7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgICB0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLnJlbHR5cGUgPSBvcHRpb25zLnJlbHR5cGU7XG4gIH1cbn1cbnZhciBmb3JlaWduX2tleV9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHQgPSBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => timeout_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass TimeoutError extends import_database_error.default {\n  constructor(parent, options = {}) {\n    super(parent, options);\n    this.name = \"SequelizeTimeoutError\";\n  }\n}\nvar timeout_error_default = TimeoutError;\n//# sourceMappingURL=timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdGltZW91dC1lcnJvci5qcz9lNjdlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiB0aW1lb3V0X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9kYXRhYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2RhdGFiYXNlLWVycm9yXCIpKTtcbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIGltcG9ydF9kYXRhYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihwYXJlbnQsIG9wdGlvbnMpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplVGltZW91dEVycm9yXCI7XG4gIH1cbn1cbnZhciB0aW1lb3V0X2Vycm9yX2RlZmF1bHQgPSBUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unknown_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass UnknownConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeUnknownConstraintError\";\n    this.message = options.message || \"The specified constraint does not exist\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar unknown_constraint_error_default = UnknownConstraintError;\n//# sourceMappingURL=unknown-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzPzc5YmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gdW5rbm93bl9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9kYXRhYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2RhdGFiYXNlLWVycm9yXCIpKTtcbmNsYXNzIFVua25vd25Db25zdHJhaW50RXJyb3IgZXh0ZW5kcyBpbXBvcnRfZGF0YWJhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IG9wdGlvbnMucGFyZW50IHx8IHsgc3FsOiBcIlwiLCBuYW1lOiBcIlwiLCBtZXNzYWdlOiBcIlwiIH07XG4gICAgc3VwZXIob3B0aW9ucy5wYXJlbnQsIHsgc3RhY2s6IG9wdGlvbnMuc3RhY2sgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbnN0cmFpbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFibGVcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVVbmtub3duQ29uc3RyYWludEVycm9yXCI7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IFwiVGhlIHNwZWNpZmllZCBjb25zdHJhaW50IGRvZXMgbm90IGV4aXN0XCI7XG4gICAgdGhpcy5jb25zdHJhaW50ID0gb3B0aW9ucy5jb25zdHJhaW50O1xuICAgIHRoaXMuZmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy50YWJsZSA9IG9wdGlvbnMudGFibGU7XG4gIH1cbn1cbnZhciB1bmtub3duX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdCA9IFVua25vd25Db25zdHJhaW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmtub3duLWNvbnN0cmFpbnQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => eager_loading_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass EagerLoadingError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEagerLoadingError\";\n  }\n}\nvar eager_loading_error_default = EagerLoadingError;\n//# sourceMappingURL=eager-loading-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZWFnZXItbG9hZGluZy1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZWFnZXItbG9hZGluZy1lcnJvci5qcz84MGZjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBlYWdlcl9sb2FkaW5nX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEVhZ2VyTG9hZGluZ0Vycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUVhZ2VyTG9hZGluZ0Vycm9yXCI7XG4gIH1cbn1cbnZhciBlYWdlcl9sb2FkaW5nX2Vycm9yX2RlZmF1bHQgPSBFYWdlckxvYWRpbmdFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVhZ2VyLWxvYWRpbmctZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => empty_result_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass EmptyResultError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEmptyResultError\";\n  }\n}\nvar empty_result_error_default = EmptyResultError;\n//# sourceMappingURL=empty-result-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9lbXB0eS1yZXN1bHQtZXJyb3IuanM/MTJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gZW1wdHlfcmVzdWx0X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEVtcHR5UmVzdWx0RXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplRW1wdHlSZXN1bHRFcnJvclwiO1xuICB9XG59XG52YXIgZW1wdHlfcmVzdWx0X2Vycm9yX2RlZmF1bHQgPSBFbXB0eVJlc3VsdEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHktcmVzdWx0LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  AccessDeniedError: () => import_access_denied_error.default,\n  AggregateError: () => import_aggregate_error.default,\n  AssociationError: () => import_association_error.default,\n  AsyncQueueError: () => import_async_queue.AsyncQueueError,\n  BaseError: () => import_base_error.default,\n  BulkRecordError: () => import_bulk_record_error.default,\n  ConnectionAcquireTimeoutError: () => import_connection_acquire_timeout_error.default,\n  ConnectionError: () => import_connection_error.default,\n  ConnectionRefusedError: () => import_connection_refused_error.default,\n  ConnectionTimedOutError: () => import_connection_timed_out_error.default,\n  DatabaseError: () => import_database_error.default,\n  EagerLoadingError: () => import_eager_loading_error.default,\n  EmptyResultError: () => import_empty_result_error.default,\n  ExclusionConstraintError: () => import_exclusion_constraint_error.default,\n  ForeignKeyConstraintError: () => import_foreign_key_constraint_error.default,\n  HostNotFoundError: () => import_host_not_found_error.default,\n  HostNotReachableError: () => import_host_not_reachable_error.default,\n  InstanceError: () => import_instance_error.default,\n  InvalidConnectionError: () => import_invalid_connection_error.default,\n  OptimisticLockError: () => import_optimistic_lock_error.default,\n  QueryError: () => import_query_error.default,\n  SequelizeScopeError: () => import_sequelize_scope_error.default,\n  TimeoutError: () => import_timeout_error.default,\n  UniqueConstraintError: () => import_unique_constraint_error.default,\n  UnknownConstraintError: () => import_unknown_constraint_error.default,\n  ValidationError: () => import_validation_error.default,\n  ValidationErrorItem: () => import_validation_error.ValidationErrorItem,\n  ValidationErrorItemOrigin: () => import_validation_error.ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => import_validation_error.ValidationErrorItemType\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_database_error = __toModule(__webpack_require__(/*! ./database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nvar import_aggregate_error = __toModule(__webpack_require__(/*! ./aggregate-error */ \"(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js\"));\nvar import_association_error = __toModule(__webpack_require__(/*! ./association-error */ \"(rsc)/./node_modules/sequelize/lib/errors/association-error.js\"));\nvar import_bulk_record_error = __toModule(__webpack_require__(/*! ./bulk-record-error */ \"(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ./connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nvar import_eager_loading_error = __toModule(__webpack_require__(/*! ./eager-loading-error */ \"(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js\"));\nvar import_empty_result_error = __toModule(__webpack_require__(/*! ./empty-result-error */ \"(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js\"));\nvar import_instance_error = __toModule(__webpack_require__(/*! ./instance-error */ \"(rsc)/./node_modules/sequelize/lib/errors/instance-error.js\"));\nvar import_optimistic_lock_error = __toModule(__webpack_require__(/*! ./optimistic-lock-error */ \"(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js\"));\nvar import_query_error = __toModule(__webpack_require__(/*! ./query-error */ \"(rsc)/./node_modules/sequelize/lib/errors/query-error.js\"));\nvar import_sequelize_scope_error = __toModule(__webpack_require__(/*! ./sequelize-scope-error */ \"(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js\"));\nvar import_validation_error = __toModule(__webpack_require__(/*! ./validation-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\"));\nvar import_access_denied_error = __toModule(__webpack_require__(/*! ./connection/access-denied-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js\"));\nvar import_connection_acquire_timeout_error = __toModule(__webpack_require__(/*! ./connection/connection-acquire-timeout-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\"));\nvar import_connection_refused_error = __toModule(__webpack_require__(/*! ./connection/connection-refused-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js\"));\nvar import_connection_timed_out_error = __toModule(__webpack_require__(/*! ./connection/connection-timed-out-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\"));\nvar import_host_not_found_error = __toModule(__webpack_require__(/*! ./connection/host-not-found-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js\"));\nvar import_host_not_reachable_error = __toModule(__webpack_require__(/*! ./connection/host-not-reachable-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\"));\nvar import_invalid_connection_error = __toModule(__webpack_require__(/*! ./connection/invalid-connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\"));\nvar import_exclusion_constraint_error = __toModule(__webpack_require__(/*! ./database/exclusion-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\"));\nvar import_foreign_key_constraint_error = __toModule(__webpack_require__(/*! ./database/foreign-key-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\"));\nvar import_timeout_error = __toModule(__webpack_require__(/*! ./database/timeout-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js\"));\nvar import_unknown_constraint_error = __toModule(__webpack_require__(/*! ./database/unknown-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\"));\nvar import_unique_constraint_error = __toModule(__webpack_require__(/*! ./validation/unique-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\"));\nvar import_async_queue = __toModule(__webpack_require__(/*! ../dialects/mssql/async-queue */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\"));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pELHVDQUF1QyxtQkFBTyxDQUFDLHFGQUFrQjtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDbkUsMENBQTBDLG1CQUFPLENBQUMsMkZBQXFCO0FBQ3ZFLDBDQUEwQyxtQkFBTyxDQUFDLDJGQUFxQjtBQUN2RSx5Q0FBeUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMsK0ZBQXVCO0FBQzNFLDJDQUEyQyxtQkFBTyxDQUFDLDZGQUFzQjtBQUN6RSx1Q0FBdUMsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDakUsOENBQThDLG1CQUFPLENBQUMsbUdBQXlCO0FBQy9FLG9DQUFvQyxtQkFBTyxDQUFDLCtFQUFlO0FBQzNELDhDQUE4QyxtQkFBTyxDQUFDLG1HQUF5QjtBQUMvRSx5Q0FBeUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMscUhBQWtDO0FBQ3RGLHlEQUF5RCxtQkFBTyxDQUFDLCtJQUErQztBQUNoSCxpREFBaUQsbUJBQU8sQ0FBQywrSEFBdUM7QUFDaEcsbURBQW1ELG1CQUFPLENBQUMsbUlBQXlDO0FBQ3BHLDZDQUE2QyxtQkFBTyxDQUFDLHVIQUFtQztBQUN4RixpREFBaUQsbUJBQU8sQ0FBQywrSEFBdUM7QUFDaEcsaURBQWlELG1CQUFPLENBQUMsK0hBQXVDO0FBQ2hHLG1EQUFtRCxtQkFBTyxDQUFDLCtIQUF1QztBQUNsRyxxREFBcUQsbUJBQU8sQ0FBQyxtSUFBeUM7QUFDdEcsc0NBQXNDLG1CQUFPLENBQUMscUdBQTBCO0FBQ3hFLGlEQUFpRCxtQkFBTyxDQUFDLDJIQUFxQztBQUM5RixnREFBZ0QsbUJBQU8sQ0FBQyw2SEFBc0M7QUFDOUYsb0NBQW9DLG1CQUFPLENBQUMsdUdBQStCO0FBQzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luZGV4LmpzPzk3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIEFjY2Vzc0RlbmllZEVycm9yOiAoKSA9PiBpbXBvcnRfYWNjZXNzX2RlbmllZF9lcnJvci5kZWZhdWx0LFxuICBBZ2dyZWdhdGVFcnJvcjogKCkgPT4gaW1wb3J0X2FnZ3JlZ2F0ZV9lcnJvci5kZWZhdWx0LFxuICBBc3NvY2lhdGlvbkVycm9yOiAoKSA9PiBpbXBvcnRfYXNzb2NpYXRpb25fZXJyb3IuZGVmYXVsdCxcbiAgQXN5bmNRdWV1ZUVycm9yOiAoKSA9PiBpbXBvcnRfYXN5bmNfcXVldWUuQXN5bmNRdWV1ZUVycm9yLFxuICBCYXNlRXJyb3I6ICgpID0+IGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQsXG4gIEJ1bGtSZWNvcmRFcnJvcjogKCkgPT4gaW1wb3J0X2J1bGtfcmVjb3JkX2Vycm9yLmRlZmF1bHQsXG4gIENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yOiAoKSA9PiBpbXBvcnRfY29ubmVjdGlvbl9hY3F1aXJlX3RpbWVvdXRfZXJyb3IuZGVmYXVsdCxcbiAgQ29ubmVjdGlvbkVycm9yOiAoKSA9PiBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0LFxuICBDb25uZWN0aW9uUmVmdXNlZEVycm9yOiAoKSA9PiBpbXBvcnRfY29ubmVjdGlvbl9yZWZ1c2VkX2Vycm9yLmRlZmF1bHQsXG4gIENvbm5lY3Rpb25UaW1lZE91dEVycm9yOiAoKSA9PiBpbXBvcnRfY29ubmVjdGlvbl90aW1lZF9vdXRfZXJyb3IuZGVmYXVsdCxcbiAgRGF0YWJhc2VFcnJvcjogKCkgPT4gaW1wb3J0X2RhdGFiYXNlX2Vycm9yLmRlZmF1bHQsXG4gIEVhZ2VyTG9hZGluZ0Vycm9yOiAoKSA9PiBpbXBvcnRfZWFnZXJfbG9hZGluZ19lcnJvci5kZWZhdWx0LFxuICBFbXB0eVJlc3VsdEVycm9yOiAoKSA9PiBpbXBvcnRfZW1wdHlfcmVzdWx0X2Vycm9yLmRlZmF1bHQsXG4gIEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcjogKCkgPT4gaW1wb3J0X2V4Y2x1c2lvbl9jb25zdHJhaW50X2Vycm9yLmRlZmF1bHQsXG4gIEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3I6ICgpID0+IGltcG9ydF9mb3JlaWduX2tleV9jb25zdHJhaW50X2Vycm9yLmRlZmF1bHQsXG4gIEhvc3ROb3RGb3VuZEVycm9yOiAoKSA9PiBpbXBvcnRfaG9zdF9ub3RfZm91bmRfZXJyb3IuZGVmYXVsdCxcbiAgSG9zdE5vdFJlYWNoYWJsZUVycm9yOiAoKSA9PiBpbXBvcnRfaG9zdF9ub3RfcmVhY2hhYmxlX2Vycm9yLmRlZmF1bHQsXG4gIEluc3RhbmNlRXJyb3I6ICgpID0+IGltcG9ydF9pbnN0YW5jZV9lcnJvci5kZWZhdWx0LFxuICBJbnZhbGlkQ29ubmVjdGlvbkVycm9yOiAoKSA9PiBpbXBvcnRfaW52YWxpZF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQsXG4gIE9wdGltaXN0aWNMb2NrRXJyb3I6ICgpID0+IGltcG9ydF9vcHRpbWlzdGljX2xvY2tfZXJyb3IuZGVmYXVsdCxcbiAgUXVlcnlFcnJvcjogKCkgPT4gaW1wb3J0X3F1ZXJ5X2Vycm9yLmRlZmF1bHQsXG4gIFNlcXVlbGl6ZVNjb3BlRXJyb3I6ICgpID0+IGltcG9ydF9zZXF1ZWxpemVfc2NvcGVfZXJyb3IuZGVmYXVsdCxcbiAgVGltZW91dEVycm9yOiAoKSA9PiBpbXBvcnRfdGltZW91dF9lcnJvci5kZWZhdWx0LFxuICBVbmlxdWVDb25zdHJhaW50RXJyb3I6ICgpID0+IGltcG9ydF91bmlxdWVfY29uc3RyYWludF9lcnJvci5kZWZhdWx0LFxuICBVbmtub3duQ29uc3RyYWludEVycm9yOiAoKSA9PiBpbXBvcnRfdW5rbm93bl9jb25zdHJhaW50X2Vycm9yLmRlZmF1bHQsXG4gIFZhbGlkYXRpb25FcnJvcjogKCkgPT4gaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IuZGVmYXVsdCxcbiAgVmFsaWRhdGlvbkVycm9ySXRlbTogKCkgPT4gaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbSxcbiAgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjogKCkgPT4gaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbixcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGU6ICgpID0+IGltcG9ydF92YWxpZGF0aW9uX2Vycm9yLlZhbGlkYXRpb25FcnJvckl0ZW1UeXBlXG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2RhdGFiYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9kYXRhYmFzZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2FnZ3JlZ2F0ZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYWdncmVnYXRlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfYXNzb2NpYXRpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9uLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfYnVsa19yZWNvcmRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2J1bGstcmVjb3JkLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2VhZ2VyX2xvYWRpbmdfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2VhZ2VyLWxvYWRpbmctZXJyb3JcIikpO1xudmFyIGltcG9ydF9lbXB0eV9yZXN1bHRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2VtcHR5LXJlc3VsdC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2luc3RhbmNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9pbnN0YW5jZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X29wdGltaXN0aWNfbG9ja19lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vb3B0aW1pc3RpYy1sb2NrLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfcXVlcnlfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL3F1ZXJ5LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfc2VxdWVsaXplX3Njb3BlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9zZXF1ZWxpemUtc2NvcGUtZXJyb3JcIikpO1xudmFyIGltcG9ydF92YWxpZGF0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi92YWxpZGF0aW9uLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfYWNjZXNzX2RlbmllZF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9hY3F1aXJlX3RpbWVvdXRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1hY3F1aXJlLXRpbWVvdXQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX3JlZnVzZWRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl90aW1lZF9vdXRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi10aW1lZC1vdXQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9ob3N0X25vdF9mb3VuZF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2hvc3Rfbm90X3JlYWNoYWJsZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3JcIikpO1xudmFyIGltcG9ydF9pbnZhbGlkX2Nvbm5lY3Rpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24vaW52YWxpZC1jb25uZWN0aW9uLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfZXhjbHVzaW9uX2NvbnN0cmFpbnRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2RhdGFiYXNlL2V4Y2x1c2lvbi1jb25zdHJhaW50LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfZm9yZWlnbl9rZXlfY29uc3RyYWludF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3RpbWVvdXRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2RhdGFiYXNlL3RpbWVvdXQtZXJyb3JcIikpO1xudmFyIGltcG9ydF91bmtub3duX2NvbnN0cmFpbnRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2RhdGFiYXNlL3Vua25vd24tY29uc3RyYWludC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3VuaXF1ZV9jb25zdHJhaW50X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfYXN5bmNfcXVldWUgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/instance-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/instance-error.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => instance_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass InstanceError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeInstanceError\";\n  }\n}\nvar instance_error_default = InstanceError;\n//# sourceMappingURL=instance-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5zdGFuY2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2luc3RhbmNlLWVycm9yLmpzPzkzY2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGluc3RhbmNlX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIEluc3RhbmNlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplSW5zdGFuY2VFcnJvclwiO1xuICB9XG59XG52YXIgaW5zdGFuY2VfZXJyb3JfZGVmYXVsdCA9IEluc3RhbmNlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnN0YW5jZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/instance-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => optimistic_lock_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass OptimisticLockError extends import_base_error.default {\n  constructor(options) {\n    options = options || {};\n    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;\n    super(options.message);\n    __publicField(this, \"modelName\");\n    __publicField(this, \"values\");\n    __publicField(this, \"where\");\n    this.name = \"SequelizeOptimisticLockError\";\n    this.modelName = options.modelName;\n    this.values = options.values;\n    this.where = options.where;\n  }\n}\nvar optimistic_lock_error_default = OptimisticLockError;\n//# sourceMappingURL=optimistic-lock-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvb3B0aW1pc3RpYy1sb2NrLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL29wdGltaXN0aWMtbG9jay1lcnJvci5qcz9jZTBmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IG9wdGltaXN0aWNfbG9ja19lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBPcHRpbWlzdGljTG9ja0Vycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgYEF0dGVtcHRpbmcgdG8gdXBkYXRlIGEgc3RhbGUgbW9kZWwgaW5zdGFuY2U6ICR7b3B0aW9ucy5tb2RlbE5hbWV9YDtcbiAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb2RlbE5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbHVlc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid2hlcmVcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVPcHRpbWlzdGljTG9ja0Vycm9yXCI7XG4gICAgdGhpcy5tb2RlbE5hbWUgPSBvcHRpb25zLm1vZGVsTmFtZTtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMud2hlcmUgPSBvcHRpb25zLndoZXJlO1xuICB9XG59XG52YXIgb3B0aW1pc3RpY19sb2NrX2Vycm9yX2RlZmF1bHQgPSBPcHRpbWlzdGljTG9ja0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW1pc3RpYy1sb2NrLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/query-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/query-error.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => query_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass QueryError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeQueryError\";\n  }\n}\nvar query_error_default = QueryError;\n//# sourceMappingURL=query-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvcXVlcnktZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL3F1ZXJ5LWVycm9yLmpzPzlmNzIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHF1ZXJ5X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIFF1ZXJ5RXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplUXVlcnlFcnJvclwiO1xuICB9XG59XG52YXIgcXVlcnlfZXJyb3JfZGVmYXVsdCA9IFF1ZXJ5RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/query-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => sequelize_scope_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass SequelizeScopeError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeScopeError\";\n  }\n}\nvar sequelize_scope_error_default = SequelizeScopeError;\n//# sourceMappingURL=sequelize-scope-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvc2VxdWVsaXplLXNjb3BlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9zZXF1ZWxpemUtc2NvcGUtZXJyb3IuanM/MDA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gc2VxdWVsaXplX3Njb3BlX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIFNlcXVlbGl6ZVNjb3BlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplU2NvcGVFcnJvclwiO1xuICB9XG59XG52YXIgc2VxdWVsaXplX3Njb3BlX2Vycm9yX2RlZmF1bHQgPSBTZXF1ZWxpemVTY29wZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVsaXplLXNjb3BlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/validation-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation-error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  ValidationErrorItem: () => ValidationErrorItem,\n  ValidationErrorItemOrigin: () => ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => ValidationErrorItemType,\n  default: () => validation_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar ValidationErrorItemType = /* @__PURE__ */ ((ValidationErrorItemType2) => {\n  ValidationErrorItemType2[\"notnull violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"string violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"unique violation\"] = \"DB\";\n  ValidationErrorItemType2[\"validation error\"] = \"FUNCTION\";\n  return ValidationErrorItemType2;\n})(ValidationErrorItemType || {});\nvar ValidationErrorItemOrigin = /* @__PURE__ */ ((ValidationErrorItemOrigin2) => {\n  ValidationErrorItemOrigin2[\"CORE\"] = \"CORE\";\n  ValidationErrorItemOrigin2[\"DB\"] = \"DB\";\n  ValidationErrorItemOrigin2[\"FUNCTION\"] = \"FUNCTION\";\n  return ValidationErrorItemOrigin2;\n})(ValidationErrorItemOrigin || {});\nclass ValidationErrorItem {\n  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {\n    __publicField(this, \"message\");\n    __publicField(this, \"type\");\n    __publicField(this, \"path\");\n    __publicField(this, \"value\");\n    __publicField(this, \"origin\");\n    __publicField(this, \"instance\");\n    __publicField(this, \"validatorKey\");\n    __publicField(this, \"validatorName\");\n    __publicField(this, \"validatorArgs\");\n    this.message = message || \"\";\n    this.type = null;\n    this.path = path || null;\n    this.value = value !== void 0 ? value : null;\n    this.origin = null;\n    this.instance = instance || null;\n    this.validatorKey = validatorKey || null;\n    this.validatorName = fnName || null;\n    this.validatorArgs = fnArgs || [];\n    if (type) {\n      if (this.isValidationErrorItemOrigin(type)) {\n        this.origin = type;\n      } else {\n        const lowercaseType = this.normalizeString(type);\n        const realType = ValidationErrorItemType[lowercaseType];\n        if (realType && ValidationErrorItemOrigin[realType]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n  }\n  isValidationErrorItemOrigin(origin) {\n    return ValidationErrorItemOrigin[origin] !== void 0;\n  }\n  normalizeString(str) {\n    return str.toLowerCase().trim();\n  }\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === void 0 || !!useTypeAsNS;\n    const NSSep = NSSeparator === void 0 ? \".\" : NSSeparator;\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItemOrigin[type];\n    if (useNS && (typeof NSSep !== \"string\" || !NSSep.length)) {\n      throw new Error(\"Invalid namespace separator given, must be a non-empty string\");\n    }\n    if (!(typeof key === \"string\" && key.length)) {\n      return \"\";\n    }\n    return (useNS ? [this.origin, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n__publicField(ValidationErrorItem, \"TypeStringMap\", ValidationErrorItemType);\n__publicField(ValidationErrorItem, \"Origins\", ValidationErrorItemOrigin);\nclass ValidationError extends import_base_error.default {\n  constructor(message, errors, options = {}) {\n    super(message);\n    __publicField(this, \"errors\");\n    this.name = \"SequelizeValidationError\";\n    this.message = \"Validation Error\";\n    this.errors = errors || [];\n    if (message) {\n      this.message = message;\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map((err) => `${err.type || err.origin}: ${err.message}`).join(\",\\n\");\n    }\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\nvar validation_error_default = ValidationError;\n//# sourceMappingURL=validation-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saURBQWlELHVCQUF1QixJQUFJLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy92YWxpZGF0aW9uLWVycm9yLmpzP2MzZDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbTogKCkgPT4gVmFsaWRhdGlvbkVycm9ySXRlbSxcbiAgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjogKCkgPT4gVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbixcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGU6ICgpID0+IFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlLFxuICBkZWZhdWx0OiAoKSA9PiB2YWxpZGF0aW9uX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbnZhciBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMikgPT4ge1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTJbXCJub3RudWxsIHZpb2xhdGlvblwiXSA9IFwiQ09SRVwiO1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTJbXCJzdHJpbmcgdmlvbGF0aW9uXCJdID0gXCJDT1JFXCI7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMltcInVuaXF1ZSB2aW9sYXRpb25cIl0gPSBcIkRCXCI7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMltcInZhbGlkYXRpb24gZXJyb3JcIl0gPSBcIkZVTkNUSU9OXCI7XG4gIHJldHVybiBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTI7XG59KShWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZSB8fCB7fSk7XG52YXIgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4yKSA9PiB7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4yW1wiQ09SRVwiXSA9IFwiQ09SRVwiO1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luMltcIkRCXCJdID0gXCJEQlwiO1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luMltcIkZVTkNUSU9OXCJdID0gXCJGVU5DVElPTlwiO1xuICByZXR1cm4gVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjI7XG59KShWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luIHx8IHt9KTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvckl0ZW0ge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0eXBlLCBwYXRoLCB2YWx1ZSwgaW5zdGFuY2UsIHZhbGlkYXRvcktleSwgZm5OYW1lLCBmbkFyZ3MpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWVzc2FnZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidHlwZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGF0aFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9yaWdpblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaW5zdGFuY2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZhbGlkYXRvcktleVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsaWRhdG9yTmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsaWRhdG9yQXJnc1wiKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IFwiXCI7XG4gICAgdGhpcy50eXBlID0gbnVsbDtcbiAgICB0aGlzLnBhdGggPSBwYXRoIHx8IG51bGw7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IG51bGw7XG4gICAgdGhpcy5vcmlnaW4gPSBudWxsO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZSB8fCBudWxsO1xuICAgIHRoaXMudmFsaWRhdG9yS2V5ID0gdmFsaWRhdG9yS2V5IHx8IG51bGw7XG4gICAgdGhpcy52YWxpZGF0b3JOYW1lID0gZm5OYW1lIHx8IG51bGw7XG4gICAgdGhpcy52YWxpZGF0b3JBcmdzID0gZm5BcmdzIHx8IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAodGhpcy5pc1ZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4odHlwZSkpIHtcbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVHlwZSA9IHRoaXMubm9ybWFsaXplU3RyaW5nKHR5cGUpO1xuICAgICAgICBjb25zdCByZWFsVHlwZSA9IFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlW2xvd2VyY2FzZVR5cGVdO1xuICAgICAgICBpZiAocmVhbFR5cGUgJiYgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbltyZWFsVHlwZV0pIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbiA9IHJlYWxUeXBlO1xuICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luKG9yaWdpbikge1xuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luW29yaWdpbl0gIT09IHZvaWQgMDtcbiAgfVxuICBub3JtYWxpemVTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfVxuICBnZXRWYWxpZGF0b3JLZXkodXNlVHlwZUFzTlMsIE5TU2VwYXJhdG9yKSB7XG4gICAgY29uc3QgdXNlVEFOUyA9IHVzZVR5cGVBc05TID09PSB2b2lkIDAgfHwgISF1c2VUeXBlQXNOUztcbiAgICBjb25zdCBOU1NlcCA9IE5TU2VwYXJhdG9yID09PSB2b2lkIDAgPyBcIi5cIiA6IE5TU2VwYXJhdG9yO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLm9yaWdpbjtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnZhbGlkYXRvcktleSB8fCB0aGlzLnZhbGlkYXRvck5hbWU7XG4gICAgY29uc3QgdXNlTlMgPSB1c2VUQU5TICYmIHR5cGUgJiYgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpblt0eXBlXTtcbiAgICBpZiAodXNlTlMgJiYgKHR5cGVvZiBOU1NlcCAhPT0gXCJzdHJpbmdcIiB8fCAhTlNTZXAubGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuYW1lc3BhY2Ugc2VwYXJhdG9yIGdpdmVuLCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKCEodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBrZXkubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiAodXNlTlMgPyBbdGhpcy5vcmlnaW4sIGtleV0uam9pbihOU1NlcCkgOiBrZXkpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB9XG59XG5fX3B1YmxpY0ZpZWxkKFZhbGlkYXRpb25FcnJvckl0ZW0sIFwiVHlwZVN0cmluZ01hcFwiLCBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZSk7XG5fX3B1YmxpY0ZpZWxkKFZhbGlkYXRpb25FcnJvckl0ZW0sIFwiT3JpZ2luc1wiLCBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luKTtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlcnJvcnNcIik7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVWYWxpZGF0aW9uRXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gRXJyb3JcIjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA+IDAgJiYgdGhpcy5lcnJvcnNbMF0ubWVzc2FnZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubWFwKChlcnIpID0+IGAke2Vyci50eXBlIHx8IGVyci5vcmlnaW59OiAke2Vyci5tZXNzYWdlfWApLmpvaW4oXCIsXFxuXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zdGFjaykge1xuICAgICAgdGhpcy5zdGFjayA9IG9wdGlvbnMuc3RhY2s7XG4gICAgfVxuICB9XG4gIGdldChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3JzLnJlZHVjZSgocmVkdWNlZCwgZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvci5wYXRoID09PSBwYXRoKSB7XG4gICAgICAgIHJlZHVjZWQucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVkdWNlZDtcbiAgICB9LCBbXSk7XG4gIH1cbn1cbnZhciB2YWxpZGF0aW9uX2Vycm9yX2RlZmF1bHQgPSBWYWxpZGF0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unique_constraint_error_default\n});\nvar import_validation_error = __toModule(__webpack_require__(/*! ../validation-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\"));\nclass UniqueConstraintError extends import_validation_error.default {\n  constructor(options) {\n    var _a, _b, _c;\n    options = options != null ? options : {};\n    options.parent = (_a = options.parent) != null ? _a : { sql: \"\", name: \"\", message: \"\" };\n    options.message = options.message || options.parent.message || \"Validation Error\";\n    options.errors = (_b = options.errors) != null ? _b : [];\n    super(options.message, options.errors, { stack: options.stack });\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"sql\");\n    this.name = \"SequelizeUniqueConstraintError\";\n    this.fields = (_c = options.fields) != null ? _c : {};\n    this.parent = options.parent;\n    this.original = options.parent;\n    this.sql = options.parent.sql;\n  }\n}\nvar unique_constraint_error_default = UniqueConstraintError;\n//# sourceMappingURL=unique-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvci5qcz8yYTljIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHVuaXF1ZV9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF92YWxpZGF0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vdmFsaWRhdGlvbi1lcnJvclwiKSk7XG5jbGFzcyBVbmlxdWVDb25zdHJhaW50RXJyb3IgZXh0ZW5kcyBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSAoX2EgPSBvcHRpb25zLnBhcmVudCkgIT0gbnVsbCA/IF9hIDogeyBzcWw6IFwiXCIsIG5hbWU6IFwiXCIsIG1lc3NhZ2U6IFwiXCIgfTtcbiAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5wYXJlbnQubWVzc2FnZSB8fCBcIlZhbGlkYXRpb24gRXJyb3JcIjtcbiAgICBvcHRpb25zLmVycm9ycyA9IChfYiA9IG9wdGlvbnMuZXJyb3JzKSAhPSBudWxsID8gX2IgOiBbXTtcbiAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UsIG9wdGlvbnMuZXJyb3JzLCB7IHN0YWNrOiBvcHRpb25zLnN0YWNrIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9yaWdpbmFsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWVsZHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNxbFwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVVuaXF1ZUNvbnN0cmFpbnRFcnJvclwiO1xuICAgIHRoaXMuZmllbGRzID0gKF9jID0gb3B0aW9ucy5maWVsZHMpICE9IG51bGwgPyBfYyA6IHt9O1xuICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy5vcmlnaW5hbCA9IG9wdGlvbnMucGFyZW50O1xuICAgIHRoaXMuc3FsID0gb3B0aW9ucy5wYXJlbnQuc3FsO1xuICB9XG59XG52YXIgdW5pcXVlX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdCA9IFVuaXF1ZUNvbnN0cmFpbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXF1ZS1jb25zdHJhaW50LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"hooks\");\nconst hookTypes = {\n  beforeValidate: { params: 2 },\n  afterValidate: { params: 2 },\n  validationFailed: { params: 3 },\n  beforeCreate: { params: 2 },\n  afterCreate: { params: 2 },\n  beforeDestroy: { params: 2 },\n  afterDestroy: { params: 2 },\n  beforeRestore: { params: 2 },\n  afterRestore: { params: 2 },\n  beforeUpdate: { params: 2 },\n  afterUpdate: { params: 2 },\n  beforeSave: { params: 2, proxies: [\"beforeUpdate\", \"beforeCreate\"] },\n  afterSave: { params: 2, proxies: [\"afterUpdate\", \"afterCreate\"] },\n  beforeUpsert: { params: 2 },\n  afterUpsert: { params: 2 },\n  beforeBulkCreate: { params: 2 },\n  afterBulkCreate: { params: 2 },\n  beforeBulkDestroy: { params: 1 },\n  afterBulkDestroy: { params: 1 },\n  beforeBulkRestore: { params: 1 },\n  afterBulkRestore: { params: 1 },\n  beforeBulkUpdate: { params: 1 },\n  afterBulkUpdate: { params: 1 },\n  beforeFind: { params: 1 },\n  beforeFindAfterExpandIncludeAll: { params: 1 },\n  beforeFindAfterOptions: { params: 1 },\n  afterFind: { params: 2 },\n  beforeCount: { params: 1 },\n  beforeDefine: { params: 2, sync: true, noModel: true },\n  afterDefine: { params: 1, sync: true, noModel: true },\n  beforeInit: { params: 2, sync: true, noModel: true },\n  afterInit: { params: 1, sync: true, noModel: true },\n  beforeAssociate: { params: 2, sync: true },\n  afterAssociate: { params: 2, sync: true },\n  beforeConnect: { params: 1, noModel: true },\n  afterConnect: { params: 2, noModel: true },\n  beforeDisconnect: { params: 1, noModel: true },\n  afterDisconnect: { params: 1, noModel: true },\n  beforePoolAcquire: { params: 1, noModel: true },\n  afterPoolAcquire: { params: 2, noModel: true },\n  beforeSync: { params: 1 },\n  afterSync: { params: 1 },\n  beforeBulkSync: { params: 1 },\n  afterBulkSync: { params: 1 },\n  beforeQuery: { params: 2 },\n  afterQuery: { params: 2 }\n};\nexports.hooks = hookTypes;\nconst getProxiedHooks = (hookType) => hookTypes[hookType].proxies ? hookTypes[hookType].proxies.concat(hookType) : [hookType];\nfunction getHooks(hooked, hookType) {\n  return (hooked.options.hooks || {})[hookType] || [];\n}\nconst Hooks = {\n  _setupHooks(hooks) {\n    this.options.hooks = {};\n    _.map(hooks || {}, (hooksArray, hookName) => {\n      if (!Array.isArray(hooksArray))\n        hooksArray = [hooksArray];\n      hooksArray.forEach((hookFn) => this.addHook(hookName, hookFn));\n    });\n  },\n  async runHooks(hooks, ...hookArgs) {\n    if (!hooks)\n      throw new Error(\"runHooks requires at least 1 argument\");\n    let hookType;\n    if (typeof hooks === \"string\") {\n      hookType = hooks;\n      hooks = getHooks(this, hookType);\n      if (this.sequelize) {\n        hooks = hooks.concat(getHooks(this.sequelize, hookType));\n      }\n    }\n    if (!Array.isArray(hooks)) {\n      hooks = [hooks];\n    }\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      for (let hook of hooks) {\n        if (typeof hook === \"object\") {\n          hook = hook.fn;\n        }\n        debug(`running hook(sync) ${hookType}`);\n        hook.apply(this, hookArgs);\n      }\n      return;\n    }\n    for (let hook of hooks) {\n      if (typeof hook === \"object\") {\n        hook = hook.fn;\n      }\n      debug(`running hook ${hookType}`);\n      await hook.apply(this, hookArgs);\n    }\n  },\n  addHook(hookType, name, fn) {\n    if (typeof name === \"function\") {\n      fn = name;\n      name = null;\n    }\n    debug(`adding hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    hookType.forEach((type) => {\n      const hooks = getHooks(this, type);\n      hooks.push(name ? { name, fn } : fn);\n      this.options.hooks[type] = hooks;\n    });\n    return this;\n  },\n  removeHook(hookType, name) {\n    const isReference = typeof name === \"function\" ? true : false;\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n    debug(`removing hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    for (const type of hookType) {\n      this.options.hooks[type] = this.options.hooks[type].filter((hook) => {\n        if (isReference && typeof hook === \"function\") {\n          return hook !== name;\n        }\n        if (!isReference && typeof hook === \"object\") {\n          return hook.name !== name;\n        }\n        return true;\n      });\n    }\n    return this;\n  },\n  hasHook(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  }\n};\nHooks.hasHooks = Hooks.hasHook;\nfunction applyTo(target, isModel = false) {\n  _.mixin(target, Hooks);\n  for (const hook of Object.keys(hookTypes)) {\n    if (isModel && hookTypes[hook].noModel) {\n      continue;\n    }\n    target[hook] = function(name, callback) {\n      return this.addHook(hook, name, callback);\n    };\n  }\n}\nexports.applyTo = applyTo;\n//# sourceMappingURL=hooks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9ob29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDBFQUFnQjtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0IsbUJBQW1CLFdBQVc7QUFDOUIsc0JBQXNCLFdBQVc7QUFDakMsa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0IsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsZ0JBQWdCLHNEQUFzRDtBQUN0RSxlQUFlLG9EQUFvRDtBQUNuRSxrQkFBa0IsV0FBVztBQUM3QixpQkFBaUIsV0FBVztBQUM1QixzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyxzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyxnQkFBZ0IsV0FBVztBQUMzQixxQ0FBcUMsV0FBVztBQUNoRCw0QkFBNEIsV0FBVztBQUN2QyxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUIsa0JBQWtCLHNDQUFzQztBQUN4RCxpQkFBaUIsc0NBQXNDO0FBQ3ZELGdCQUFnQixzQ0FBc0M7QUFDdEQsZUFBZSxzQ0FBc0M7QUFDckQscUJBQXFCLHVCQUF1QjtBQUM1QyxvQkFBb0IsdUJBQXVCO0FBQzNDLG1CQUFtQiwwQkFBMEI7QUFDN0Msa0JBQWtCLDBCQUEwQjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELHFCQUFxQiwwQkFBMEI7QUFDL0MsdUJBQXVCLDBCQUEwQjtBQUNqRCxzQkFBc0IsMEJBQTBCO0FBQ2hELGdCQUFnQixXQUFXO0FBQzNCLGVBQWUsV0FBVztBQUMxQixvQkFBb0IsV0FBVztBQUMvQixtQkFBbUIsV0FBVztBQUM5QixpQkFBaUIsV0FBVztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaG9va3MuanM/OTFmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImhvb2tzXCIpO1xuY29uc3QgaG9va1R5cGVzID0ge1xuICBiZWZvcmVWYWxpZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJWYWxpZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgdmFsaWRhdGlvbkZhaWxlZDogeyBwYXJhbXM6IDMgfSxcbiAgYmVmb3JlQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlckNyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlRGVzdHJveTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJEZXN0cm95OiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVSZXN0b3JlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclJlc3RvcmU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVVwZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJVcGRhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVNhdmU6IHsgcGFyYW1zOiAyLCBwcm94aWVzOiBbXCJiZWZvcmVVcGRhdGVcIiwgXCJiZWZvcmVDcmVhdGVcIl0gfSxcbiAgYWZ0ZXJTYXZlOiB7IHBhcmFtczogMiwgcHJveGllczogW1wiYWZ0ZXJVcGRhdGVcIiwgXCJhZnRlckNyZWF0ZVwiXSB9LFxuICBiZWZvcmVVcHNlcnQ6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyVXBzZXJ0OiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVCdWxrQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlckJ1bGtDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUJ1bGtEZXN0cm95OiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtEZXN0cm95OiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrUmVzdG9yZTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrUmVzdG9yZTogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlQnVsa1VwZGF0ZTogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrVXBkYXRlOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVGaW5kQWZ0ZXJPcHRpb25zOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckZpbmQ6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUNvdW50OiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVEZWZpbmU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyRGVmaW5lOiB7IHBhcmFtczogMSwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVJbml0OiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckluaXQ6IHsgcGFyYW1zOiAxLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZUFzc29jaWF0ZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUgfSxcbiAgYWZ0ZXJBc3NvY2lhdGU6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlIH0sXG4gIGJlZm9yZUNvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVyQ29ubmVjdDogeyBwYXJhbXM6IDIsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlRGlzY29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJEaXNjb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVQb29sQWNxdWlyZTogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJQb29sQWNxdWlyZTogeyBwYXJhbXM6IDIsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJTeW5jOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYWZ0ZXJCdWxrU3luYzogeyBwYXJhbXM6IDEgfSxcbiAgYmVmb3JlUXVlcnk6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyUXVlcnk6IHsgcGFyYW1zOiAyIH1cbn07XG5leHBvcnRzLmhvb2tzID0gaG9va1R5cGVzO1xuY29uc3QgZ2V0UHJveGllZEhvb2tzID0gKGhvb2tUeXBlKSA9PiBob29rVHlwZXNbaG9va1R5cGVdLnByb3hpZXMgPyBob29rVHlwZXNbaG9va1R5cGVdLnByb3hpZXMuY29uY2F0KGhvb2tUeXBlKSA6IFtob29rVHlwZV07XG5mdW5jdGlvbiBnZXRIb29rcyhob29rZWQsIGhvb2tUeXBlKSB7XG4gIHJldHVybiAoaG9va2VkLm9wdGlvbnMuaG9va3MgfHwge30pW2hvb2tUeXBlXSB8fCBbXTtcbn1cbmNvbnN0IEhvb2tzID0ge1xuICBfc2V0dXBIb29rcyhob29rcykge1xuICAgIHRoaXMub3B0aW9ucy5ob29rcyA9IHt9O1xuICAgIF8ubWFwKGhvb2tzIHx8IHt9LCAoaG9va3NBcnJheSwgaG9va05hbWUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShob29rc0FycmF5KSlcbiAgICAgICAgaG9va3NBcnJheSA9IFtob29rc0FycmF5XTtcbiAgICAgIGhvb2tzQXJyYXkuZm9yRWFjaCgoaG9va0ZuKSA9PiB0aGlzLmFkZEhvb2soaG9va05hbWUsIGhvb2tGbikpO1xuICAgIH0pO1xuICB9LFxuICBhc3luYyBydW5Ib29rcyhob29rcywgLi4uaG9va0FyZ3MpIHtcbiAgICBpZiAoIWhvb2tzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVuSG9va3MgcmVxdWlyZXMgYXQgbGVhc3QgMSBhcmd1bWVudFwiKTtcbiAgICBsZXQgaG9va1R5cGU7XG4gICAgaWYgKHR5cGVvZiBob29rcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaG9va1R5cGUgPSBob29rcztcbiAgICAgIGhvb2tzID0gZ2V0SG9va3ModGhpcywgaG9va1R5cGUpO1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplKSB7XG4gICAgICAgIGhvb2tzID0gaG9va3MuY29uY2F0KGdldEhvb2tzKHRoaXMuc2VxdWVsaXplLCBob29rVHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaG9va3MpKSB7XG4gICAgICBob29rcyA9IFtob29rc107XG4gICAgfVxuICAgIGlmIChob29rVHlwZXNbaG9va1R5cGVdICYmIGhvb2tUeXBlc1tob29rVHlwZV0uc3luYykge1xuICAgICAgZm9yIChsZXQgaG9vayBvZiBob29rcykge1xuICAgICAgICBpZiAodHlwZW9mIGhvb2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBob29rID0gaG9vay5mbjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhgcnVubmluZyBob29rKHN5bmMpICR7aG9va1R5cGV9YCk7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgaG9va0FyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBob29rIG9mIGhvb2tzKSB7XG4gICAgICBpZiAodHlwZW9mIGhvb2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaG9vayA9IGhvb2suZm47XG4gICAgICB9XG4gICAgICBkZWJ1ZyhgcnVubmluZyBob29rICR7aG9va1R5cGV9YCk7XG4gICAgICBhd2FpdCBob29rLmFwcGx5KHRoaXMsIGhvb2tBcmdzKTtcbiAgICB9XG4gIH0sXG4gIGFkZEhvb2soaG9va1R5cGUsIG5hbWUsIGZuKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZuID0gbmFtZTtcbiAgICAgIG5hbWUgPSBudWxsO1xuICAgIH1cbiAgICBkZWJ1ZyhgYWRkaW5nIGhvb2sgJHtob29rVHlwZX1gKTtcbiAgICBob29rVHlwZSA9IGdldFByb3hpZWRIb29rcyhob29rVHlwZSk7XG4gICAgaG9va1R5cGUuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgY29uc3QgaG9va3MgPSBnZXRIb29rcyh0aGlzLCB0eXBlKTtcbiAgICAgIGhvb2tzLnB1c2gobmFtZSA/IHsgbmFtZSwgZm4gfSA6IGZuKTtcbiAgICAgIHRoaXMub3B0aW9ucy5ob29rc1t0eXBlXSA9IGhvb2tzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVIb29rKGhvb2tUeXBlLCBuYW1lKSB7XG4gICAgY29uc3QgaXNSZWZlcmVuY2UgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGlmICghdGhpcy5oYXNIb29rKGhvb2tUeXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlYnVnKGByZW1vdmluZyBob29rICR7aG9va1R5cGV9YCk7XG4gICAgaG9va1R5cGUgPSBnZXRQcm94aWVkSG9va3MoaG9va1R5cGUpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBob29rVHlwZSkge1xuICAgICAgdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdID0gdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdLmZpbHRlcigoaG9vaykgPT4ge1xuICAgICAgICBpZiAoaXNSZWZlcmVuY2UgJiYgdHlwZW9mIGhvb2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBob29rICE9PSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNSZWZlcmVuY2UgJiYgdHlwZW9mIGhvb2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZXR1cm4gaG9vay5uYW1lICE9PSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBoYXNIb29rKGhvb2tUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ob29rc1tob29rVHlwZV0gJiYgISF0aGlzLm9wdGlvbnMuaG9va3NbaG9va1R5cGVdLmxlbmd0aDtcbiAgfVxufTtcbkhvb2tzLmhhc0hvb2tzID0gSG9va3MuaGFzSG9vaztcbmZ1bmN0aW9uIGFwcGx5VG8odGFyZ2V0LCBpc01vZGVsID0gZmFsc2UpIHtcbiAgXy5taXhpbih0YXJnZXQsIEhvb2tzKTtcbiAgZm9yIChjb25zdCBob29rIG9mIE9iamVjdC5rZXlzKGhvb2tUeXBlcykpIHtcbiAgICBpZiAoaXNNb2RlbCAmJiBob29rVHlwZXNbaG9va10ubm9Nb2RlbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhcmdldFtob29rXSA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRIb29rKGhvb2ssIG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG59XG5leHBvcnRzLmFwcGx5VG8gPSBhcHBseVRvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/hooks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/index-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst IndexHints = module.exports = {\n  USE: \"USE\",\n  FORCE: \"FORCE\",\n  IGNORE: \"IGNORE\"\n};\n//# sourceMappingURL=index-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luZGV4LWhpbnRzLmpzP2QxMTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBJbmRleEhpbnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFVTRTogXCJVU0VcIixcbiAgRk9SQ0U6IFwiRk9SQ0VcIixcbiAgSUdOT1JFOiBcIklHTk9SRVwiXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtaGludHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index-hints.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./sequelize */ \"(rsc)/./node_modules/sequelize/lib/sequelize.js\");\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDBHQUF1QztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luZGV4LmpzPzBlMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NlcXVlbGl6ZVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/instance-validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/instance-validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst sequelizeError = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = __spreadValues({\n      hooks: true\n    }, options);\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n    this.options = options;\n    this.modelInstance = modelInstance;\n    this.validator = validator;\n    this.errors = [];\n    this.inProgress = false;\n  }\n  async _validate() {\n    if (this.inProgress)\n      throw new Error(\"Validations already in progress.\");\n    this.inProgress = true;\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks(\"beforeValidate\", this.modelInstance, this.options);\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks(\"validationFailed\", this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n    await runHooks(\"afterValidate\", this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n  async _perAttributeValidators() {\n    const validators = [];\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n      const value = this.modelInstance.dataValues[field];\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        this._validateSchema(rawAttribute, field, value);\n      }\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n    return await Promise.all(validators);\n  }\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n      const valprom = this._invokeCustomValidator(validator2, validatorType).catch(() => {\n      });\n      validators.push(valprom);\n    });\n    return await Promise.all(validators);\n  }\n  async _singleAttrValidate(value, field, allowNull) {\n    if ((value === null || value === void 0) && !allowNull) {\n      return;\n    }\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if ([\"isUrl\", \"isURL\", \"isEmail\"].includes(validatorType)) {\n        if (typeof test === \"object\" && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n      if (typeof test === \"function\") {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n      if (value === null || value === void 0) {\n        return;\n      }\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      validatorPromise.catch(() => {\n      });\n      validators.push(validatorPromise);\n    });\n    return Promise.all(validators.map((validator2) => validator2.catch((rejection) => {\n      const isBuiltIn = !!rejection.validatorName;\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n  async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator2.length;\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator2.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator2.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n    try {\n      return await validator2.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    const valueString = String(value);\n    if (typeof validator[validatorType] !== \"function\") {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== \"string\" && [\"isAlpha\", \"isAlphanumeric\", \"isMobilePhone\"].includes(validatorType);\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === \"isImmutable\") {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === \"isIP\") {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === void 0)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find((association2) => association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, \"notNull.msg\", `${this.modelInstance.constructor.name}.${field} cannot be null`);\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, \"notNull Violation\", field, value, this.modelInstance, \"is_null\"));\n      }\n    }\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, \"string violation\", field, value, this.modelInstance, \"not_a_string\"));\n      }\n    }\n  }\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || \"Validation error\";\n    const error = new sequelizeError.ValidationErrorItem(message, \"Validation error\", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n}\nInstanceValidator.RAW_KEY_NAME = \"original\";\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports[\"default\"] = InstanceValidator;\n//# sourceMappingURL=instance-validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBVTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDckQsa0JBQWtCLCtIQUE2QztBQUMvRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWUsS0FBSyxPQUFPLFlBQVksNkNBQTZDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DLEdBQUcsT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luc3RhbmNlLXZhbGlkYXRvci5qcz8yZjA4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3IgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG9cIik7XG5jb25zdCB2YWxpZGF0b3IgPSByZXF1aXJlKFwiLi91dGlscy92YWxpZGF0b3ItZXh0cmFzXCIpLnZhbGlkYXRvcjtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbmNsYXNzIEluc3RhbmNlVmFsaWRhdG9yIHtcbiAgY29uc3RydWN0b3IobW9kZWxJbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob29rczogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcyAmJiAhb3B0aW9ucy5za2lwKSB7XG4gICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXMobW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSwgb3B0aW9ucy5maWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLnNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5tb2RlbEluc3RhbmNlID0gbW9kZWxJbnN0YW5jZTtcbiAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuaW5Qcm9ncmVzcyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIF92YWxpZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5pblByb2dyZXNzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbnMgYWxyZWFkeSBpbiBwcm9ncmVzcy5cIik7XG4gICAgdGhpcy5pblByb2dyZXNzID0gdHJ1ZTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLl9wZXJBdHRyaWJ1dGVWYWxpZGF0b3JzKCksXG4gICAgICB0aGlzLl9jdXN0b21WYWxpZGF0b3JzKClcbiAgICBdKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9yKG51bGwsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdmFsaWRhdGUoKSB7XG4gICAgcmV0dXJuIGF3YWl0ICh0aGlzLm9wdGlvbnMuaG9va3MgPyB0aGlzLl92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkgOiB0aGlzLl92YWxpZGF0ZSgpKTtcbiAgfVxuICBhc3luYyBfdmFsaWRhdGVBbmRSdW5Ib29rcygpIHtcbiAgICBjb25zdCBydW5Ib29rcyA9IHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5ydW5Ib29rcy5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgYXdhaXQgcnVuSG9va3MoXCJiZWZvcmVWYWxpZGF0ZVwiLCB0aGlzLm1vZGVsSW5zdGFuY2UsIHRoaXMub3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG5ld0Vycm9yID0gYXdhaXQgcnVuSG9va3MoXCJ2YWxpZGF0aW9uRmFpbGVkXCIsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXdFcnJvciB8fCBlcnJvcjtcbiAgICB9XG4gICAgYXdhaXQgcnVuSG9va3MoXCJhZnRlclZhbGlkYXRlXCIsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcy5tb2RlbEluc3RhbmNlO1xuICB9XG4gIGFzeW5jIF9wZXJBdHRyaWJ1dGVWYWxpZGF0b3JzKCkge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS5yYXdBdHRyaWJ1dGVzLCAocmF3QXR0cmlidXRlLCBmaWVsZCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubW9kZWxJbnN0YW5jZS5kYXRhVmFsdWVzW2ZpZWxkXTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXJhd0F0dHJpYnV0ZS5fYXV0b0dlbmVyYXRlZCAmJiAhcmF3QXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVTY2hlbWEocmF3QXR0cmlidXRlLCBmaWVsZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9ycywgZmllbGQpKSB7XG4gICAgICAgIHZhbGlkYXRvcnMucHVzaCh0aGlzLl9zaW5nbGVBdHRyVmFsaWRhdGUodmFsdWUsIGZpZWxkLCByYXdBdHRyaWJ1dGUuYWxsb3dOdWxsKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKHZhbGlkYXRvcnMpO1xuICB9XG4gIGFzeW5jIF9jdXN0b21WYWxpZGF0b3JzKCkge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBfLmVhY2godGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMudmFsaWRhdGUsICh2YWxpZGF0b3IyLCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXAuaW5jbHVkZXModmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFscHJvbSA9IHRoaXMuX2ludm9rZUN1c3RvbVZhbGlkYXRvcih2YWxpZGF0b3IyLCB2YWxpZGF0b3JUeXBlKS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh2YWxwcm9tKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cbiAgYXN5bmMgX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIGFsbG93TnVsbCkge1xuICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkgJiYgIWFsbG93TnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgXy5mb3JJbih0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9yc1tmaWVsZF0sICh0ZXN0LCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAoW1wiaXNVcmxcIiwgXCJpc1VSTFwiLCBcImlzRW1haWxcIl0uaW5jbHVkZXModmFsaWRhdG9yVHlwZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSBcIm9iamVjdFwiICYmIHRlc3QgIT09IG51bGwgJiYgdGVzdC5tc2cpIHtcbiAgICAgICAgICB0ZXN0ID0ge1xuICAgICAgICAgICAgbXNnOiB0ZXN0Lm1zZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGVzdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRlc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX2ludm9rZUN1c3RvbVZhbGlkYXRvcih0ZXN0LCB2YWxpZGF0b3JUeXBlLCB0cnVlLCB2YWx1ZSwgZmllbGQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdG9yUHJvbWlzZSA9IHRoaXMuX2ludm9rZUJ1aWx0aW5WYWxpZGF0b3IodmFsdWUsIHRlc3QsIHZhbGlkYXRvclR5cGUsIGZpZWxkKTtcbiAgICAgIHZhbGlkYXRvclByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgfSk7XG4gICAgICB2YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yUHJvbWlzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHZhbGlkYXRvcnMubWFwKCh2YWxpZGF0b3IyKSA9PiB2YWxpZGF0b3IyLmNhdGNoKChyZWplY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGlzQnVpbHRJbiA9ICEhcmVqZWN0aW9uLnZhbGlkYXRvck5hbWU7XG4gICAgICB0aGlzLl9wdXNoRXJyb3IoaXNCdWlsdEluLCBmaWVsZCwgcmVqZWN0aW9uLCB2YWx1ZSwgcmVqZWN0aW9uLnZhbGlkYXRvck5hbWUsIHJlamVjdGlvbi52YWxpZGF0b3JBcmdzKTtcbiAgICB9KSkpO1xuICB9XG4gIGFzeW5jIF9pbnZva2VDdXN0b21WYWxpZGF0b3IodmFsaWRhdG9yMiwgdmFsaWRhdG9yVHlwZSwgb3B0QXR0ckRlZmluZWQsIG9wdFZhbHVlLCBvcHRGaWVsZCkge1xuICAgIGxldCBpc0FzeW5jID0gZmFsc2U7XG4gICAgY29uc3QgdmFsaWRhdG9yQXJpdHkgPSB2YWxpZGF0b3IyLmxlbmd0aDtcbiAgICBsZXQgYXN5bmNBcml0eSA9IDE7XG4gICAgbGV0IGVycm9yS2V5ID0gdmFsaWRhdG9yVHlwZTtcbiAgICBsZXQgaW52b2tlQXJncztcbiAgICBpZiAob3B0QXR0ckRlZmluZWQpIHtcbiAgICAgIGFzeW5jQXJpdHkgPSAyO1xuICAgICAgaW52b2tlQXJncyA9IG9wdFZhbHVlO1xuICAgICAgZXJyb3JLZXkgPSBvcHRGaWVsZDtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRvckFyaXR5ID09PSBhc3luY0FyaXR5KSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkodmFsaWRhdG9yMi5iaW5kKHRoaXMubW9kZWxJbnN0YW5jZSwgaW52b2tlQXJncykpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSh2YWxpZGF0b3IyLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlKSkoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hFcnJvcihmYWxzZSwgZXJyb3JLZXksIGUsIG9wdFZhbHVlLCB2YWxpZGF0b3JUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB2YWxpZGF0b3IyLmNhbGwodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEVycm9yKGZhbHNlLCBlcnJvcktleSwgZSwgb3B0VmFsdWUsIHZhbGlkYXRvclR5cGUpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfaW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcbiAgICBjb25zdCB2YWx1ZVN0cmluZyA9IFN0cmluZyh2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3JbdmFsaWRhdG9yVHlwZV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbjogJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGF0b3JBcmdzID0gdGhpcy5fZXh0cmFjdFZhbGlkYXRvckFyZ3ModGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpO1xuICAgIGlmICghdmFsaWRhdG9yW3ZhbGlkYXRvclR5cGVdKHZhbHVlU3RyaW5nLCAuLi52YWxpZGF0b3JBcmdzKSkge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGVzdC5tc2cgfHwgYFZhbGlkYXRpb24gJHt2YWxpZGF0b3JUeXBlfSBvbiAke2ZpZWxkfSBmYWlsZWRgKSwgeyB2YWxpZGF0b3JOYW1lOiB2YWxpZGF0b3JUeXBlLCB2YWxpZGF0b3JBcmdzIH0pO1xuICAgIH1cbiAgfVxuICBfZXh0cmFjdFZhbGlkYXRvckFyZ3ModGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpIHtcbiAgICBsZXQgdmFsaWRhdG9yQXJncyA9IHRlc3QuYXJncyB8fCB0ZXN0O1xuICAgIGNvbnN0IGlzTG9jYWxpemVkVmFsaWRhdG9yID0gdHlwZW9mIHZhbGlkYXRvckFyZ3MgIT09IFwic3RyaW5nXCIgJiYgW1wiaXNBbHBoYVwiLCBcImlzQWxwaGFudW1lcmljXCIsIFwiaXNNb2JpbGVQaG9uZVwiXS5pbmNsdWRlcyh2YWxpZGF0b3JUeXBlKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsaWRhdG9yQXJncykpIHtcbiAgICAgIGlmICh2YWxpZGF0b3JUeXBlID09PSBcImlzSW1tdXRhYmxlXCIpIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFt2YWxpZGF0b3JBcmdzLCBmaWVsZCwgdGhpcy5tb2RlbEluc3RhbmNlXTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbGl6ZWRWYWxpZGF0b3IgfHwgdmFsaWRhdG9yVHlwZSA9PT0gXCJpc0lQXCIpIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yQXJncyA9IFt2YWxpZGF0b3JBcmdzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdG9yQXJncyA9IHZhbGlkYXRvckFyZ3Muc2xpY2UoMCk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0b3JBcmdzO1xuICB9XG4gIF92YWxpZGF0ZVNjaGVtYShyYXdBdHRyaWJ1dGUsIGZpZWxkLCB2YWx1ZSkge1xuICAgIGlmIChyYXdBdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSAmJiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkpIHtcbiAgICAgIGNvbnN0IGFzc29jaWF0aW9uID0gT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zKS5maW5kKChhc3NvY2lhdGlvbjIpID0+IGFzc29jaWF0aW9uMiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyAmJiBhc3NvY2lhdGlvbjIuZm9yZWlnbktleSA9PT0gcmF3QXR0cmlidXRlLmZpZWxkTmFtZSk7XG4gICAgICBpZiAoIWFzc29jaWF0aW9uIHx8ICF0aGlzLm1vZGVsSW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLmFzc29jaWF0aW9uQWNjZXNzb3IpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSB0aGlzLm1vZGVsSW5zdGFuY2UudmFsaWRhdG9yc1tmaWVsZF07XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IF8uZ2V0KHZhbGlkYXRvcnMsIFwibm90TnVsbC5tc2dcIiwgYCR7dGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWV9LiR7ZmllbGR9IGNhbm5vdCBiZSBudWxsYCk7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0oZXJyTXNnLCBcIm5vdE51bGwgVmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5tb2RlbEluc3RhbmNlLCBcImlzX251bGxcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuU1RSSU5HIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlRFWFQgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQ0lURVhUKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXy5pc09iamVjdCh2YWx1ZSkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkgJiYgIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShgJHtmaWVsZH0gY2Fubm90IGJlIGFuIGFycmF5IG9yIGFuIG9iamVjdGAsIFwic3RyaW5nIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMubW9kZWxJbnN0YW5jZSwgXCJub3RfYV9zdHJpbmdcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcHVzaEVycm9yKGlzQnVpbHRpbiwgZXJyb3JLZXksIHJhd0Vycm9yLCB2YWx1ZSwgZm5OYW1lLCBmbkFyZ3MpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gcmF3RXJyb3IubWVzc2FnZSB8fCByYXdFcnJvciB8fCBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKG1lc3NhZ2UsIFwiVmFsaWRhdGlvbiBlcnJvclwiLCBlcnJvcktleSwgdmFsdWUsIHRoaXMubW9kZWxJbnN0YW5jZSwgZm5OYW1lLCBpc0J1aWx0aW4gPyBmbk5hbWUgOiB2b2lkIDAsIGlzQnVpbHRpbiA/IGZuQXJncyA6IHZvaWQgMCk7XG4gICAgZXJyb3JbSW5zdGFuY2VWYWxpZGF0b3IuUkFXX0tFWV9OQU1FXSA9IHJhd0Vycm9yO1xuICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5JbnN0YW5jZVZhbGlkYXRvci5SQVdfS0VZX05BTUUgPSBcIm9yaWdpbmFsXCI7XG5tb2R1bGUuZXhwb3J0cyA9IEluc3RhbmNlVmFsaWRhdG9yO1xubW9kdWxlLmV4cG9ydHMuSW5zdGFuY2VWYWxpZGF0b3IgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBJbnN0YW5jZVZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RhbmNlLXZhbGlkYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/instance-validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/model-manager.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize/lib/model-manager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Toposort = __webpack_require__(/*! toposort-class */ \"(rsc)/./node_modules/toposort-class/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n    return model;\n  }\n  removeModel(modelToRemove) {\n    this.models = this.models.filter((model) => model.name !== modelToRemove.name);\n    delete this.sequelize.models[modelToRemove.name];\n  }\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: \"name\"\n    });\n    return this.models.find((model) => model[options.attribute] === against);\n  }\n  findModel(callback) {\n    return this.models.find(callback);\n  }\n  get all() {\n    return this.models;\n  }\n  getModelsTopoSortedByForeignKey() {\n    const models = /* @__PURE__ */ new Map();\n    const sorter = new Toposort();\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      models.set(tableName, model);\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n          if (attribute.references) {\n            let dep = attribute.references.model;\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n            deps.push(dep);\n          }\n        }\n      }\n      deps = deps.filter((dep) => tableName !== dep);\n      sorter.add(tableName, deps);\n    }\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (e) {\n      if (!e.message.startsWith(\"Cyclic dependency found.\")) {\n        throw e;\n      }\n      return null;\n    }\n    return sorted.map((modelName) => {\n      return models.get(modelName);\n    }).filter(Boolean);\n  }\n  forEachModel(iterator, options) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error(\"Cyclic dependency found.\");\n    }\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports[\"default\"] = ModelManager;\n//# sourceMappingURL=model-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsR0FBRyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC1tYW5hZ2VyLmpzPzUxYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBUb3Bvc29ydCA9IHJlcXVpcmUoXCJ0b3Bvc29ydC1jbGFzc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY2xhc3MgTW9kZWxNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgdGhpcy5tb2RlbHMgPSBbXTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgfVxuICBhZGRNb2RlbChtb2RlbCkge1xuICAgIHRoaXMubW9kZWxzLnB1c2gobW9kZWwpO1xuICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsc1ttb2RlbC5uYW1lXSA9IG1vZGVsO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICByZW1vdmVNb2RlbChtb2RlbFRvUmVtb3ZlKSB7XG4gICAgdGhpcy5tb2RlbHMgPSB0aGlzLm1vZGVscy5maWx0ZXIoKG1vZGVsKSA9PiBtb2RlbC5uYW1lICE9PSBtb2RlbFRvUmVtb3ZlLm5hbWUpO1xuICAgIGRlbGV0ZSB0aGlzLnNlcXVlbGl6ZS5tb2RlbHNbbW9kZWxUb1JlbW92ZS5uYW1lXTtcbiAgfVxuICBnZXRNb2RlbChhZ2FpbnN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xuICAgICAgYXR0cmlidXRlOiBcIm5hbWVcIlxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm1vZGVscy5maW5kKChtb2RlbCkgPT4gbW9kZWxbb3B0aW9ucy5hdHRyaWJ1dGVdID09PSBhZ2FpbnN0KTtcbiAgfVxuICBmaW5kTW9kZWwoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbHMuZmluZChjYWxsYmFjayk7XG4gIH1cbiAgZ2V0IGFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbHM7XG4gIH1cbiAgZ2V0TW9kZWxzVG9wb1NvcnRlZEJ5Rm9yZWlnbktleSgpIHtcbiAgICBjb25zdCBtb2RlbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHNvcnRlciA9IG5ldyBUb3Bvc29ydCgpO1xuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbHMpIHtcbiAgICAgIGxldCBkZXBzID0gW107XG4gICAgICBsZXQgdGFibGVOYW1lID0gbW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgICBpZiAoXy5pc09iamVjdCh0YWJsZU5hbWUpKSB7XG4gICAgICAgIHRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7dGFibGVOYW1lLnRhYmxlTmFtZX1gO1xuICAgICAgfVxuICAgICAgbW9kZWxzLnNldCh0YWJsZU5hbWUsIG1vZGVsKTtcbiAgICAgIGZvciAoY29uc3QgYXR0ck5hbWUgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF0dHJOYW1lKSkge1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0ck5hbWVdO1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgbGV0IGRlcCA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsO1xuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QoZGVwKSkge1xuICAgICAgICAgICAgICBkZXAgPSBgJHtkZXAuc2NoZW1hfS4ke2RlcC50YWJsZU5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlcHMucHVzaChkZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVwcyA9IGRlcHMuZmlsdGVyKChkZXApID0+IHRhYmxlTmFtZSAhPT0gZGVwKTtcbiAgICAgIHNvcnRlci5hZGQodGFibGVOYW1lLCBkZXBzKTtcbiAgICB9XG4gICAgbGV0IHNvcnRlZDtcbiAgICB0cnkge1xuICAgICAgc29ydGVkID0gc29ydGVyLnNvcnQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIWUubWVzc2FnZS5zdGFydHNXaXRoKFwiQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQuXCIpKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNvcnRlZC5tYXAoKG1vZGVsTmFtZSkgPT4ge1xuICAgICAgcmV0dXJuIG1vZGVscy5nZXQobW9kZWxOYW1lKTtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgZm9yRWFjaE1vZGVsKGl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc29ydGVkTW9kZWxzID0gdGhpcy5nZXRNb2RlbHNUb3BvU29ydGVkQnlGb3JlaWduS2V5KCk7XG4gICAgaWYgKHNvcnRlZE1vZGVscyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBmb3VuZC5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIHJldmVyc2U6IHRydWVcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBzb3J0ZWRNb2RlbHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHNvcnRlZE1vZGVscykge1xuICAgICAgaXRlcmF0b3IobW9kZWwpO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Nb2RlbE1hbmFnZXIgPSBNb2RlbE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gTW9kZWxNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwtbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/model-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/model.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Dottie = __webpack_require__(/*! dottie */ \"(rsc)/./node_modules/dottie/dottie.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst InstanceValidator = __webpack_require__(/*! ./instance-validator */ \"(rsc)/./node_modules/sequelize/lib/instance-validator.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Association = __webpack_require__(/*! ./associations/base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst HasMany = __webpack_require__(/*! ./associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(rsc)/./node_modules/sequelize/lib/hooks.js\");\nconst associationsMixin = __webpack_require__(/*! ./associations/mixin */ \"(rsc)/./node_modules/sequelize/lib/associations/mixin.js\");\nconst Op = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst validQueryKeywords = /* @__PURE__ */ new Set([\n  \"where\",\n  \"attributes\",\n  \"paranoid\",\n  \"include\",\n  \"order\",\n  \"limit\",\n  \"offset\",\n  \"transaction\",\n  \"lock\",\n  \"raw\",\n  \"logging\",\n  \"benchmark\",\n  \"having\",\n  \"searchPath\",\n  \"rejectOnEmpty\",\n  \"plain\",\n  \"scope\",\n  \"group\",\n  \"through\",\n  \"defaults\",\n  \"distinct\",\n  \"primary\",\n  \"exception\",\n  \"type\",\n  \"hooks\",\n  \"force\",\n  \"name\"\n]);\nconst nonCascadingOptions = [\"include\", \"attributes\", \"originalAttributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"group\", \"having\"];\nclass Model {\n  static get queryInterface() {\n    return this.sequelize.getQueryInterface();\n  }\n  static get queryGenerator() {\n    return this.queryInterface.queryGenerator;\n  }\n  get sequelize() {\n    return this.constructor.sequelize;\n  }\n  constructor(values = {}, options = {}) {\n    if (!this.constructor._overwrittenAttributesChecked) {\n      this.constructor._overwrittenAttributesChecked = true;\n      setTimeout(() => {\n        const overwrittenAttributes = [];\n        for (const key of Object.keys(this.constructor._attributeManipulation)) {\n          if (Object.prototype.hasOwnProperty.call(this, key)) {\n            overwrittenAttributes.push(key);\n          }\n        }\n        if (overwrittenAttributes.length > 0) {\n          logger.warn(`Model ${JSON.stringify(this.constructor.name)} is declaring public class fields for attribute(s): ${overwrittenAttributes.map((attr) => JSON.stringify(attr)).join(\", \")}.\nThese class fields are shadowing Sequelize's attribute getters & setters.\nSee https://sequelize.org/main/manual/model-basics.html#caveat-with-public-class-fields`);\n        }\n      }, 0);\n    }\n    options = __spreadValues({\n      isNewRecord: true,\n      _schema: this.constructor._schema,\n      _schemaDelimiter: this.constructor._schemaDelimiter\n    }, options);\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    if (!options.includeValidated) {\n      this.constructor._conformIncludes(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        this.constructor._validateIncludedElements(options);\n      }\n    }\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this.uniqno = 1;\n    this._changed = /* @__PURE__ */ new Set();\n    this._options = options;\n    this.isNewRecord = options.isNewRecord;\n    this._initValues(values, options);\n  }\n  _initValues(values, options) {\n    let defaults;\n    let key;\n    values = __spreadValues({}, values);\n    if (options.isNewRecord) {\n      defaults = {};\n      if (this.constructor._hasDefaultValues) {\n        defaults = _.mapValues(this.constructor._defaultValues, (valueFn) => {\n          const value = valueFn();\n          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);\n        });\n      }\n      if (this.constructor.primaryKeyAttributes.length) {\n        this.constructor.primaryKeyAttributes.forEach((primaryKeyAttribute) => {\n          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {\n            defaults[primaryKeyAttribute] = null;\n          }\n        });\n      }\n      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {\n        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.createdAt];\n      }\n      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.updatedAt];\n      }\n      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.deletedAt];\n      }\n      for (key in defaults) {\n        if (values[key] === void 0) {\n          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });\n          delete values[key];\n        }\n      }\n    }\n    this.set(values, options);\n  }\n  static _paranoidClause(model, options = {}) {\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n    if (_.get(options, \"groupedLimit.on.options.paranoid\")) {\n      const throughModel = _.get(options, \"groupedLimit.on.through.model\");\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);\n      }\n    }\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      return options;\n    }\n    const deletedAtCol = model._timestampAttributes.deletedAt;\n    const deletedAtAttribute = model.rawAttributes[deletedAtCol];\n    const deletedAtObject = {};\n    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    deletedAtDefaultValue = deletedAtDefaultValue || {\n      [Op.eq]: null\n    };\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    if (Utils.isWhereEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { [Op.and]: [deletedAtObject, options.where] };\n    }\n    return options;\n  }\n  static _addDefaultAttributes() {\n    const tail = {};\n    let head = {};\n    if (!_.some(this.rawAttributes, \"primaryKey\")) {\n      if (\"id\" in this.rawAttributes) {\n        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);\n      }\n      head = {\n        id: {\n          type: new DataTypes.INTEGER(),\n          allowNull: false,\n          primaryKey: true,\n          autoIncrement: true,\n          _autoGenerated: true\n        }\n      };\n    }\n    if (this._timestampAttributes.createdAt) {\n      tail[this._timestampAttributes.createdAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.updatedAt) {\n      tail[this._timestampAttributes.updatedAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.deletedAt) {\n      tail[this._timestampAttributes.deletedAt] = {\n        type: DataTypes.DATE,\n        _autoGenerated: true\n      };\n    }\n    if (this._versionAttribute) {\n      tail[this._versionAttribute] = {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n        defaultValue: 0,\n        _autoGenerated: true\n      };\n    }\n    const newRawAttributes = __spreadValues(__spreadValues({}, head), this.rawAttributes);\n    _.each(tail, (value, attr) => {\n      if (newRawAttributes[attr] === void 0) {\n        newRawAttributes[attr] = value;\n      }\n    });\n    this.rawAttributes = newRawAttributes;\n    if (!Object.keys(this.primaryKeys).length) {\n      this.primaryKeys.id = this.rawAttributes.id;\n    }\n  }\n  static getAttributes() {\n    return this.rawAttributes;\n  }\n  static _findAutoIncrementAttribute() {\n    this.autoIncrementAttribute = null;\n    for (const name in this.rawAttributes) {\n      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {\n        const definition = this.rawAttributes[name];\n        if (definition && definition.autoIncrement) {\n          if (this.autoIncrementAttribute) {\n            throw new Error(\"Invalid Instance definition. Only one autoincrement field allowed.\");\n          }\n          this.autoIncrementAttribute = name;\n        }\n      }\n    }\n  }\n  static _conformIncludes(options, self) {\n    if (!options.include)\n      return;\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (!options.include.length) {\n      delete options.include;\n      return;\n    }\n    options.include = options.include.map((include) => this._conformInclude(include, self));\n  }\n  static _transformStringAssociation(include, self) {\n    if (self && typeof include === \"string\") {\n      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {\n        throw new Error(`Association with alias \"${include}\" does not exist on ${self.name}`);\n      }\n      return self.associations[include];\n    }\n    return include;\n  }\n  static _conformInclude(include, self) {\n    if (include) {\n      let model;\n      if (include._pseudo)\n        return include;\n      include = this._transformStringAssociation(include, self);\n      if (include instanceof Association) {\n        if (self && include.target.name === self.name) {\n          model = include.source;\n        } else {\n          model = include.target;\n        }\n        return { model, association: include, as: include.as };\n      }\n      if (include.prototype && include.prototype instanceof Model) {\n        return { model: include };\n      }\n      if (_.isPlainObject(include)) {\n        if (include.association) {\n          include.association = this._transformStringAssociation(include.association, self);\n          if (self && include.association.target.name === self.name) {\n            model = include.association.source;\n          } else {\n            model = include.association.target;\n          }\n          if (!include.model)\n            include.model = model;\n          if (!include.as)\n            include.as = include.association.as;\n          this._conformIncludes(include, model);\n          return include;\n        }\n        if (include.model) {\n          this._conformIncludes(include, include.model);\n          return include;\n        }\n        if (include.all) {\n          this._conformIncludes(include);\n          return include;\n        }\n      }\n    }\n    throw new Error(\"Include unexpected. Element has to be either a Model, an Association or an object.\");\n  }\n  static _expandIncludeAllElement(includes, include) {\n    let all = include.all;\n    delete include.all;\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: [\"BelongsTo\", \"HasOne\"],\n        Has: [\"HasOne\", \"HasMany\"],\n        Many: [\"HasMany\"]\n      };\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === \"All\") {\n          all = true;\n          break;\n        }\n        const types = validTypes[type];\n        if (!types) {\n          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);\n        }\n        if (types !== true) {\n          all.splice(i, 1);\n          i--;\n          for (let j = 0; j < types.length; j++) {\n            if (!all.includes(types[j])) {\n              all.unshift(types[j]);\n              i++;\n            }\n          }\n        }\n      }\n    }\n    const nested = include.nested;\n    if (nested) {\n      delete include.nested;\n      if (!include.include) {\n        include.include = [];\n      } else if (!Array.isArray(include.include)) {\n        include.include = [include.include];\n      }\n    }\n    const used = [];\n    (function addAllIncludes(parent, includes2) {\n      _.forEach(parent.associations, (association) => {\n        if (all !== true && !all.includes(association.associationType)) {\n          return;\n        }\n        const model = association.target;\n        const as = association.options.as;\n        const predicate = { model };\n        if (as) {\n          predicate.as = as;\n        }\n        if (_.some(includes2, predicate)) {\n          return;\n        }\n        if (nested && used.includes(model)) {\n          return;\n        }\n        used.push(parent);\n        const thisInclude = Utils.cloneDeep(include);\n        thisInclude.model = model;\n        if (as) {\n          thisInclude.as = as;\n        }\n        includes2.push(thisInclude);\n        if (nested) {\n          addAllIncludes(model, thisInclude.include);\n          if (thisInclude.include.length === 0)\n            delete thisInclude.include;\n        }\n      });\n      used.pop();\n    })(this, includes);\n  }\n  static _validateIncludedElements(options, tableNames) {\n    if (!options.model)\n      options.model = this;\n    tableNames = tableNames || {};\n    options.includeNames = [];\n    options.includeMap = {};\n    options.hasSingleAssociation = false;\n    options.hasMultiAssociation = false;\n    if (!options.parent) {\n      options.topModel = options.model;\n      options.topLimit = options.limit;\n    }\n    options.include = options.include.map((include) => {\n      include = this._conformInclude(include);\n      include.parent = options;\n      include.topLimit = options.topLimit;\n      this._validateIncludedElement.call(options.model, include, tableNames, options);\n      if (include.duplicating === void 0) {\n        include.duplicating = include.association.isMultiAssociation;\n      }\n      include.hasDuplicating = include.hasDuplicating || include.duplicating;\n      include.hasRequired = include.hasRequired || include.required;\n      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n      options.hasRequired = options.hasRequired || include.required;\n      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n      return include;\n    });\n    for (const include of options.include) {\n      include.hasParentWhere = options.hasParentWhere || !!options.where;\n      include.hasParentRequired = options.hasParentRequired || !!options.required;\n      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n        if (include.duplicating) {\n          include.subQuery = include.subQuery || false;\n          include.subQueryFilter = include.hasRequired;\n        } else {\n          include.subQuery = include.hasRequired;\n          include.subQueryFilter = false;\n        }\n      } else {\n        include.subQuery = include.subQuery || false;\n        if (include.duplicating) {\n          include.subQueryFilter = include.subQuery;\n        } else {\n          include.subQueryFilter = false;\n          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\n        }\n      }\n      options.includeMap[include.as] = include;\n      options.includeNames.push(include.as);\n      if (options.topModel === options.model && options.subQuery === void 0 && options.topLimit) {\n        if (include.subQuery) {\n          options.subQuery = include.subQuery;\n        } else if (include.hasDuplicating) {\n          options.subQuery = true;\n        }\n      }\n      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n      if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n        options.hasMultiAssociation = true;\n      }\n      if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n        options.hasSingleAssociation = true;\n      }\n    }\n    if (options.topModel === options.model && options.subQuery === void 0) {\n      options.subQuery = false;\n    }\n    return options;\n  }\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.getTableName()] = true;\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);\n      include = Utils.mapFinderOptions(include, include.model);\n      if (include.attributes.length) {\n        _.each(include.model.primaryKeys, (attr, key) => {\n          if (!include.attributes.some((includeAttr) => {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = Utils.mapFinderOptions(include, include.model);\n    }\n    if (include._pseudo) {\n      if (!include.attributes) {\n        include.attributes = Object.keys(include.model.tableAttributes);\n      }\n      return Utils.mapFinderOptions(include, include.model);\n    }\n    const association = include.association || this._getIncludedAssociation(include.model, include.as);\n    include.association = association;\n    include.as = association.as;\n    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n      if (!include.include)\n        include.include = [];\n      const through = include.association.through;\n      include.through = _.defaults(include.through || {}, {\n        model: through.model,\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true\n        },\n        _pseudo: true,\n        parent: include\n      });\n      if (through.scope) {\n        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;\n      }\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n    let model;\n    if (include.model.scoped === true) {\n      model = include.model;\n    } else {\n      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n    }\n    model._injectScope(include);\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n    include = Utils.mapFinderOptions(include, include.model);\n    if (include.required === void 0) {\n      include.required = !!include.where;\n    }\n    if (include.association.scope) {\n      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;\n    }\n    if (include.limit && include.separate === void 0) {\n      include.separate = true;\n    }\n    if (include.separate === true) {\n      if (!(include.association instanceof HasMany)) {\n        throw new Error(\"Only HasMany associations support include.separate\");\n      }\n      include.duplicating = false;\n      if (options.attributes && options.attributes.length && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)) {\n        options.attributes.push(association.sourceKey);\n      }\n      if (include.attributes && include.attributes.length && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)) {\n        include.attributes.push(association.foreignKey);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(include, \"include\")) {\n      this._validateIncludedElements.call(include.model, include, tableNames);\n    }\n    return include;\n  }\n  static _getIncludedAssociation(targetModel, targetAlias) {\n    const associations = this.getAssociations(targetModel);\n    let association = null;\n    if (associations.length === 0) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);\n    }\n    if (associations.length === 1) {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (association) {\n        return association;\n      }\n      if (targetAlias) {\n        const existingAliases = this.getAssociations(targetModel).map((association2) => association2.as);\n        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(\", \")}).`);\n      }\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You must use the 'as' keyword to specify the alias within your include statement.`);\n    }\n    association = this.getAssociationForAlias(targetModel, targetAlias);\n    if (!association) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include.`);\n    }\n    return association;\n  }\n  static _expandIncludeAll(options) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n        this._expandIncludeAllElement(includes, include);\n      }\n    }\n    includes.forEach((include) => {\n      this._expandIncludeAll.call(include.model, include);\n    });\n  }\n  static _conformIndex(index) {\n    if (!index.fields) {\n      throw new Error('Missing \"fields\" property for index definition');\n    }\n    index = _.defaults(index, {\n      type: \"\",\n      parser: null\n    });\n    if (index.type && index.type.toLowerCase() === \"unique\") {\n      index.unique = true;\n      delete index.type;\n    }\n    return index;\n  }\n  static _uniqIncludes(options) {\n    if (!options.include)\n      return;\n    options.include = _(options.include).groupBy((include) => `${include.model && include.model.name}-${include.as}`).map((includes) => this._assignOptions(...includes)).value();\n  }\n  static _baseMerge(...args) {\n    _.assignWith(...args);\n    this._conformIncludes(args[0], this);\n    this._uniqIncludes(args[0]);\n    return args[0];\n  }\n  static _mergeFunction(objValue, srcValue, key) {\n    if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n      return _.union(objValue, srcValue);\n    }\n    if ([\"where\", \"having\"].includes(key)) {\n      if (this.options && this.options.whereMergeStrategy === \"and\") {\n        return combineWheresWithAnd(objValue, srcValue);\n      }\n      if (srcValue instanceof Utils.SequelizeMethod) {\n        srcValue = { [Op.and]: srcValue };\n      }\n      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n    } else if (key === \"attributes\" && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n      return _.assignWith(objValue, srcValue, (objValue2, srcValue2) => {\n        if (Array.isArray(objValue2) && Array.isArray(srcValue2)) {\n          return _.union(objValue2, srcValue2);\n        }\n      });\n    }\n    if (srcValue) {\n      return Utils.cloneDeep(srcValue, true);\n    }\n    return srcValue === void 0 ? objValue : srcValue;\n  }\n  static _assignOptions(...args) {\n    return this._baseMerge(...args, this._mergeFunction.bind(this));\n  }\n  static _defaultsOptions(target, opts) {\n    return this._baseMerge(target, opts, (srcValue, objValue, key) => {\n      return this._mergeFunction(objValue, srcValue, key);\n    });\n  }\n  static init(attributes, options = {}) {\n    if (!options.sequelize) {\n      throw new Error(\"No Sequelize instance passed\");\n    }\n    this.sequelize = options.sequelize;\n    const globalOptions = this.sequelize.options;\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n    if (!options.modelName) {\n      options.modelName = this.name;\n    }\n    options = Utils.merge({\n      name: {\n        plural: Utils.pluralize(options.modelName),\n        singular: Utils.singularize(options.modelName)\n      },\n      indexes: [],\n      omitNull: globalOptions.omitNull,\n      schema: globalOptions.schema\n    }, options);\n    this.sequelize.runHooks(\"beforeDefine\", attributes, options);\n    if (options.modelName !== this.name) {\n      Object.defineProperty(this, \"name\", { value: options.modelName });\n    }\n    delete options.modelName;\n    this.options = __spreadValues({\n      timestamps: true,\n      validate: {},\n      freezeTableName: false,\n      underscored: false,\n      paranoid: false,\n      rejectOnEmpty: false,\n      whereCollection: null,\n      schema: null,\n      schemaDelimiter: \"\",\n      defaultScope: {},\n      scopes: {},\n      indexes: [],\n      whereMergeStrategy: \"overwrite\"\n    }, options);\n    if (this.sequelize.isDefined(this.name)) {\n      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));\n    }\n    this.associations = {};\n    this._setupHooks(options.hooks);\n    this.underscored = this.options.underscored;\n    if (!this.options.tableName) {\n      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);\n    } else {\n      this.tableName = this.options.tableName;\n    }\n    this._schema = this.options.schema;\n    this._schemaDelimiter = this.options.schemaDelimiter;\n    _.each(options.validate, (validator, validatorType) => {\n      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {\n        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);\n      }\n      if (typeof validator !== \"function\") {\n        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);\n      }\n    });\n    if (!_.includes([\"and\", \"overwrite\"], this.options && this.options.whereMergeStrategy)) {\n      throw new Error(`Invalid value ${this.options && this.options.whereMergeStrategy} for whereMergeStrategy. Allowed values are 'and' and 'overwrite'.`);\n    }\n    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {\n      attribute = this.sequelize.normalizeAttribute(attribute);\n      if (attribute.type === void 0) {\n        throw new Error(`Unrecognized datatype for attribute \"${this.name}.${name}\"`);\n      }\n      if (attribute.allowNull !== false && _.get(attribute, \"validate.notNull\")) {\n        throw new Error(`Invalid definition for \"${this.name}.${name}\", \"notNull\" validator is only allowed with \"allowNull:false\"`);\n      }\n      if (_.get(attribute, \"references.model.prototype\") instanceof Model) {\n        attribute.references.model = attribute.references.model.getTableName();\n      }\n      return attribute;\n    });\n    const tableName = this.getTableName();\n    this._indexes = this.options.indexes.map((index) => Utils.nameIndex(this._conformIndex(index), tableName));\n    this.primaryKeys = {};\n    this._readOnlyAttributes = /* @__PURE__ */ new Set();\n    this._timestampAttributes = {};\n    if (this.options.timestamps) {\n      for (const key of [\"createdAt\", \"updatedAt\", \"deletedAt\"]) {\n        if (![\"undefined\", \"string\", \"boolean\"].includes(typeof this.options[key])) {\n          throw new Error(`Value for \"${key}\" option must be a string or a boolean, got ${typeof this.options[key]}`);\n        }\n        if (this.options[key] === \"\") {\n          throw new Error(`Value for \"${key}\" option cannot be an empty string`);\n        }\n      }\n      if (this.options.createdAt !== false) {\n        this._timestampAttributes.createdAt = typeof this.options.createdAt === \"string\" ? this.options.createdAt : \"createdAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);\n      }\n      if (this.options.updatedAt !== false) {\n        this._timestampAttributes.updatedAt = typeof this.options.updatedAt === \"string\" ? this.options.updatedAt : \"updatedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);\n      }\n      if (this.options.paranoid && this.options.deletedAt !== false) {\n        this._timestampAttributes.deletedAt = typeof this.options.deletedAt === \"string\" ? this.options.deletedAt : \"deletedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);\n      }\n    }\n    if (this.options.version) {\n      this._versionAttribute = typeof this.options.version === \"string\" ? this.options.version : \"version\";\n      this._readOnlyAttributes.add(this._versionAttribute);\n    }\n    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;\n    this._addDefaultAttributes();\n    this.refreshAttributes();\n    this._findAutoIncrementAttribute();\n    this._scope = this.options.defaultScope;\n    this._scopeNames = [\"defaultScope\"];\n    this.sequelize.modelManager.addModel(this);\n    this.sequelize.runHooks(\"afterDefine\", this);\n    return this;\n  }\n  static refreshAttributes() {\n    const attributeManipulation = {};\n    this.prototype._customGetters = {};\n    this.prototype._customSetters = {};\n    [\"get\", \"set\"].forEach((type) => {\n      const opt = `${type}terMethods`;\n      const funcs = __spreadValues({}, this.options[opt]);\n      const _custom = type === \"get\" ? this.prototype._customGetters : this.prototype._customSetters;\n      _.each(funcs, (method, attribute) => {\n        _custom[attribute] = method;\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(this.rawAttributes, (options, attribute) => {\n        if (Object.prototype.hasOwnProperty.call(options, type)) {\n          _custom[attribute] = options[type];\n        }\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(funcs, (fct, name) => {\n        if (!attributeManipulation[name]) {\n          attributeManipulation[name] = {\n            configurable: true\n          };\n        }\n        attributeManipulation[name][type] = fct;\n      });\n    });\n    this._dataTypeChanges = {};\n    this._dataTypeSanitizers = {};\n    this._hasBooleanAttributes = false;\n    this._hasDateAttributes = false;\n    this._jsonAttributes = /* @__PURE__ */ new Set();\n    this._virtualAttributes = /* @__PURE__ */ new Set();\n    this._defaultValues = {};\n    this.prototype.validators = {};\n    this.fieldRawAttributesMap = {};\n    this.primaryKeys = {};\n    this.uniqueKeys = {};\n    _.each(this.rawAttributes, (definition, name) => {\n      definition.type = this.sequelize.normalizeDataType(definition.type);\n      definition.Model = this;\n      definition.fieldName = name;\n      definition._modelAttribute = true;\n      if (definition.field === void 0) {\n        definition.field = Utils.underscoredIf(name, this.underscored);\n      }\n      if (definition.primaryKey === true) {\n        this.primaryKeys[name] = definition;\n      }\n      this.fieldRawAttributesMap[definition.field] = definition;\n      if (definition.type._sanitize) {\n        this._dataTypeSanitizers[name] = definition.type._sanitize;\n      }\n      if (definition.type._isChanged) {\n        this._dataTypeChanges[name] = definition.type._isChanged;\n      }\n      if (definition.type instanceof DataTypes.BOOLEAN) {\n        this._hasBooleanAttributes = true;\n      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {\n        this._hasDateAttributes = true;\n      } else if (definition.type instanceof DataTypes.JSON) {\n        this._jsonAttributes.add(name);\n      } else if (definition.type instanceof DataTypes.VIRTUAL) {\n        this._virtualAttributes.add(name);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"defaultValue\")) {\n        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"unique\") && definition.unique) {\n        let idxName;\n        if (typeof definition.unique === \"object\" && Object.prototype.hasOwnProperty.call(definition.unique, \"name\")) {\n          idxName = definition.unique.name;\n        } else if (typeof definition.unique === \"string\") {\n          idxName = definition.unique;\n        } else {\n          idxName = `${this.tableName}_${name}_unique`;\n        }\n        const idx = this.uniqueKeys[idxName] || { fields: [] };\n        idx.fields.push(definition.field);\n        idx.msg = idx.msg || definition.unique.msg || null;\n        idx.name = idxName || false;\n        idx.column = name;\n        idx.customIndex = definition.unique !== true;\n        this.uniqueKeys[idxName] = idx;\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"validate\")) {\n        this.prototype.validators[name] = definition.validate;\n      }\n      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n        this._indexes.push(Utils.nameIndex(this._conformIndex({\n          fields: [definition.field || name],\n          using: \"gin\"\n        }), this.getTableName()));\n        delete definition.index;\n      }\n    });\n    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {\n      if (key !== value.fieldName) {\n        map[key] = value.fieldName;\n      }\n      return map;\n    }, {});\n    this._hasJsonAttributes = !!this._jsonAttributes.size;\n    this._hasVirtualAttributes = !!this._virtualAttributes.size;\n    this._hasDefaultValues = !_.isEmpty(this._defaultValues);\n    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));\n    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;\n    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;\n    for (const key of Object.keys(attributeManipulation)) {\n      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {\n        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);\n        continue;\n      }\n      Object.defineProperty(this.prototype, key, attributeManipulation[key]);\n    }\n    this.prototype.rawAttributes = this.rawAttributes;\n    this.prototype._isAttribute = (key) => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);\n    this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n    this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n    if (this.primaryKeyAttribute) {\n      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n    }\n    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;\n    this._isPrimaryKey = (key) => this.primaryKeyAttributes.includes(key);\n    this._attributeManipulation = attributeManipulation;\n  }\n  static removeAttribute(attribute) {\n    delete this.rawAttributes[attribute];\n    this.refreshAttributes();\n  }\n  static async sync(options) {\n    options = __spreadValues(__spreadValues({}, this.options), options);\n    options.hooks = options.hooks === void 0 ? true : !!options.hooks;\n    const attributes = this.tableAttributes;\n    const rawAttributes = this.fieldRawAttributesMap;\n    if (options.hooks) {\n      await this.runHooks(\"beforeSync\", options);\n    }\n    const tableName = this.getTableName(options);\n    let tableExists;\n    if (options.force) {\n      await this.drop(options);\n      tableExists = false;\n    } else {\n      tableExists = await this.queryInterface.tableExists(tableName, options);\n    }\n    if (!tableExists) {\n      await this.queryInterface.createTable(tableName, attributes, options, this);\n    } else {\n      await this.queryInterface.ensureEnums(tableName, attributes, options, this);\n    }\n    if (tableExists && options.alter) {\n      const tableInfos = await Promise.all([\n        this.queryInterface.describeTable(tableName, options),\n        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)\n      ]);\n      const columns = tableInfos[0];\n      const foreignKeyReferences = tableInfos[1];\n      const removedConstraints = {};\n      for (const columnName in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, columnName))\n          continue;\n        if (!columns[columnName] && !columns[attributes[columnName].field]) {\n          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);\n        }\n      }\n      if (options.alter === true || typeof options.alter === \"object\" && options.alter.drop !== false) {\n        for (const columnName in columns) {\n          if (!Object.prototype.hasOwnProperty.call(columns, columnName))\n            continue;\n          const currentAttribute = rawAttributes[columnName];\n          if (!currentAttribute) {\n            await this.queryInterface.removeColumn(tableName, columnName, options);\n            continue;\n          }\n          if (currentAttribute.primaryKey)\n            continue;\n          const references = currentAttribute.references;\n          if (currentAttribute.references) {\n            const database = this.sequelize.config.database;\n            const schema = this.sequelize.config.schema;\n            for (const foreignKeyReference of foreignKeyReferences) {\n              const constraintName = foreignKeyReference.constraintName;\n              if (!!constraintName && foreignKeyReference.tableCatalog === database && (schema ? foreignKeyReference.tableSchema === schema : true) && foreignKeyReference.referencedTableName === references.model && foreignKeyReference.referencedColumnName === references.key && (schema ? foreignKeyReference.referencedTableSchema === schema : true) && !removedConstraints[constraintName]) {\n                await this.queryInterface.removeConstraint(tableName, constraintName, options);\n                removedConstraints[constraintName] = true;\n              }\n            }\n          }\n          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);\n        }\n      }\n    }\n    const existingIndexes = await this.queryInterface.showIndex(tableName, options);\n    const missingIndexes = this._indexes.filter((item1) => !existingIndexes.some((item2) => item1.name === item2.name)).sort((index1, index2) => {\n      if (this.sequelize.options.dialect === \"postgres\") {\n        if (index1.concurrently === true)\n          return 1;\n        if (index2.concurrently === true)\n          return -1;\n      }\n      return 0;\n    });\n    for (const index of missingIndexes) {\n      await this.queryInterface.addIndex(tableName, __spreadValues(__spreadValues({}, options), index));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterSync\", options);\n    }\n    return this;\n  }\n  static async drop(options) {\n    return await this.queryInterface.dropTable(this.getTableName(options), options);\n  }\n  static async dropSchema(schema) {\n    return await this.queryInterface.dropSchema(schema);\n  }\n  static schema(schema, options) {\n    const clone = class extends this {\n    };\n    Object.defineProperty(clone, \"name\", { value: this.name });\n    clone._schema = schema;\n    if (options) {\n      if (typeof options === \"string\") {\n        clone._schemaDelimiter = options;\n      } else if (options.schemaDelimiter) {\n        clone._schemaDelimiter = options.schemaDelimiter;\n      }\n    }\n    return clone;\n  }\n  static getTableName() {\n    return this.queryGenerator.addSchema(this);\n  }\n  static unscoped() {\n    return this.scope();\n  }\n  static addScope(name, scope, options) {\n    options = __spreadValues({ override: false }, options);\n    if ((name === \"defaultScope\" && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {\n      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);\n    }\n    if (name === \"defaultScope\") {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n  static scope(option) {\n    const self = class extends this {\n    };\n    let scope;\n    let scopeName;\n    Object.defineProperty(self, \"name\", { value: this.name });\n    self._scope = {};\n    self._scopeNames = [];\n    self.scoped = true;\n    if (!option) {\n      return self;\n    }\n    const options = _.flatten(arguments);\n    for (const option2 of options) {\n      scope = null;\n      scopeName = null;\n      if (_.isPlainObject(option2)) {\n        if (option2.method) {\n          if (Array.isArray(option2.method) && !!self.options.scopes[option2.method[0]]) {\n            scopeName = option2.method[0];\n            scope = self.options.scopes[scopeName].apply(self, option2.method.slice(1));\n          } else if (self.options.scopes[option2.method]) {\n            scopeName = option2.method;\n            scope = self.options.scopes[scopeName].apply(self);\n          }\n        } else {\n          scope = option2;\n        }\n      } else if (option2 === \"defaultScope\" && _.isPlainObject(self.options.defaultScope)) {\n        scope = self.options.defaultScope;\n      } else {\n        scopeName = option2;\n        scope = self.options.scopes[scopeName];\n        if (typeof scope === \"function\") {\n          scope = scope();\n        }\n      }\n      if (scope) {\n        this._conformIncludes(scope, this);\n        this._assignOptions(self._scope, Utils.cloneDeep(scope));\n        self._scopeNames.push(scopeName ? scopeName : \"defaultScope\");\n      } else {\n        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);\n      }\n    }\n    return self;\n  }\n  static async findAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new sequelizeErrors.QueryError(\"The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    if (options !== void 0 && options.attributes) {\n      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {\n        throw new sequelizeErrors.QueryError(\"The attributes option must be an array of column names or an object\");\n      }\n    }\n    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));\n    const tableNames = {};\n    tableNames[this.getTableName(options)] = true;\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    _.defaults(options, { hooks: true });\n    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, \"rejectOnEmpty\") ? options.rejectOnEmpty : this.options.rejectOnEmpty;\n    this._injectScope(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFind\", options);\n    }\n    this._conformIncludes(options, this);\n    this._expandAttributes(options);\n    this._expandIncludeAll(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterExpandIncludeAll\", options);\n    }\n    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    if (options.include) {\n      options.hasJoin = true;\n      this._validateIncludedElements(options, tableNames);\n      if (options.attributes && !options.raw && this.primaryKeyAttribute && !options.attributes.includes(this.primaryKeyAttribute) && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)) {\n        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n      }\n    }\n    if (!options.attributes) {\n      options.attributes = Object.keys(this.rawAttributes);\n      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    }\n    this.options.whereCollection = options.where || null;\n    Utils.mapFinderOptions(options, this);\n    options = this._paranoidClause(this, options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterOptions\", options);\n    }\n    const selectOptions = __spreadProps(__spreadValues({}, options), { tableNames: Object.keys(tableNames) });\n    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);\n    if (options.hooks) {\n      await this.runHooks(\"afterFind\", results, options);\n    }\n    if (_.isEmpty(results) && options.rejectOnEmpty) {\n      if (typeof options.rejectOnEmpty === \"function\") {\n        throw new options.rejectOnEmpty();\n      }\n      if (typeof options.rejectOnEmpty === \"object\") {\n        throw options.rejectOnEmpty;\n      }\n      throw new sequelizeErrors.EmptyResultError();\n    }\n    return await Model._findSeparate(results, options);\n  }\n  static warnOnInvalidOptions(options, validColumnNames) {\n    if (!_.isPlainObject(options)) {\n      return;\n    }\n    const unrecognizedOptions = Object.keys(options).filter((k) => !validQueryKeywords.has(k));\n    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      logger.warn(`Model attributes (${unexpectedModelAttributes.join(\", \")}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);\n    }\n  }\n  static _injectDependentVirtualAttributes(attributes) {\n    if (!this._hasVirtualAttributes)\n      return attributes;\n    if (!attributes || !Array.isArray(attributes))\n      return attributes;\n    for (const attribute of attributes) {\n      if (this._virtualAttributes.has(attribute) && this.rawAttributes[attribute].type.fields) {\n        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);\n      }\n    }\n    attributes = _.uniq(attributes);\n    return attributes;\n  }\n  static async _findSeparate(results, options) {\n    if (!options.include || options.raw || !results)\n      return results;\n    const original = results;\n    if (options.plain)\n      results = [results];\n    if (!results.length)\n      return original;\n    await Promise.all(options.include.map(async (include) => {\n      if (!include.separate) {\n        return await Model._findSeparate(results.reduce((memo, result) => {\n          let associations = result.get(include.association.as);\n          if (!associations)\n            return memo;\n          if (!Array.isArray(associations))\n            associations = [associations];\n          for (let i = 0, len = associations.length; i !== len; ++i) {\n            memo.push(associations[i]);\n          }\n          return memo;\n        }, []), __spreadProps(__spreadValues({}, _.omit(options, \"include\", \"attributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"scope\")), {\n          include: include.include || []\n        }));\n      }\n      const map = await include.association.get(results, __spreadValues(__spreadValues({}, _.omit(options, nonCascadingOptions)), _.omit(include, [\"parent\", \"association\", \"as\", \"originalAttributes\"])));\n      for (const result of results) {\n        result.set(include.association.as, map[result.get(include.association.sourceKey)], { raw: true });\n      }\n    }));\n    return original;\n  }\n  static async findByPk(param, options) {\n    if ([null, void 0].includes(param)) {\n      return null;\n    }\n    options = Utils.cloneDeep(options) || {};\n    if (typeof param === \"number\" || typeof param === \"bigint\" || typeof param === \"string\" || Buffer.isBuffer(param)) {\n      options.where = {\n        [this.primaryKeyAttribute]: param\n      };\n    } else {\n      throw new Error(`Argument passed to findByPk is invalid: ${param}`);\n    }\n    return await this.findOne(options);\n  }\n  static async findOne(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.limit === void 0) {\n      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter((c) => c.fields.length === 1).map(\"column\").value();\n      if (!options.where || !_.some(options.where, (value, key) => (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) && (Utils.isPrimitive(value) || Buffer.isBuffer(value)))) {\n        options.limit = 1;\n      }\n    }\n    return await this.findAll(_.defaults(options, {\n      plain: true\n    }));\n  }\n  static async aggregate(attribute, aggregateFunction, options) {\n    options = Utils.cloneDeep(options);\n    const prevAttributes = options.attributes;\n    this._injectScope(options);\n    options.attributes = prevAttributes;\n    this._conformIncludes(options, this);\n    if (options.include) {\n      this._expandIncludeAll(options);\n      this._validateIncludedElements(options);\n    }\n    const attrOptions = this.rawAttributes[attribute];\n    const field = attrOptions && attrOptions.field || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn(\"DISTINCT\", aggregateColumn);\n    }\n    let { group } = options;\n    if (Array.isArray(group) && Array.isArray(group[0])) {\n      noDoubleNestedGroup();\n      group = _.flatten(group);\n    }\n    options.attributes = _.unionBy(options.attributes, group, [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]], (a) => Array.isArray(a) ? a[1] : a);\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n    Utils.mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);\n    return value;\n  }\n  static async count(options) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { hooks: true });\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.raw = true;\n    if (options.hooks) {\n      await this.runHooks(\"beforeCount\", options);\n    }\n    let col = options.col || \"*\";\n    if (options.include) {\n      col = `${this.name}.${options.col || this.primaryKeyField}`;\n    }\n    if (options.distinct && col === \"*\") {\n      col = this.primaryKeyField;\n    }\n    options.plain = !options.group;\n    options.dataType = new DataTypes.INTEGER();\n    options.includeIgnoreAttributes = false;\n    options.limit = null;\n    options.offset = null;\n    options.order = null;\n    const result = await this.aggregate(col, \"count\", options);\n    if (Array.isArray(result)) {\n      return result.map((item) => __spreadProps(__spreadValues({}, item), {\n        count: Number(item.count)\n      }));\n    }\n    return result;\n  }\n  static async findAndCountAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    const countOptions = Utils.cloneDeep(options);\n    if (countOptions.attributes) {\n      countOptions.attributes = void 0;\n    }\n    const [count, rows] = await Promise.all([\n      this.count(countOptions),\n      this.findAll(options)\n    ]);\n    return {\n      count,\n      rows: count === 0 ? [] : rows\n    };\n  }\n  static async max(field, options) {\n    return await this.aggregate(field, \"max\", options);\n  }\n  static async min(field, options) {\n    return await this.aggregate(field, \"min\", options);\n  }\n  static async sum(field, options) {\n    return await this.aggregate(field, \"sum\", options);\n  }\n  static build(values, options) {\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n    return new this(values, options);\n  }\n  static bulkBuild(valueSets, options) {\n    options = __spreadValues({ isNewRecord: true }, options);\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    return valueSets.map((values) => this.build(values, options));\n  }\n  static async create(values, options) {\n    options = Utils.cloneDeep(options || {});\n    return await this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent\n    }).save(options);\n  }\n  static async findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    let values;\n    let instance = await this.findOne(options);\n    if (instance === null) {\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      instance = this.build(values, options);\n      return [instance, true];\n    }\n    return [instance, false];\n  }\n  static async findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    options = __spreadValues({}, options);\n    if (options.defaults) {\n      const defaults = Object.keys(options.defaults);\n      const unknownDefaults = defaults.filter((name) => !this.rawAttributes[name]);\n      if (unknownDefaults.length) {\n        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);\n      }\n    }\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n    try {\n      const t = await this.sequelize.transaction(options);\n      transaction = t;\n      options.transaction = t;\n      const found = await this.findOne(Utils.defaults({ transaction }, options));\n      if (found !== null) {\n        return [found, false];\n      }\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      options.exception = true;\n      options.returning = true;\n      try {\n        const created = await this.create(values, options);\n        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          throw new sequelizeErrors.UniqueConstraintError();\n        }\n        return [created, true];\n      } catch (err) {\n        if (!(err instanceof sequelizeErrors.UniqueConstraintError))\n          throw err;\n        const flattenedWhere = Utils.flattenObjectDeep(options.where);\n        const flattenedWhereKeys = Object.keys(flattenedWhere).map((name) => _.last(name.split(\".\")));\n        const whereFields = flattenedWhereKeys.map((name) => _.get(this.rawAttributes, `${name}.field`, name));\n        const defaultFields = options.defaults && Object.keys(options.defaults).filter((name) => this.rawAttributes[name]).map((name) => this.rawAttributes[name].field || name);\n        const errFieldKeys = Object.keys(err.fields);\n        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);\n        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {\n          throw err;\n        }\n        if (errFieldsWhereIntersects) {\n          _.each(err.fields, (value, key) => {\n            const name = this.fieldRawAttributesMap[key].fieldName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);\n            }\n          });\n        }\n        const otherCreated = await this.findOne(Utils.defaults({\n          transaction: internalTransaction ? null : transaction\n        }, options));\n        if (otherCreated === null)\n          throw err;\n        return [otherCreated, false];\n      }\n    } finally {\n      if (internalTransaction && transaction) {\n        await transaction.commit();\n      }\n    }\n  }\n  static async findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findCreateFind.\");\n    }\n    let values = __spreadValues({}, options.defaults);\n    if (_.isPlainObject(options.where)) {\n      values = Utils.defaults(values, options.where);\n    }\n    const found = await this.findOne(options);\n    if (found)\n      return [found, false];\n    try {\n      const createOptions = __spreadValues({}, options);\n      if (this.sequelize.options.dialect === \"postgres\" && options.transaction) {\n        createOptions.ignoreDuplicates = true;\n      }\n      const created = await this.create(values, createOptions);\n      return [created, true];\n    } catch (err) {\n      if (!(err instanceof sequelizeErrors.UniqueConstraintError || err instanceof sequelizeErrors.EmptyResultError)) {\n        throw err;\n      }\n      const foundAgain = await this.findOne(options);\n      return [foundAgain, false];\n    }\n  }\n  static async upsert(values, options) {\n    options = __spreadValues({\n      hooks: true,\n      returning: true,\n      validate: true\n    }, Utils.cloneDeep(options));\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n    options.model = this;\n    options.instance = instance;\n    const changed = Array.from(instance._changed);\n    if (!options.fields) {\n      options.fields = changed;\n    }\n    if (options.validate) {\n      await instance.validate(options);\n    }\n    const updatedDataValues = _.pick(instance.dataValues, changed);\n    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);\n    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);\n    const now = Utils.now(this.sequelize.options.dialect);\n    if (createdAtAttr && !insertValues[createdAtAttr]) {\n      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;\n      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\") {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(insertValues, this.rawAttributes, this.uniqno);\n    }\n    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n      delete insertValues[this.primaryKeyField];\n      delete updateValues[this.primaryKeyField];\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeUpsert\", values, options);\n    }\n    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);\n    const [record] = result;\n    record.isNewRecord = false;\n    if (options.hooks) {\n      await this.runHooks(\"afterUpsert\", result, options);\n      return result;\n    }\n    return result;\n  }\n  static async bulkCreate(records, options = {}) {\n    if (!records.length) {\n      return [];\n    }\n    const dialect = this.sequelize.options.dialect;\n    const now = Utils.now(this.sequelize.options.dialect);\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.model = this;\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    const instances = records.map((values) => this.build(values, { isNewRecord: true, include: options.include }));\n    const recursiveBulkCreate = async (instances2, options2) => {\n      options2 = __spreadValues({\n        validate: false,\n        hooks: true,\n        individualHooks: false,\n        ignoreDuplicates: false\n      }, options2);\n      if (options2.returning === void 0) {\n        if (options2.association) {\n          options2.returning = false;\n        } else {\n          options2.returning = true;\n        }\n      }\n      if (options2.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.onConflictDoNothing) {\n        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);\n      }\n      if (options2.updateOnDuplicate && (dialect !== \"mysql\" && dialect !== \"mariadb\" && dialect !== \"sqlite\" && dialect !== \"postgres\")) {\n        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);\n      }\n      const model = options2.model;\n      options2.fields = options2.fields || Object.keys(model.rawAttributes);\n      const createdAtAttr = model._timestampAttributes.createdAt;\n      const updatedAtAttr = model._timestampAttributes.updatedAt;\n      if (options2.updateOnDuplicate !== void 0) {\n        if (Array.isArray(options2.updateOnDuplicate) && options2.updateOnDuplicate.length) {\n          options2.updateOnDuplicate = _.intersection(_.without(Object.keys(model.tableAttributes), createdAtAttr), options2.updateOnDuplicate);\n        } else {\n          throw new Error(\"updateOnDuplicate option only supports non-empty array.\");\n        }\n      }\n      if (options2.hooks) {\n        await model.runHooks(\"beforeBulkCreate\", instances2, options2);\n      }\n      if (options2.validate) {\n        const errors = [];\n        const validateOptions = __spreadValues({}, options2);\n        validateOptions.hooks = options2.individualHooks;\n        await Promise.all(instances2.map(async (instance) => {\n          try {\n            await instance.validate(validateOptions);\n          } catch (err) {\n            errors.push(new sequelizeErrors.BulkRecordError(err, instance));\n          }\n        }));\n        delete options2.skip;\n        if (errors.length) {\n          throw new sequelizeErrors.AggregateError(errors);\n        }\n      }\n      if (options2.individualHooks) {\n        await Promise.all(instances2.map(async (instance) => {\n          const individualOptions = __spreadProps(__spreadValues({}, options2), {\n            validate: false,\n            hooks: true\n          });\n          delete individualOptions.fields;\n          delete individualOptions.individualHooks;\n          delete individualOptions.ignoreDuplicates;\n          await instance.save(individualOptions);\n        }));\n      } else {\n        if (options2.include && options2.include.length) {\n          await Promise.all(options2.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n            const associationInstances = [];\n            const associationInstanceIndexToInstanceMap = [];\n            for (const instance of instances2) {\n              const associationInstance = instance.get(include.as);\n              if (associationInstance) {\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n            if (!associationInstances.length) {\n              return;\n            }\n            const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              await include.association.set(instance, associationInstance, { save: false, logging: options2.logging });\n            }\n          }));\n        }\n        records = instances2.map((instance) => {\n          const values = instance.dataValues;\n          if (createdAtAttr && !values[createdAtAttr]) {\n            values[createdAtAttr] = now;\n            if (!options2.fields.includes(createdAtAttr)) {\n              options2.fields.push(createdAtAttr);\n            }\n          }\n          if (updatedAtAttr && !values[updatedAtAttr]) {\n            values[updatedAtAttr] = now;\n            if (!options2.fields.includes(updatedAtAttr)) {\n              options2.fields.push(updatedAtAttr);\n            }\n          }\n          const out = Utils.mapValueFieldNames(values, options2.fields, model);\n          for (const key of model._virtualAttributes) {\n            delete out[key];\n          }\n          return out;\n        });\n        const fieldMappedAttributes = {};\n        for (const attr in model.tableAttributes) {\n          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];\n        }\n        if (options2.updateOnDuplicate) {\n          options2.updateOnDuplicate = options2.updateOnDuplicate.map((attr) => model.rawAttributes[attr].field || attr);\n          if (options2.conflictAttributes) {\n            options2.upsertKeys = options2.conflictAttributes.map((attrName) => model.rawAttributes[attrName].field || attrName);\n          } else {\n            const upsertKeys = [];\n            for (const i of model._indexes) {\n              if (i.unique && !i.where) {\n                upsertKeys.push(...i.fields);\n              }\n            }\n            const firstUniqueKey = Object.values(model.uniqueKeys).find((c) => c.fields.length > 0);\n            if (firstUniqueKey && firstUniqueKey.fields) {\n              upsertKeys.push(...firstUniqueKey.fields);\n            }\n            options2.upsertKeys = upsertKeys.length > 0 ? upsertKeys : Object.values(model.primaryKeys).map((x) => x.field);\n          }\n        }\n        if (options2.returning && Array.isArray(options2.returning)) {\n          options2.returning = options2.returning.map((attr) => _.get(model.rawAttributes[attr], \"field\", attr));\n        }\n        const results = await model.queryInterface.bulkInsert(model.getTableName(options2), records, options2, fieldMappedAttributes);\n        if (Array.isArray(results)) {\n          results.forEach((result, i) => {\n            const instance = instances2[i];\n            for (const key in result) {\n              if (!instance || key === model.primaryKeyAttribute && instance.get(model.primaryKeyAttribute) && [\"mysql\", \"mariadb\", \"sqlite\"].includes(dialect)) {\n                continue;\n              }\n              if (Object.prototype.hasOwnProperty.call(result, key)) {\n                const record = result[key];\n                const attr = _.find(model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n                instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            }\n          });\n        }\n      }\n      if (options2.include && options2.include.length) {\n        await Promise.all(options2.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n          const associationInstances = [];\n          const associationInstanceIndexToInstanceMap = [];\n          for (const instance of instances2) {\n            let associated = instance.get(include.as);\n            if (!Array.isArray(associated))\n              associated = [associated];\n            for (const associationInstance of associated) {\n              if (associationInstance) {\n                if (!(include.association instanceof BelongsToMany)) {\n                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n                  Object.assign(associationInstance, include.association.scope);\n                }\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n          }\n          if (!associationInstances.length) {\n            return;\n          }\n          const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n            transaction: options2.transaction,\n            logging: options2.logging\n          }).value();\n          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n          if (include.association instanceof BelongsToMany) {\n            const valueSets = [];\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              const values = __spreadValues({\n                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),\n                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true })\n              }, include.association.through.scope);\n              if (associationInstance[include.association.through.model.name]) {\n                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                  if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof associationInstance[include.association.through.model.name][attr] === \"undefined\") {\n                    continue;\n                  }\n                  values[attr] = associationInstance[include.association.through.model.name][attr];\n                }\n              }\n              valueSets.push(values);\n            }\n            const throughOptions = _(Utils.cloneDeep(include)).omit([\"association\", \"attributes\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            throughOptions.model = include.association.throughModel;\n            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);\n            await recursiveBulkCreate(throughInstances, throughOptions);\n          }\n        }));\n      }\n      instances2.forEach((instance) => {\n        for (const attr in model.rawAttributes) {\n          if (model.rawAttributes[attr].field && instance.dataValues[model.rawAttributes[attr].field] !== void 0 && model.rawAttributes[attr].field !== attr) {\n            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];\n            delete instance.dataValues[model.rawAttributes[attr].field];\n          }\n          instance._previousDataValues[attr] = instance.dataValues[attr];\n          instance.changed(attr, false);\n        }\n        instance.isNewRecord = false;\n      });\n      if (options2.hooks) {\n        await model.runHooks(\"afterBulkCreate\", instances2, options2);\n      }\n      return instances2;\n    };\n    return await recursiveBulkCreate(instances, options);\n  }\n  static async truncate(options) {\n    options = Utils.cloneDeep(options) || {};\n    options.truncate = true;\n    return await this.destroy(options);\n  }\n  static async destroy(options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    if (!options || !(options.where || options.truncate)) {\n      throw new Error(\"Missing where or truncate attribute in the options parameter of model.destroy.\");\n    }\n    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {\n      throw new Error(\"Expected plain object, array or sequelize method in the options.where parameter of model.destroy.\");\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n      cascade: false,\n      restartIdentity: false\n    });\n    options.type = QueryTypes.BULKDELETE;\n    Utils.mapOptionFieldNames(options, this);\n    options.model = this;\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkDestroy\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeDestroy\", instance, options)));\n    }\n    let result;\n    if (this._timestampAttributes.deletedAt && !options.force) {\n      options.type = QueryTypes.BULKUPDATE;\n      const attrValueHash = {};\n      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];\n      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;\n      const where = {\n        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null\n      };\n      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);\n      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);\n    } else {\n      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterDestroy\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkDestroy\", options);\n    }\n    return result;\n  }\n  static async restore(options) {\n    if (!this._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      individualHooks: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.type = QueryTypes.RAW;\n    options.model = this;\n    Utils.mapOptionFieldNames(options, this);\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkRestore\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeRestore\", instance, options)));\n    }\n    const attrValueHash = {};\n    const deletedAtCol = this._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    options.omitNull = false;\n    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterRestore\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkRestore\", options);\n    }\n    return result;\n  }\n  static async update(values, options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = this._paranoidClause(this, _.defaults(options, {\n      validate: true,\n      hooks: true,\n      individualHooks: false,\n      returning: false,\n      force: false,\n      sideEffects: true\n    }));\n    options.type = QueryTypes.BULKUPDATE;\n    values = _.omitBy(values, (value) => value === void 0);\n    if (options.fields && options.fields instanceof Array) {\n      for (const key of Object.keys(values)) {\n        if (!options.fields.includes(key)) {\n          delete values[key];\n        }\n      }\n    } else {\n      const updatedAtAttr = this._timestampAttributes.updatedAt;\n      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {\n        options.fields.push(updatedAtAttr);\n      }\n    }\n    if (this._timestampAttributes.updatedAt && !options.silent) {\n      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n    }\n    options.model = this;\n    let valuesUse;\n    if (options.validate) {\n      const build = this.build(values);\n      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });\n      if (options.sideEffects) {\n        Object.assign(values, _.pick(build.get(), build.changed()));\n        options.fields = _.union(options.fields, Object.keys(values));\n      }\n      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));\n      const attributes = await build.validate(options);\n      options.skip = void 0;\n      if (attributes && attributes.dataValues) {\n        values = _.pick(attributes.dataValues, Object.keys(values));\n      }\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"beforeBulkUpdate\", options);\n      values = options.attributes;\n      delete options.attributes;\n    }\n    valuesUse = values;\n    let instances;\n    let updateDoneRowByRow = false;\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n        paranoid: options.paranoid\n      });\n      if (instances.length) {\n        let changedValues;\n        let different = false;\n        instances = await Promise.all(instances.map(async (instance) => {\n          Object.assign(instance.dataValues, values);\n          _.forIn(valuesUse, (newValue, attr) => {\n            if (newValue !== instance._previousDataValues[attr]) {\n              instance.setDataValue(attr, newValue);\n            }\n          });\n          await this.runHooks(\"beforeUpdate\", instance, options);\n          if (!different) {\n            const thisChangedValues = {};\n            _.forIn(instance.dataValues, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                thisChangedValues[attr] = newValue;\n              }\n            });\n            if (!changedValues) {\n              changedValues = thisChangedValues;\n            } else {\n              different = !_.isEqual(changedValues, thisChangedValues);\n            }\n          }\n          return instance;\n        }));\n        if (!different) {\n          const keys = Object.keys(changedValues);\n          if (keys.length) {\n            valuesUse = changedValues;\n            options.fields = _.union(options.fields, keys);\n          }\n        } else {\n          instances = await Promise.all(instances.map(async (instance) => {\n            const individualOptions = __spreadProps(__spreadValues({}, options), {\n              hooks: false,\n              validate: false\n            });\n            delete individualOptions.individualHooks;\n            return instance.save(individualOptions);\n          }));\n          updateDoneRowByRow = true;\n        }\n      }\n    }\n    let result;\n    if (updateDoneRowByRow) {\n      result = [instances.length, instances];\n    } else if (_.isEmpty(valuesUse) || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {\n      result = [0];\n    } else {\n      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);\n      options = Utils.mapOptionFieldNames(options, this);\n      options.hasTrigger = this.options ? this.options.hasTrigger : false;\n      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);\n      if (options.returning) {\n        result = [affectedRows.length, affectedRows];\n        instances = affectedRows;\n      } else {\n        result = [affectedRows];\n      }\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterUpdate\", instance, options)));\n      result[1] = instances;\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"afterBulkUpdate\", options);\n      delete options.attributes;\n    }\n    return result;\n  }\n  static async describe(schema, options) {\n    return await this.queryInterface.describeTable(this.tableName, __spreadValues({ schema: schema || this._schema || void 0 }, options));\n  }\n  static _getDefaultTimestamp(attr) {\n    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);\n    }\n    return void 0;\n  }\n  static _expandAttributes(options) {\n    if (!_.isPlainObject(options.attributes)) {\n      return;\n    }\n    let attributes = Object.keys(this.rawAttributes);\n    if (options.attributes.exclude) {\n      attributes = attributes.filter((elem) => !options.attributes.exclude.includes(elem));\n    }\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n    options.attributes = attributes;\n  }\n  static _injectScope(options) {\n    const scope = Utils.cloneDeep(this._scope);\n    this._defaultsOptions(options, scope);\n  }\n  static [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.name;\n  }\n  static hasAlias(alias) {\n    return Object.prototype.hasOwnProperty.call(this.associations, alias);\n  }\n  static async increment(fields, options) {\n    options = options || {};\n    if (typeof fields === \"string\")\n      fields = [fields];\n    if (Array.isArray(fields)) {\n      fields = fields.map((f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          return this.rawAttributes[f].field;\n        }\n        return f;\n      });\n    } else if (fields && typeof fields === \"object\") {\n      fields = Object.keys(fields).reduce((rawFields, f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          rawFields[this.rawAttributes[f].field] = fields[f];\n        } else {\n          rawFields[f] = fields[f];\n        }\n        return rawFields;\n      }, {});\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = Utils.defaults({}, options, {\n      by: 1,\n      where: {},\n      increment: true\n    });\n    const isSubtraction = !options.increment;\n    Utils.mapOptionFieldNames(options, this);\n    const where = __spreadValues({}, options.where);\n    let incrementAmountsByField = {};\n    if (Array.isArray(fields)) {\n      incrementAmountsByField = {};\n      for (const field of fields) {\n        incrementAmountsByField[field] = options.by;\n      }\n    } else {\n      incrementAmountsByField = fields;\n    }\n    if (this._versionAttribute) {\n      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;\n    }\n    const extraAttributesToBeUpdated = {};\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {\n      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n    }\n    const tableName = this.getTableName(options);\n    let affectedRows;\n    if (isSubtraction) {\n      affectedRows = await this.queryInterface.decrement(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    } else {\n      affectedRows = await this.queryInterface.increment(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    }\n    if (options.returning) {\n      return [affectedRows, affectedRows.length];\n    }\n    return [affectedRows];\n  }\n  static async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, \"Missing where attribute in the options parameter\");\n    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod, \"Expected plain object, array or sequelize method in the options.where parameter\");\n  }\n  where(checkVersion) {\n    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {\n      result[attribute] = this.get(attribute, { raw: true });\n      return result;\n    }, {});\n    if (_.size(where) === 0) {\n      return this.constructor.options.whereCollection;\n    }\n    const versionAttr = this.constructor._versionAttribute;\n    if (checkVersion && versionAttr) {\n      where[versionAttr] = this.get(versionAttr, { raw: true });\n    }\n    return Utils.mapWhereFieldNames(where, this.constructor);\n  }\n  toString() {\n    return `[object SequelizeInstance:${this.constructor.name}]`;\n  }\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n    if (!_.isEqual(value, originalValue)) {\n      this.changed(key, true);\n    }\n    this.dataValues[key] = value;\n  }\n  get(key, options) {\n    if (options === void 0 && typeof key === \"object\") {\n      options = key;\n      key = void 0;\n    }\n    options = options || {};\n    if (key) {\n      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {\n        return this._customGetters[key].call(this, key, options);\n      }\n      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {\n        if (Array.isArray(this.dataValues[key])) {\n          return this.dataValues[key].map((instance) => instance.get(options));\n        }\n        if (this.dataValues[key] instanceof Model) {\n          return this.dataValues[key].get(options);\n        }\n        return this.dataValues[key];\n      }\n      return this.dataValues[key];\n    }\n    if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {\n      const values = {};\n      let _key;\n      if (this._hasCustomGetters) {\n        for (_key in this._customGetters) {\n          if (this._options.attributes && !this._options.attributes.includes(_key)) {\n            continue;\n          }\n          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {\n            values[_key] = this.get(_key, options);\n          }\n        }\n      }\n      for (_key in this.dataValues) {\n        if (!Object.prototype.hasOwnProperty.call(values, _key) && Object.prototype.hasOwnProperty.call(this.dataValues, _key)) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n      return values;\n    }\n    return this.dataValues;\n  }\n  set(key, value, options) {\n    let values;\n    let originalValue;\n    if (typeof key === \"object\" && key !== null) {\n      values = key;\n      options = value || {};\n      if (options.reset) {\n        this.dataValues = {};\n        for (const key2 in values) {\n          this.changed(key2, false);\n        }\n      }\n      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {\n        if (Object.keys(this.dataValues).length) {\n          Object.assign(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n        this._previousDataValues = __spreadValues({}, this.dataValues);\n      } else {\n        if (options.attributes) {\n          const setKeys = (data) => {\n            for (const k of data) {\n              if (values[k] === void 0) {\n                continue;\n              }\n              this.set(k, values[k], options);\n            }\n          };\n          setKeys(options.attributes);\n          if (this.constructor._hasVirtualAttributes) {\n            setKeys(this.constructor._virtualAttributes);\n          }\n          if (this._options.includeNames) {\n            setKeys(this._options.includeNames);\n          }\n        } else {\n          for (const key2 in values) {\n            this.set(key2, values[key2], options);\n          }\n        }\n        if (options.raw) {\n          this._previousDataValues = __spreadValues({}, this.dataValues);\n        }\n      }\n      return this;\n    }\n    if (!options)\n      options = {};\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n    if (!options.raw && this._customSetters[key]) {\n      this._customSetters[key].call(this, value, key);\n      const newValue = this.dataValues[key];\n      if (!_.isEqual(newValue, originalValue)) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      if (this._options && this._options.include && this._options.includeNames.includes(key)) {\n        this._setInclude(key, value, options);\n        return this;\n      }\n      if (!options.raw) {\n        if (!this._isAttribute(key)) {\n          if (key.includes(\".\") && this.constructor._jsonAttributes.has(key.split(\".\")[0])) {\n            const previousNestedValue = Dottie.get(this.dataValues, key);\n            if (!_.isEqual(previousNestedValue, value)) {\n              Dottie.set(this.dataValues, key, value);\n              this.changed(key.split(\".\")[0], true);\n            }\n          }\n          return this;\n        }\n        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {\n          return this;\n        }\n        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {\n          return this;\n        }\n      }\n      if (!(value instanceof Utils.SequelizeMethod) && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)) {\n        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);\n      }\n      if (!options.raw && (value instanceof Utils.SequelizeMethod || !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n      this.dataValues[key] = value;\n    }\n    return this;\n  }\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n  changed(key, value) {\n    if (key === void 0) {\n      if (this._changed.size > 0) {\n        return Array.from(this._changed);\n      }\n      return false;\n    }\n    if (value === true) {\n      this._changed.add(key);\n      return this;\n    }\n    if (value === false) {\n      this._changed.delete(key);\n      return this;\n    }\n    return this._changed.has(key);\n  }\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n    return _.pickBy(this._previousDataValues, (value, key2) => this.changed(key2));\n  }\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value))\n      value = [value];\n    if (value[0] instanceof Model) {\n      value = value.map((instance) => instance.dataValues);\n    }\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const accessor = key;\n    const primaryKeyAttribute = include.model.primaryKeyAttribute;\n    const childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes\n    };\n    let isEmpty;\n    if (include.originalAttributes === void 0 || include.originalAttributes.length) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n        isEmpty = value && value[primaryKeyAttribute] === null || value === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n  async save(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"The second argument was removed in favor of the options object.\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      validate: true\n    });\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Object.keys(this.constructor.rawAttributes);\n      } else {\n        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));\n      }\n      options.defaultFields = options.fields;\n    }\n    if (options.returning === void 0) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];\n    const createdAtAttr = this.constructor._timestampAttributes.createdAt;\n    const versionAttr = this.constructor._versionAttribute;\n    const hook = this.isNewRecord ? \"Create\" : \"Update\";\n    const wasNewRecord = this.isNewRecord;\n    const now = Utils.now(this.sequelize.options.dialect);\n    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;\n    if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {\n      options.fields.push(updatedAtAttr);\n    }\n    if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {\n      options.fields.push(versionAttr);\n    }\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {\n      _.remove(options.fields, (val) => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {\n        options.fields.push(createdAtAttr);\n      }\n      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n    if (this.isNewRecord === false) {\n      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === void 0) {\n        throw new Error(\"You attempted to save an instance with no primary key, this is not allowed since it would result in a global update\");\n      }\n    }\n    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\" && this.isNewRecord) {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(this.dataValues, this.constructor.rawAttributes, this.uniqno);\n    }\n    if (options.validate) {\n      await this.validate(options);\n    }\n    if (options.hooks) {\n      const beforeHookValues = _.pick(this.dataValues, options.fields);\n      let ignoreChanged = _.difference(this.changed(), options.fields);\n      let hookChanged;\n      let afterHookValues;\n      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {\n        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n      }\n      await this.constructor.runHooks(`before${hook}`, this, options);\n      if (options.defaultFields && !this.isNewRecord) {\n        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n        hookChanged = [];\n        for (const key of Object.keys(afterHookValues)) {\n          if (afterHookValues[key] !== beforeHookValues[key]) {\n            hookChanged.push(key);\n          }\n        }\n        options.fields = _.uniq(options.fields.concat(hookChanged));\n      }\n      if (hookChanged) {\n        if (options.validate) {\n          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);\n          await this.validate(options);\n          delete options.skip;\n        }\n      }\n    }\n    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n        const instance = this.get(include.as);\n        if (!instance)\n          return;\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await instance.save(includeOptions);\n        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });\n      }));\n    }\n    const realFields = options.fields.filter((field) => !this.constructor._virtualAttributes.has(field));\n    if (!realFields.length)\n      return this;\n    if (!this.changed() && !this.isNewRecord)\n      return this;\n    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], \"field\") || versionAttr;\n    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n    let query = null;\n    let args = [];\n    let where;\n    if (this.isNewRecord) {\n      query = \"insert\";\n      args = [this, this.constructor.getTableName(options), values, options];\n    } else {\n      where = this.where(true);\n      if (versionAttr) {\n        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;\n      }\n      query = \"update\";\n      args = [this, this.constructor.getTableName(options), values, where, options];\n    }\n    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);\n    if (versionAttr) {\n      if (rowsUpdated < 1) {\n        throw new sequelizeErrors.OptimisticLockError({\n          modelName: this.constructor.name,\n          values,\n          where\n        });\n      } else {\n        result.dataValues[versionAttr] = values[versionFieldName];\n      }\n    }\n    for (const attr of Object.keys(this.constructor.rawAttributes)) {\n      if (this.constructor.rawAttributes[attr].field && values[this.constructor.rawAttributes[attr].field] !== void 0 && this.constructor.rawAttributes[attr].field !== attr) {\n        values[attr] = values[this.constructor.rawAttributes[attr].field];\n        delete values[this.constructor.rawAttributes[attr].field];\n      }\n    }\n    Object.assign(values, result.dataValues);\n    Object.assign(result.dataValues, values);\n    if (wasNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n        let instances = this.get(include.as);\n        if (!instances)\n          return;\n        if (!Array.isArray(instances))\n          instances = [instances];\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await Promise.all(instances.map(async (instance) => {\n          if (include.association instanceof BelongsToMany) {\n            await instance.save(includeOptions);\n            const values0 = __spreadValues({\n              [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),\n              [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true })\n            }, include.association.through.scope);\n            if (instance[include.association.through.model.name]) {\n              for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof instance[include.association.through.model.name][attr] === \"undefined\") {\n                  continue;\n                }\n                values0[attr] = instance[include.association.through.model.name][attr];\n              }\n            }\n            await include.association.throughModel.create(values0, includeOptions);\n          } else {\n            instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n            Object.assign(instance, include.association.scope);\n            await instance.save(includeOptions);\n          }\n        }));\n      }));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(`after${hook}`, result, options);\n    }\n    for (const field of options.fields) {\n      result._previousDataValues[field] = result.dataValues[field];\n      this.changed(field, false);\n    }\n    this.isNewRecord = false;\n    return result;\n  }\n  async reload(options) {\n    options = Utils.defaults({\n      where: this.where()\n    }, options, {\n      include: this._options.include || void 0\n    });\n    const reloaded = await this.constructor.findOne(options);\n    if (!reloaded) {\n      throw new sequelizeErrors.InstanceError(\"Instance could not be reloaded because it does not exist anymore (find call returned null)\");\n    }\n    this._options = reloaded._options;\n    this.set(reloaded.dataValues, {\n      raw: true,\n      reset: !options.attributes\n    });\n    return this;\n  }\n  async validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n  async update(values, options) {\n    values = _.omitBy(values, (value) => value === void 0);\n    const changedBefore = this.changed() || [];\n    options = options || {};\n    if (Array.isArray(options))\n      options = { fields: options };\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const setOptions = Utils.cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n    const sideEffects = _.without(this.changed(), ...changedBefore);\n    const fields = _.union(Object.keys(values), sideEffects);\n    if (!options.fields) {\n      options.fields = _.intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n    return await this.save(options);\n  }\n  async destroy(options) {\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeDestroy\", this, options);\n    }\n    const where = this.where(true);\n    let result;\n    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {\n      const attributeName = this.constructor._timestampAttributes.deletedAt;\n      const attribute = this.constructor.rawAttributes[attributeName];\n      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\") ? attribute.defaultValue : null;\n      const currentValue = this.getDataValue(attributeName);\n      const undefinedOrNull = currentValue == null && defaultValue == null;\n      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {\n        this.setDataValue(attributeName, new Date());\n      }\n      result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false }));\n    } else {\n      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, __spreadValues({ type: QueryTypes.DELETE, limit: null }, options));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterDestroy\", this, options);\n    }\n    return result;\n  }\n  isSoftDeleted() {\n    if (!this.constructor._timestampAttributes.deletedAt) {\n      throw new Error(\"Model is not paranoid\");\n    }\n    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;\n    const isSet = deletedAt !== defaultValue;\n    return isSet;\n  }\n  async restore(options) {\n    if (!this.constructor._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeRestore\", this, options);\n    }\n    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n    const result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false, omitNull: false }));\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterRestore\", this, options);\n      return result;\n    }\n    return result;\n  }\n  async increment(fields, options) {\n    const identifier = this.where();\n    options = Utils.cloneDeep(options);\n    options.where = __spreadValues(__spreadValues({}, options.where), identifier);\n    options.instance = this;\n    await this.constructor.increment(fields, options);\n    return this;\n  }\n  async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  equals(other) {\n    if (!other || !other.constructor) {\n      return false;\n    }\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n    return this.constructor.primaryKeyAttributes.every((attribute) => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));\n  }\n  equalsOneOf(others) {\n    return others.some((other) => this.equals(other));\n  }\n  setValidators(attribute, validators) {\n    this.validators[attribute] = validators;\n  }\n  toJSON() {\n    return _.cloneDeep(this.get({\n      plain: true\n    }));\n  }\n  static hasMany(target, options) {\n  }\n  static belongsToMany(target, options) {\n  }\n  static hasOne(target, options) {\n  }\n  static belongsTo(target, options) {\n  }\n}\nfunction unpackAnd(where) {\n  if (!_.isObject(where)) {\n    return where;\n  }\n  const keys = Utils.getComplexKeys(where);\n  if (keys.length === 0) {\n    return;\n  }\n  if (keys.length !== 1 || keys[0] !== Op.and) {\n    return where;\n  }\n  const andParts = where[Op.and];\n  return andParts;\n}\nfunction combineWheresWithAnd(whereA, whereB) {\n  const unpackedA = unpackAnd(whereA);\n  if (unpackedA === void 0) {\n    return whereB;\n  }\n  const unpackedB = unpackAnd(whereB);\n  if (unpackedB === void 0) {\n    return whereA;\n  }\n  return {\n    [Op.and]: _.flatten([unpackedA, unpackedB])\n  };\n}\nObject.assign(Model, associationsMixin);\nHooks.applyTo(Model, true);\nmodule.exports = Model;\n//# sourceMappingURL=model.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCwwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsb0VBQVU7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDRGQUF5QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsMEJBQTBCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ3hELFdBQVcsbUJBQU8sQ0FBQyxvRUFBYTtBQUNoQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQXVDLHFEQUFxRCxxRUFBcUU7QUFDaE07QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRLHNCQUFzQixVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBEQUEwRCxtREFBbUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLHVCQUF1QixVQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCLG1CQUFtQixXQUFXLDRDQUE0QyxZQUFZLHNFQUFzRSwyQkFBMkI7QUFDaFE7QUFDQSxxREFBcUQsa0JBQWtCLG1CQUFtQixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsbUJBQW1CLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9DQUFvQyxHQUFHLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLDJCQUEyQixjQUFjO0FBQ3hKO0FBQ0E7QUFDQSxvRkFBb0YsVUFBVSwrQkFBK0IsY0FBYztBQUMzSTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVSxHQUFHLEtBQUs7QUFDbEY7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLEdBQUcsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSw4Q0FBOEMseUJBQXlCO0FBQ25IO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCLGVBQWUsR0FBRyxLQUFLO0FBQzlDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBLG1DQUFtQyxNQUFNLHVCQUF1QixpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjLHFDQUFxQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUMsK0NBQStDLFVBQVU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFzQztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLDZGQUE2RixXQUFXO0FBQ3hHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVLEdBQUcsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxnQ0FBZ0MsTUFBTSx5REFBeUQsb0JBQW9CLFFBQVEsTUFBTTtBQUM1SztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2Q0FBNkM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHdDQUF3QztBQUNySDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLFdBQVcsS0FBSyxXQUFXO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFdBQVc7QUFDdEgsK0hBQStILFdBQVc7QUFDMUksZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0hBQWdIO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUlBQWlJO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsMENBQTBDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFdBQVc7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtFQUFrRSx1Q0FBdUM7QUFDekcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsV0FBVztBQUM1Ryx1R0FBdUcsV0FBVztBQUNsSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDJJQUEySSxXQUFXLEtBQUssV0FBVztBQUN0SztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjLGNBQWM7QUFDMUYsTUFBTTtBQUNOLGtJQUFrSSxzQ0FBc0M7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYywrQkFBK0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsV0FBVyw2QkFBNkIsV0FBVztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvbW9kZWwuanM/YjQyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgRG90dGllID0gcmVxdWlyZShcImRvdHRpZVwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgQmVsb25nc1RvID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG9cIik7XG5jb25zdCBCZWxvbmdzVG9NYW55ID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueVwiKTtcbmNvbnN0IEluc3RhbmNlVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vaW5zdGFuY2UtdmFsaWRhdG9yXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgQXNzb2NpYXRpb24gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmFzZVwiKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzLW1hbnlcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgSG9va3MgPSByZXF1aXJlKFwiLi9ob29rc1wiKTtcbmNvbnN0IGFzc29jaWF0aW9uc01peGluID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL21peGluXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi9vcGVyYXRvcnNcIik7XG5jb25zdCB7IG5vRG91YmxlTmVzdGVkR3JvdXAgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2RlcHJlY2F0aW9uc1wiKTtcbmNvbnN0IHZhbGlkUXVlcnlLZXl3b3JkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJ3aGVyZVwiLFxuICBcImF0dHJpYnV0ZXNcIixcbiAgXCJwYXJhbm9pZFwiLFxuICBcImluY2x1ZGVcIixcbiAgXCJvcmRlclwiLFxuICBcImxpbWl0XCIsXG4gIFwib2Zmc2V0XCIsXG4gIFwidHJhbnNhY3Rpb25cIixcbiAgXCJsb2NrXCIsXG4gIFwicmF3XCIsXG4gIFwibG9nZ2luZ1wiLFxuICBcImJlbmNobWFya1wiLFxuICBcImhhdmluZ1wiLFxuICBcInNlYXJjaFBhdGhcIixcbiAgXCJyZWplY3RPbkVtcHR5XCIsXG4gIFwicGxhaW5cIixcbiAgXCJzY29wZVwiLFxuICBcImdyb3VwXCIsXG4gIFwidGhyb3VnaFwiLFxuICBcImRlZmF1bHRzXCIsXG4gIFwiZGlzdGluY3RcIixcbiAgXCJwcmltYXJ5XCIsXG4gIFwiZXhjZXB0aW9uXCIsXG4gIFwidHlwZVwiLFxuICBcImhvb2tzXCIsXG4gIFwiZm9yY2VcIixcbiAgXCJuYW1lXCJcbl0pO1xuY29uc3Qgbm9uQ2FzY2FkaW5nT3B0aW9ucyA9IFtcImluY2x1ZGVcIiwgXCJhdHRyaWJ1dGVzXCIsIFwib3JpZ2luYWxBdHRyaWJ1dGVzXCIsIFwib3JkZXJcIiwgXCJ3aGVyZVwiLCBcImxpbWl0XCIsIFwib2Zmc2V0XCIsIFwicGxhaW5cIiwgXCJncm91cFwiLCBcImhhdmluZ1wiXTtcbmNsYXNzIE1vZGVsIHtcbiAgc3RhdGljIGdldCBxdWVyeUludGVyZmFjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHF1ZXJ5R2VuZXJhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnF1ZXJ5R2VuZXJhdG9yO1xuICB9XG4gIGdldCBzZXF1ZWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iuc2VxdWVsaXplO1xuICB9XG4gIGNvbnN0cnVjdG9yKHZhbHVlcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX292ZXJ3cml0dGVuQXR0cmlidXRlc0NoZWNrZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuX292ZXJ3cml0dGVuQXR0cmlidXRlc0NoZWNrZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG92ZXJ3cml0dGVuQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLl9hdHRyaWJ1dGVNYW5pcHVsYXRpb24pKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBrZXkpKSB7XG4gICAgICAgICAgICBvdmVyd3JpdHRlbkF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcndyaXR0ZW5BdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgTW9kZWwgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnN0cnVjdG9yLm5hbWUpfSBpcyBkZWNsYXJpbmcgcHVibGljIGNsYXNzIGZpZWxkcyBmb3IgYXR0cmlidXRlKHMpOiAke292ZXJ3cml0dGVuQXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IEpTT04uc3RyaW5naWZ5KGF0dHIpKS5qb2luKFwiLCBcIil9LlxuVGhlc2UgY2xhc3MgZmllbGRzIGFyZSBzaGFkb3dpbmcgU2VxdWVsaXplJ3MgYXR0cmlidXRlIGdldHRlcnMgJiBzZXR0ZXJzLlxuU2VlIGh0dHBzOi8vc2VxdWVsaXplLm9yZy9tYWluL21hbnVhbC9tb2RlbC1iYXNpY3MuaHRtbCNjYXZlYXQtd2l0aC1wdWJsaWMtY2xhc3MtZmllbGRzYCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaXNOZXdSZWNvcmQ6IHRydWUsXG4gICAgICBfc2NoZW1hOiB0aGlzLmNvbnN0cnVjdG9yLl9zY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiB0aGlzLmNvbnN0cnVjdG9yLl9zY2hlbWFEZWxpbWl0ZXJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IEFycmF5LmlzQXJyYXkoYXR0cmlidXRlKSA/IGF0dHJpYnV0ZVsxXSA6IGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kYXRhVmFsdWVzID0ge307XG4gICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0ge307XG4gICAgdGhpcy51bmlxbm8gPSAxO1xuICAgIHRoaXMuX2NoYW5nZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXNOZXdSZWNvcmQgPSBvcHRpb25zLmlzTmV3UmVjb3JkO1xuICAgIHRoaXMuX2luaXRWYWx1ZXModmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuICBfaW5pdFZhbHVlcyh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGVmYXVsdHM7XG4gICAgbGV0IGtleTtcbiAgICB2YWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdmFsdWVzKTtcbiAgICBpZiAob3B0aW9ucy5pc05ld1JlY29yZCkge1xuICAgICAgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgIGRlZmF1bHRzID0gXy5tYXBWYWx1ZXModGhpcy5jb25zdHJ1Y3Rvci5fZGVmYXVsdFZhbHVlcywgKHZhbHVlRm4pID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlRm4oKTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgPyB2YWx1ZSA6IF8uY2xvbmVEZWVwKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5mb3JFYWNoKChwcmltYXJ5S2V5QXR0cmlidXRlKSA9PiB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmYXVsdHMsIHByaW1hcnlLZXlBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBkZWZhdWx0c1twcmltYXJ5S2V5QXR0cmlidXRlXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiBkZWZhdWx0c1t0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0pIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSA9IFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgICAgZGVsZXRlIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICAgIH1cbiAgICAgIGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhpcy5zZXQoa2V5LCBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZhdWx0c1trZXldLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXQodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgX3BhcmFub2lkQ2xhdXNlKG1vZGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX3BhcmFub2lkQ2xhdXNlKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXy5nZXQob3B0aW9ucywgXCJncm91cGVkTGltaXQub24ub3B0aW9ucy5wYXJhbm9pZFwiKSkge1xuICAgICAgY29uc3QgdGhyb3VnaE1vZGVsID0gXy5nZXQob3B0aW9ucywgXCJncm91cGVkTGltaXQub24udGhyb3VnaC5tb2RlbFwiKTtcbiAgICAgIGlmICh0aHJvdWdoTW9kZWwpIHtcbiAgICAgICAgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRocm91Z2hNb2RlbCwgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbW9kZWwub3B0aW9ucy50aW1lc3RhbXBzIHx8ICFtb2RlbC5vcHRpb25zLnBhcmFub2lkIHx8IG9wdGlvbnMucGFyYW5vaWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXRPYmplY3QgPSB7fTtcbiAgICBsZXQgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBkZWxldGVkQXREZWZhdWx0VmFsdWUgfHwge1xuICAgICAgW09wLmVxXTogbnVsbFxuICAgIH07XG4gICAgZGVsZXRlZEF0T2JqZWN0W2RlbGV0ZWRBdEF0dHJpYnV0ZS5maWVsZCB8fCBkZWxldGVkQXRDb2xdID0gZGVsZXRlZEF0RGVmYXVsdFZhbHVlO1xuICAgIGlmIChVdGlscy5pc1doZXJlRW1wdHkob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSBkZWxldGVkQXRPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB7IFtPcC5hbmRdOiBbZGVsZXRlZEF0T2JqZWN0LCBvcHRpb25zLndoZXJlXSB9O1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBzdGF0aWMgX2FkZERlZmF1bHRBdHRyaWJ1dGVzKCkge1xuICAgIGNvbnN0IHRhaWwgPSB7fTtcbiAgICBsZXQgaGVhZCA9IHt9O1xuICAgIGlmICghXy5zb21lKHRoaXMucmF3QXR0cmlidXRlcywgXCJwcmltYXJ5S2V5XCIpKSB7XG4gICAgICBpZiAoXCJpZFwiIGluIHRoaXMucmF3QXR0cmlidXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgY29sdW1uIGNhbGxlZCAnaWQnIHdhcyBhZGRlZCB0byB0aGUgYXR0cmlidXRlcyBvZiAnJHt0aGlzLnRhYmxlTmFtZX0nIGJ1dCBub3QgbWFya2VkIHdpdGggJ3ByaW1hcnlLZXk6IHRydWUnYCk7XG4gICAgICB9XG4gICAgICBoZWFkID0ge1xuICAgICAgICBpZDoge1xuICAgICAgICAgIHR5cGU6IG5ldyBEYXRhVHlwZXMuSU5URUdFUigpLFxuICAgICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgICAgcHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlLFxuICAgICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl92ZXJzaW9uQXR0cmlidXRlKSB7XG4gICAgICB0YWlsW3RoaXMuX3ZlcnNpb25BdHRyaWJ1dGVdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuSU5URUdFUixcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiAwLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbmV3UmF3QXR0cmlidXRlcyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBoZWFkKSwgdGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICBfLmVhY2godGFpbCwgKHZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICBpZiAobmV3UmF3QXR0cmlidXRlc1thdHRyXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG5ld1Jhd0F0dHJpYnV0ZXNbYXR0cl0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJhd0F0dHJpYnV0ZXMgPSBuZXdSYXdBdHRyaWJ1dGVzO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5wcmltYXJ5S2V5cykubGVuZ3RoKSB7XG4gICAgICB0aGlzLnByaW1hcnlLZXlzLmlkID0gdGhpcy5yYXdBdHRyaWJ1dGVzLmlkO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0QXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yYXdBdHRyaWJ1dGVzO1xuICB9XG4gIHN0YXRpYyBfZmluZEF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUoKSB7XG4gICAgdGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucmF3QXR0cmlidXRlcywgbmFtZSkpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBJbnN0YW5jZSBkZWZpbml0aW9uLiBPbmx5IG9uZSBhdXRvaW5jcmVtZW50IGZpZWxkIGFsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHNlbGYpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlKSkge1xuICAgICAgb3B0aW9ucy5pbmNsdWRlID0gW29wdGlvbnMuaW5jbHVkZV07XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMuaW5jbHVkZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlLm1hcCgoaW5jbHVkZSkgPT4gdGhpcy5fY29uZm9ybUluY2x1ZGUoaW5jbHVkZSwgc2VsZikpO1xuICB9XG4gIHN0YXRpYyBfdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZSwgc2VsZikge1xuICAgIGlmIChzZWxmICYmIHR5cGVvZiBpbmNsdWRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLmFzc29jaWF0aW9ucywgaW5jbHVkZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NvY2lhdGlvbiB3aXRoIGFsaWFzIFwiJHtpbmNsdWRlfVwiIGRvZXMgbm90IGV4aXN0IG9uICR7c2VsZi5uYW1lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuYXNzb2NpYXRpb25zW2luY2x1ZGVdO1xuICAgIH1cbiAgICByZXR1cm4gaW5jbHVkZTtcbiAgfVxuICBzdGF0aWMgX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUsIHNlbGYpIHtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgbGV0IG1vZGVsO1xuICAgICAgaWYgKGluY2x1ZGUuX3BzZXVkbylcbiAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICBpbmNsdWRlID0gdGhpcy5fdHJhbnNmb3JtU3RyaW5nQXNzb2NpYXRpb24oaW5jbHVkZSwgc2VsZik7XG4gICAgICBpZiAoaW5jbHVkZSBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgIGlmIChzZWxmICYmIGluY2x1ZGUudGFyZ2V0Lm5hbWUgPT09IHNlbGYubmFtZSkge1xuICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5zb3VyY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtb2RlbCwgYXNzb2NpYXRpb246IGluY2x1ZGUsIGFzOiBpbmNsdWRlLmFzIH07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZS5wcm90b3R5cGUgJiYgaW5jbHVkZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICByZXR1cm4geyBtb2RlbDogaW5jbHVkZSB9O1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpbmNsdWRlKSkge1xuICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbikge1xuICAgICAgICAgIGluY2x1ZGUuYXNzb2NpYXRpb24gPSB0aGlzLl90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLmFzc29jaWF0aW9uLCBzZWxmKTtcbiAgICAgICAgICBpZiAoc2VsZiAmJiBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldC5uYW1lID09PSBzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaW5jbHVkZS5tb2RlbClcbiAgICAgICAgICAgIGluY2x1ZGUubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgICBpZiAoIWluY2x1ZGUuYXMpXG4gICAgICAgICAgICBpbmNsdWRlLmFzID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5hcztcbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSwgbW9kZWwpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlLm1vZGVsKSB7XG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlLmFsbCkge1xuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlKTtcbiAgICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNsdWRlIHVuZXhwZWN0ZWQuIEVsZW1lbnQgaGFzIHRvIGJlIGVpdGhlciBhIE1vZGVsLCBhbiBBc3NvY2lhdGlvbiBvciBhbiBvYmplY3QuXCIpO1xuICB9XG4gIHN0YXRpYyBfZXhwYW5kSW5jbHVkZUFsbEVsZW1lbnQoaW5jbHVkZXMsIGluY2x1ZGUpIHtcbiAgICBsZXQgYWxsID0gaW5jbHVkZS5hbGw7XG4gICAgZGVsZXRlIGluY2x1ZGUuYWxsO1xuICAgIGlmIChhbGwgIT09IHRydWUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhbGwpKSB7XG4gICAgICAgIGFsbCA9IFthbGxdO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRUeXBlcyA9IHtcbiAgICAgICAgQmVsb25nc1RvOiB0cnVlLFxuICAgICAgICBIYXNPbmU6IHRydWUsXG4gICAgICAgIEhhc01hbnk6IHRydWUsXG4gICAgICAgIE9uZTogW1wiQmVsb25nc1RvXCIsIFwiSGFzT25lXCJdLFxuICAgICAgICBIYXM6IFtcIkhhc09uZVwiLCBcIkhhc01hbnlcIl0sXG4gICAgICAgIE1hbnk6IFtcIkhhc01hbnlcIl1cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gYWxsW2ldO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJBbGxcIikge1xuICAgICAgICAgIGFsbCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZXMgPSB2YWxpZFR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgaW5jbHVkZSBhbGwgJyR7dHlwZX0nIGlzIG5vdCB2YWxpZCAtIG11c3QgYmUgQmVsb25nc1RvLCBIYXNPbmUsIEhhc01hbnksIE9uZSwgSGFzLCBNYW55IG9yIEFsbGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgIGFsbC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdHlwZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICghYWxsLmluY2x1ZGVzKHR5cGVzW2pdKSkge1xuICAgICAgICAgICAgICBhbGwudW5zaGlmdCh0eXBlc1tqXSk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmVzdGVkID0gaW5jbHVkZS5uZXN0ZWQ7XG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgZGVsZXRlIGluY2x1ZGUubmVzdGVkO1xuICAgICAgaWYgKCFpbmNsdWRlLmluY2x1ZGUpIHtcbiAgICAgICAgaW5jbHVkZS5pbmNsdWRlID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGluY2x1ZGUuaW5jbHVkZSkpIHtcbiAgICAgICAgaW5jbHVkZS5pbmNsdWRlID0gW2luY2x1ZGUuaW5jbHVkZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVzZWQgPSBbXTtcbiAgICAoZnVuY3Rpb24gYWRkQWxsSW5jbHVkZXMocGFyZW50LCBpbmNsdWRlczIpIHtcbiAgICAgIF8uZm9yRWFjaChwYXJlbnQuYXNzb2NpYXRpb25zLCAoYXNzb2NpYXRpb24pID0+IHtcbiAgICAgICAgaWYgKGFsbCAhPT0gdHJ1ZSAmJiAhYWxsLmluY2x1ZGVzKGFzc29jaWF0aW9uLmFzc29jaWF0aW9uVHlwZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBhc3NvY2lhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGFzID0gYXNzb2NpYXRpb24ub3B0aW9ucy5hcztcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0geyBtb2RlbCB9O1xuICAgICAgICBpZiAoYXMpIHtcbiAgICAgICAgICBwcmVkaWNhdGUuYXMgPSBhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5zb21lKGluY2x1ZGVzMiwgcHJlZGljYXRlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVzdGVkICYmIHVzZWQuaW5jbHVkZXMobW9kZWwpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHVzZWQucHVzaChwYXJlbnQpO1xuICAgICAgICBjb25zdCB0aGlzSW5jbHVkZSA9IFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKTtcbiAgICAgICAgdGhpc0luY2x1ZGUubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgaWYgKGFzKSB7XG4gICAgICAgICAgdGhpc0luY2x1ZGUuYXMgPSBhcztcbiAgICAgICAgfVxuICAgICAgICBpbmNsdWRlczIucHVzaCh0aGlzSW5jbHVkZSk7XG4gICAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgICBhZGRBbGxJbmNsdWRlcyhtb2RlbCwgdGhpc0luY2x1ZGUuaW5jbHVkZSk7XG4gICAgICAgICAgaWYgKHRoaXNJbmNsdWRlLmluY2x1ZGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXNJbmNsdWRlLmluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdXNlZC5wb3AoKTtcbiAgICB9KSh0aGlzLCBpbmNsdWRlcyk7XG4gIH1cbiAgc3RhdGljIF92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucywgdGFibGVOYW1lcykge1xuICAgIGlmICghb3B0aW9ucy5tb2RlbClcbiAgICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIHRhYmxlTmFtZXMgPSB0YWJsZU5hbWVzIHx8IHt9O1xuICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzID0gW107XG4gICAgb3B0aW9ucy5pbmNsdWRlTWFwID0ge307XG4gICAgb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiA9IGZhbHNlO1xuICAgIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA9IGZhbHNlO1xuICAgIGlmICghb3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIG9wdGlvbnMudG9wTW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgICAgb3B0aW9ucy50b3BMaW1pdCA9IG9wdGlvbnMubGltaXQ7XG4gICAgfVxuICAgIG9wdGlvbnMuaW5jbHVkZSA9IG9wdGlvbnMuaW5jbHVkZS5tYXAoKGluY2x1ZGUpID0+IHtcbiAgICAgIGluY2x1ZGUgPSB0aGlzLl9jb25mb3JtSW5jbHVkZShpbmNsdWRlKTtcbiAgICAgIGluY2x1ZGUucGFyZW50ID0gb3B0aW9ucztcbiAgICAgIGluY2x1ZGUudG9wTGltaXQgPSBvcHRpb25zLnRvcExpbWl0O1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnQuY2FsbChvcHRpb25zLm1vZGVsLCBpbmNsdWRlLCB0YWJsZU5hbWVzLCBvcHRpb25zKTtcbiAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5jbHVkZS5kdXBsaWNhdGluZyA9IGluY2x1ZGUuYXNzb2NpYXRpb24uaXNNdWx0aUFzc29jaWF0aW9uO1xuICAgICAgfVxuICAgICAgaW5jbHVkZS5oYXNEdXBsaWNhdGluZyA9IGluY2x1ZGUuaGFzRHVwbGljYXRpbmcgfHwgaW5jbHVkZS5kdXBsaWNhdGluZztcbiAgICAgIGluY2x1ZGUuaGFzUmVxdWlyZWQgPSBpbmNsdWRlLmhhc1JlcXVpcmVkIHx8IGluY2x1ZGUucmVxdWlyZWQ7XG4gICAgICBvcHRpb25zLmhhc0R1cGxpY2F0aW5nID0gb3B0aW9ucy5oYXNEdXBsaWNhdGluZyB8fCBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nO1xuICAgICAgb3B0aW9ucy5oYXNSZXF1aXJlZCA9IG9wdGlvbnMuaGFzUmVxdWlyZWQgfHwgaW5jbHVkZS5yZXF1aXJlZDtcbiAgICAgIG9wdGlvbnMuaGFzV2hlcmUgPSBvcHRpb25zLmhhc1doZXJlIHx8IGluY2x1ZGUuaGFzV2hlcmUgfHwgISFpbmNsdWRlLndoZXJlO1xuICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgaW5jbHVkZS5oYXNQYXJlbnRXaGVyZSA9IG9wdGlvbnMuaGFzUGFyZW50V2hlcmUgfHwgISFvcHRpb25zLndoZXJlO1xuICAgICAgaW5jbHVkZS5oYXNQYXJlbnRSZXF1aXJlZCA9IG9wdGlvbnMuaGFzUGFyZW50UmVxdWlyZWQgfHwgISFvcHRpb25zLnJlcXVpcmVkO1xuICAgICAgaWYgKGluY2x1ZGUuc3ViUXVlcnkgIT09IGZhbHNlICYmIG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgJiYgb3B0aW9ucy50b3BMaW1pdCkge1xuICAgICAgICBpZiAoaW5jbHVkZS5kdXBsaWNhdGluZykge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5IHx8IGZhbHNlO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBpbmNsdWRlLmhhc1JlcXVpcmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLmhhc1JlcXVpcmVkO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnkgfHwgZmFsc2U7XG4gICAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGluY2x1ZGUuc3ViUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgIGluY2x1ZGUuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5IHx8IGluY2x1ZGUuaGFzUGFyZW50UmVxdWlyZWQgJiYgaW5jbHVkZS5oYXNSZXF1aXJlZCAmJiAhaW5jbHVkZS5zZXBhcmF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5pbmNsdWRlTWFwW2luY2x1ZGUuYXNdID0gaW5jbHVkZTtcbiAgICAgIG9wdGlvbnMuaW5jbHVkZU5hbWVzLnB1c2goaW5jbHVkZS5hcyk7XG4gICAgICBpZiAob3B0aW9ucy50b3BNb2RlbCA9PT0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLnN1YlF1ZXJ5ID09PSB2b2lkIDAgJiYgb3B0aW9ucy50b3BMaW1pdCkge1xuICAgICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSkge1xuICAgICAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSBpbmNsdWRlLnN1YlF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUuaGFzRHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgPSBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSB8fCBpbmNsdWRlLmhhc0luY2x1ZGVXaGVyZSB8fCAhIWluY2x1ZGUud2hlcmU7XG4gICAgICBvcHRpb25zLmhhc0luY2x1ZGVSZXF1aXJlZCA9IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IGluY2x1ZGUuaGFzSW5jbHVkZVJlcXVpcmVkIHx8ICEhaW5jbHVkZS5yZXF1aXJlZDtcbiAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLmlzTXVsdGlBc3NvY2lhdGlvbiB8fCBpbmNsdWRlLmhhc011bHRpQXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24gfHwgaW5jbHVkZS5oYXNTaW5nbGVBc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudG9wTW9kZWwgPT09IG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5zdWJRdWVyeSA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zLnN1YlF1ZXJ5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIHN0YXRpYyBfdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnQoaW5jbHVkZSwgdGFibGVOYW1lcywgb3B0aW9ucykge1xuICAgIHRhYmxlTmFtZXNbaW5jbHVkZS5tb2RlbC5nZXRUYWJsZU5hbWUoKV0gPSB0cnVlO1xuICAgIGlmIChpbmNsdWRlLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMucmF3KSB7XG4gICAgICBpbmNsdWRlLm1vZGVsLl9leHBhbmRBdHRyaWJ1dGVzKGluY2x1ZGUpO1xuICAgICAgaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMgPSBpbmNsdWRlLm1vZGVsLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhpbmNsdWRlLmF0dHJpYnV0ZXMpO1xuICAgICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgICBpZiAoaW5jbHVkZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICBfLmVhY2goaW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5cywgKGF0dHIsIGtleSkgPT4ge1xuICAgICAgICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzLnNvbWUoKGluY2x1ZGVBdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ci5maWVsZCAhPT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGluY2x1ZGVBdHRyKSAmJiBpbmNsdWRlQXR0clswXSA9PT0gYXR0ci5maWVsZCAmJiBpbmNsdWRlQXR0clsxXSA9PT0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVBdHRyID09PSBrZXk7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcy51bnNoaWZ0KGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5jbHVkZSA9IFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLl9wc2V1ZG8pIHtcbiAgICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKGluY2x1ZGUubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb24gfHwgdGhpcy5fZ2V0SW5jbHVkZWRBc3NvY2lhdGlvbihpbmNsdWRlLm1vZGVsLCBpbmNsdWRlLmFzKTtcbiAgICBpbmNsdWRlLmFzc29jaWF0aW9uID0gYXNzb2NpYXRpb247XG4gICAgaW5jbHVkZS5hcyA9IGFzc29jaWF0aW9uLmFzO1xuICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2ggJiYgT2JqZWN0KGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkge1xuICAgICAgaWYgKCFpbmNsdWRlLmluY2x1ZGUpXG4gICAgICAgIGluY2x1ZGUuaW5jbHVkZSA9IFtdO1xuICAgICAgY29uc3QgdGhyb3VnaCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaDtcbiAgICAgIGluY2x1ZGUudGhyb3VnaCA9IF8uZGVmYXVsdHMoaW5jbHVkZS50aHJvdWdoIHx8IHt9LCB7XG4gICAgICAgIG1vZGVsOiB0aHJvdWdoLm1vZGVsLFxuICAgICAgICBhczogdGhyb3VnaC5tb2RlbC5uYW1lLFxuICAgICAgICBhc3NvY2lhdGlvbjoge1xuICAgICAgICAgIGlzU2luZ2xlQXNzb2NpYXRpb246IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgX3BzZXVkbzogdHJ1ZSxcbiAgICAgICAgcGFyZW50OiBpbmNsdWRlXG4gICAgICB9KTtcbiAgICAgIGlmICh0aHJvdWdoLnNjb3BlKSB7XG4gICAgICAgIGluY2x1ZGUudGhyb3VnaC53aGVyZSA9IGluY2x1ZGUudGhyb3VnaC53aGVyZSA/IHsgW09wLmFuZF06IFtpbmNsdWRlLnRocm91Z2gud2hlcmUsIHRocm91Z2guc2NvcGVdIH0gOiB0aHJvdWdoLnNjb3BlO1xuICAgICAgfVxuICAgICAgaW5jbHVkZS5pbmNsdWRlLnB1c2goaW5jbHVkZS50aHJvdWdoKTtcbiAgICAgIHRhYmxlTmFtZXNbdGhyb3VnaC50YWJsZU5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG1vZGVsO1xuICAgIGlmIChpbmNsdWRlLm1vZGVsLnNjb3BlZCA9PT0gdHJ1ZSkge1xuICAgICAgbW9kZWwgPSBpbmNsdWRlLm1vZGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IGluY2x1ZGUubW9kZWwubmFtZSA/IGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0IDogaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgfVxuICAgIG1vZGVsLl9pbmplY3RTY29wZShpbmNsdWRlKTtcbiAgICBpZiAoIWluY2x1ZGUuYXR0cmlidXRlcykge1xuICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5jbHVkZS5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICBpZiAoaW5jbHVkZS5yZXF1aXJlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlLnJlcXVpcmVkID0gISFpbmNsdWRlLndoZXJlO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZSkge1xuICAgICAgaW5jbHVkZS53aGVyZSA9IGluY2x1ZGUud2hlcmUgPyB7IFtPcC5hbmRdOiBbaW5jbHVkZS53aGVyZSwgaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZV0gfSA6IGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGU7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLmxpbWl0ICYmIGluY2x1ZGUuc2VwYXJhdGUgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZS5zZXBhcmF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlID09PSB0cnVlKSB7XG4gICAgICBpZiAoIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgSGFzTWFueSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBIYXNNYW55IGFzc29jaWF0aW9ucyBzdXBwb3J0IGluY2x1ZGUuc2VwYXJhdGVcIik7XG4gICAgICB9XG4gICAgICBpbmNsdWRlLmR1cGxpY2F0aW5nID0gZmFsc2U7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmIG9wdGlvbnMuYXR0cmlidXRlcy5sZW5ndGggJiYgIV8uZmxhdHRlbkRlcHRoKG9wdGlvbnMuYXR0cmlidXRlcywgMikuaW5jbHVkZXMoYXNzb2NpYXRpb24uc291cmNlS2V5KSkge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMucHVzaChhc3NvY2lhdGlvbi5zb3VyY2VLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGUuYXR0cmlidXRlcyAmJiBpbmNsdWRlLmF0dHJpYnV0ZXMubGVuZ3RoICYmICFfLmZsYXR0ZW5EZXB0aChpbmNsdWRlLmF0dHJpYnV0ZXMsIDIpLmluY2x1ZGVzKGFzc29jaWF0aW9uLmZvcmVpZ25LZXkpKSB7XG4gICAgICAgIGluY2x1ZGUuYXR0cmlidXRlcy5wdXNoKGFzc29jaWF0aW9uLmZvcmVpZ25LZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluY2x1ZGUsIFwiaW5jbHVkZVwiKSkge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzLmNhbGwoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSwgdGFibGVOYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlO1xuICB9XG4gIHN0YXRpYyBfZ2V0SW5jbHVkZWRBc3NvY2lhdGlvbih0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbnMgPSB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXRNb2RlbCk7XG4gICAgbGV0IGFzc29jaWF0aW9uID0gbnVsbDtcbiAgICBpZiAoYXNzb2NpYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBub3QgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0hYCk7XG4gICAgfVxuICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBhc3NvY2lhdGlvbiA9IHRoaXMuZ2V0QXNzb2NpYXRpb25Gb3JBbGlhcyh0YXJnZXRNb2RlbCwgdGFyZ2V0QWxpYXMpO1xuICAgICAgaWYgKGFzc29jaWF0aW9uKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRBbGlhcykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0FsaWFzZXMgPSB0aGlzLmdldEFzc29jaWF0aW9ucyh0YXJnZXRNb2RlbCkubWFwKChhc3NvY2lhdGlvbjIpID0+IGFzc29jaWF0aW9uMi5hcyk7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRWFnZXJMb2FkaW5nRXJyb3IoYCR7dGFyZ2V0TW9kZWwubmFtZX0gaXMgYXNzb2NpYXRlZCB0byAke3RoaXMubmFtZX0gdXNpbmcgYW4gYWxpYXMuIFlvdSd2ZSBpbmNsdWRlZCBhbiBhbGlhcyAoJHt0YXJnZXRBbGlhc30pLCBidXQgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGFsaWFzKGVzKSBkZWZpbmVkIGluIHlvdXIgYXNzb2NpYXRpb24gKCR7ZXhpc3RpbmdBbGlhc2VzLmpvaW4oXCIsIFwiKX0pLmApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSB1c2luZyBhbiBhbGlhcy4gWW91IG11c3QgdXNlIHRoZSAnYXMnIGtleXdvcmQgdG8gc3BlY2lmeSB0aGUgYWxpYXMgd2l0aGluIHlvdXIgaW5jbHVkZSBzdGF0ZW1lbnQuYCk7XG4gICAgfVxuICAgIGFzc29jaWF0aW9uID0gdGhpcy5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcyk7XG4gICAgaWYgKCFhc3NvY2lhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSBtdWx0aXBsZSB0aW1lcy4gVG8gaWRlbnRpZnkgdGhlIGNvcnJlY3QgYXNzb2NpYXRpb24sIHlvdSBtdXN0IHVzZSB0aGUgJ2FzJyBrZXl3b3JkIHRvIHNwZWNpZnkgdGhlIGFsaWFzIG9mIHRoZSBhc3NvY2lhdGlvbiB5b3Ugd2FudCB0byBpbmNsdWRlLmApO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH1cbiAgc3RhdGljIF9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbmNsdWRlcyA9IG9wdGlvbnMuaW5jbHVkZTtcbiAgICBpZiAoIWluY2x1ZGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbmNsdWRlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGluY2x1ZGUgPSBpbmNsdWRlc1tpbmRleF07XG4gICAgICBpZiAoaW5jbHVkZS5hbGwpIHtcbiAgICAgICAgaW5jbHVkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbEVsZW1lbnQoaW5jbHVkZXMsIGluY2x1ZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbmNsdWRlcy5mb3JFYWNoKChpbmNsdWRlKSA9PiB7XG4gICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsLmNhbGwoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIF9jb25mb3JtSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoIWluZGV4LmZpZWxkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwiZmllbGRzXCIgcHJvcGVydHkgZm9yIGluZGV4IGRlZmluaXRpb24nKTtcbiAgICB9XG4gICAgaW5kZXggPSBfLmRlZmF1bHRzKGluZGV4LCB7XG4gICAgICB0eXBlOiBcIlwiLFxuICAgICAgcGFyc2VyOiBudWxsXG4gICAgfSk7XG4gICAgaWYgKGluZGV4LnR5cGUgJiYgaW5kZXgudHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInVuaXF1ZVwiKSB7XG4gICAgICBpbmRleC51bmlxdWUgPSB0cnVlO1xuICAgICAgZGVsZXRlIGluZGV4LnR5cGU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICBzdGF0aWMgX3VuaXFJbmNsdWRlcyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUpXG4gICAgICByZXR1cm47XG4gICAgb3B0aW9ucy5pbmNsdWRlID0gXyhvcHRpb25zLmluY2x1ZGUpLmdyb3VwQnkoKGluY2x1ZGUpID0+IGAke2luY2x1ZGUubW9kZWwgJiYgaW5jbHVkZS5tb2RlbC5uYW1lfS0ke2luY2x1ZGUuYXN9YCkubWFwKChpbmNsdWRlcykgPT4gdGhpcy5fYXNzaWduT3B0aW9ucyguLi5pbmNsdWRlcykpLnZhbHVlKCk7XG4gIH1cbiAgc3RhdGljIF9iYXNlTWVyZ2UoLi4uYXJncykge1xuICAgIF8uYXNzaWduV2l0aCguLi5hcmdzKTtcbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoYXJnc1swXSwgdGhpcyk7XG4gICAgdGhpcy5fdW5pcUluY2x1ZGVzKGFyZ3NbMF0pO1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG4gIHN0YXRpYyBfbWVyZ2VGdW5jdGlvbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9ialZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHNyY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIF8udW5pb24ob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKFtcIndoZXJlXCIsIFwiaGF2aW5nXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndoZXJlTWVyZ2VTdHJhdGVneSA9PT0gXCJhbmRcIikge1xuICAgICAgICByZXR1cm4gY29tYmluZVdoZXJlc1dpdGhBbmQob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcmNWYWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICBzcmNWYWx1ZSA9IHsgW09wLmFuZF06IHNyY1ZhbHVlIH07XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9ialZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9ialZhbHVlLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiYXR0cmlidXRlc1wiICYmIF8uaXNQbGFpbk9iamVjdChvYmpWYWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIF8uYXNzaWduV2l0aChvYmpWYWx1ZSwgc3JjVmFsdWUsIChvYmpWYWx1ZTIsIHNyY1ZhbHVlMikgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpWYWx1ZTIpICYmIEFycmF5LmlzQXJyYXkoc3JjVmFsdWUyKSkge1xuICAgICAgICAgIHJldHVybiBfLnVuaW9uKG9ialZhbHVlMiwgc3JjVmFsdWUyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmNsb25lRGVlcChzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzcmNWYWx1ZSA9PT0gdm9pZCAwID8gb2JqVmFsdWUgOiBzcmNWYWx1ZTtcbiAgfVxuICBzdGF0aWMgX2Fzc2lnbk9wdGlvbnMoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9iYXNlTWVyZ2UoLi4uYXJncywgdGhpcy5fbWVyZ2VGdW5jdGlvbi5iaW5kKHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgX2RlZmF1bHRzT3B0aW9ucyh0YXJnZXQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZU1lcmdlKHRhcmdldCwgb3B0cywgKHNyY1ZhbHVlLCBvYmpWYWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fbWVyZ2VGdW5jdGlvbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSk7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGluaXQoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFvcHRpb25zLnNlcXVlbGl6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gU2VxdWVsaXplIGluc3RhbmNlIHBhc3NlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBvcHRpb25zLnNlcXVlbGl6ZTtcbiAgICBjb25zdCBnbG9iYWxPcHRpb25zID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucztcbiAgICBvcHRpb25zID0gVXRpbHMubWVyZ2UoXy5jbG9uZURlZXAoZ2xvYmFsT3B0aW9ucy5kZWZpbmUpLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMubW9kZWxOYW1lKSB7XG4gICAgICBvcHRpb25zLm1vZGVsTmFtZSA9IHRoaXMubmFtZTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLm1lcmdlKHtcbiAgICAgIG5hbWU6IHtcbiAgICAgICAgcGx1cmFsOiBVdGlscy5wbHVyYWxpemUob3B0aW9ucy5tb2RlbE5hbWUpLFxuICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUob3B0aW9ucy5tb2RlbE5hbWUpXG4gICAgICB9LFxuICAgICAgaW5kZXhlczogW10sXG4gICAgICBvbWl0TnVsbDogZ2xvYmFsT3B0aW9ucy5vbWl0TnVsbCxcbiAgICAgIHNjaGVtYTogZ2xvYmFsT3B0aW9ucy5zY2hlbWFcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImJlZm9yZURlZmluZVwiLCBhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5tb2RlbE5hbWUgIT09IHRoaXMubmFtZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7IHZhbHVlOiBvcHRpb25zLm1vZGVsTmFtZSB9KTtcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMubW9kZWxOYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHRpbWVzdGFtcHM6IHRydWUsXG4gICAgICB2YWxpZGF0ZToge30sXG4gICAgICBmcmVlemVUYWJsZU5hbWU6IGZhbHNlLFxuICAgICAgdW5kZXJzY29yZWQ6IGZhbHNlLFxuICAgICAgcGFyYW5vaWQ6IGZhbHNlLFxuICAgICAgcmVqZWN0T25FbXB0eTogZmFsc2UsXG4gICAgICB3aGVyZUNvbGxlY3Rpb246IG51bGwsXG4gICAgICBzY2hlbWE6IG51bGwsXG4gICAgICBzY2hlbWFEZWxpbWl0ZXI6IFwiXCIsXG4gICAgICBkZWZhdWx0U2NvcGU6IHt9LFxuICAgICAgc2NvcGVzOiB7fSxcbiAgICAgIGluZGV4ZXM6IFtdLFxuICAgICAgd2hlcmVNZXJnZVN0cmF0ZWd5OiBcIm92ZXJ3cml0ZVwiXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmlzRGVmaW5lZCh0aGlzLm5hbWUpKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIucmVtb3ZlTW9kZWwodGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLmdldE1vZGVsKHRoaXMubmFtZSkpO1xuICAgIH1cbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3NldHVwSG9va3Mob3B0aW9ucy5ob29rcyk7XG4gICAgdGhpcy51bmRlcnNjb3JlZCA9IHRoaXMub3B0aW9ucy51bmRlcnNjb3JlZDtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy50YWJsZU5hbWUpIHtcbiAgICAgIHRoaXMudGFibGVOYW1lID0gdGhpcy5vcHRpb25zLmZyZWV6ZVRhYmxlTmFtZSA/IHRoaXMubmFtZSA6IFV0aWxzLnVuZGVyc2NvcmVkSWYoVXRpbHMucGx1cmFsaXplKHRoaXMubmFtZSksIHRoaXMudW5kZXJzY29yZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhYmxlTmFtZSA9IHRoaXMub3B0aW9ucy50YWJsZU5hbWU7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVtYSA9IHRoaXMub3B0aW9ucy5zY2hlbWE7XG4gICAgdGhpcy5fc2NoZW1hRGVsaW1pdGVyID0gdGhpcy5vcHRpb25zLnNjaGVtYURlbGltaXRlcjtcbiAgICBfLmVhY2gob3B0aW9ucy52YWxpZGF0ZSwgKHZhbGlkYXRvciwgdmFsaWRhdG9yVHlwZSkgPT4ge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCB2YWxpZGF0b3JUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbW9kZWwgdmFsaWRhdG9yIGZ1bmN0aW9uIG11c3Qgbm90IGhhdmUgdGhlIHNhbWUgbmFtZSBhcyBhIGZpZWxkLiBNb2RlbDogJHt0aGlzLm5hbWV9LCBmaWVsZC92YWxpZGF0aW9uIG5hbWU6ICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZW1iZXJzIG9mIHRoZSB2YWxpZGF0ZSBvcHRpb24gbXVzdCBiZSBmdW5jdGlvbnMuIE1vZGVsOiAke3RoaXMubmFtZX0sIGVycm9yIHdpdGggdmFsaWRhdGUgbWVtYmVyICR7dmFsaWRhdG9yVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIV8uaW5jbHVkZXMoW1wiYW5kXCIsIFwib3ZlcndyaXRlXCJdLCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLndoZXJlTWVyZ2VTdHJhdGVneSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSAke3RoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMud2hlcmVNZXJnZVN0cmF0ZWd5fSBmb3Igd2hlcmVNZXJnZVN0cmF0ZWd5LiBBbGxvd2VkIHZhbHVlcyBhcmUgJ2FuZCcgYW5kICdvdmVyd3JpdGUnLmApO1xuICAgIH1cbiAgICB0aGlzLnJhd0F0dHJpYnV0ZXMgPSBfLm1hcFZhbHVlcyhhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBuYW1lKSA9PiB7XG4gICAgICBhdHRyaWJ1dGUgPSB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGRhdGF0eXBlIGZvciBhdHRyaWJ1dGUgXCIke3RoaXMubmFtZX0uJHtuYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCAhPT0gZmFsc2UgJiYgXy5nZXQoYXR0cmlidXRlLCBcInZhbGlkYXRlLm5vdE51bGxcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlZmluaXRpb24gZm9yIFwiJHt0aGlzLm5hbWV9LiR7bmFtZX1cIiwgXCJub3ROdWxsXCIgdmFsaWRhdG9yIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFwiYWxsb3dOdWxsOmZhbHNlXCJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmdldChhdHRyaWJ1dGUsIFwicmVmZXJlbmNlcy5tb2RlbC5wcm90b3R5cGVcIikgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCA9IGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsLmdldFRhYmxlTmFtZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZSgpO1xuICAgIHRoaXMuX2luZGV4ZXMgPSB0aGlzLm9wdGlvbnMuaW5kZXhlcy5tYXAoKGluZGV4KSA9PiBVdGlscy5uYW1lSW5kZXgodGhpcy5fY29uZm9ybUluZGV4KGluZGV4KSwgdGFibGVOYW1lKSk7XG4gICAgdGhpcy5wcmltYXJ5S2V5cyA9IHt9O1xuICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcyA9IHt9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGltZXN0YW1wcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgW1wiY3JlYXRlZEF0XCIsIFwidXBkYXRlZEF0XCIsIFwiZGVsZXRlZEF0XCJdKSB7XG4gICAgICAgIGlmICghW1widW5kZWZpbmVkXCIsIFwic3RyaW5nXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlb2YgdGhpcy5vcHRpb25zW2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBmb3IgXCIke2tleX1cIiBvcHRpb24gbXVzdCBiZSBhIHN0cmluZyBvciBhIGJvb2xlYW4sIGdvdCAke3R5cGVvZiB0aGlzLm9wdGlvbnNba2V5XX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2tleV0gPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciBcIiR7a2V5fVwiIG9wdGlvbiBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3JlYXRlZEF0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuY3JlYXRlZEF0ID09PSBcInN0cmluZ1wiID8gdGhpcy5vcHRpb25zLmNyZWF0ZWRBdCA6IFwiY3JlYXRlZEF0XCI7XG4gICAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGVkQXQgPT09IFwic3RyaW5nXCIgPyB0aGlzLm9wdGlvbnMudXBkYXRlZEF0IDogXCJ1cGRhdGVkQXRcIjtcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFub2lkICYmIHRoaXMub3B0aW9ucy5kZWxldGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5kZWxldGVkQXQgPT09IFwic3RyaW5nXCIgPyB0aGlzLm9wdGlvbnMuZGVsZXRlZEF0IDogXCJkZWxldGVkQXRcIjtcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyc2lvbikge1xuICAgICAgdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMudmVyc2lvbiA9PT0gXCJzdHJpbmdcIiA/IHRoaXMub3B0aW9ucy52ZXJzaW9uIDogXCJ2ZXJzaW9uXCI7XG4gICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpO1xuICAgIH1cbiAgICB0aGlzLl9oYXNSZWFkT25seUF0dHJpYnV0ZXMgPSB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuc2l6ZSA+IDA7XG4gICAgdGhpcy5fYWRkRGVmYXVsdEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5fZmluZEF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUoKTtcbiAgICB0aGlzLl9zY29wZSA9IHRoaXMub3B0aW9ucy5kZWZhdWx0U2NvcGU7XG4gICAgdGhpcy5fc2NvcGVOYW1lcyA9IFtcImRlZmF1bHRTY29wZVwiXTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuYWRkTW9kZWwodGhpcyk7XG4gICAgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJhZnRlckRlZmluZVwiLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgcmVmcmVzaEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgYXR0cmlidXRlTWFuaXB1bGF0aW9uID0ge307XG4gICAgdGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMgPSB7fTtcbiAgICB0aGlzLnByb3RvdHlwZS5fY3VzdG9tU2V0dGVycyA9IHt9O1xuICAgIFtcImdldFwiLCBcInNldFwiXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICBjb25zdCBvcHQgPSBgJHt0eXBlfXRlck1ldGhvZHNgO1xuICAgICAgY29uc3QgZnVuY3MgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zW29wdF0pO1xuICAgICAgY29uc3QgX2N1c3RvbSA9IHR5cGUgPT09IFwiZ2V0XCIgPyB0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycyA6IHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzO1xuICAgICAgXy5lYWNoKGZ1bmNzLCAobWV0aG9kLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgX2N1c3RvbVthdHRyaWJ1dGVdID0gbWV0aG9kO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJnZXRcIikge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyaWJ1dGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF8uZWFjaCh0aGlzLnJhd0F0dHJpYnV0ZXMsIChvcHRpb25zLCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCB0eXBlKSkge1xuICAgICAgICAgIF9jdXN0b21bYXR0cmlidXRlXSA9IG9wdGlvbnNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSBcInNldFwiKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBfLmVhY2goZnVuY3MsIChmY3QsIG5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV0pIHtcbiAgICAgICAgICBhdHRyaWJ1dGVNYW5pcHVsYXRpb25bbmFtZV0gPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXVt0eXBlXSA9IGZjdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2RhdGFUeXBlQ2hhbmdlcyA9IHt9O1xuICAgIHRoaXMuX2RhdGFUeXBlU2FuaXRpemVycyA9IHt9O1xuICAgIHRoaXMuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgdGhpcy5faGFzRGF0ZUF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9qc29uQXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLnByb3RvdHlwZS52YWxpZGF0b3JzID0ge307XG4gICAgdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXAgPSB7fTtcbiAgICB0aGlzLnByaW1hcnlLZXlzID0ge307XG4gICAgdGhpcy51bmlxdWVLZXlzID0ge307XG4gICAgXy5lYWNoKHRoaXMucmF3QXR0cmlidXRlcywgKGRlZmluaXRpb24sIG5hbWUpID0+IHtcbiAgICAgIGRlZmluaXRpb24udHlwZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZURhdGFUeXBlKGRlZmluaXRpb24udHlwZSk7XG4gICAgICBkZWZpbml0aW9uLk1vZGVsID0gdGhpcztcbiAgICAgIGRlZmluaXRpb24uZmllbGROYW1lID0gbmFtZTtcbiAgICAgIGRlZmluaXRpb24uX21vZGVsQXR0cmlidXRlID0gdHJ1ZTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmZpZWxkID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVmaW5pdGlvbi5maWVsZCA9IFV0aWxzLnVuZGVyc2NvcmVkSWYobmFtZSwgdGhpcy51bmRlcnNjb3JlZCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5wcmltYXJ5S2V5ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeUtleXNbbmFtZV0gPSBkZWZpbml0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXBbZGVmaW5pdGlvbi5maWVsZF0gPSBkZWZpbml0aW9uO1xuICAgICAgaWYgKGRlZmluaXRpb24udHlwZS5fc2FuaXRpemUpIHtcbiAgICAgICAgdGhpcy5fZGF0YVR5cGVTYW5pdGl6ZXJzW25hbWVdID0gZGVmaW5pdGlvbi50eXBlLl9zYW5pdGl6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUuX2lzQ2hhbmdlZCkge1xuICAgICAgICB0aGlzLl9kYXRhVHlwZUNoYW5nZXNbbmFtZV0gPSBkZWZpbml0aW9uLnR5cGUuX2lzQ2hhbmdlZDtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQk9PTEVBTikge1xuICAgICAgICB0aGlzLl9oYXNCb29sZWFuQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFIHx8IGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFT05MWSkge1xuICAgICAgICB0aGlzLl9oYXNEYXRlQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgIHRoaXMuX2pzb25BdHRyaWJ1dGVzLmFkZChuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlZJUlRVQUwpIHtcbiAgICAgICAgdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCBcImRlZmF1bHRWYWx1ZVwiKSkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVzW25hbWVdID0gKCkgPT4gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmaW5pdGlvbi5kZWZhdWx0VmFsdWUsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIFwidW5pcXVlXCIpICYmIGRlZmluaXRpb24udW5pcXVlKSB7XG4gICAgICAgIGxldCBpZHhOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGRlZmluaXRpb24udW5pcXVlID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLnVuaXF1ZSwgXCJuYW1lXCIpKSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGRlZmluaXRpb24udW5pcXVlLm5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24udW5pcXVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGRlZmluaXRpb24udW5pcXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkeE5hbWUgPSBgJHt0aGlzLnRhYmxlTmFtZX1fJHtuYW1lfV91bmlxdWVgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMudW5pcXVlS2V5c1tpZHhOYW1lXSB8fCB7IGZpZWxkczogW10gfTtcbiAgICAgICAgaWR4LmZpZWxkcy5wdXNoKGRlZmluaXRpb24uZmllbGQpO1xuICAgICAgICBpZHgubXNnID0gaWR4Lm1zZyB8fCBkZWZpbml0aW9uLnVuaXF1ZS5tc2cgfHwgbnVsbDtcbiAgICAgICAgaWR4Lm5hbWUgPSBpZHhOYW1lIHx8IGZhbHNlO1xuICAgICAgICBpZHguY29sdW1uID0gbmFtZTtcbiAgICAgICAgaWR4LmN1c3RvbUluZGV4ID0gZGVmaW5pdGlvbi51bmlxdWUgIT09IHRydWU7XG4gICAgICAgIHRoaXMudW5pcXVlS2V5c1tpZHhOYW1lXSA9IGlkeDtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgXCJ2YWxpZGF0ZVwiKSkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS52YWxpZGF0b3JzW25hbWVdID0gZGVmaW5pdGlvbi52YWxpZGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluZGV4ID09PSB0cnVlICYmIGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OQikge1xuICAgICAgICB0aGlzLl9pbmRleGVzLnB1c2goVXRpbHMubmFtZUluZGV4KHRoaXMuX2NvbmZvcm1JbmRleCh7XG4gICAgICAgICAgZmllbGRzOiBbZGVmaW5pdGlvbi5maWVsZCB8fCBuYW1lXSxcbiAgICAgICAgICB1c2luZzogXCJnaW5cIlxuICAgICAgICB9KSwgdGhpcy5nZXRUYWJsZU5hbWUoKSkpO1xuICAgICAgICBkZWxldGUgZGVmaW5pdGlvbi5pbmRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmZpZWxkQXR0cmlidXRlTWFwID0gXy5yZWR1Y2UodGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXAsIChtYXAsIHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgIT09IHZhbHVlLmZpZWxkTmFtZSkge1xuICAgICAgICBtYXBba2V5XSA9IHZhbHVlLmZpZWxkTmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuICAgIHRoaXMuX2hhc0pzb25BdHRyaWJ1dGVzID0gISF0aGlzLl9qc29uQXR0cmlidXRlcy5zaXplO1xuICAgIHRoaXMuX2hhc1ZpcnR1YWxBdHRyaWJ1dGVzID0gISF0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5zaXplO1xuICAgIHRoaXMuX2hhc0RlZmF1bHRWYWx1ZXMgPSAhXy5pc0VtcHR5KHRoaXMuX2RlZmF1bHRWYWx1ZXMpO1xuICAgIHRoaXMudGFibGVBdHRyaWJ1dGVzID0gXy5vbWl0QnkodGhpcy5yYXdBdHRyaWJ1dGVzLCAoX2EsIGtleSkgPT4gdGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGtleSkpO1xuICAgIHRoaXMucHJvdG90eXBlLl9oYXNDdXN0b21HZXR0ZXJzID0gT2JqZWN0LmtleXModGhpcy5wcm90b3R5cGUuX2N1c3RvbUdldHRlcnMpLmxlbmd0aDtcbiAgICB0aGlzLnByb3RvdHlwZS5faGFzQ3VzdG9tU2V0dGVycyA9IE9iamVjdC5rZXlzKHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzKS5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYXR0cmlidXRlTWFuaXB1bGF0aW9uKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNb2RlbC5wcm90b3R5cGUsIGtleSkpIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBOb3Qgb3ZlcnJpZGluZyBidWlsdC1pbiBtZXRob2QgZnJvbSBtb2RlbCBhdHRyaWJ1dGU6ICR7a2V5fWApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwga2V5LCBhdHRyaWJ1dGVNYW5pcHVsYXRpb25ba2V5XSk7XG4gICAgfVxuICAgIHRoaXMucHJvdG90eXBlLnJhd0F0dHJpYnV0ZXMgPSB0aGlzLnJhd0F0dHJpYnV0ZXM7XG4gICAgdGhpcy5wcm90b3R5cGUuX2lzQXR0cmlidXRlID0gKGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMucHJvdG90eXBlLnJhd0F0dHJpYnV0ZXMsIGtleSk7XG4gICAgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucHJpbWFyeUtleXMpO1xuICAgIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSA9IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXNbMF07XG4gICAgaWYgKHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSkge1xuICAgICAgdGhpcy5wcmltYXJ5S2V5RmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCB8fCB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgfVxuICAgIHRoaXMuX2hhc1ByaW1hcnlLZXlzID0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcy5sZW5ndGggPiAwO1xuICAgIHRoaXMuX2lzUHJpbWFyeUtleSA9IChrZXkpID0+IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVNYW5pcHVsYXRpb24gPSBhdHRyaWJ1dGVNYW5pcHVsYXRpb247XG4gIH1cbiAgc3RhdGljIHJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBkZWxldGUgdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlcygpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzeW5jKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB2b2lkIDAgPyB0cnVlIDogISFvcHRpb25zLmhvb2tzO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLnRhYmxlQXR0cmlidXRlcztcbiAgICBjb25zdCByYXdBdHRyaWJ1dGVzID0gdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXA7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVTeW5jXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKTtcbiAgICBsZXQgdGFibGVFeGlzdHM7XG4gICAgaWYgKG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZHJvcChvcHRpb25zKTtcbiAgICAgIHRhYmxlRXhpc3RzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlRXhpc3RzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS50YWJsZUV4aXN0cyh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIXRhYmxlRXhpc3RzKSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmNyZWF0ZVRhYmxlKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZW5zdXJlRW51bXModGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRhYmxlRXhpc3RzICYmIG9wdGlvbnMuYWx0ZXIpIHtcbiAgICAgIGNvbnN0IHRhYmxlSW5mb3MgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucXVlcnlJbnRlcmZhY2UuZGVzY3JpYmVUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpLFxuICAgICAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmdldEZvcmVpZ25LZXlSZWZlcmVuY2VzRm9yVGFibGUodGFibGVOYW1lLCBvcHRpb25zKVxuICAgICAgXSk7XG4gICAgICBjb25zdCBjb2x1bW5zID0gdGFibGVJbmZvc1swXTtcbiAgICAgIGNvbnN0IGZvcmVpZ25LZXlSZWZlcmVuY2VzID0gdGFibGVJbmZvc1sxXTtcbiAgICAgIGNvbnN0IHJlbW92ZWRDb25zdHJhaW50cyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBjb2x1bW5OYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgY29sdW1uTmFtZSkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghY29sdW1uc1tjb2x1bW5OYW1lXSAmJiAhY29sdW1uc1thdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLmZpZWxkXSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYWRkQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlc1tjb2x1bW5OYW1lXS5maWVsZCB8fCBjb2x1bW5OYW1lLCBhdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYWx0ZXIgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMuYWx0ZXIgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5hbHRlci5kcm9wICE9PSBmYWxzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbHVtbk5hbWUgaW4gY29sdW1ucykge1xuICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbHVtbnMsIGNvbHVtbk5hbWUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZSA9IHJhd0F0dHJpYnV0ZXNbY29sdW1uTmFtZV07XG4gICAgICAgICAgaWYgKCFjdXJyZW50QXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlLnByaW1hcnlLZXkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gY3VycmVudEF0dHJpYnV0ZS5yZWZlcmVuY2VzO1xuICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLnNjaGVtYTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm9yZWlnbktleVJlZmVyZW5jZSBvZiBmb3JlaWduS2V5UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50TmFtZSA9IGZvcmVpZ25LZXlSZWZlcmVuY2UuY29uc3RyYWludE5hbWU7XG4gICAgICAgICAgICAgIGlmICghIWNvbnN0cmFpbnROYW1lICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UudGFibGVDYXRhbG9nID09PSBkYXRhYmFzZSAmJiAoc2NoZW1hID8gZm9yZWlnbktleVJlZmVyZW5jZS50YWJsZVNjaGVtYSA9PT0gc2NoZW1hIDogdHJ1ZSkgJiYgZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkVGFibGVOYW1lID09PSByZWZlcmVuY2VzLm1vZGVsICYmIGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZENvbHVtbk5hbWUgPT09IHJlZmVyZW5jZXMua2V5ICYmIChzY2hlbWEgPyBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRUYWJsZVNjaGVtYSA9PT0gc2NoZW1hIDogdHJ1ZSkgJiYgIXJlbW92ZWRDb25zdHJhaW50c1tjb25zdHJhaW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZENvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5jaGFuZ2VDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBjdXJyZW50QXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0luZGV4ZXMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnNob3dJbmRleCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1pc3NpbmdJbmRleGVzID0gdGhpcy5faW5kZXhlcy5maWx0ZXIoKGl0ZW0xKSA9PiAhZXhpc3RpbmdJbmRleGVzLnNvbWUoKGl0ZW0yKSA9PiBpdGVtMS5uYW1lID09PSBpdGVtMi5uYW1lKSkuc29ydCgoaW5kZXgxLCBpbmRleDIpID0+IHtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09IFwicG9zdGdyZXNcIikge1xuICAgICAgICBpZiAoaW5kZXgxLmNvbmN1cnJlbnRseSA9PT0gdHJ1ZSlcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGluZGV4Mi5jb25jdXJyZW50bHkgPT09IHRydWUpXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBtaXNzaW5nSW5kZXhlcykge1xuICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5hZGRJbmRleCh0YWJsZU5hbWUsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgaW5kZXgpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlclN5bmNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkcm9wKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kcm9wVGFibGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRyb3BTY2hlbWEoc2NoZW1hKTtcbiAgfVxuICBzdGF0aWMgc2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gY2xhc3MgZXh0ZW5kcyB0aGlzIHtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgXCJuYW1lXCIsIHsgdmFsdWU6IHRoaXMubmFtZSB9KTtcbiAgICBjbG9uZS5fc2NoZW1hID0gc2NoZW1hO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2xvbmUuX3NjaGVtYURlbGltaXRlciA9IG9wdGlvbnM7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgICAgIGNsb25lLl9zY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHN0YXRpYyBnZXRUYWJsZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkU2NoZW1hKHRoaXMpO1xuICB9XG4gIHN0YXRpYyB1bnNjb3BlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSgpO1xuICB9XG4gIHN0YXRpYyBhZGRTY29wZShuYW1lLCBzY29wZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7IG92ZXJyaWRlOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICBpZiAoKG5hbWUgPT09IFwiZGVmYXVsdFNjb3BlXCIgJiYgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZSkubGVuZ3RoID4gMCB8fCBuYW1lIGluIHRoaXMub3B0aW9ucy5zY29wZXMpICYmIG9wdGlvbnMub3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzY29wZSAke25hbWV9IGFscmVhZHkgZXhpc3RzLiBQYXNzIHsgb3ZlcnJpZGU6IHRydWUgfSBhcyBvcHRpb25zIHRvIHNpbGVuY2UgdGhpcyBlcnJvcmApO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJkZWZhdWx0U2NvcGVcIikge1xuICAgICAgdGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZSA9IHRoaXMuX3Njb3BlID0gc2NvcGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY29wZXNbbmFtZV0gPSBzY29wZTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNjb3BlKG9wdGlvbikge1xuICAgIGNvbnN0IHNlbGYgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgIH07XG4gICAgbGV0IHNjb3BlO1xuICAgIGxldCBzY29wZU5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwibmFtZVwiLCB7IHZhbHVlOiB0aGlzLm5hbWUgfSk7XG4gICAgc2VsZi5fc2NvcGUgPSB7fTtcbiAgICBzZWxmLl9zY29wZU5hbWVzID0gW107XG4gICAgc2VsZi5zY29wZWQgPSB0cnVlO1xuICAgIGlmICghb3B0aW9uKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uZmxhdHRlbihhcmd1bWVudHMpO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uMiBvZiBvcHRpb25zKSB7XG4gICAgICBzY29wZSA9IG51bGw7XG4gICAgICBzY29wZU5hbWUgPSBudWxsO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb24yKSkge1xuICAgICAgICBpZiAob3B0aW9uMi5tZXRob2QpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb24yLm1ldGhvZCkgJiYgISFzZWxmLm9wdGlvbnMuc2NvcGVzW29wdGlvbjIubWV0aG9kWzBdXSkge1xuICAgICAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uMi5tZXRob2RbMF07XG4gICAgICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXS5hcHBseShzZWxmLCBvcHRpb24yLm1ldGhvZC5zbGljZSgxKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm9wdGlvbnMuc2NvcGVzW29wdGlvbjIubWV0aG9kXSkge1xuICAgICAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uMi5tZXRob2Q7XG4gICAgICAgICAgICBzY29wZSA9IHNlbGYub3B0aW9ucy5zY29wZXNbc2NvcGVOYW1lXS5hcHBseShzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NvcGUgPSBvcHRpb24yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbjIgPT09IFwiZGVmYXVsdFNjb3BlXCIgJiYgXy5pc1BsYWluT2JqZWN0KHNlbGYub3B0aW9ucy5kZWZhdWx0U2NvcGUpKSB7XG4gICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLmRlZmF1bHRTY29wZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlTmFtZSA9IG9wdGlvbjI7XG4gICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHNjb3BlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBzY29wZSA9IHNjb3BlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY29wZSkge1xuICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoc2NvcGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9hc3NpZ25PcHRpb25zKHNlbGYuX3Njb3BlLCBVdGlscy5jbG9uZURlZXAoc2NvcGUpKTtcbiAgICAgICAgc2VsZi5fc2NvcGVOYW1lcy5wdXNoKHNjb3BlTmFtZSA/IHNjb3BlTmFtZSA6IFwiZGVmYXVsdFNjb3BlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5TZXF1ZWxpemVTY29wZUVycm9yKGBJbnZhbGlkIHNjb3BlICR7c2NvcGVOYW1lfSBjYWxsZWQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kQWxsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuUXVlcnlFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZEFsbCBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgIT09IHZvaWQgMCAmJiBvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlF1ZXJ5RXJyb3IoXCJUaGUgYXR0cmlidXRlcyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBjb2x1bW4gbmFtZXMgb3IgYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndhcm5PbkludmFsaWRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcykpO1xuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSB7fTtcbiAgICB0YWJsZU5hbWVzW3RoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpXSA9IHRydWU7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgeyBob29rczogdHJ1ZSB9KTtcbiAgICBvcHRpb25zLnJlamVjdE9uRW1wdHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJyZWplY3RPbkVtcHR5XCIpID8gb3B0aW9ucy5yZWplY3RPbkVtcHR5IDogdGhpcy5vcHRpb25zLnJlamVjdE9uRW1wdHk7XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVGaW5kXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5fZXhwYW5kQXR0cmlidXRlcyhvcHRpb25zKTtcbiAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlRmluZEFmdGVyRXhwYW5kSW5jbHVkZUFsbFwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgPSB0aGlzLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIG9wdGlvbnMuaGFzSm9pbiA9IHRydWU7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucywgdGFibGVOYW1lcyk7XG4gICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmICFvcHRpb25zLnJhdyAmJiB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgIW9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlcyh0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUpICYmICghb3B0aW9ucy5ncm91cCB8fCAhb3B0aW9ucy5oYXNTaW5nbGVBc3NvY2lhdGlvbiB8fCBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24pKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFt0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmNvbmNhdChvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIG9wdGlvbnMub3JpZ2luYWxBdHRyaWJ1dGVzID0gdGhpcy5faW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zLndoZXJlQ29sbGVjdGlvbiA9IG9wdGlvbnMud2hlcmUgfHwgbnVsbDtcbiAgICBVdGlscy5tYXBGaW5kZXJPcHRpb25zKG9wdGlvbnMsIHRoaXMpO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUZpbmRBZnRlck9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdE9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyB0YWJsZU5hbWVzOiBPYmplY3Qua2V5cyh0YWJsZU5hbWVzKSB9KTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5zZWxlY3QodGhpcywgdGhpcy5nZXRUYWJsZU5hbWUoc2VsZWN0T3B0aW9ucyksIHNlbGVjdE9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJGaW5kXCIsIHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoXy5pc0VtcHR5KHJlc3VsdHMpICYmIG9wdGlvbnMucmVqZWN0T25FbXB0eSkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlamVjdE9uRW1wdHkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgb3B0aW9ucy5yZWplY3RPbkVtcHR5KCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBvcHRpb25zLnJlamVjdE9uRW1wdHk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVtcHR5UmVzdWx0RXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IE1vZGVsLl9maW5kU2VwYXJhdGUocmVzdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIHdhcm5PbkludmFsaWRPcHRpb25zKG9wdGlvbnMsIHZhbGlkQ29sdW1uTmFtZXMpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB1bnJlY29nbml6ZWRPcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAhdmFsaWRRdWVyeUtleXdvcmRzLmhhcyhrKSk7XG4gICAgY29uc3QgdW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcyA9IF8uaW50ZXJzZWN0aW9uKHVucmVjb2duaXplZE9wdGlvbnMsIHZhbGlkQ29sdW1uTmFtZXMpO1xuICAgIGlmICghb3B0aW9ucy53aGVyZSAmJiB1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZ2dlci53YXJuKGBNb2RlbCBhdHRyaWJ1dGVzICgke3VuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMuam9pbihcIiwgXCIpfSkgcGFzc2VkIGludG8gZmluZGVyIG1ldGhvZCBvcHRpb25zIG9mIG1vZGVsICR7dGhpcy5uYW1lfSwgYnV0IHRoZSBvcHRpb25zLndoZXJlIG9iamVjdCBpcyBlbXB0eS4gRGlkIHlvdSBmb3JnZXQgdG8gdXNlIG9wdGlvbnMud2hlcmU/YCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaW5qZWN0RGVwZW5kZW50VmlydHVhbEF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGlmICghdGhpcy5faGFzVmlydHVhbEF0dHJpYnV0ZXMpXG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgIUFycmF5LmlzQXJyYXkoYXR0cmlidXRlcykpXG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAodGhpcy5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZSkgJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0udHlwZS5maWVsZHMpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdLnR5cGUuZmllbGRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXR0cmlidXRlcyA9IF8udW5pcShhdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxuICBzdGF0aWMgYXN5bmMgX2ZpbmRTZXBhcmF0ZShyZXN1bHRzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGUgfHwgb3B0aW9ucy5yYXcgfHwgIXJlc3VsdHMpXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICBjb25zdCBvcmlnaW5hbCA9IHJlc3VsdHM7XG4gICAgaWYgKG9wdGlvbnMucGxhaW4pXG4gICAgICByZXN1bHRzID0gW3Jlc3VsdHNdO1xuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpXG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwob3B0aW9ucy5pbmNsdWRlLm1hcChhc3luYyAoaW5jbHVkZSkgPT4ge1xuICAgICAgaWYgKCFpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBNb2RlbC5fZmluZFNlcGFyYXRlKHJlc3VsdHMucmVkdWNlKChtZW1vLCByZXN1bHQpID0+IHtcbiAgICAgICAgICBsZXQgYXNzb2NpYXRpb25zID0gcmVzdWx0LmdldChpbmNsdWRlLmFzc29jaWF0aW9uLmFzKTtcbiAgICAgICAgICBpZiAoIWFzc29jaWF0aW9ucylcbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NvY2lhdGlvbnMpKVxuICAgICAgICAgICAgYXNzb2NpYXRpb25zID0gW2Fzc29jaWF0aW9uc107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFzc29jaWF0aW9ucy5sZW5ndGg7IGkgIT09IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBtZW1vLnB1c2goYXNzb2NpYXRpb25zW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH0sIFtdKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgXy5vbWl0KG9wdGlvbnMsIFwiaW5jbHVkZVwiLCBcImF0dHJpYnV0ZXNcIiwgXCJvcmRlclwiLCBcIndoZXJlXCIsIFwibGltaXRcIiwgXCJvZmZzZXRcIiwgXCJwbGFpblwiLCBcInNjb3BlXCIpKSwge1xuICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGUuaW5jbHVkZSB8fCBbXVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXAgPSBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLmdldChyZXN1bHRzLCBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgXy5vbWl0KG9wdGlvbnMsIG5vbkNhc2NhZGluZ09wdGlvbnMpKSwgXy5vbWl0KGluY2x1ZGUsIFtcInBhcmVudFwiLCBcImFzc29jaWF0aW9uXCIsIFwiYXNcIiwgXCJvcmlnaW5hbEF0dHJpYnV0ZXNcIl0pKSk7XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5hcywgbWFwW3Jlc3VsdC5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkpXSwgeyByYXc6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZEJ5UGsocGFyYW0sIG9wdGlvbnMpIHtcbiAgICBpZiAoW251bGwsIHZvaWQgMF0uaW5jbHVkZXMocGFyYW0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIgfHwgQnVmZmVyLmlzQnVmZmVyKHBhcmFtKSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgICAgW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV06IHBhcmFtXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQnlQayBpcyBpbnZhbGlkOiAke3BhcmFtfWApO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kT25lKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZE9uZSBtdXN0IGJlIGFuIG9wdGlvbnMgb2JqZWN0LCB1c2UgZmluZEJ5UGsgaWYgeW91IHdpc2ggdG8gcGFzcyBhIHNpbmdsZSBwcmltYXJ5IGtleSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IHVuaXF1ZVNpbmdsZUNvbHVtbnMgPSBfLmNoYWluKHRoaXMudW5pcXVlS2V5cykudmFsdWVzKCkuZmlsdGVyKChjKSA9PiBjLmZpZWxkcy5sZW5ndGggPT09IDEpLm1hcChcImNvbHVtblwiKS52YWx1ZSgpO1xuICAgICAgaWYgKCFvcHRpb25zLndoZXJlIHx8ICFfLnNvbWUob3B0aW9ucy53aGVyZSwgKHZhbHVlLCBrZXkpID0+IChrZXkgPT09IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSB8fCB1bmlxdWVTaW5nbGVDb2x1bW5zLmluY2x1ZGVzKGtleSkpICYmIChVdGlscy5pc1ByaW1pdGl2ZSh2YWx1ZSkgfHwgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkpKSB7XG4gICAgICAgIG9wdGlvbnMubGltaXQgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5maW5kQWxsKF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgcGxhaW46IHRydWVcbiAgICB9KSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGFnZ3JlZ2F0ZShhdHRyaWJ1dGUsIGFnZ3JlZ2F0ZUZ1bmN0aW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBwcmV2QXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBwcmV2QXR0cmlidXRlcztcbiAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgYXR0ck9wdGlvbnMgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICBjb25zdCBmaWVsZCA9IGF0dHJPcHRpb25zICYmIGF0dHJPcHRpb25zLmZpZWxkIHx8IGF0dHJpYnV0ZTtcbiAgICBsZXQgYWdncmVnYXRlQ29sdW1uID0gdGhpcy5zZXF1ZWxpemUuY29sKGZpZWxkKTtcbiAgICBpZiAob3B0aW9ucy5kaXN0aW5jdCkge1xuICAgICAgYWdncmVnYXRlQ29sdW1uID0gdGhpcy5zZXF1ZWxpemUuZm4oXCJESVNUSU5DVFwiLCBhZ2dyZWdhdGVDb2x1bW4pO1xuICAgIH1cbiAgICBsZXQgeyBncm91cCB9ID0gb3B0aW9ucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShncm91cCkgJiYgQXJyYXkuaXNBcnJheShncm91cFswXSkpIHtcbiAgICAgIG5vRG91YmxlTmVzdGVkR3JvdXAoKTtcbiAgICAgIGdyb3VwID0gXy5mbGF0dGVuKGdyb3VwKTtcbiAgICB9XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gXy51bmlvbkJ5KG9wdGlvbnMuYXR0cmlidXRlcywgZ3JvdXAsIFtbdGhpcy5zZXF1ZWxpemUuZm4oYWdncmVnYXRlRnVuY3Rpb24sIGFnZ3JlZ2F0ZUNvbHVtbiksIGFnZ3JlZ2F0ZUZ1bmN0aW9uXV0sIChhKSA9PiBBcnJheS5pc0FycmF5KGEpID8gYVsxXSA6IGEpO1xuICAgIGlmICghb3B0aW9ucy5kYXRhVHlwZSkge1xuICAgICAgaWYgKGF0dHJPcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBhdHRyT3B0aW9ucy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IG5ldyBEYXRhVHlwZXMuRkxPQVQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZURhdGFUeXBlKG9wdGlvbnMuZGF0YVR5cGUpO1xuICAgIH1cbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJhbm9pZENsYXVzZSh0aGlzLCBvcHRpb25zKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmF3U2VsZWN0KHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zLCBhZ2dyZWdhdGVGdW5jdGlvbiwgdGhpcyk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb3VudChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7IGhvb2tzOiB0cnVlIH0pO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQ291bnRcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBjb2wgPSBvcHRpb25zLmNvbCB8fCBcIipcIjtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBjb2wgPSBgJHt0aGlzLm5hbWV9LiR7b3B0aW9ucy5jb2wgfHwgdGhpcy5wcmltYXJ5S2V5RmllbGR9YDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGlzdGluY3QgJiYgY29sID09PSBcIipcIikge1xuICAgICAgY29sID0gdGhpcy5wcmltYXJ5S2V5RmllbGQ7XG4gICAgfVxuICAgIG9wdGlvbnMucGxhaW4gPSAhb3B0aW9ucy5ncm91cDtcbiAgICBvcHRpb25zLmRhdGFUeXBlID0gbmV3IERhdGFUeXBlcy5JTlRFR0VSKCk7XG4gICAgb3B0aW9ucy5pbmNsdWRlSWdub3JlQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIG9wdGlvbnMubGltaXQgPSBudWxsO1xuICAgIG9wdGlvbnMub2Zmc2V0ID0gbnVsbDtcbiAgICBvcHRpb25zLm9yZGVyID0gbnVsbDtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmFnZ3JlZ2F0ZShjb2wsIFwiY291bnRcIiwgb3B0aW9ucyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGl0ZW0pID0+IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGl0ZW0pLCB7XG4gICAgICAgIGNvdW50OiBOdW1iZXIoaXRlbS5jb3VudClcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZEFuZENvdW50QWxsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwICYmICFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgdG8gZmluZEFuZENvdW50QWxsIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBjb3VudE9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKGNvdW50T3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb3VudE9wdGlvbnMuYXR0cmlidXRlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgW2NvdW50LCByb3dzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuY291bnQoY291bnRPcHRpb25zKSxcbiAgICAgIHRoaXMuZmluZEFsbChvcHRpb25zKVxuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICBjb3VudCxcbiAgICAgIHJvd3M6IGNvdW50ID09PSAwID8gW10gOiByb3dzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWF4KGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCBcIm1heFwiLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgbWluKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCBcIm1pblwiLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgc3VtKGZpZWxkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYWdncmVnYXRlKGZpZWxkLCBcInN1bVwiLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYnVpbGQodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVsa0J1aWxkKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBidWxrQnVpbGQodmFsdWVTZXRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHsgaXNOZXdSZWNvcmQ6IHRydWUgfSwgb3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKChhdHRyaWJ1dGUpID0+IEFycmF5LmlzQXJyYXkoYXR0cmlidXRlKSA/IGF0dHJpYnV0ZVsxXSA6IGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVNldHMubWFwKCh2YWx1ZXMpID0+IHRoaXMuYnVpbGQodmFsdWVzLCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMgfHwge30pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJ1aWxkKHZhbHVlcywge1xuICAgICAgaXNOZXdSZWNvcmQ6IHRydWUsXG4gICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zLmZpZWxkcyxcbiAgICAgIGluY2x1ZGU6IG9wdGlvbnMuaW5jbHVkZSxcbiAgICAgIHJhdzogb3B0aW9ucy5yYXcsXG4gICAgICBzaWxlbnQ6IG9wdGlvbnMuc2lsZW50XG4gICAgfSkuc2F2ZShvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZE9yQnVpbGQob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kT3JCdWlsZC4gUGxlYXNlIG5vdGUgdGhhdCB0aGUgQVBJIGhhcyBjaGFuZ2VkLCBhbmQgaXMgbm93IG9wdGlvbnMgb25seSAoYW4gb2JqZWN0IHdpdGggd2hlcmUsIGRlZmF1bHRzIGtleXMsIHRyYW5zYWN0aW9uIGV0Yy4pXCIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCBpbnN0YW5jZSA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLmRlZmF1bHRzKTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlID0gdGhpcy5idWlsZCh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtpbnN0YW5jZSwgdHJ1ZV07XG4gICAgfVxuICAgIHJldHVybiBbaW5zdGFuY2UsIGZhbHNlXTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZmluZE9yQ3JlYXRlKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZE9yQ3JlYXRlLiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBBUEkgaGFzIGNoYW5nZWQsIGFuZCBpcyBub3cgb3B0aW9ucyBvbmx5IChhbiBvYmplY3Qgd2l0aCB3aGVyZSwgZGVmYXVsdHMga2V5cywgdHJhbnNhY3Rpb24gZXRjLilcIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0gT2JqZWN0LmtleXMob3B0aW9ucy5kZWZhdWx0cyk7XG4gICAgICBjb25zdCB1bmtub3duRGVmYXVsdHMgPSBkZWZhdWx0cy5maWx0ZXIoKG5hbWUpID0+ICF0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgaWYgKHVua25vd25EZWZhdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oYFVua25vd24gYXR0cmlidXRlcyAoJHt1bmtub3duRGVmYXVsdHN9KSBwYXNzZWQgdG8gZGVmYXVsdHMgb3B0aW9uIG9mIGZpbmRPckNyZWF0ZWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludGVybmFsVHJhbnNhY3Rpb24gPSAhb3B0aW9ucy50cmFuc2FjdGlvbjtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnRyYW5zYWN0aW9uKG9wdGlvbnMpO1xuICAgICAgdHJhbnNhY3Rpb24gPSB0O1xuICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZE9uZShVdGlscy5kZWZhdWx0cyh7IHRyYW5zYWN0aW9uIH0sIG9wdGlvbnMpKTtcbiAgICAgIGlmIChmb3VuZCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW2ZvdW5kLCBmYWxzZV07XG4gICAgICB9XG4gICAgICB2YWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5kZWZhdWx0cyk7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmV4Y2VwdGlvbiA9IHRydWU7XG4gICAgICBvcHRpb25zLnJldHVybmluZyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVhdGVkID0gYXdhaXQgdGhpcy5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGNyZWF0ZWQuZ2V0KHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbY3JlYXRlZCwgdHJ1ZV07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcikpXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICBjb25zdCBmbGF0dGVuZWRXaGVyZSA9IFV0aWxzLmZsYXR0ZW5PYmplY3REZWVwKG9wdGlvbnMud2hlcmUpO1xuICAgICAgICBjb25zdCBmbGF0dGVuZWRXaGVyZUtleXMgPSBPYmplY3Qua2V5cyhmbGF0dGVuZWRXaGVyZSkubWFwKChuYW1lKSA9PiBfLmxhc3QobmFtZS5zcGxpdChcIi5cIikpKTtcbiAgICAgICAgY29uc3Qgd2hlcmVGaWVsZHMgPSBmbGF0dGVuZWRXaGVyZUtleXMubWFwKChuYW1lKSA9PiBfLmdldCh0aGlzLnJhd0F0dHJpYnV0ZXMsIGAke25hbWV9LmZpZWxkYCwgbmFtZSkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0RmllbGRzID0gb3B0aW9ucy5kZWZhdWx0cyAmJiBPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHRzKS5maWx0ZXIoKG5hbWUpID0+IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXSkubWFwKChuYW1lKSA9PiB0aGlzLnJhd0F0dHJpYnV0ZXNbbmFtZV0uZmllbGQgfHwgbmFtZSk7XG4gICAgICAgIGNvbnN0IGVyckZpZWxkS2V5cyA9IE9iamVjdC5rZXlzKGVyci5maWVsZHMpO1xuICAgICAgICBjb25zdCBlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMgPSBVdGlscy5pbnRlcnNlY3RzKGVyckZpZWxkS2V5cywgd2hlcmVGaWVsZHMpO1xuICAgICAgICBpZiAoZGVmYXVsdEZpZWxkcyAmJiAhZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzICYmIFV0aWxzLmludGVyc2VjdHMoZXJyRmllbGRLZXlzLCBkZWZhdWx0RmllbGRzKSkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyRmllbGRzV2hlcmVJbnRlcnNlY3RzKSB7XG4gICAgICAgICAgXy5lYWNoKGVyci5maWVsZHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5maWVsZFJhd0F0dHJpYnV0ZXNNYXBba2V5XS5maWVsZE5hbWU7XG4gICAgICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKSAhPT0gb3B0aW9ucy53aGVyZVtuYW1lXS50b1N0cmluZygpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9I2ZpbmRPckNyZWF0ZTogdmFsdWUgdXNlZCBmb3IgJHtuYW1lfSB3YXMgbm90IGVxdWFsIGZvciBib3RoIHRoZSBmaW5kIGFuZCB0aGUgY3JlYXRlIGNhbGxzLCAnJHtvcHRpb25zLndoZXJlW25hbWVdfScgdnMgJyR7dmFsdWV9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG90aGVyQ3JlYXRlZCA9IGF3YWl0IHRoaXMuZmluZE9uZShVdGlscy5kZWZhdWx0cyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IGludGVybmFsVHJhbnNhY3Rpb24gPyBudWxsIDogdHJhbnNhY3Rpb25cbiAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgICBpZiAob3RoZXJDcmVhdGVkID09PSBudWxsKVxuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgcmV0dXJuIFtvdGhlckNyZWF0ZWQsIGZhbHNlXTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGludGVybmFsVHJhbnNhY3Rpb24gJiYgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgdHJhbnNhY3Rpb24uY29tbWl0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kQ3JlYXRlRmluZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRDcmVhdGVGaW5kLlwiKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLmRlZmF1bHRzKTtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgIH1cbiAgICBjb25zdCBmb3VuZCA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoZm91bmQpXG4gICAgICByZXR1cm4gW2ZvdW5kLCBmYWxzZV07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNyZWF0ZU9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0ID09PSBcInBvc3RncmVzXCIgJiYgb3B0aW9ucy50cmFuc2FjdGlvbikge1xuICAgICAgICBjcmVhdGVPcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMuY3JlYXRlKHZhbHVlcywgY3JlYXRlT3B0aW9ucyk7XG4gICAgICByZXR1cm4gW2NyZWF0ZWQsIHRydWVdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2Ygc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvciB8fCBlcnIgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvcnMuRW1wdHlSZXN1bHRFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgZm91bmRBZ2FpbiA9IGF3YWl0IHRoaXMuZmluZE9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBbZm91bmRBZ2FpbiwgZmFsc2VdO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgYXN5bmMgdXBzZXJ0KHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIHJldHVybmluZzogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB0cnVlXG4gICAgfSwgVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgY29uc3QgaGFzUHJpbWFyeSA9IHRoaXMucHJpbWFyeUtleUZpZWxkIGluIHZhbHVlcyB8fCB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGUgaW4gdmFsdWVzO1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5idWlsZCh2YWx1ZXMpO1xuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBjaGFuZ2VkID0gQXJyYXkuZnJvbShpbnN0YW5jZS5fY2hhbmdlZCk7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBjaGFuZ2VkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgYXdhaXQgaW5zdGFuY2UudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWREYXRhVmFsdWVzID0gXy5waWNrKGluc3RhbmNlLmRhdGFWYWx1ZXMsIGNoYW5nZWQpO1xuICAgIGNvbnN0IGluc2VydFZhbHVlcyA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyhpbnN0YW5jZS5kYXRhVmFsdWVzLCBPYmplY3Qua2V5cyhpbnN0YW5jZS5yYXdBdHRyaWJ1dGVzKSwgdGhpcyk7XG4gICAgY29uc3QgdXBkYXRlVmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHVwZGF0ZWREYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcywgdGhpcyk7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIWluc2VydFZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbY3JlYXRlZEF0QXR0cl0uZmllbGQgfHwgY3JlYXRlZEF0QXR0cjtcbiAgICAgIGluc2VydFZhbHVlc1tmaWVsZF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKGNyZWF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIWluc2VydFZhbHVlc1t1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdXBkYXRlZEF0QXR0cl0uZmllbGQgfHwgdXBkYXRlZEF0QXR0cjtcbiAgICAgIGluc2VydFZhbHVlc1tmaWVsZF0gPSB1cGRhdGVWYWx1ZXNbZmllbGRdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09IFwiZGIyXCIpIHtcbiAgICAgIHRoaXMudW5pcW5vID0gdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5hZGRVbmlxdWVGaWVsZHMoaW5zZXJ0VmFsdWVzLCB0aGlzLnJhd0F0dHJpYnV0ZXMsIHRoaXMudW5pcW5vKTtcbiAgICB9XG4gICAgaWYgKCFoYXNQcmltYXJ5ICYmIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiAhdGhpcy5yYXdBdHRyaWJ1dGVzW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uZGVmYXVsdFZhbHVlKSB7XG4gICAgICBkZWxldGUgaW5zZXJ0VmFsdWVzW3RoaXMucHJpbWFyeUtleUZpZWxkXTtcbiAgICAgIGRlbGV0ZSB1cGRhdGVWYWx1ZXNbdGhpcy5wcmltYXJ5S2V5RmllbGRdO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZVVwc2VydFwiLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnVwc2VydCh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIGluc3RhbmNlLndoZXJlKCksIG9wdGlvbnMpO1xuICAgIGNvbnN0IFtyZWNvcmRdID0gcmVzdWx0O1xuICAgIHJlY29yZC5pc05ld1JlY29yZCA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJVcHNlcnRcIiwgcmVzdWx0LCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGJ1bGtDcmVhdGUocmVjb3Jkcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFyZWNvcmRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBkaWFsZWN0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0O1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlcyA9IHJlY29yZHMubWFwKCh2YWx1ZXMpID0+IHRoaXMuYnVpbGQodmFsdWVzLCB7IGlzTmV3UmVjb3JkOiB0cnVlLCBpbmNsdWRlOiBvcHRpb25zLmluY2x1ZGUgfSkpO1xuICAgIGNvbnN0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUgPSBhc3luYyAoaW5zdGFuY2VzMiwgb3B0aW9uczIpID0+IHtcbiAgICAgIG9wdGlvbnMyID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgICBpbmRpdmlkdWFsSG9va3M6IGZhbHNlLFxuICAgICAgICBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZVxuICAgICAgfSwgb3B0aW9uczIpO1xuICAgICAgaWYgKG9wdGlvbnMyLnJldHVybmluZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zMi5hc3NvY2lhdGlvbikge1xuICAgICAgICAgIG9wdGlvbnMyLnJldHVybmluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMyLnJldHVybmluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi5pZ25vcmVEdXBsaWNhdGVzICYmICF0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMuaWdub3JlRHVwbGljYXRlcyAmJiAhdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLm9uQ29uZmxpY3REb05vdGhpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RpYWxlY3R9IGRvZXMgbm90IHN1cHBvcnQgdGhlIGlnbm9yZUR1cGxpY2F0ZXMgb3B0aW9uLmApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlICYmIChkaWFsZWN0ICE9PSBcIm15c3FsXCIgJiYgZGlhbGVjdCAhPT0gXCJtYXJpYWRiXCIgJiYgZGlhbGVjdCAhPT0gXCJzcWxpdGVcIiAmJiBkaWFsZWN0ICE9PSBcInBvc3RncmVzXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkaWFsZWN0fSBkb2VzIG5vdCBzdXBwb3J0IHRoZSB1cGRhdGVPbkR1cGxpY2F0ZSBvcHRpb24uYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMyLm1vZGVsO1xuICAgICAgb3B0aW9uczIuZmllbGRzID0gb3B0aW9uczIuZmllbGRzIHx8IE9iamVjdC5rZXlzKG1vZGVsLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgICBpZiAob3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSkgJiYgb3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgb3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUgPSBfLmludGVyc2VjdGlvbihfLndpdGhvdXQoT2JqZWN0LmtleXMobW9kZWwudGFibGVBdHRyaWJ1dGVzKSwgY3JlYXRlZEF0QXR0ciksIG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1cGRhdGVPbkR1cGxpY2F0ZSBvcHRpb24gb25seSBzdXBwb3J0cyBub24tZW1wdHkgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIuaG9va3MpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwucnVuSG9va3MoXCJiZWZvcmVCdWxrQ3JlYXRlXCIsIGluc3RhbmNlczIsIG9wdGlvbnMyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMyKTtcbiAgICAgICAgdmFsaWRhdGVPcHRpb25zLmhvb2tzID0gb3B0aW9uczIuaW5kaXZpZHVhbEhvb2tzO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMyLm1hcChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2UudmFsaWRhdGUodmFsaWRhdGVPcHRpb25zKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuQnVsa1JlY29yZEVycm9yKGVyciwgaW5zdGFuY2UpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMyLnNraXA7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5BZ2dyZWdhdGVFcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlczIubWFwKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWxPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uczIpLCB7XG4gICAgICAgICAgICB2YWxpZGF0ZTogZmFsc2UsXG4gICAgICAgICAgICBob29rczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5maWVsZHM7XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmluZGl2aWR1YWxIb29rcztcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaWdub3JlRHVwbGljYXRlcztcbiAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluZGl2aWR1YWxPcHRpb25zKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMyLmluY2x1ZGUgJiYgb3B0aW9uczIuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zMi5pbmNsdWRlLmZpbHRlcigoaW5jbHVkZSkgPT4gaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbykubWFwKGFzeW5jIChpbmNsdWRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZXMucHVzaChhc3NvY2lhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzc29jaWF0aW9uSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKS5vbWl0KFtcImFzc29jaWF0aW9uXCJdKS5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zMi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9uczIubG9nZ2luZ1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcyA9IGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoYXNzb2NpYXRpb25JbnN0YW5jZXMsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcykge1xuICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlID0gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzW2lkeF07XG4gICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcFtpZHhdO1xuICAgICAgICAgICAgICBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLnNldChpbnN0YW5jZSwgYXNzb2NpYXRpb25JbnN0YW5jZSwgeyBzYXZlOiBmYWxzZSwgbG9nZ2luZzogb3B0aW9uczIubG9nZ2luZyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3JkcyA9IGluc3RhbmNlczIubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGluc3RhbmNlLmRhdGFWYWx1ZXM7XG4gICAgICAgICAgaWYgKGNyZWF0ZWRBdEF0dHIgJiYgIXZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgICAgICAgdmFsdWVzW2NyZWF0ZWRBdEF0dHJdID0gbm93O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zMi5maWVsZHMuaW5jbHVkZXMoY3JlYXRlZEF0QXR0cikpIHtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZmllbGRzLnB1c2goY3JlYXRlZEF0QXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICF2YWx1ZXNbdXBkYXRlZEF0QXR0cl0pIHtcbiAgICAgICAgICAgIHZhbHVlc1t1cGRhdGVkQXRBdHRyXSA9IG5vdztcbiAgICAgICAgICAgIGlmICghb3B0aW9uczIuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMyLmZpZWxkcy5wdXNoKHVwZGF0ZWRBdEF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBvdXQgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModmFsdWVzLCBvcHRpb25zMi5maWVsZHMsIG1vZGVsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBtb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvdXRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gbW9kZWwudGFibGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgfHwgYXR0cl0gPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSkge1xuICAgICAgICAgIG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlID0gb3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUubWFwKChhdHRyKSA9PiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkIHx8IGF0dHIpO1xuICAgICAgICAgIGlmIChvcHRpb25zMi5jb25mbGljdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMyLnVwc2VydEtleXMgPSBvcHRpb25zMi5jb25mbGljdEF0dHJpYnV0ZXMubWFwKChhdHRyTmFtZSkgPT4gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyTmFtZV0uZmllbGQgfHwgYXR0ck5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1cHNlcnRLZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbW9kZWwuX2luZGV4ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGkudW5pcXVlICYmICFpLndoZXJlKSB7XG4gICAgICAgICAgICAgICAgdXBzZXJ0S2V5cy5wdXNoKC4uLmkuZmllbGRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlyc3RVbmlxdWVLZXkgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLmZpbmQoKGMpID0+IGMuZmllbGRzLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgaWYgKGZpcnN0VW5pcXVlS2V5ICYmIGZpcnN0VW5pcXVlS2V5LmZpZWxkcykge1xuICAgICAgICAgICAgICB1cHNlcnRLZXlzLnB1c2goLi4uZmlyc3RVbmlxdWVLZXkuZmllbGRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMyLnVwc2VydEtleXMgPSB1cHNlcnRLZXlzLmxlbmd0aCA+IDAgPyB1cHNlcnRLZXlzIDogT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKCh4KSA9PiB4LmZpZWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMyLnJldHVybmluZyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMyLnJldHVybmluZykpIHtcbiAgICAgICAgICBvcHRpb25zMi5yZXR1cm5pbmcgPSBvcHRpb25zMi5yZXR1cm5pbmcubWFwKChhdHRyKSA9PiBfLmdldChtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLCBcImZpZWxkXCIsIGF0dHIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgbW9kZWwucXVlcnlJbnRlcmZhY2UuYnVsa0luc2VydChtb2RlbC5nZXRUYWJsZU5hbWUob3B0aW9uczIpLCByZWNvcmRzLCBvcHRpb25zMiwgZmllbGRNYXBwZWRBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdCwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXMyW2ldO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghaW5zdGFuY2UgfHwga2V5ID09PSBtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmIGluc3RhbmNlLmdldChtb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlKSAmJiBbXCJteXNxbFwiLCBcIm1hcmlhZGJcIiwgXCJzcWxpdGVcIl0uaW5jbHVkZXMoZGlhbGVjdCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQobW9kZWwucmF3QXR0cmlidXRlcywgKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlLmZpZWxkTmFtZSA9PT0ga2V5IHx8IGF0dHJpYnV0ZS5maWVsZCA9PT0ga2V5KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIuaW5jbHVkZSAmJiBvcHRpb25zMi5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zMi5pbmNsdWRlLmZpbHRlcigoaW5jbHVkZSkgPT4gIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvIHx8IGluY2x1ZGUucGFyZW50ICYmIGluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpLm1hcChhc3luYyAoaW5jbHVkZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZUluZGV4VG9JbnN0YW5jZU1hcCA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgaW5zdGFuY2Ugb2YgaW5zdGFuY2VzMikge1xuICAgICAgICAgICAgbGV0IGFzc29jaWF0ZWQgPSBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXNzb2NpYXRlZCkpXG4gICAgICAgICAgICAgIGFzc29jaWF0ZWQgPSBbYXNzb2NpYXRlZF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2Ugb2YgYXNzb2NpYXRlZCkge1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkge1xuICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZS5zZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5LCBpbnN0YW5jZS5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkgfHwgaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhc3NvY2lhdGlvbkluc3RhbmNlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzb2NpYXRpb25JbnN0YW5jZXMucHVzaChhc3NvY2lhdGlvbkluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYXNzb2NpYXRpb25JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpLm9taXQoW1wiYXNzb2NpYXRpb25cIl0pLmRlZmF1bHRzKHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zMi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMyLmxvZ2dpbmdcbiAgICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlcyA9IGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUoYXNzb2NpYXRpb25JbnN0YW5jZXMsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlU2V0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXNbaWR4XTtcbiAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwW2lkeF07XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5XTogaW5zdGFuY2UuZ2V0KGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5XTogYXNzb2NpYXRpb25JbnN0YW5jZS5nZXQoYXNzb2NpYXRpb25JbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KVxuICAgICAgICAgICAgICB9LCBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2guc2NvcGUpO1xuICAgICAgICAgICAgICBpZiAoYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXMoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uX2F1dG9HZW5lcmF0ZWQgfHwgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5IHx8IGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXkgfHwgdHlwZW9mIGFzc29jaWF0aW9uSW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFsdWVzW2F0dHJdID0gYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbHVlU2V0cy5wdXNoKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aHJvdWdoT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKS5vbWl0KFtcImFzc29jaWF0aW9uXCIsIFwiYXR0cmlidXRlc1wiXSkuZGVmYXVsdHMoe1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9uczIudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMyLmxvZ2dpbmdcbiAgICAgICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgICAgICB0aHJvdWdoT3B0aW9ucy5tb2RlbCA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsO1xuICAgICAgICAgICAgY29uc3QgdGhyb3VnaEluc3RhbmNlcyA9IGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaE1vZGVsLmJ1bGtCdWlsZCh2YWx1ZVNldHMsIHRocm91Z2hPcHRpb25zKTtcbiAgICAgICAgICAgIGF3YWl0IHJlY3Vyc2l2ZUJ1bGtDcmVhdGUodGhyb3VnaEluc3RhbmNlcywgdGhyb3VnaE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2VzMi5mb3JFYWNoKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmIGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF0gIT09IHZvaWQgMCAmJiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHJdID0gaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdID0gaW5zdGFuY2UuZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgICAgICBpbnN0YW5jZS5jaGFuZ2VkKGF0dHIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5pc05ld1JlY29yZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9uczIuaG9va3MpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwucnVuSG9va3MoXCJhZnRlckJ1bGtDcmVhdGVcIiwgaW5zdGFuY2VzMiwgb3B0aW9uczIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlczI7XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShpbnN0YW5jZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyB0cnVuY2F0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKSB8fCB7fTtcbiAgICBvcHRpb25zLnRydW5jYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5kZXN0cm95KG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zIHx8ICEob3B0aW9ucy53aGVyZSB8fCBvcHRpb25zLnRydW5jYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB3aGVyZSBvciB0cnVuY2F0ZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIG1vZGVsLmRlc3Ryb3kuXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHJ1bmNhdGUgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zLndoZXJlKSAmJiAhKG9wdGlvbnMud2hlcmUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwbGFpbiBvYmplY3QsIGFycmF5IG9yIHNlcXVlbGl6ZSBtZXRob2QgaW4gdGhlIG9wdGlvbnMud2hlcmUgcGFyYW1ldGVyIG9mIG1vZGVsLmRlc3Ryb3kuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICBjYXNjYWRlOiBmYWxzZSxcbiAgICAgIHJlc3RhcnRJZGVudGl0eTogZmFsc2VcbiAgICB9KTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtERUxFVEU7XG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUJ1bGtEZXN0cm95XCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHsgd2hlcmU6IG9wdGlvbnMud2hlcmUsIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmsgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gdGhpcy5ydW5Ib29rcyhcImJlZm9yZURlc3Ryb3lcIiwgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmICFvcHRpb25zLmZvcmNlKSB7XG4gICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gICAgICBjb25zdCBhdHRyVmFsdWVIYXNoID0ge307XG4gICAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdLmZpZWxkO1xuICAgICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICAgIFtmaWVsZF06IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGxcbiAgICAgIH07XG4gICAgICBhdHRyVmFsdWVIYXNoW2ZpZWxkXSA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBhdHRyVmFsdWVIYXNoLCBPYmplY3QuYXNzaWduKHdoZXJlLCBvcHRpb25zLndoZXJlKSwgb3B0aW9ucywgdGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrRGVsZXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gdGhpcy5ydW5Ib29rcyhcImFmdGVyRGVzdHJveVwiLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlckJ1bGtEZXN0cm95XCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhc3luYyByZXN0b3JlKG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgaXMgbm90IHBhcmFub2lkXCIpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuUkFXO1xuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVCdWxrUmVzdG9yZVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IGluc3RhbmNlcztcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7IHdoZXJlOiBvcHRpb25zLndoZXJlLCB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbiwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLCBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrLCBwYXJhbm9pZDogZmFsc2UgfSk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gdGhpcy5ydW5Ib29rcyhcImJlZm9yZVJlc3RvcmVcIiwgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIGNvbnN0IGF0dHJWYWx1ZUhhc2ggPSB7fTtcbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbZGVsZXRlZEF0Q29sXTtcbiAgICBjb25zdCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIGF0dHJWYWx1ZUhhc2hbZGVsZXRlZEF0QXR0cmlidXRlLmZpZWxkIHx8IGRlbGV0ZWRBdENvbF0gPSBkZWxldGVkQXREZWZhdWx0VmFsdWU7XG4gICAgb3B0aW9ucy5vbWl0TnVsbCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgYXR0clZhbHVlSGFzaCwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcy5yYXdBdHRyaWJ1dGVzKTtcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJSZXN0b3JlXCIsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyQnVsa1Jlc3RvcmVcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHVwZGF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faW5qZWN0U2NvcGUob3B0aW9ucyk7XG4gICAgdGhpcy5fb3B0aW9uc011c3RDb250YWluV2hlcmUob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgdmFsaWRhdGU6IHRydWUsXG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICByZXR1cm5pbmc6IGZhbHNlLFxuICAgICAgZm9yY2U6IGZhbHNlLFxuICAgICAgc2lkZUVmZmVjdHM6IHRydWVcbiAgICB9KSk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5CVUxLVVBEQVRFO1xuICAgIHZhbHVlcyA9IF8ub21pdEJ5KHZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdm9pZCAwKTtcbiAgICBpZiAob3B0aW9ucy5maWVsZHMgJiYgb3B0aW9ucy5maWVsZHMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWVzKSkge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0O1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbihPYmplY3Qua2V5cyh2YWx1ZXMpLCBPYmplY3Qua2V5cyh0aGlzLnRhYmxlQXR0cmlidXRlcykpO1xuICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIHZhbHVlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KSB8fCBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgbGV0IHZhbHVlc1VzZTtcbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgY29uc3QgYnVpbGQgPSB0aGlzLmJ1aWxkKHZhbHVlcyk7XG4gICAgICBidWlsZC5zZXQodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQsIHZhbHVlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdF0sIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgaWYgKG9wdGlvbnMuc2lkZUVmZmVjdHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih2YWx1ZXMsIF8ucGljayhidWlsZC5nZXQoKSwgYnVpbGQuY2hhbmdlZCgpKSk7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy51bmlvbihvcHRpb25zLmZpZWxkcywgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKSwgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXdhaXQgYnVpbGQudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICBvcHRpb25zLnNraXAgPSB2b2lkIDA7XG4gICAgICBpZiAoYXR0cmlidXRlcyAmJiBhdHRyaWJ1dGVzLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gXy5waWNrKGF0dHJpYnV0ZXMuZGF0YVZhbHVlcywgT2JqZWN0LmtleXModmFsdWVzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB2YWx1ZXM7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQnVsa1VwZGF0ZVwiLCBvcHRpb25zKTtcbiAgICAgIHZhbHVlcyA9IG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHZhbHVlc1VzZSA9IHZhbHVlcztcbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIGxldCB1cGRhdGVEb25lUm93QnlSb3cgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGluc3RhbmNlcyA9IGF3YWl0IHRoaXMuZmluZEFsbCh7XG4gICAgICAgIHdoZXJlOiBvcHRpb25zLndoZXJlLFxuICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICBiZW5jaG1hcms6IG9wdGlvbnMuYmVuY2htYXJrLFxuICAgICAgICBwYXJhbm9pZDogb3B0aW9ucy5wYXJhbm9pZFxuICAgICAgfSk7XG4gICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICBsZXQgY2hhbmdlZFZhbHVlcztcbiAgICAgICAgbGV0IGRpZmZlcmVudCA9IGZhbHNlO1xuICAgICAgICBpbnN0YW5jZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICAgICAgICBfLmZvckluKHZhbHVlc1VzZSwgKG5ld1ZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0pIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RGF0YVZhbHVlKGF0dHIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlVXBkYXRlXCIsIGluc3RhbmNlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc0NoYW5nZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIF8uZm9ySW4oaW5zdGFuY2UuZGF0YVZhbHVlcywgKG5ld1ZhbHVlLCBhdHRyKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSkge1xuICAgICAgICAgICAgICAgIHRoaXNDaGFuZ2VkVmFsdWVzW2F0dHJdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRWYWx1ZXMgPSB0aGlzQ2hhbmdlZFZhbHVlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRpZmZlcmVudCA9ICFfLmlzRXF1YWwoY2hhbmdlZFZhbHVlcywgdGhpc0NoYW5nZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCFkaWZmZXJlbnQpIHtcbiAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hhbmdlZFZhbHVlcyk7XG4gICAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZXNVc2UgPSBjaGFuZ2VkVmFsdWVzO1xuICAgICAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaW9uKG9wdGlvbnMuZmllbGRzLCBrZXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGl2aWR1YWxPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgICAgICAgICAgaG9va3M6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWxpZGF0ZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmluZGl2aWR1YWxIb29rcztcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5zYXZlKGluZGl2aWR1YWxPcHRpb25zKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdXBkYXRlRG9uZVJvd0J5Um93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh1cGRhdGVEb25lUm93QnlSb3cpIHtcbiAgICAgIHJlc3VsdCA9IFtpbnN0YW5jZXMubGVuZ3RoLCBpbnN0YW5jZXNdO1xuICAgIH0gZWxzZSBpZiAoXy5pc0VtcHR5KHZhbHVlc1VzZSkgfHwgT2JqZWN0LmtleXModmFsdWVzVXNlKS5sZW5ndGggPT09IDEgJiYgdmFsdWVzVXNlW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSkge1xuICAgICAgcmVzdWx0ID0gWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNVc2UgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModmFsdWVzVXNlLCBvcHRpb25zLmZpZWxkcywgdGhpcyk7XG4gICAgICBvcHRpb25zID0gVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5oYXNUcmlnZ2VyIDogZmFsc2U7XG4gICAgICBjb25zdCBhZmZlY3RlZFJvd3MgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlc1VzZSwgb3B0aW9ucy53aGVyZSwgb3B0aW9ucywgdGhpcy50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJlc3VsdCA9IFthZmZlY3RlZFJvd3MubGVuZ3RoLCBhZmZlY3RlZFJvd3NdO1xuICAgICAgICBpbnN0YW5jZXMgPSBhZmZlY3RlZFJvd3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBbYWZmZWN0ZWRSb3dzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4gdGhpcy5ydW5Ib29rcyhcImFmdGVyVXBkYXRlXCIsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgICAgcmVzdWx0WzFdID0gaW5zdGFuY2VzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdmFsdWVzO1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyQnVsa1VwZGF0ZVwiLCBvcHRpb25zKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2NyaWJlKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRlc2NyaWJlVGFibGUodGhpcy50YWJsZU5hbWUsIF9fc3ByZWFkVmFsdWVzKHsgc2NoZW1hOiBzY2hlbWEgfHwgdGhpcy5fc2NoZW1hIHx8IHZvaWQgMCB9LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIF9nZXREZWZhdWx0VGltZXN0YW1wKGF0dHIpIHtcbiAgICBpZiAoISF0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgISF0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gVXRpbHMudG9EZWZhdWx0VmFsdWUodGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJdLmRlZmF1bHRWYWx1ZSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgX2V4cGFuZEF0dHJpYnV0ZXMob3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMuZXhjbHVkZSkge1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuZmlsdGVyKChlbGVtKSA9PiAhb3B0aW9ucy5hdHRyaWJ1dGVzLmV4Y2x1ZGUuaW5jbHVkZXMoZWxlbSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGUpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzLmNvbmNhdChvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZSk7XG4gICAgfVxuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIH1cbiAgc3RhdGljIF9pbmplY3RTY29wZShvcHRpb25zKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBVdGlscy5jbG9uZURlZXAodGhpcy5fc2NvcGUpO1xuICAgIHRoaXMuX2RlZmF1bHRzT3B0aW9ucyhvcHRpb25zLCBzY29wZSk7XG4gIH1cbiAgc3RhdGljIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cbiAgc3RhdGljIGhhc0FsaWFzKGFsaWFzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmFzc29jaWF0aW9ucywgYWxpYXMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBpbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBmaWVsZHMgPT09IFwic3RyaW5nXCIpXG4gICAgICBmaWVsZHMgPSBbZmllbGRzXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICBmaWVsZHMgPSBmaWVsZHMubWFwKChmKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJhd0F0dHJpYnV0ZXNbZl0gJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAhPT0gZikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGZpZWxkcyAmJiB0eXBlb2YgZmllbGRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhmaWVsZHMpLnJlZHVjZSgocmF3RmllbGRzLCBmKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnJhd0F0dHJpYnV0ZXNbZl0gJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICYmIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZCAhPT0gZikge1xuICAgICAgICAgIHJhd0ZpZWxkc1t0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGRdID0gZmllbGRzW2ZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhd0ZpZWxkc1tmXSA9IGZpZWxkc1tmXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3RmllbGRzO1xuICAgICAgfSwge30pO1xuICAgIH1cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICB0aGlzLl9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKTtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGJ5OiAxLFxuICAgICAgd2hlcmU6IHt9LFxuICAgICAgaW5jcmVtZW50OiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaXNTdWJ0cmFjdGlvbiA9ICFvcHRpb25zLmluY3JlbWVudDtcbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIGNvbnN0IHdoZXJlID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMud2hlcmUpO1xuICAgIGxldCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0ge307XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFtmaWVsZF0gPSBvcHRpb25zLmJ5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCA9IGZpZWxkcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkW3RoaXMuX3ZlcnNpb25BdHRyaWJ1dGVdID0gaXNTdWJ0cmFjdGlvbiA/IC0xIDogMTtcbiAgICB9XG4gICAgY29uc3QgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgaWYgKCFvcHRpb25zLnNpbGVudCAmJiB1cGRhdGVkQXRBdHRyICYmICFpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFt1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLnJhd0F0dHJpYnV0ZXNbdXBkYXRlZEF0QXR0cl0uZmllbGQgfHwgdXBkYXRlZEF0QXR0cjtcbiAgICAgIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkW2F0dHJOYW1lXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodXBkYXRlZEF0QXR0cikgfHwgVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpO1xuICAgIGxldCBhZmZlY3RlZFJvd3M7XG4gICAgaWYgKGlzU3VidHJhY3Rpb24pIHtcbiAgICAgIGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZGVjcmVtZW50KHRoaXMsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuaW5jcmVtZW50KHRoaXMsIHRhYmxlTmFtZSwgd2hlcmUsIGluY3JlbWVudEFtb3VudHNCeUZpZWxkLCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgcmV0dXJuIFthZmZlY3RlZFJvd3MsIGFmZmVjdGVkUm93cy5sZW5ndGhdO1xuICAgIH1cbiAgICByZXR1cm4gW2FmZmVjdGVkUm93c107XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnQoZmllbGRzLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGJ5OiAxXG4gICAgfSwgb3B0aW9ucyksIHtcbiAgICAgIGluY3JlbWVudDogZmFsc2VcbiAgICB9KSk7XG4gIH1cbiAgc3RhdGljIF9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKSB7XG4gICAgYXNzZXJ0KG9wdGlvbnMgJiYgb3B0aW9ucy53aGVyZSwgXCJNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXJcIik7XG4gICAgYXNzZXJ0KF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMud2hlcmUpIHx8IG9wdGlvbnMud2hlcmUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QsIFwiRXhwZWN0ZWQgcGxhaW4gb2JqZWN0LCBhcnJheSBvciBzZXF1ZWxpemUgbWV0aG9kIGluIHRoZSBvcHRpb25zLndoZXJlIHBhcmFtZXRlclwiKTtcbiAgfVxuICB3aGVyZShjaGVja1ZlcnNpb24pIHtcbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMucmVkdWNlKChyZXN1bHQsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZV0gPSB0aGlzLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gICAgaWYgKF8uc2l6ZSh3aGVyZSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm9wdGlvbnMud2hlcmVDb2xsZWN0aW9uO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uQXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3ZlcnNpb25BdHRyaWJ1dGU7XG4gICAgaWYgKGNoZWNrVmVyc2lvbiAmJiB2ZXJzaW9uQXR0cikge1xuICAgICAgd2hlcmVbdmVyc2lvbkF0dHJdID0gdGhpcy5nZXQodmVyc2lvbkF0dHIsIHsgcmF3OiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMubWFwV2hlcmVGaWVsZE5hbWVzKHdoZXJlLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYFtvYmplY3QgU2VxdWVsaXplSW5zdGFuY2U6JHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9XWA7XG4gIH1cbiAgZ2V0RGF0YVZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgfVxuICBzZXREYXRhVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XTtcbiAgICBpZiAoIV8uaXNFcXVhbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkpIHtcbiAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmRhdGFWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICB9XG4gIGdldChrZXksIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwICYmIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSBrZXk7XG4gICAgICBrZXkgPSB2b2lkIDA7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fY3VzdG9tR2V0dGVycywga2V5KSAmJiAhb3B0aW9ucy5yYXcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1c3RvbUdldHRlcnNba2V5XS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5wbGFpbiAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmRhdGFWYWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV0ubWFwKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuZ2V0KG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhVmFsdWVzW2tleV0gaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XS5nZXQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICAgIH1cbiAgICBpZiAodGhpcy5faGFzQ3VzdG9tR2V0dGVycyB8fCBvcHRpb25zLnBsYWluICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSB8fCBvcHRpb25zLmNsb25lKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB7fTtcbiAgICAgIGxldCBfa2V5O1xuICAgICAgaWYgKHRoaXMuX2hhc0N1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgZm9yIChfa2V5IGluIHRoaXMuX2N1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5hdHRyaWJ1dGVzICYmICF0aGlzLl9vcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZXMoX2tleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX2N1c3RvbUdldHRlcnMsIF9rZXkpKSB7XG4gICAgICAgICAgICB2YWx1ZXNbX2tleV0gPSB0aGlzLmdldChfa2V5LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoX2tleSBpbiB0aGlzLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWVzLCBfa2V5KSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5kYXRhVmFsdWVzLCBfa2V5KSkge1xuICAgICAgICAgIHZhbHVlc1tfa2V5XSA9IHRoaXMuZ2V0KF9rZXksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzO1xuICB9XG4gIHNldChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgbGV0IHZhbHVlcztcbiAgICBsZXQgb3JpZ2luYWxWYWx1ZTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgIHZhbHVlcyA9IGtleTtcbiAgICAgIG9wdGlvbnMgPSB2YWx1ZSB8fCB7fTtcbiAgICAgIGlmIChvcHRpb25zLnJlc2V0KSB7XG4gICAgICAgIHRoaXMuZGF0YVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleTIgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkKGtleTIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmF3ICYmICEodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUpICYmICEob3B0aW9ucyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMpICYmICF0aGlzLmNvbnN0cnVjdG9yLl9oYXNEYXRlQXR0cmlidXRlcyAmJiAhdGhpcy5jb25zdHJ1Y3Rvci5faGFzQm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuZGF0YVZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kYXRhVmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRhdGFWYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICAgIGNvbnN0IHNldEtleXMgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGRhdGEpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlc1trXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zZXQoaywgdmFsdWVzW2tdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldEtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzVmlydHVhbEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHNldEtleXModGhpcy5jb25zdHJ1Y3Rvci5fdmlydHVhbEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMpIHtcbiAgICAgICAgICAgIHNldEtleXModGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleTIgaW4gdmFsdWVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXkyLCB2YWx1ZXNba2V5Ml0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5yYXcpIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5kYXRhVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucylcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoIW9wdGlvbnMucmF3KSB7XG4gICAgICBvcmlnaW5hbFZhbHVlID0gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5yYXcgJiYgdGhpcy5fY3VzdG9tU2V0dGVyc1trZXldKSB7XG4gICAgICB0aGlzLl9jdXN0b21TZXR0ZXJzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwga2V5KTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgICBpZiAoIV8uaXNFcXVhbChuZXdWYWx1ZSwgb3JpZ2luYWxWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV0gPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZU5hbWVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgdGhpcy5fc2V0SW5jbHVkZShrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMucmF3KSB7XG4gICAgICAgIGlmICghdGhpcy5faXNBdHRyaWJ1dGUoa2V5KSkge1xuICAgICAgICAgIGlmIChrZXkuaW5jbHVkZXMoXCIuXCIpICYmIHRoaXMuY29uc3RydWN0b3IuX2pzb25BdHRyaWJ1dGVzLmhhcyhrZXkuc3BsaXQoXCIuXCIpWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNOZXN0ZWRWYWx1ZSA9IERvdHRpZS5nZXQodGhpcy5kYXRhVmFsdWVzLCBrZXkpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldmlvdXNOZXN0ZWRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIERvdHRpZS5zZXQodGhpcy5kYXRhVmFsdWVzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkKGtleS5zcGxpdChcIi5cIilbMF0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5faGFzUHJpbWFyeUtleXMgJiYgb3JpZ2luYWxWYWx1ZSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9pc1ByaW1hcnlLZXkoa2V5KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLmNvbnN0cnVjdG9yLl9oYXNSZWFkT25seUF0dHJpYnV0ZXMgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fcmVhZE9ubHlBdHRyaWJ1dGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVTYW5pdGl6ZXJzLCBrZXkpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVTYW5pdGl6ZXJzW2tleV0uY2FsbCh0aGlzLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMucmF3ICYmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XSAmJiB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBvcHRpb25zKSB8fCAhdGhpcy5jb25zdHJ1Y3Rvci5fZGF0YVR5cGVDaGFuZ2VzW2tleV0gJiYgIV8uaXNFcXVhbCh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSkpKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGFWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRBdHRyaWJ1dGVzKHVwZGF0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQodXBkYXRlcyk7XG4gIH1cbiAgY2hhbmdlZChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5fY2hhbmdlZC5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9jaGFuZ2VkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmFkZChrZXkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWQuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQuaGFzKGtleSk7XG4gIH1cbiAgcHJldmlvdXMoa2V5KSB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrQnkodGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzLCAodmFsdWUsIGtleTIpID0+IHRoaXMuY2hhbmdlZChrZXkyKSk7XG4gIH1cbiAgX3NldEluY2x1ZGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2YgTW9kZWwpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuZGF0YVZhbHVlcyk7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGUgPSB0aGlzLl9vcHRpb25zLmluY2x1ZGVNYXBba2V5XTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgYWNjZXNzb3IgPSBrZXk7XG4gICAgY29uc3QgcHJpbWFyeUtleUF0dHJpYnV0ZSA9IGluY2x1ZGUubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICBjb25zdCBjaGlsZE9wdGlvbnMgPSB7XG4gICAgICBpc05ld1JlY29yZDogdGhpcy5pc05ld1JlY29yZCxcbiAgICAgIGluY2x1ZGU6IGluY2x1ZGUuaW5jbHVkZSxcbiAgICAgIGluY2x1ZGVOYW1lczogaW5jbHVkZS5pbmNsdWRlTmFtZXMsXG4gICAgICBpbmNsdWRlTWFwOiBpbmNsdWRlLmluY2x1ZGVNYXAsXG4gICAgICBpbmNsdWRlVmFsaWRhdGVkOiB0cnVlLFxuICAgICAgcmF3OiBvcHRpb25zLnJhdyxcbiAgICAgIGF0dHJpYnV0ZXM6IGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzXG4gICAgfTtcbiAgICBsZXQgaXNFbXB0eTtcbiAgICBpZiAoaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXMgPT09IHZvaWQgMCB8fCBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIGlmIChhc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgIH1cbiAgICAgICAgaXNFbXB0eSA9IHZhbHVlICYmIHZhbHVlW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBudWxsIHx8IHZhbHVlID09PSBudWxsO1xuICAgICAgICB0aGlzW2FjY2Vzc29yXSA9IHRoaXMuZGF0YVZhbHVlc1thY2Nlc3Nvcl0gPSBpc0VtcHR5ID8gbnVsbCA6IGluY2x1ZGUubW9kZWwuYnVpbGQodmFsdWUsIGNoaWxkT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0VtcHR5ID0gdmFsdWVbMF0gJiYgdmFsdWVbMF1bcHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG51bGw7XG4gICAgICAgIHRoaXNbYWNjZXNzb3JdID0gdGhpcy5kYXRhVmFsdWVzW2FjY2Vzc29yXSA9IGlzRW1wdHkgPyBbXSA6IGluY2x1ZGUubW9kZWwuYnVsa0J1aWxkKHZhbHVlLCBjaGlsZE9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBzYXZlKG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBzZWNvbmQgYXJndW1lbnQgd2FzIHJlbW92ZWQgaW4gZmF2b3Igb2YgdGhlIG9wdGlvbnMgb2JqZWN0LlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKHRoaXMuY2hhbmdlZCgpLCBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKG9wdGlvbnMuYXNzb2NpYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5yZXR1cm5pbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHByaW1hcnlLZXlOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IHByaW1hcnlLZXlBdHRyaWJ1dGUgPSBwcmltYXJ5S2V5TmFtZSAmJiB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbcHJpbWFyeUtleU5hbWVdO1xuICAgIGNvbnN0IGNyZWF0ZWRBdEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdDtcbiAgICBjb25zdCB2ZXJzaW9uQXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3ZlcnNpb25BdHRyaWJ1dGU7XG4gICAgY29uc3QgaG9vayA9IHRoaXMuaXNOZXdSZWNvcmQgPyBcIkNyZWF0ZVwiIDogXCJVcGRhdGVcIjtcbiAgICBjb25zdCB3YXNOZXdSZWNvcmQgPSB0aGlzLmlzTmV3UmVjb3JkO1xuICAgIGNvbnN0IG5vdyA9IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIGxldCB1cGRhdGVkQXRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgb3B0aW9ucy5maWVsZHMubGVuZ3RoID4gMCAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uQXR0ciAmJiBvcHRpb25zLmZpZWxkcy5sZW5ndGggPiAwICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh2ZXJzaW9uQXR0cikpIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2godmVyc2lvbkF0dHIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zaWxlbnQgPT09IHRydWUgJiYgISh0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuZ2V0KHVwZGF0ZWRBdEF0dHIsIHsgcmF3OiB0cnVlIH0pKSkge1xuICAgICAgXy5yZW1vdmUob3B0aW9ucy5maWVsZHMsICh2YWwpID0+IHZhbCA9PT0gdXBkYXRlZEF0QXR0cik7XG4gICAgICB1cGRhdGVkQXRBdHRyID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkID09PSB0cnVlKSB7XG4gICAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMoY3JlYXRlZEF0QXR0cikpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChjcmVhdGVkQXRBdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmltYXJ5S2V5QXR0cmlidXRlICYmIHByaW1hcnlLZXlBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhwcmltYXJ5S2V5TmFtZSkpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMudW5zaGlmdChwcmltYXJ5S2V5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkID09PSBmYWxzZSkge1xuICAgICAgaWYgKHByaW1hcnlLZXlOYW1lICYmIHRoaXMuZ2V0KHByaW1hcnlLZXlOYW1lLCB7IHJhdzogdHJ1ZSB9KSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhdHRlbXB0ZWQgdG8gc2F2ZSBhbiBpbnN0YW5jZSB3aXRoIG5vIHByaW1hcnkga2V5LCB0aGlzIGlzIG5vdCBhbGxvd2VkIHNpbmNlIGl0IHdvdWxkIHJlc3VsdCBpbiBhIGdsb2JhbCB1cGRhdGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGVkQXRBdHRyICYmICFvcHRpb25zLnNpbGVudCAmJiBvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgdGhpcy5kYXRhVmFsdWVzW3VwZGF0ZWRBdEF0dHJdID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkICYmIGNyZWF0ZWRBdEF0dHIgJiYgIXRoaXMuZGF0YVZhbHVlc1tjcmVhdGVkQXRBdHRyXSkge1xuICAgICAgdGhpcy5kYXRhVmFsdWVzW2NyZWF0ZWRBdEF0dHJdID0gdGhpcy5jb25zdHJ1Y3Rvci5fZ2V0RGVmYXVsdFRpbWVzdGFtcChjcmVhdGVkQXRBdHRyKSB8fCBub3c7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09IFwiZGIyXCIgJiYgdGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgdGhpcy51bmlxbm8gPSB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmFkZFVuaXF1ZUZpZWxkcyh0aGlzLmRhdGFWYWx1ZXMsIHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcywgdGhpcy51bmlxbm8pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZShvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGNvbnN0IGJlZm9yZUhvb2tWYWx1ZXMgPSBfLnBpY2sodGhpcy5kYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgICBsZXQgaWdub3JlQ2hhbmdlZCA9IF8uZGlmZmVyZW5jZSh0aGlzLmNoYW5nZWQoKSwgb3B0aW9ucy5maWVsZHMpO1xuICAgICAgbGV0IGhvb2tDaGFuZ2VkO1xuICAgICAgbGV0IGFmdGVySG9va1ZhbHVlcztcbiAgICAgIGlmICh1cGRhdGVkQXRBdHRyICYmIG9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICAgIGlnbm9yZUNoYW5nZWQgPSBfLndpdGhvdXQoaWdub3JlQ2hhbmdlZCwgdXBkYXRlZEF0QXR0cik7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKGBiZWZvcmUke2hvb2t9YCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5kZWZhdWx0RmllbGRzICYmICF0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIGFmdGVySG9va1ZhbHVlcyA9IF8ucGljayh0aGlzLmRhdGFWYWx1ZXMsIF8uZGlmZmVyZW5jZSh0aGlzLmNoYW5nZWQoKSwgaWdub3JlQ2hhbmdlZCkpO1xuICAgICAgICBob29rQ2hhbmdlZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhZnRlckhvb2tWYWx1ZXMpKSB7XG4gICAgICAgICAgaWYgKGFmdGVySG9va1ZhbHVlc1trZXldICE9PSBiZWZvcmVIb29rVmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIGhvb2tDaGFuZ2VkLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaXEob3B0aW9ucy5maWVsZHMuY29uY2F0KGhvb2tDaGFuZ2VkKSk7XG4gICAgICB9XG4gICAgICBpZiAoaG9va0NoYW5nZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmFsaWRhdGUpIHtcbiAgICAgICAgICBvcHRpb25zLnNraXAgPSBfLmRpZmZlcmVuY2UoT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSwgaG9va0NoYW5nZWQpO1xuICAgICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc2tpcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWVsZHMubGVuZ3RoICYmIHRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZS5sZW5ndGgpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX29wdGlvbnMuaW5jbHVkZS5maWx0ZXIoKGluY2x1ZGUpID0+IGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8pLm1hcChhc3luYyAoaW5jbHVkZSkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0KGluY2x1ZGUuYXMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSkub21pdChbXCJhc3NvY2lhdGlvblwiXSkuZGVmYXVsdHMoe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgICBwYXJlbnRSZWNvcmQ6IHRoaXNcbiAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IHRoaXNbaW5jbHVkZS5hc3NvY2lhdGlvbi5hY2Nlc3NvcnMuc2V0XShpbnN0YW5jZSwgeyBzYXZlOiBmYWxzZSwgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nIH0pO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByZWFsRmllbGRzID0gb3B0aW9ucy5maWVsZHMuZmlsdGVyKChmaWVsZCkgPT4gIXRoaXMuY29uc3RydWN0b3IuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhmaWVsZCkpO1xuICAgIGlmICghcmVhbEZpZWxkcy5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoIXRoaXMuY2hhbmdlZCgpICYmICF0aGlzLmlzTmV3UmVjb3JkKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmVyc2lvbkZpZWxkTmFtZSA9IF8uZ2V0KHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1t2ZXJzaW9uQXR0cl0sIFwiZmllbGRcIikgfHwgdmVyc2lvbkF0dHI7XG4gICAgY29uc3QgdmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKHRoaXMuZGF0YVZhbHVlcywgb3B0aW9ucy5maWVsZHMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIGxldCBxdWVyeSA9IG51bGw7XG4gICAgbGV0IGFyZ3MgPSBbXTtcbiAgICBsZXQgd2hlcmU7XG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgIHF1ZXJ5ID0gXCJpbnNlcnRcIjtcbiAgICAgIGFyZ3MgPSBbdGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlcywgb3B0aW9uc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlID0gdGhpcy53aGVyZSh0cnVlKTtcbiAgICAgIGlmICh2ZXJzaW9uQXR0cikge1xuICAgICAgICB2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV0gPSBwYXJzZUludCh2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV0sIDEwKSArIDE7XG4gICAgICB9XG4gICAgICBxdWVyeSA9IFwidXBkYXRlXCI7XG4gICAgICBhcmdzID0gW3RoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB2YWx1ZXMsIHdoZXJlLCBvcHRpb25zXTtcbiAgICB9XG4gICAgY29uc3QgW3Jlc3VsdCwgcm93c1VwZGF0ZWRdID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5xdWVyeUludGVyZmFjZVtxdWVyeV0oLi4uYXJncyk7XG4gICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICBpZiAocm93c1VwZGF0ZWQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuT3B0aW1pc3RpY0xvY2tFcnJvcih7XG4gICAgICAgICAgbW9kZWxOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgIHdoZXJlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmRhdGFWYWx1ZXNbdmVyc2lvbkF0dHJdID0gdmFsdWVzW3ZlcnNpb25GaWVsZE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJiB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSAhPT0gdm9pZCAwICYmIHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAhPT0gYXR0cikge1xuICAgICAgICB2YWx1ZXNbYXR0cl0gPSB2YWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXTtcbiAgICAgICAgZGVsZXRlIHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgcmVzdWx0LmRhdGFWYWx1ZXMpO1xuICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LmRhdGFWYWx1ZXMsIHZhbHVlcyk7XG4gICAgaWYgKHdhc05ld1JlY29yZCAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fb3B0aW9ucy5pbmNsdWRlLmZpbHRlcigoaW5jbHVkZSkgPT4gIShpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvIHx8IGluY2x1ZGUucGFyZW50ICYmIGluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkpLm1hcChhc3luYyAoaW5jbHVkZSkgPT4ge1xuICAgICAgICBsZXQgaW5zdGFuY2VzID0gdGhpcy5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2VzKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpXG4gICAgICAgICAgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG4gICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpLm9taXQoW1wiYXNzb2NpYXRpb25cIl0pLmRlZmF1bHRzKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbjogb3B0aW9ucy50cmFuc2FjdGlvbixcbiAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgICAgcGFyZW50UmVjb3JkOiB0aGlzXG4gICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSB7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlczAgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXldOiB0aGlzLmdldCh0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLFxuICAgICAgICAgICAgICBbaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleV06IGluc3RhbmNlLmdldChpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KVxuICAgICAgICAgICAgfSwgaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV0pIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5rZXlzKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5fYXV0b0dlbmVyYXRlZCB8fCBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXkgfHwgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleSB8fCB0eXBlb2YgaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzMFthdHRyXSA9IGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWwuY3JlYXRlKHZhbHVlczAsIGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSwgdGhpcy5nZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5zb3VyY2VLZXkgfHwgdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKTtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhgYWZ0ZXIke2hvb2t9YCwgcmVzdWx0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiBvcHRpb25zLmZpZWxkcykge1xuICAgICAgcmVzdWx0Ll9wcmV2aW91c0RhdGFWYWx1ZXNbZmllbGRdID0gcmVzdWx0LmRhdGFWYWx1ZXNbZmllbGRdO1xuICAgICAgdGhpcy5jaGFuZ2VkKGZpZWxkLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuaXNOZXdSZWNvcmQgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHJlbG9hZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKHtcbiAgICAgIHdoZXJlOiB0aGlzLndoZXJlKClcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICBpbmNsdWRlOiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgfHwgdm9pZCAwXG4gICAgfSk7XG4gICAgY29uc3QgcmVsb2FkZWQgPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLmZpbmRPbmUob3B0aW9ucyk7XG4gICAgaWYgKCFyZWxvYWRlZCkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5JbnN0YW5jZUVycm9yKFwiSW5zdGFuY2UgY291bGQgbm90IGJlIHJlbG9hZGVkIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QgYW55bW9yZSAoZmluZCBjYWxsIHJldHVybmVkIG51bGwpXCIpO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zID0gcmVsb2FkZWQuX29wdGlvbnM7XG4gICAgdGhpcy5zZXQocmVsb2FkZWQuZGF0YVZhbHVlcywge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcmVzZXQ6ICFvcHRpb25zLmF0dHJpYnV0ZXNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBJbnN0YW5jZVZhbGlkYXRvcih0aGlzLCBvcHRpb25zKS52YWxpZGF0ZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YWx1ZXMgPSBfLm9taXRCeSh2YWx1ZXMsICh2YWx1ZSkgPT4gdmFsdWUgPT09IHZvaWQgMCk7XG4gICAgY29uc3QgY2hhbmdlZEJlZm9yZSA9IHRoaXMuY2hhbmdlZCgpIHx8IFtdO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKVxuICAgICAgb3B0aW9ucyA9IHsgZmllbGRzOiBvcHRpb25zIH07XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNldE9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgc2V0T3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgdGhpcy5zZXQodmFsdWVzLCBzZXRPcHRpb25zKTtcbiAgICBjb25zdCBzaWRlRWZmZWN0cyA9IF8ud2l0aG91dCh0aGlzLmNoYW5nZWQoKSwgLi4uY2hhbmdlZEJlZm9yZSk7XG4gICAgY29uc3QgZmllbGRzID0gXy51bmlvbihPYmplY3Qua2V5cyh2YWx1ZXMpLCBzaWRlRWZmZWN0cyk7XG4gICAgaWYgKCFvcHRpb25zLmZpZWxkcykge1xuICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLmludGVyc2VjdGlvbihmaWVsZHMsIHRoaXMuY2hhbmdlZCgpKTtcbiAgICAgIG9wdGlvbnMuZGVmYXVsdEZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zYXZlKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob29rczogdHJ1ZSxcbiAgICAgIGZvcmNlOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoXCJiZWZvcmVEZXN0cm95XCIsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCB3aGVyZSA9IHRoaXMud2hlcmUodHJ1ZSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgb3B0aW9ucy5mb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdDtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmdldERhdGFWYWx1ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGNvbnN0IHVuZGVmaW5lZE9yTnVsbCA9IGN1cnJlbnRWYWx1ZSA9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSA9PSBudWxsO1xuICAgICAgaWYgKHVuZGVmaW5lZE9yTnVsbCB8fCBfLmlzRXF1YWwoY3VycmVudFZhbHVlLCBkZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YVZhbHVlKGF0dHJpYnV0ZU5hbWUsIG5ldyBEYXRlKCkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYXZlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGhvb2tzOiBmYWxzZSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IucXVlcnlJbnRlcmZhY2UuZGVsZXRlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCB3aGVyZSwgX19zcHJlYWRWYWx1ZXMoeyB0eXBlOiBRdWVyeVR5cGVzLkRFTEVURSwgbGltaXQ6IG51bGwgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhcImFmdGVyRGVzdHJveVwiLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1NvZnREZWxldGVkKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGlzIG5vdCBwYXJhbm9pZFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIGNvbnN0IGRlbGV0ZWRBdCA9IHRoaXMuZ2V0KHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KSB8fCBudWxsO1xuICAgIGNvbnN0IGlzU2V0ID0gZGVsZXRlZEF0ICE9PSBkZWZhdWx0VmFsdWU7XG4gICAgcmV0dXJuIGlzU2V0O1xuICB9XG4gIGFzeW5jIHJlc3RvcmUob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBpcyBub3QgcGFyYW5vaWRcIik7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgZm9yY2U6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhcImJlZm9yZVJlc3RvcmVcIiwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgdGhpcy5zZXREYXRhVmFsdWUoZGVsZXRlZEF0Q29sLCBkZWxldGVkQXREZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2F2ZShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBob29rczogZmFsc2UsIG9taXROdWxsOiBmYWxzZSB9KSk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoXCJhZnRlclJlc3RvcmVcIiwgdGhpcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gdGhpcy53aGVyZSgpO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy53aGVyZSA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLndoZXJlKSwgaWRlbnRpZmllcik7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IHRoaXM7XG4gICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5pbmNyZW1lbnQoZmllbGRzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBkZWNyZW1lbnQoZmllbGRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5jcmVtZW50KGZpZWxkcywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBieTogMVxuICAgIH0sIG9wdGlvbnMpLCB7XG4gICAgICBpbmNyZW1lbnQ6IGZhbHNlXG4gICAgfSkpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghb3RoZXIgfHwgIW90aGVyLmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZXMuZXZlcnkoKGF0dHJpYnV0ZSkgPT4gdGhpcy5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gb3RoZXIuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkpO1xuICB9XG4gIGVxdWFsc09uZU9mKG90aGVycykge1xuICAgIHJldHVybiBvdGhlcnMuc29tZSgob3RoZXIpID0+IHRoaXMuZXF1YWxzKG90aGVyKSk7XG4gIH1cbiAgc2V0VmFsaWRhdG9ycyhhdHRyaWJ1dGUsIHZhbGlkYXRvcnMpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnNbYXR0cmlidXRlXSA9IHZhbGlkYXRvcnM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBfLmNsb25lRGVlcCh0aGlzLmdldCh7XG4gICAgICBwbGFpbjogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuICBzdGF0aWMgaGFzTWFueSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgfVxuICBzdGF0aWMgYmVsb25nc1RvTWFueSh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgfVxuICBzdGF0aWMgaGFzT25lKHRhcmdldCwgb3B0aW9ucykge1xuICB9XG4gIHN0YXRpYyBiZWxvbmdzVG8odGFyZ2V0LCBvcHRpb25zKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucGFja0FuZCh3aGVyZSkge1xuICBpZiAoIV8uaXNPYmplY3Qod2hlcmUpKSB7XG4gICAgcmV0dXJuIHdoZXJlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBVdGlscy5nZXRDb21wbGV4S2V5cyh3aGVyZSk7XG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoa2V5cy5sZW5ndGggIT09IDEgfHwga2V5c1swXSAhPT0gT3AuYW5kKSB7XG4gICAgcmV0dXJuIHdoZXJlO1xuICB9XG4gIGNvbnN0IGFuZFBhcnRzID0gd2hlcmVbT3AuYW5kXTtcbiAgcmV0dXJuIGFuZFBhcnRzO1xufVxuZnVuY3Rpb24gY29tYmluZVdoZXJlc1dpdGhBbmQod2hlcmVBLCB3aGVyZUIpIHtcbiAgY29uc3QgdW5wYWNrZWRBID0gdW5wYWNrQW5kKHdoZXJlQSk7XG4gIGlmICh1bnBhY2tlZEEgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB3aGVyZUI7XG4gIH1cbiAgY29uc3QgdW5wYWNrZWRCID0gdW5wYWNrQW5kKHdoZXJlQik7XG4gIGlmICh1bnBhY2tlZEIgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB3aGVyZUE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBbT3AuYW5kXTogXy5mbGF0dGVuKFt1bnBhY2tlZEEsIHVucGFja2VkQl0pXG4gIH07XG59XG5PYmplY3QuYXNzaWduKE1vZGVsLCBhc3NvY2lhdGlvbnNNaXhpbik7XG5Ib29rcy5hcHBseVRvKE1vZGVsLCB0cnVlKTtcbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/operators.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/operators.js ***!
  \*************************************************/
/***/ ((module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  Op: () => Op,\n  default: () => operators_default\n});\nconst Op = {\n  eq: Symbol.for(\"eq\"),\n  ne: Symbol.for(\"ne\"),\n  gte: Symbol.for(\"gte\"),\n  gt: Symbol.for(\"gt\"),\n  lte: Symbol.for(\"lte\"),\n  lt: Symbol.for(\"lt\"),\n  not: Symbol.for(\"not\"),\n  is: Symbol.for(\"is\"),\n  in: Symbol.for(\"in\"),\n  notIn: Symbol.for(\"notIn\"),\n  like: Symbol.for(\"like\"),\n  notLike: Symbol.for(\"notLike\"),\n  iLike: Symbol.for(\"iLike\"),\n  notILike: Symbol.for(\"notILike\"),\n  startsWith: Symbol.for(\"startsWith\"),\n  endsWith: Symbol.for(\"endsWith\"),\n  substring: Symbol.for(\"substring\"),\n  regexp: Symbol.for(\"regexp\"),\n  notRegexp: Symbol.for(\"notRegexp\"),\n  iRegexp: Symbol.for(\"iRegexp\"),\n  notIRegexp: Symbol.for(\"notIRegexp\"),\n  between: Symbol.for(\"between\"),\n  notBetween: Symbol.for(\"notBetween\"),\n  overlap: Symbol.for(\"overlap\"),\n  contains: Symbol.for(\"contains\"),\n  contained: Symbol.for(\"contained\"),\n  adjacent: Symbol.for(\"adjacent\"),\n  strictLeft: Symbol.for(\"strictLeft\"),\n  strictRight: Symbol.for(\"strictRight\"),\n  noExtendRight: Symbol.for(\"noExtendRight\"),\n  noExtendLeft: Symbol.for(\"noExtendLeft\"),\n  and: Symbol.for(\"and\"),\n  or: Symbol.for(\"or\"),\n  any: Symbol.for(\"any\"),\n  all: Symbol.for(\"all\"),\n  values: Symbol.for(\"values\"),\n  col: Symbol.for(\"col\"),\n  placeholder: Symbol.for(\"placeholder\"),\n  join: Symbol.for(\"join\"),\n  match: Symbol.for(\"match\")\n};\nvar operators_default = Op;\nmodule.exports = Op;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9vcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL29wZXJhdG9ycy5qcz9hYTIyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3A6ICgpID0+IE9wLFxuICBkZWZhdWx0OiAoKSA9PiBvcGVyYXRvcnNfZGVmYXVsdFxufSk7XG5jb25zdCBPcCA9IHtcbiAgZXE6IFN5bWJvbC5mb3IoXCJlcVwiKSxcbiAgbmU6IFN5bWJvbC5mb3IoXCJuZVwiKSxcbiAgZ3RlOiBTeW1ib2wuZm9yKFwiZ3RlXCIpLFxuICBndDogU3ltYm9sLmZvcihcImd0XCIpLFxuICBsdGU6IFN5bWJvbC5mb3IoXCJsdGVcIiksXG4gIGx0OiBTeW1ib2wuZm9yKFwibHRcIiksXG4gIG5vdDogU3ltYm9sLmZvcihcIm5vdFwiKSxcbiAgaXM6IFN5bWJvbC5mb3IoXCJpc1wiKSxcbiAgaW46IFN5bWJvbC5mb3IoXCJpblwiKSxcbiAgbm90SW46IFN5bWJvbC5mb3IoXCJub3RJblwiKSxcbiAgbGlrZTogU3ltYm9sLmZvcihcImxpa2VcIiksXG4gIG5vdExpa2U6IFN5bWJvbC5mb3IoXCJub3RMaWtlXCIpLFxuICBpTGlrZTogU3ltYm9sLmZvcihcImlMaWtlXCIpLFxuICBub3RJTGlrZTogU3ltYm9sLmZvcihcIm5vdElMaWtlXCIpLFxuICBzdGFydHNXaXRoOiBTeW1ib2wuZm9yKFwic3RhcnRzV2l0aFwiKSxcbiAgZW5kc1dpdGg6IFN5bWJvbC5mb3IoXCJlbmRzV2l0aFwiKSxcbiAgc3Vic3RyaW5nOiBTeW1ib2wuZm9yKFwic3Vic3RyaW5nXCIpLFxuICByZWdleHA6IFN5bWJvbC5mb3IoXCJyZWdleHBcIiksXG4gIG5vdFJlZ2V4cDogU3ltYm9sLmZvcihcIm5vdFJlZ2V4cFwiKSxcbiAgaVJlZ2V4cDogU3ltYm9sLmZvcihcImlSZWdleHBcIiksXG4gIG5vdElSZWdleHA6IFN5bWJvbC5mb3IoXCJub3RJUmVnZXhwXCIpLFxuICBiZXR3ZWVuOiBTeW1ib2wuZm9yKFwiYmV0d2VlblwiKSxcbiAgbm90QmV0d2VlbjogU3ltYm9sLmZvcihcIm5vdEJldHdlZW5cIiksXG4gIG92ZXJsYXA6IFN5bWJvbC5mb3IoXCJvdmVybGFwXCIpLFxuICBjb250YWluczogU3ltYm9sLmZvcihcImNvbnRhaW5zXCIpLFxuICBjb250YWluZWQ6IFN5bWJvbC5mb3IoXCJjb250YWluZWRcIiksXG4gIGFkamFjZW50OiBTeW1ib2wuZm9yKFwiYWRqYWNlbnRcIiksXG4gIHN0cmljdExlZnQ6IFN5bWJvbC5mb3IoXCJzdHJpY3RMZWZ0XCIpLFxuICBzdHJpY3RSaWdodDogU3ltYm9sLmZvcihcInN0cmljdFJpZ2h0XCIpLFxuICBub0V4dGVuZFJpZ2h0OiBTeW1ib2wuZm9yKFwibm9FeHRlbmRSaWdodFwiKSxcbiAgbm9FeHRlbmRMZWZ0OiBTeW1ib2wuZm9yKFwibm9FeHRlbmRMZWZ0XCIpLFxuICBhbmQ6IFN5bWJvbC5mb3IoXCJhbmRcIiksXG4gIG9yOiBTeW1ib2wuZm9yKFwib3JcIiksXG4gIGFueTogU3ltYm9sLmZvcihcImFueVwiKSxcbiAgYWxsOiBTeW1ib2wuZm9yKFwiYWxsXCIpLFxuICB2YWx1ZXM6IFN5bWJvbC5mb3IoXCJ2YWx1ZXNcIiksXG4gIGNvbDogU3ltYm9sLmZvcihcImNvbFwiKSxcbiAgcGxhY2Vob2xkZXI6IFN5bWJvbC5mb3IoXCJwbGFjZWhvbGRlclwiKSxcbiAgam9pbjogU3ltYm9sLmZvcihcImpvaW5cIiksXG4gIG1hdGNoOiBTeW1ib2wuZm9yKFwibWF0Y2hcIilcbn07XG52YXIgb3BlcmF0b3JzX2RlZmF1bHQgPSBPcDtcbm1vZHVsZS5leHBvcnRzID0gT3A7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVyYXRvcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/operators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/query-types.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/query-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst QueryTypes = module.exports = {\n  SELECT: \"SELECT\",\n  INSERT: \"INSERT\",\n  UPDATE: \"UPDATE\",\n  BULKUPDATE: \"BULKUPDATE\",\n  BULKDELETE: \"BULKDELETE\",\n  DELETE: \"DELETE\",\n  UPSERT: \"UPSERT\",\n  VERSION: \"VERSION\",\n  SHOWTABLES: \"SHOWTABLES\",\n  SHOWINDEXES: \"SHOWINDEXES\",\n  DESCRIBE: \"DESCRIBE\",\n  RAW: \"RAW\",\n  FOREIGNKEYS: \"FOREIGNKEYS\",\n  SHOWCONSTRAINTS: \"SHOWCONSTRAINTS\"\n};\n//# sourceMappingURL=query-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9xdWVyeS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9xdWVyeS10eXBlcy5qcz84MjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgUXVlcnlUeXBlcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBTRUxFQ1Q6IFwiU0VMRUNUXCIsXG4gIElOU0VSVDogXCJJTlNFUlRcIixcbiAgVVBEQVRFOiBcIlVQREFURVwiLFxuICBCVUxLVVBEQVRFOiBcIkJVTEtVUERBVEVcIixcbiAgQlVMS0RFTEVURTogXCJCVUxLREVMRVRFXCIsXG4gIERFTEVURTogXCJERUxFVEVcIixcbiAgVVBTRVJUOiBcIlVQU0VSVFwiLFxuICBWRVJTSU9OOiBcIlZFUlNJT05cIixcbiAgU0hPV1RBQkxFUzogXCJTSE9XVEFCTEVTXCIsXG4gIFNIT1dJTkRFWEVTOiBcIlNIT1dJTkRFWEVTXCIsXG4gIERFU0NSSUJFOiBcIkRFU0NSSUJFXCIsXG4gIFJBVzogXCJSQVdcIixcbiAgRk9SRUlHTktFWVM6IFwiRk9SRUlHTktFWVNcIixcbiAgU0hPV0NPTlNUUkFJTlRTOiBcIlNIT1dDT05TVFJBSU5UU1wiXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/query-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/sequelize.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/sequelize.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst pgConnectionString = __webpack_require__(/*! pg-connection-string */ \"(rsc)/./node_modules/pg-connection-string/index.js\");\nconst retry = (__webpack_require__(/*! retry-as-promised */ \"(rsc)/./node_modules/retry-as-promised/dist/index.js\")[\"default\"]);\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Model = __webpack_require__(/*! ./model */ \"(rsc)/./node_modules/sequelize/lib/model.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Deferrable = __webpack_require__(/*! ./deferrable */ \"(rsc)/./node_modules/sequelize/lib/deferrable.js\");\nconst ModelManager = __webpack_require__(/*! ./model-manager */ \"(rsc)/./node_modules/sequelize/lib/model-manager.js\");\nconst Transaction = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst TableHints = __webpack_require__(/*! ./table-hints */ \"(rsc)/./node_modules/sequelize/lib/table-hints.js\");\nconst IndexHints = __webpack_require__(/*! ./index-hints */ \"(rsc)/./node_modules/sequelize/lib/index-hints.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(rsc)/./node_modules/sequelize/lib/hooks.js\");\nconst Association = __webpack_require__(/*! ./associations/index */ \"(rsc)/./node_modules/sequelize/lib/associations/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst Op = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst deprecations = __webpack_require__(/*! ./utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst { QueryInterface } = __webpack_require__(/*! ./dialects/abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { BelongsTo } = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasOne = __webpack_require__(/*! ./associations/has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst { BelongsToMany } = __webpack_require__(/*! ./associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst { HasMany } = __webpack_require__(/*! ./associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst { withSqliteForeignKeysOff } = __webpack_require__(/*! ./dialects/sqlite/sqlite-utils */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\");\nconst { injectReplacements } = __webpack_require__(/*! ./utils/sql */ \"(rsc)/./node_modules/sequelize/lib/utils/sql.js\");\nclass Sequelize {\n  constructor(database, username, password, options) {\n    let config;\n    if (arguments.length === 1 && typeof database === \"object\") {\n      options = database;\n      config = _.pick(options, \"host\", \"port\", \"database\", \"username\", \"password\");\n    } else if (arguments.length === 1 && typeof database === \"string\" || arguments.length === 2 && typeof username === \"object\") {\n      config = {};\n      options = username || {};\n      const urlParts = url.parse(arguments[0], true);\n      options.dialect = urlParts.protocol.replace(/:$/, \"\");\n      options.host = urlParts.hostname;\n      if (options.dialect === \"sqlite\" && urlParts.pathname && !urlParts.pathname.startsWith(\"/:memory\")) {\n        const storagePath = path.join(options.host, urlParts.pathname);\n        options.storage = path.resolve(options.storage || storagePath);\n      }\n      if (urlParts.pathname) {\n        config.database = urlParts.pathname.replace(/^\\//, \"\");\n      }\n      if (urlParts.port) {\n        options.port = urlParts.port;\n      }\n      if (urlParts.auth) {\n        const authParts = urlParts.auth.split(\":\");\n        config.username = authParts[0];\n        if (authParts.length > 1)\n          config.password = authParts.slice(1).join(\":\");\n      }\n      if (urlParts.query) {\n        if (urlParts.query.host) {\n          options.host = urlParts.query.host;\n        }\n        if (options.dialectOptions) {\n          Object.assign(options.dialectOptions, urlParts.query);\n        } else {\n          options.dialectOptions = urlParts.query;\n          if (urlParts.query.options) {\n            try {\n              const o = JSON.parse(urlParts.query.options);\n              options.dialectOptions.options = o;\n            } catch (e) {\n            }\n          }\n        }\n      }\n      if ([\"postgres\", \"postgresql\"].includes(options.dialect)) {\n        Object.assign(options.dialectOptions, pgConnectionString.parse(arguments[0]));\n      }\n    } else {\n      options = options || {};\n      config = { database, username, password };\n    }\n    Sequelize.runHooks(\"beforeInit\", config, options);\n    this.options = __spreadValues({\n      dialect: null,\n      dialectModule: null,\n      dialectModulePath: null,\n      host: \"localhost\",\n      protocol: \"tcp\",\n      define: {},\n      query: {},\n      sync: {},\n      timezone: \"+00:00\",\n      standardConformingStrings: true,\n      logging: console.log,\n      omitNull: false,\n      native: false,\n      replication: false,\n      ssl: void 0,\n      pool: {},\n      quoteIdentifiers: true,\n      hooks: {},\n      retry: {\n        max: 5,\n        match: [\n          \"SQLITE_BUSY: database is locked\"\n        ]\n      },\n      transactionType: Transaction.TYPES.DEFERRED,\n      isolationLevel: null,\n      databaseVersion: 0,\n      typeValidation: false,\n      benchmark: false,\n      minifyAliases: false,\n      logQueryParameters: false,\n      attributeBehavior: \"throw\"\n    }, options);\n    if (!this.options.dialect) {\n      throw new Error(\"Dialect needs to be explicitly supplied as of v4.0.0\");\n    }\n    if (this.options.dialect === \"postgresql\") {\n      this.options.dialect = \"postgres\";\n    }\n    if (this.options.dialect === \"sqlite\" && this.options.timezone !== \"+00:00\") {\n      throw new Error(\"Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.\");\n    }\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n    this._setupHooks(options.hooks);\n    this.config = {\n      database: config.database || this.options.database,\n      username: config.username || this.options.username,\n      password: config.password || this.options.password || null,\n      host: config.host || this.options.host,\n      port: config.port || this.options.port,\n      pool: this.options.pool,\n      protocol: this.options.protocol,\n      native: this.options.native,\n      ssl: this.options.ssl,\n      replication: this.options.replication,\n      dialectModule: this.options.dialectModule,\n      dialectModulePath: this.options.dialectModulePath,\n      keepDefaultTimezone: this.options.keepDefaultTimezone,\n      dialectOptions: this.options.dialectOptions\n    };\n    let Dialect;\n    switch (this.getDialect()) {\n      case \"mariadb\":\n        Dialect = __webpack_require__(/*! ./dialects/mariadb */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js\");\n        break;\n      case \"mssql\":\n        Dialect = __webpack_require__(/*! ./dialects/mssql */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js\");\n        break;\n      case \"mysql\":\n        Dialect = __webpack_require__(/*! ./dialects/mysql */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js\");\n        break;\n      case \"oracle\":\n        Dialect = __webpack_require__(/*! ./dialects/oracle */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js\");\n        break;\n      case \"postgres\":\n        Dialect = __webpack_require__(/*! ./dialects/postgres */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js\");\n        break;\n      case \"sqlite\":\n        Dialect = __webpack_require__(/*! ./dialects/sqlite */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js\");\n        break;\n      case \"db2\":\n        Dialect = __webpack_require__(/*! ./dialects/db2 */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js\");\n        break;\n      case \"snowflake\":\n        Dialect = __webpack_require__(/*! ./dialects/snowflake */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js\");\n        break;\n      default:\n        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, oracle, postgres, db2 and sqlite.`);\n    }\n    this.dialect = new Dialect(this);\n    this.dialect.queryGenerator.typeValidation = options.typeValidation;\n    if (_.isPlainObject(this.options.operatorsAliases)) {\n      deprecations.noStringOperators();\n      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);\n    } else if (typeof this.options.operatorsAliases === \"boolean\") {\n      deprecations.noBoolOperatorAliases();\n    }\n    this.queryInterface = this.dialect.queryInterface;\n    this.models = {};\n    this.modelManager = new ModelManager(this);\n    this.connectionManager = this.dialect.connectionManager;\n    Sequelize.runHooks(\"afterInit\", this);\n  }\n  refreshTypes() {\n    this.connectionManager.refreshTypeParser(DataTypes);\n  }\n  getDialect() {\n    return this.options.dialect;\n  }\n  getDatabaseName() {\n    return this.config.database;\n  }\n  getQueryInterface() {\n    return this.queryInterface;\n  }\n  define(modelName, attributes, options = {}) {\n    options.modelName = modelName;\n    options.sequelize = this;\n    const model = class extends Model {\n    };\n    model.init(attributes, options);\n    return model;\n  }\n  model(modelName) {\n    if (!this.isDefined(modelName)) {\n      throw new Error(`${modelName} has not been defined`);\n    }\n    return this.modelManager.getModel(modelName);\n  }\n  isDefined(modelName) {\n    return !!this.modelManager.models.find((model) => model.name === modelName);\n  }\n  async query(sql, options) {\n    options = __spreadValues(__spreadValues({}, this.options.query), options);\n    if (options.instance && !options.model) {\n      options.model = options.instance.constructor;\n    }\n    if (!options.instance && !options.model) {\n      options.raw = true;\n    }\n    if (options.mapToModel) {\n      options.fieldMap = _.get(options, \"model.fieldAttributeMap\", {});\n    }\n    options = _.defaults(options, {\n      logging: Object.prototype.hasOwnProperty.call(this.options, \"logging\") ? this.options.logging : console.log,\n      searchPath: Object.prototype.hasOwnProperty.call(this.options, \"searchPath\") ? this.options.searchPath : \"DEFAULT\"\n    });\n    if (!options.type) {\n      if (options.model || options.nest || options.plain) {\n        options.type = QueryTypes.SELECT;\n      } else {\n        options.type = QueryTypes.RAW;\n      }\n    }\n    if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {\n      delete options.searchPath;\n    } else if (!options.searchPath) {\n      options.searchPath = \"DEFAULT\";\n    }\n    if (typeof sql === \"object\") {\n      if (sql.values !== void 0) {\n        if (options.replacements !== void 0) {\n          throw new Error(\"Both `sql.values` and `options.replacements` cannot be set at the same time\");\n        }\n        options.replacements = sql.values;\n      }\n      if (sql.bind !== void 0) {\n        if (options.bind !== void 0) {\n          throw new Error(\"Both `sql.bind` and `options.bind` cannot be set at the same time\");\n        }\n        options.bind = sql.bind;\n      }\n      if (sql.query !== void 0) {\n        sql = sql.query;\n      }\n    }\n    sql = sql.trim();\n    if (options.replacements && options.bind) {\n      throw new Error(\"Both `replacements` and `bind` cannot be set at the same time\");\n    }\n    if (options.replacements) {\n      sql = injectReplacements(sql, this.dialect, options.replacements);\n    }\n    let bindParameters;\n    if (options.bind) {\n      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n    }\n    const checkTransaction = () => {\n      if (options.transaction && options.transaction.finished && !options.completesTransaction) {\n        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);\n        error.sql = sql;\n        throw error;\n      }\n    };\n    const retryOptions = __spreadValues(__spreadValues({}, this.options.retry), options.retry);\n    return retry(async () => {\n      if (options.transaction === void 0 && Sequelize._cls) {\n        options.transaction = Sequelize._cls.get(\"transaction\");\n      }\n      checkTransaction();\n      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));\n      if (this.options.dialect === \"db2\" && options.alter) {\n        if (options.alter.drop === false) {\n          connection.dropTable = false;\n        }\n      }\n      const query = new this.dialect.Query(connection, this, options);\n      try {\n        await this.runHooks(\"beforeQuery\", options, query);\n        checkTransaction();\n        return await query.run(sql, bindParameters);\n      } finally {\n        await this.runHooks(\"afterQuery\", options, query);\n        if (!options.transaction) {\n          this.connectionManager.releaseConnection(connection);\n        }\n      }\n    }, retryOptions);\n  }\n  async set(variables, options) {\n    options = __spreadValues(__spreadValues({}, this.options.set), typeof options === \"object\" && options);\n    if (![\"mysql\", \"mariadb\"].includes(this.options.dialect)) {\n      throw new Error(\"sequelize.set is only supported for mysql or mariadb\");\n    }\n    if (!options.transaction || !(options.transaction instanceof Transaction)) {\n      throw new TypeError(\"options.transaction is required\");\n    }\n    options.raw = true;\n    options.plain = true;\n    options.type = \"SET\";\n    const query = `SET ${_.map(variables, (v, k) => `@${k} := ${typeof v === \"string\" ? `\"${v}\"` : v}`).join(\", \")}`;\n    return await this.query(query, options);\n  }\n  escape(value) {\n    return this.dialect.queryGenerator.escape(value);\n  }\n  async createSchema(schema, options) {\n    return await this.getQueryInterface().createSchema(schema, options);\n  }\n  async showAllSchemas(options) {\n    return await this.getQueryInterface().showAllSchemas(options);\n  }\n  async dropSchema(schema, options) {\n    return await this.getQueryInterface().dropSchema(schema, options);\n  }\n  async dropAllSchemas(options) {\n    return await this.getQueryInterface().dropAllSchemas(options);\n  }\n  async sync(options) {\n    options = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.options), this.options.sync), options), {\n      hooks: options ? options.hooks !== false : true\n    });\n    if (options.match) {\n      if (!options.match.test(this.config.database)) {\n        throw new Error(`Database \"${this.config.database}\" does not match sync match parameter \"${options.match}\"`);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkSync\", options);\n    }\n    if (options.force) {\n      await this.drop(options);\n    }\n    if (this.modelManager.models.length === 0) {\n      await this.authenticate(options);\n    } else {\n      const models = this.modelManager.getModelsTopoSortedByForeignKey();\n      if (models == null) {\n        return this._syncModelsWithCyclicReferences(options);\n      }\n      models.reverse();\n      for (const model of models) {\n        await model.sync(options);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkSync\", options);\n    }\n    return this;\n  }\n  async _syncModelsWithCyclicReferences(options) {\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.sync(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { withoutForeignKeyConstraints: true }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { force: false, alter: true }));\n    }\n  }\n  async truncate(options) {\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    const models = sortedModels || this.modelManager.models;\n    const hasCyclicDependencies = sortedModels == null;\n    if (hasCyclicDependencies && (!options || !options.cascade)) {\n      throw new Error('Sequelize#truncate: Some of your models have cyclic references (foreign keys). You need to use the \"cascade\" option to be able to delete rows from models that have cyclic references.');\n    }\n    if (hasCyclicDependencies && this.dialect.name === \"sqlite\") {\n      return withSqliteForeignKeysOff(this, options, async () => {\n        await Promise.all(models.map((model) => model.truncate(options)));\n      });\n    }\n    if (options && options.cascade) {\n      for (const model of models)\n        await model.truncate(options);\n    } else {\n      await Promise.all(models.map((model) => model.truncate(options)));\n    }\n  }\n  async drop(options) {\n    if (options && options.cascade) {\n      for (const model of this.modelManager.models) {\n        await model.drop(options);\n      }\n    }\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    if (sortedModels) {\n      for (const model of sortedModels) {\n        await model.drop(options);\n      }\n    }\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.drop(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      const tableName = model.getTableName();\n      const foreignKeys = await this.queryInterface.getForeignKeyReferencesForTable(tableName, options);\n      await Promise.all(foreignKeys.map((foreignKey) => {\n        return this.queryInterface.removeConstraint(tableName, foreignKey.constraintName, options);\n      }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.drop(options);\n    }\n  }\n  async authenticate(options) {\n    options = __spreadValues({\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    }, options);\n    await this.query(this.dialect.queryGenerator.authTestQuery(), options);\n    return;\n  }\n  async databaseVersion(options) {\n    return await this.getQueryInterface().databaseVersion(options);\n  }\n  random() {\n    if ([\"postgres\", \"sqlite\", \"snowflake\"].includes(this.getDialect())) {\n      return this.fn(\"RANDOM\");\n    }\n    return this.fn(\"RAND\");\n  }\n  static fn(fn, ...args) {\n    return new Utils.Fn(fn, args);\n  }\n  static col(col) {\n    return new Utils.Col(col);\n  }\n  static cast(val, type) {\n    return new Utils.Cast(val, type);\n  }\n  static literal(val) {\n    return new Utils.Literal(val);\n  }\n  static and(...args) {\n    return { [Op.and]: args };\n  }\n  static or(...args) {\n    return { [Op.or]: args };\n  }\n  static json(conditionsOrPath, value) {\n    return new Utils.Json(conditionsOrPath, value);\n  }\n  static where(attr, comparator, logic) {\n    return new Utils.Where(attr, comparator, logic);\n  }\n  async transaction(options, autoCallback) {\n    if (typeof options === \"function\") {\n      autoCallback = options;\n      options = void 0;\n    }\n    const transaction = new Transaction(this, options);\n    if (!autoCallback) {\n      await transaction.prepareEnvironment(false);\n      return transaction;\n    }\n    return Sequelize._clsRun(async () => {\n      await transaction.prepareEnvironment(true);\n      let result;\n      try {\n        result = await autoCallback(transaction);\n      } catch (err) {\n        try {\n          await transaction.rollback();\n        } catch (ignore) {\n        }\n        throw err;\n      }\n      await transaction.commit();\n      return result;\n    });\n  }\n  static useCLS(ns) {\n    if (!ns || typeof ns !== \"object\" || typeof ns.bind !== \"function\" || typeof ns.run !== \"function\")\n      throw new Error(\"Must provide CLS namespace\");\n    Sequelize._cls = ns;\n    return this;\n  }\n  static _clsRun(fn) {\n    const ns = Sequelize._cls;\n    if (!ns)\n      return fn();\n    let res;\n    ns.run((context) => res = fn(context));\n    return res;\n  }\n  log(...args) {\n    let options;\n    const last = _.last(args);\n    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, \"logging\")) {\n      options = last;\n      if (options.logging === console.log) {\n        args.splice(args.length - 1, 1);\n      }\n    } else {\n      options = this.options;\n    }\n    if (options.logging) {\n      if (options.logging === true) {\n        deprecations.noTrueLogging();\n        options.logging = console.log;\n      }\n      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n        args = [`${args[0]} Elapsed time: ${args[1]}ms`];\n      }\n      options.logging(...args);\n    }\n  }\n  close() {\n    return this.connectionManager.close();\n  }\n  normalizeDataType(Type) {\n    let type = typeof Type === \"function\" ? new Type() : Type;\n    const dialectTypes = this.dialect.DataTypes || {};\n    if (dialectTypes[type.key]) {\n      type = dialectTypes[type.key].extend(type);\n    }\n    if (type instanceof DataTypes.ARRAY) {\n      if (!type.type) {\n        throw new Error(\"ARRAY is missing type definition for its values.\");\n      }\n      if (dialectTypes[type.type.key]) {\n        type.type = dialectTypes[type.type.key].extend(type.type);\n      }\n    }\n    return type;\n  }\n  normalizeAttribute(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = { type: attribute };\n    }\n    if (!attribute.type)\n      return attribute;\n    attribute.type = this.normalizeDataType(attribute.type);\n    if (Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\")) {\n      if (typeof attribute.defaultValue === \"function\" && [DataTypes.NOW, DataTypes.UUIDV1, DataTypes.UUIDV4].includes(attribute.defaultValue)) {\n        attribute.defaultValue = new attribute.defaultValue();\n      }\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.values) {\n        attribute.type.values = attribute.type.options.values = attribute.values;\n      } else {\n        attribute.values = attribute.type.values;\n      }\n      if (!attribute.values.length) {\n        throw new Error(\"Values for ENUM have not been defined.\");\n      }\n    }\n    return attribute;\n  }\n}\nSequelize.prototype.fn = Sequelize.fn;\nSequelize.prototype.col = Sequelize.col;\nSequelize.prototype.cast = Sequelize.cast;\nSequelize.prototype.literal = Sequelize.literal;\nSequelize.prototype.and = Sequelize.and;\nSequelize.prototype.or = Sequelize.or;\nSequelize.prototype.json = Sequelize.json;\nSequelize.prototype.where = Sequelize.where;\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\nObject.defineProperty(Sequelize, \"version\", {\n  enumerable: true,\n  get() {\n    return (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/sequelize/package.json\").version);\n  }\n});\nSequelize.options = { hooks: {} };\nSequelize.Utils = Utils;\nSequelize.Op = Op;\nSequelize.TableHints = TableHints;\nSequelize.IndexHints = IndexHints;\nSequelize.Transaction = Transaction;\nSequelize.prototype.Sequelize = Sequelize;\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\nSequelize.prototype.Validator = Sequelize.Validator = Validator;\nSequelize.Model = Model;\nSequelize.QueryInterface = QueryInterface;\nSequelize.BelongsTo = BelongsTo;\nSequelize.HasOne = HasOne;\nSequelize.HasMany = HasMany;\nSequelize.BelongsToMany = BelongsToMany;\nSequelize.DataTypes = DataTypes;\nfor (const dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\nSequelize.Deferrable = Deferrable;\nSequelize.prototype.Association = Sequelize.Association = Association;\nSequelize.useInflection = Utils.useInflection;\nHooks.applyTo(Sequelize);\nHooks.applyTo(Sequelize.prototype);\nSequelize.Error = sequelizeErrors.BaseError;\nfor (const error of Object.keys(sequelizeErrors)) {\n  Sequelize[error] = sequelizeErrors[error];\n}\nmodule.exports = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports[\"default\"] = Sequelize;\n//# sourceMappingURL=sequelize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zZXF1ZWxpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDekQsY0FBYyxpSEFBb0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsc0VBQWM7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWM7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLG9FQUFVO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDbEQsa0JBQWtCLCtIQUE2QztBQUMvRCxXQUFXLG1CQUFPLENBQUMsb0VBQWE7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ25ELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxvSEFBcUM7QUFDeEUsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDBGQUF3QjtBQUMvQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMEdBQWdDO0FBQ2xFLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3JELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQywwR0FBZ0M7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFvQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWtCO0FBQzVDO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDNUM7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFtQjtBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEZBQXFCO0FBQy9DO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBbUI7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFnQjtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEZBQXNCO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCLHNDQUFzQyx1QkFBdUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0IsR0FBRyxLQUFLLDRCQUE0QixFQUFFLE9BQU8sY0FBYztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUIseUNBQXlDLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxvQ0FBb0M7QUFDeEc7QUFDQTtBQUNBLHNEQUFzRCxjQUFjLDJCQUEyQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxnQkFBZ0IsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtR0FBa0M7QUFDN0M7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3NlcXVlbGl6ZS5qcz9hODgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgcGdDb25uZWN0aW9uU3RyaW5nID0gcmVxdWlyZShcInBnLWNvbm5lY3Rpb24tc3RyaW5nXCIpO1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKFwicmV0cnktYXMtcHJvbWlzZWRcIikuZGVmYXVsdDtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IE1vZGVsID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgRGVmZXJyYWJsZSA9IHJlcXVpcmUoXCIuL2RlZmVycmFibGVcIik7XG5jb25zdCBNb2RlbE1hbmFnZXIgPSByZXF1aXJlKFwiLi9tb2RlbC1tYW5hZ2VyXCIpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IFRhYmxlSGludHMgPSByZXF1aXJlKFwiLi90YWJsZS1oaW50c1wiKTtcbmNvbnN0IEluZGV4SGludHMgPSByZXF1aXJlKFwiLi9pbmRleC1oaW50c1wiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IEhvb2tzID0gcmVxdWlyZShcIi4vaG9va3NcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9pbmRleFwiKTtcbmNvbnN0IFZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXNcIikudmFsaWRhdG9yO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi9vcGVyYXRvcnNcIik7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKFwiLi91dGlscy9kZXByZWNhdGlvbnNcIik7XG5jb25zdCB7IFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCB7IEJlbG9uZ3NUbyB9ID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG9cIik7XG5jb25zdCBIYXNPbmUgPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzLW9uZVwiKTtcbmNvbnN0IHsgQmVsb25nc1RvTWFueSB9ID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueVwiKTtcbmNvbnN0IHsgSGFzTWFueSB9ID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2hhcy1tYW55XCIpO1xuY29uc3QgeyB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmYgfSA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3NxbGl0ZS9zcWxpdGUtdXRpbHNcIik7XG5jb25zdCB7IGluamVjdFJlcGxhY2VtZW50cyB9ID0gcmVxdWlyZShcIi4vdXRpbHMvc3FsXCIpO1xuY2xhc3MgU2VxdWVsaXplIHtcbiAgY29uc3RydWN0b3IoZGF0YWJhc2UsIHVzZXJuYW1lLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgIGxldCBjb25maWc7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRhdGFiYXNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBvcHRpb25zID0gZGF0YWJhc2U7XG4gICAgICBjb25maWcgPSBfLnBpY2sob3B0aW9ucywgXCJob3N0XCIsIFwicG9ydFwiLCBcImRhdGFiYXNlXCIsIFwidXNlcm5hbWVcIiwgXCJwYXNzd29yZFwiKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRhdGFiYXNlID09PSBcInN0cmluZ1wiIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIHVzZXJuYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25maWcgPSB7fTtcbiAgICAgIG9wdGlvbnMgPSB1c2VybmFtZSB8fCB7fTtcbiAgICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnBhcnNlKGFyZ3VtZW50c1swXSwgdHJ1ZSk7XG4gICAgICBvcHRpb25zLmRpYWxlY3QgPSB1cmxQYXJ0cy5wcm90b2NvbC5yZXBsYWNlKC86JC8sIFwiXCIpO1xuICAgICAgb3B0aW9ucy5ob3N0ID0gdXJsUGFydHMuaG9zdG5hbWU7XG4gICAgICBpZiAob3B0aW9ucy5kaWFsZWN0ID09PSBcInNxbGl0ZVwiICYmIHVybFBhcnRzLnBhdGhuYW1lICYmICF1cmxQYXJ0cy5wYXRobmFtZS5zdGFydHNXaXRoKFwiLzptZW1vcnlcIikpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVBhdGggPSBwYXRoLmpvaW4ob3B0aW9ucy5ob3N0LCB1cmxQYXJ0cy5wYXRobmFtZSk7XG4gICAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IHBhdGgucmVzb2x2ZShvcHRpb25zLnN0b3JhZ2UgfHwgc3RvcmFnZVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHVybFBhcnRzLnBhdGhuYW1lKSB7XG4gICAgICAgIGNvbmZpZy5kYXRhYmFzZSA9IHVybFBhcnRzLnBhdGhuYW1lLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxQYXJ0cy5wb3J0KSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IHVybFBhcnRzLnBvcnQ7XG4gICAgICB9XG4gICAgICBpZiAodXJsUGFydHMuYXV0aCkge1xuICAgICAgICBjb25zdCBhdXRoUGFydHMgPSB1cmxQYXJ0cy5hdXRoLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgY29uZmlnLnVzZXJuYW1lID0gYXV0aFBhcnRzWzBdO1xuICAgICAgICBpZiAoYXV0aFBhcnRzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgY29uZmlnLnBhc3N3b3JkID0gYXV0aFBhcnRzLnNsaWNlKDEpLmpvaW4oXCI6XCIpO1xuICAgICAgfVxuICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5KSB7XG4gICAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeS5ob3N0KSB7XG4gICAgICAgICAgb3B0aW9ucy5ob3N0ID0gdXJsUGFydHMucXVlcnkuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucy5kaWFsZWN0T3B0aW9ucywgdXJsUGFydHMucXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMgPSB1cmxQYXJ0cy5xdWVyeTtcbiAgICAgICAgICBpZiAodXJsUGFydHMucXVlcnkub3B0aW9ucykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IEpTT04ucGFyc2UodXJsUGFydHMucXVlcnkub3B0aW9ucyk7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyA9IG87XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoW1wicG9zdGdyZXNcIiwgXCJwb3N0Z3Jlc3FsXCJdLmluY2x1ZGVzKG9wdGlvbnMuZGlhbGVjdCkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmRpYWxlY3RPcHRpb25zLCBwZ0Nvbm5lY3Rpb25TdHJpbmcucGFyc2UoYXJndW1lbnRzWzBdKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgY29uZmlnID0geyBkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkIH07XG4gICAgfVxuICAgIFNlcXVlbGl6ZS5ydW5Ib29rcyhcImJlZm9yZUluaXRcIiwgY29uZmlnLCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBkaWFsZWN0OiBudWxsLFxuICAgICAgZGlhbGVjdE1vZHVsZTogbnVsbCxcbiAgICAgIGRpYWxlY3RNb2R1bGVQYXRoOiBudWxsLFxuICAgICAgaG9zdDogXCJsb2NhbGhvc3RcIixcbiAgICAgIHByb3RvY29sOiBcInRjcFwiLFxuICAgICAgZGVmaW5lOiB7fSxcbiAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgIHN5bmM6IHt9LFxuICAgICAgdGltZXpvbmU6IFwiKzAwOjAwXCIsXG4gICAgICBzdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzOiB0cnVlLFxuICAgICAgbG9nZ2luZzogY29uc29sZS5sb2csXG4gICAgICBvbWl0TnVsbDogZmFsc2UsXG4gICAgICBuYXRpdmU6IGZhbHNlLFxuICAgICAgcmVwbGljYXRpb246IGZhbHNlLFxuICAgICAgc3NsOiB2b2lkIDAsXG4gICAgICBwb29sOiB7fSxcbiAgICAgIHF1b3RlSWRlbnRpZmllcnM6IHRydWUsXG4gICAgICBob29rczoge30sXG4gICAgICByZXRyeToge1xuICAgICAgICBtYXg6IDUsXG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgXCJTUUxJVEVfQlVTWTogZGF0YWJhc2UgaXMgbG9ja2VkXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHRyYW5zYWN0aW9uVHlwZTogVHJhbnNhY3Rpb24uVFlQRVMuREVGRVJSRUQsXG4gICAgICBpc29sYXRpb25MZXZlbDogbnVsbCxcbiAgICAgIGRhdGFiYXNlVmVyc2lvbjogMCxcbiAgICAgIHR5cGVWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAgIGJlbmNobWFyazogZmFsc2UsXG4gICAgICBtaW5pZnlBbGlhc2VzOiBmYWxzZSxcbiAgICAgIGxvZ1F1ZXJ5UGFyYW1ldGVyczogZmFsc2UsXG4gICAgICBhdHRyaWJ1dGVCZWhhdmlvcjogXCJ0aHJvd1wiXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlhbGVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbGVjdCBuZWVkcyB0byBiZSBleHBsaWNpdGx5IHN1cHBsaWVkIGFzIG9mIHY0LjAuMFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ID09PSBcInBvc3RncmVzcWxcIikge1xuICAgICAgdGhpcy5vcHRpb25zLmRpYWxlY3QgPSBcInBvc3RncmVzXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJzcWxpdGVcIiAmJiB0aGlzLm9wdGlvbnMudGltZXpvbmUgIT09IFwiKzAwOjAwXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgYSBjdXN0b20gdGltZXpvbmUgaXMgbm90IHN1cHBvcnRlZCBieSBTUUxpdGUsIGRhdGVzIGFyZSBhbHdheXMgcmV0dXJuZWQgYXMgVVRDLiBQbGVhc2UgcmVtb3ZlIHRoZSBjdXN0b20gdGltZXpvbmUgcGFyYW1ldGVyLlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgdGhpcy5vcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICB9XG4gICAgdGhpcy5fc2V0dXBIb29rcyhvcHRpb25zLmhvb2tzKTtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UgfHwgdGhpcy5vcHRpb25zLmRhdGFiYXNlLFxuICAgICAgdXNlcm5hbWU6IGNvbmZpZy51c2VybmFtZSB8fCB0aGlzLm9wdGlvbnMudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkIHx8IHRoaXMub3B0aW9ucy5wYXNzd29yZCB8fCBudWxsLFxuICAgICAgaG9zdDogY29uZmlnLmhvc3QgfHwgdGhpcy5vcHRpb25zLmhvc3QsXG4gICAgICBwb3J0OiBjb25maWcucG9ydCB8fCB0aGlzLm9wdGlvbnMucG9ydCxcbiAgICAgIHBvb2w6IHRoaXMub3B0aW9ucy5wb29sLFxuICAgICAgcHJvdG9jb2w6IHRoaXMub3B0aW9ucy5wcm90b2NvbCxcbiAgICAgIG5hdGl2ZTogdGhpcy5vcHRpb25zLm5hdGl2ZSxcbiAgICAgIHNzbDogdGhpcy5vcHRpb25zLnNzbCxcbiAgICAgIHJlcGxpY2F0aW9uOiB0aGlzLm9wdGlvbnMucmVwbGljYXRpb24sXG4gICAgICBkaWFsZWN0TW9kdWxlOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE1vZHVsZSxcbiAgICAgIGRpYWxlY3RNb2R1bGVQYXRoOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE1vZHVsZVBhdGgsXG4gICAgICBrZWVwRGVmYXVsdFRpbWV6b25lOiB0aGlzLm9wdGlvbnMua2VlcERlZmF1bHRUaW1lem9uZSxcbiAgICAgIGRpYWxlY3RPcHRpb25zOiB0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnNcbiAgICB9O1xuICAgIGxldCBEaWFsZWN0O1xuICAgIHN3aXRjaCAodGhpcy5nZXREaWFsZWN0KCkpIHtcbiAgICAgIGNhc2UgXCJtYXJpYWRiXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9tYXJpYWRiXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtc3NxbFwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvbXNzcWxcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm15c3FsXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9teXNxbFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib3JhY2xlXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9vcmFjbGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvc3RncmVzXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9wb3N0Z3Jlc1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3FsaXRlXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9zcWxpdGVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRiMlwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvZGIyXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzbm93Zmxha2VcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3Nub3dmbGFrZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkaWFsZWN0ICR7dGhpcy5nZXREaWFsZWN0KCl9IGlzIG5vdCBzdXBwb3J0ZWQuIFN1cHBvcnRlZCBkaWFsZWN0czogbXNzcWwsIG1hcmlhZGIsIG15c3FsLCBvcmFjbGUsIHBvc3RncmVzLCBkYjIgYW5kIHNxbGl0ZS5gKTtcbiAgICB9XG4gICAgdGhpcy5kaWFsZWN0ID0gbmV3IERpYWxlY3QodGhpcyk7XG4gICAgdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLnR5cGVWYWxpZGF0aW9uID0gb3B0aW9ucy50eXBlVmFsaWRhdGlvbjtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzKSkge1xuICAgICAgZGVwcmVjYXRpb25zLm5vU3RyaW5nT3BlcmF0b3JzKCk7XG4gICAgICB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3Iuc2V0T3BlcmF0b3JzQWxpYXNlcyh0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9Cb29sT3BlcmF0b3JBbGlhc2VzKCk7XG4gICAgfVxuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSB0aGlzLmRpYWxlY3QucXVlcnlJbnRlcmZhY2U7XG4gICAgdGhpcy5tb2RlbHMgPSB7fTtcbiAgICB0aGlzLm1vZGVsTWFuYWdlciA9IG5ldyBNb2RlbE1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICBTZXF1ZWxpemUucnVuSG9va3MoXCJhZnRlckluaXRcIiwgdGhpcyk7XG4gIH1cbiAgcmVmcmVzaFR5cGVzKCkge1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBnZXREaWFsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlhbGVjdDtcbiAgfVxuICBnZXREYXRhYmFzZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGFiYXNlO1xuICB9XG4gIGdldFF1ZXJ5SW50ZXJmYWNlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5SW50ZXJmYWNlO1xuICB9XG4gIGRlZmluZShtb2RlbE5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMubW9kZWxOYW1lID0gbW9kZWxOYW1lO1xuICAgIG9wdGlvbnMuc2VxdWVsaXplID0gdGhpcztcbiAgICBjb25zdCBtb2RlbCA9IGNsYXNzIGV4dGVuZHMgTW9kZWwge1xuICAgIH07XG4gICAgbW9kZWwuaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbW9kZWwobW9kZWxOYW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzRGVmaW5lZChtb2RlbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bW9kZWxOYW1lfSBoYXMgbm90IGJlZW4gZGVmaW5lZGApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwobW9kZWxOYW1lKTtcbiAgfVxuICBpc0RlZmluZWQobW9kZWxOYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzLmZpbmQoKG1vZGVsKSA9PiBtb2RlbC5uYW1lID09PSBtb2RlbE5hbWUpO1xuICB9XG4gIGFzeW5jIHF1ZXJ5KHNxbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zLnF1ZXJ5KSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW5zdGFuY2UgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIG9wdGlvbnMubW9kZWwgPSBvcHRpb25zLmluc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5zdGFuY2UgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWFwVG9Nb2RlbCkge1xuICAgICAgb3B0aW9ucy5maWVsZE1hcCA9IF8uZ2V0KG9wdGlvbnMsIFwibW9kZWwuZmllbGRBdHRyaWJ1dGVNYXBcIiwge30pO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBsb2dnaW5nOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLCBcImxvZ2dpbmdcIikgPyB0aGlzLm9wdGlvbnMubG9nZ2luZyA6IGNvbnNvbGUubG9nLFxuICAgICAgc2VhcmNoUGF0aDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMub3B0aW9ucywgXCJzZWFyY2hQYXRoXCIpID8gdGhpcy5vcHRpb25zLnNlYXJjaFBhdGggOiBcIkRFRkFVTFRcIlxuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICBpZiAob3B0aW9ucy5tb2RlbCB8fCBvcHRpb25zLm5lc3QgfHwgb3B0aW9ucy5wbGFpbikge1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlNFTEVDVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuUkFXO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZGlhbGVjdC5zdXBwb3J0cy5zZWFyY2hQYXRoIHx8ICF0aGlzLm9wdGlvbnMuZGlhbGVjdE9wdGlvbnMgfHwgIXRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9ucy5wcmVwZW5kU2VhcmNoUGF0aCB8fCBvcHRpb25zLnN1cHBvcnRzU2VhcmNoUGF0aCA9PT0gZmFsc2UpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnNlYXJjaFBhdGg7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5zZWFyY2hQYXRoKSB7XG4gICAgICBvcHRpb25zLnNlYXJjaFBhdGggPSBcIkRFRkFVTFRcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlmIChzcWwudmFsdWVzICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIGBzcWwudmFsdWVzYCBhbmQgYG9wdGlvbnMucmVwbGFjZW1lbnRzYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5yZXBsYWNlbWVudHMgPSBzcWwudmFsdWVzO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5iaW5kICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBgc3FsLmJpbmRgIGFuZCBgb3B0aW9ucy5iaW5kYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5iaW5kID0gc3FsLmJpbmQ7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLnF1ZXJ5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgc3FsID0gc3FsLnF1ZXJ5O1xuICAgICAgfVxuICAgIH1cbiAgICBzcWwgPSBzcWwudHJpbSgpO1xuICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cyAmJiBvcHRpb25zLmJpbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggYHJlcGxhY2VtZW50c2AgYW5kIGBiaW5kYCBjYW5ub3QgYmUgc2V0IGF0IHRoZSBzYW1lIHRpbWVcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcGxhY2VtZW50cykge1xuICAgICAgc3FsID0gaW5qZWN0UmVwbGFjZW1lbnRzKHNxbCwgdGhpcy5kaWFsZWN0LCBvcHRpb25zLnJlcGxhY2VtZW50cyk7XG4gICAgfVxuICAgIGxldCBiaW5kUGFyYW1ldGVycztcbiAgICBpZiAob3B0aW9ucy5iaW5kKSB7XG4gICAgICBbc3FsLCBiaW5kUGFyYW1ldGVyc10gPSB0aGlzLmRpYWxlY3QuUXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCBvcHRpb25zLmJpbmQsIHRoaXMub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgJiYgIW9wdGlvbnMuY29tcGxldGVzVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYCR7b3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZH0gaGFzIGJlZW4gY2FsbGVkIG9uIHRoaXMgdHJhbnNhY3Rpb24oJHtvcHRpb25zLnRyYW5zYWN0aW9uLmlkfSksIHlvdSBjYW4gbm8gbG9uZ2VyIHVzZSBpdC4gKFRoZSByZWplY3RlZCBxdWVyeSBpcyBhdHRhY2hlZCBhcyB0aGUgJ3NxbCcgcHJvcGVydHkgb2YgdGhpcyBlcnJvcilgKTtcbiAgICAgICAgZXJyb3Iuc3FsID0gc3FsO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJldHJ5T3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMucmV0cnkpLCBvcHRpb25zLnJldHJ5KTtcbiAgICByZXR1cm4gcmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiBTZXF1ZWxpemUuX2Nscykge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gU2VxdWVsaXplLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICB9XG4gICAgICBjaGVja1RyYW5zYWN0aW9uKCk7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgKG9wdGlvbnMudHJhbnNhY3Rpb24gPyBvcHRpb25zLnRyYW5zYWN0aW9uLmNvbm5lY3Rpb24gOiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24ob3B0aW9ucykpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ID09PSBcImRiMlwiICYmIG9wdGlvbnMuYWx0ZXIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWx0ZXIuZHJvcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb25uZWN0aW9uLmRyb3BUYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyB0aGlzLmRpYWxlY3QuUXVlcnkoY29ubmVjdGlvbiwgdGhpcywgb3B0aW9ucyk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlUXVlcnlcIiwgb3B0aW9ucywgcXVlcnkpO1xuICAgICAgICBjaGVja1RyYW5zYWN0aW9uKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCBxdWVyeS5ydW4oc3FsLCBiaW5kUGFyYW1ldGVycyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJRdWVyeVwiLCBvcHRpb25zLCBxdWVyeSk7XG4gICAgICAgIGlmICghb3B0aW9ucy50cmFuc2FjdGlvbikge1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVsZWFzZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCByZXRyeU9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNldCh2YXJpYWJsZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucy5zZXQpLCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zKTtcbiAgICBpZiAoIVtcIm15c3FsXCIsIFwibWFyaWFkYlwiXS5pbmNsdWRlcyh0aGlzLm9wdGlvbnMuZGlhbGVjdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlcXVlbGl6ZS5zZXQgaXMgb25seSBzdXBwb3J0ZWQgZm9yIG15c3FsIG9yIG1hcmlhZGJcIik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50cmFuc2FjdGlvbiB8fCAhKG9wdGlvbnMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zLnRyYW5zYWN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG4gICAgb3B0aW9ucy50eXBlID0gXCJTRVRcIjtcbiAgICBjb25zdCBxdWVyeSA9IGBTRVQgJHtfLm1hcCh2YXJpYWJsZXMsICh2LCBrKSA9PiBgQCR7a30gOj0gJHt0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IGBcIiR7dn1cImAgOiB2fWApLmpvaW4oXCIsIFwiKX1gO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgfVxuICBlc2NhcGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmVzY2FwZSh2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuY3JlYXRlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2hvd0FsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuc2hvd0FsbFNjaGVtYXMob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRyb3BTY2hlbWEoc2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkcm9wQWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kcm9wQWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzeW5jKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zKSwgdGhpcy5vcHRpb25zLnN5bmMpLCBvcHRpb25zKSwge1xuICAgICAgaG9va3M6IG9wdGlvbnMgPyBvcHRpb25zLmhvb2tzICE9PSBmYWxzZSA6IHRydWVcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5tYXRjaCkge1xuICAgICAgaWYgKCFvcHRpb25zLm1hdGNoLnRlc3QodGhpcy5jb25maWcuZGF0YWJhc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YWJhc2UgXCIke3RoaXMuY29uZmlnLmRhdGFiYXNlfVwiIGRvZXMgbm90IG1hdGNoIHN5bmMgbWF0Y2ggcGFyYW1ldGVyIFwiJHtvcHRpb25zLm1hdGNofVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQnVsa1N5bmNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcmNlKSB7XG4gICAgICBhd2FpdCB0aGlzLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0ZShvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbW9kZWxzID0gdGhpcy5tb2RlbE1hbmFnZXIuZ2V0TW9kZWxzVG9wb1NvcnRlZEJ5Rm9yZWlnbktleSgpO1xuICAgICAgaWYgKG1vZGVscyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zeW5jTW9kZWxzV2l0aEN5Y2xpY1JlZmVyZW5jZXMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBtb2RlbHMucmV2ZXJzZSgpO1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiBtb2RlbHMpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwuc3luYyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlckJ1bGtTeW5jXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBfc3luY01vZGVsc1dpdGhDeWNsaWNSZWZlcmVuY2VzKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5kaWFsZWN0Lm5hbWUgPT09IFwic3FsaXRlXCIpIHtcbiAgICAgIGF3YWl0IHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZih0aGlzLCBvcHRpb25zLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICAgICAgYXdhaXQgbW9kZWwuc3luYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICBhd2FpdCBtb2RlbC5zeW5jKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHM6IHRydWUgfSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgYXdhaXQgbW9kZWwuc3luYyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBmb3JjZTogZmFsc2UsIGFsdGVyOiB0cnVlIH0pKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdHJ1bmNhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHNvcnRlZE1vZGVscyA9IHRoaXMubW9kZWxNYW5hZ2VyLmdldE1vZGVsc1RvcG9Tb3J0ZWRCeUZvcmVpZ25LZXkoKTtcbiAgICBjb25zdCBtb2RlbHMgPSBzb3J0ZWRNb2RlbHMgfHwgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzO1xuICAgIGNvbnN0IGhhc0N5Y2xpY0RlcGVuZGVuY2llcyA9IHNvcnRlZE1vZGVscyA9PSBudWxsO1xuICAgIGlmIChoYXNDeWNsaWNEZXBlbmRlbmNpZXMgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmNhc2NhZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcXVlbGl6ZSN0cnVuY2F0ZTogU29tZSBvZiB5b3VyIG1vZGVscyBoYXZlIGN5Y2xpYyByZWZlcmVuY2VzIChmb3JlaWduIGtleXMpLiBZb3UgbmVlZCB0byB1c2UgdGhlIFwiY2FzY2FkZVwiIG9wdGlvbiB0byBiZSBhYmxlIHRvIGRlbGV0ZSByb3dzIGZyb20gbW9kZWxzIHRoYXQgaGF2ZSBjeWNsaWMgcmVmZXJlbmNlcy4nKTtcbiAgICB9XG4gICAgaWYgKGhhc0N5Y2xpY0RlcGVuZGVuY2llcyAmJiB0aGlzLmRpYWxlY3QubmFtZSA9PT0gXCJzcWxpdGVcIikge1xuICAgICAgcmV0dXJuIHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZih0aGlzLCBvcHRpb25zLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZGVscy5tYXAoKG1vZGVsKSA9PiBtb2RlbC50cnVuY2F0ZShvcHRpb25zKSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2FzY2FkZSkge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiBtb2RlbHMpXG4gICAgICAgIGF3YWl0IG1vZGVsLnRydW5jYXRlKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChtb2RlbHMubWFwKChtb2RlbCkgPT4gbW9kZWwudHJ1bmNhdGUob3B0aW9ucykpKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZHJvcChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYXNjYWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgICBhd2FpdCBtb2RlbC5kcm9wKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzb3J0ZWRNb2RlbHMgPSB0aGlzLm1vZGVsTWFuYWdlci5nZXRNb2RlbHNUb3BvU29ydGVkQnlGb3JlaWduS2V5KCk7XG4gICAgaWYgKHNvcnRlZE1vZGVscykge1xuICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiBzb3J0ZWRNb2RlbHMpIHtcbiAgICAgICAgYXdhaXQgbW9kZWwuZHJvcChvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZGlhbGVjdC5uYW1lID09PSBcInNxbGl0ZVwiKSB7XG4gICAgICBhd2FpdCB3aXRoU3FsaXRlRm9yZWlnbktleXNPZmYodGhpcywgb3B0aW9ucywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgICAgIGF3YWl0IG1vZGVsLmRyb3Aob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgY29uc3QgdGFibGVOYW1lID0gbW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoZm9yZWlnbktleXMubWFwKChmb3JlaWduS2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBmb3JlaWduS2V5LmNvbnN0cmFpbnROYW1lLCBvcHRpb25zKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgIGF3YWl0IG1vZGVsLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGF1dGhlbnRpY2F0ZShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHBsYWluOiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1RcbiAgICB9LCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnF1ZXJ5KHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5hdXRoVGVzdFF1ZXJ5KCksIG9wdGlvbnMpO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3luYyBkYXRhYmFzZVZlcnNpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZGF0YWJhc2VWZXJzaW9uKG9wdGlvbnMpO1xuICB9XG4gIHJhbmRvbSgpIHtcbiAgICBpZiAoW1wicG9zdGdyZXNcIiwgXCJzcWxpdGVcIiwgXCJzbm93Zmxha2VcIl0uaW5jbHVkZXModGhpcy5nZXREaWFsZWN0KCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbihcIlJBTkRPTVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm4oXCJSQU5EXCIpO1xuICB9XG4gIHN0YXRpYyBmbihmbiwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgVXRpbHMuRm4oZm4sIGFyZ3MpO1xuICB9XG4gIHN0YXRpYyBjb2woY29sKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5Db2woY29sKTtcbiAgfVxuICBzdGF0aWMgY2FzdCh2YWwsIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkNhc3QodmFsLCB0eXBlKTtcbiAgfVxuICBzdGF0aWMgbGl0ZXJhbCh2YWwpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkxpdGVyYWwodmFsKTtcbiAgfVxuICBzdGF0aWMgYW5kKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4geyBbT3AuYW5kXTogYXJncyB9O1xuICB9XG4gIHN0YXRpYyBvciguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHsgW09wLm9yXTogYXJncyB9O1xuICB9XG4gIHN0YXRpYyBqc29uKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5Kc29uKGNvbmRpdGlvbnNPclBhdGgsIHZhbHVlKTtcbiAgfVxuICBzdGF0aWMgd2hlcmUoYXR0ciwgY29tcGFyYXRvciwgbG9naWMpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLldoZXJlKGF0dHIsIGNvbXBhcmF0b3IsIGxvZ2ljKTtcbiAgfVxuICBhc3luYyB0cmFuc2FjdGlvbihvcHRpb25zLCBhdXRvQ2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYXV0b0NhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMsIG9wdGlvbnMpO1xuICAgIGlmICghYXV0b0NhbGxiYWNrKSB7XG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi5wcmVwYXJlRW52aXJvbm1lbnQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU2VxdWVsaXplLl9jbHNSdW4oYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdHJhbnNhY3Rpb24ucHJlcGFyZUVudmlyb25tZW50KHRydWUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGF1dG9DYWxsYmFjayh0cmFuc2FjdGlvbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5yb2xsYmFjaygpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHVzZUNMUyhucykge1xuICAgIGlmICghbnMgfHwgdHlwZW9mIG5zICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBucy5iaW5kICE9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG5zLnJ1biAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIENMUyBuYW1lc3BhY2VcIik7XG4gICAgU2VxdWVsaXplLl9jbHMgPSBucztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgX2Nsc1J1bihmbikge1xuICAgIGNvbnN0IG5zID0gU2VxdWVsaXplLl9jbHM7XG4gICAgaWYgKCFucylcbiAgICAgIHJldHVybiBmbigpO1xuICAgIGxldCByZXM7XG4gICAgbnMucnVuKChjb250ZXh0KSA9PiByZXMgPSBmbihjb250ZXh0KSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBsb2coLi4uYXJncykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGNvbnN0IGxhc3QgPSBfLmxhc3QoYXJncyk7XG4gICAgaWYgKGxhc3QgJiYgXy5pc1BsYWluT2JqZWN0KGxhc3QpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXN0LCBcImxvZ2dpbmdcIikpIHtcbiAgICAgIG9wdGlvbnMgPSBsYXN0O1xuICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZyA9PT0gY29uc29sZS5sb2cpIHtcbiAgICAgICAgYXJncy5zcGxpY2UoYXJncy5sZW5ndGggLSAxLCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICAgICAgaWYgKG9wdGlvbnMubG9nZ2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgICBvcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICAgIH1cbiAgICAgIGlmICgodGhpcy5vcHRpb25zLmJlbmNobWFyayB8fCBvcHRpb25zLmJlbmNobWFyaykgJiYgb3B0aW9ucy5sb2dnaW5nID09PSBjb25zb2xlLmxvZykge1xuICAgICAgICBhcmdzID0gW2Ake2FyZ3NbMF19IEVsYXBzZWQgdGltZTogJHthcmdzWzFdfW1zYF07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmxvZ2dpbmcoLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlKCk7XG4gIH1cbiAgbm9ybWFsaXplRGF0YVR5cGUoVHlwZSkge1xuICAgIGxldCB0eXBlID0gdHlwZW9mIFR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBUeXBlKCkgOiBUeXBlO1xuICAgIGNvbnN0IGRpYWxlY3RUeXBlcyA9IHRoaXMuZGlhbGVjdC5EYXRhVHlwZXMgfHwge307XG4gICAgaWYgKGRpYWxlY3RUeXBlc1t0eXBlLmtleV0pIHtcbiAgICAgIHR5cGUgPSBkaWFsZWN0VHlwZXNbdHlwZS5rZXldLmV4dGVuZCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgIGlmICghdHlwZS50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFSUkFZIGlzIG1pc3NpbmcgdHlwZSBkZWZpbml0aW9uIGZvciBpdHMgdmFsdWVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaWFsZWN0VHlwZXNbdHlwZS50eXBlLmtleV0pIHtcbiAgICAgICAgdHlwZS50eXBlID0gZGlhbGVjdFR5cGVzW3R5cGUudHlwZS5rZXldLmV4dGVuZCh0eXBlLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0geyB0eXBlOiBhdHRyaWJ1dGUgfTtcbiAgICB9XG4gICAgaWYgKCFhdHRyaWJ1dGUudHlwZSlcbiAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgYXR0cmlidXRlLnR5cGUgPSB0aGlzLm5vcm1hbGl6ZURhdGFUeXBlKGF0dHJpYnV0ZS50eXBlKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikpIHtcbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiICYmIFtEYXRhVHlwZXMuTk9XLCBEYXRhVHlwZXMuVVVJRFYxLCBEYXRhVHlwZXMuVVVJRFY0XS5pbmNsdWRlcyhhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID0gbmV3IGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZS50eXBlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLm9wdGlvbnMudmFsdWVzID0gYXR0cmlidXRlLnZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJpYnV0ZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlcyBmb3IgRU5VTSBoYXZlIG5vdCBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlO1xuICB9XG59XG5TZXF1ZWxpemUucHJvdG90eXBlLmZuID0gU2VxdWVsaXplLmZuO1xuU2VxdWVsaXplLnByb3RvdHlwZS5jb2wgPSBTZXF1ZWxpemUuY29sO1xuU2VxdWVsaXplLnByb3RvdHlwZS5jYXN0ID0gU2VxdWVsaXplLmNhc3Q7XG5TZXF1ZWxpemUucHJvdG90eXBlLmxpdGVyYWwgPSBTZXF1ZWxpemUubGl0ZXJhbDtcblNlcXVlbGl6ZS5wcm90b3R5cGUuYW5kID0gU2VxdWVsaXplLmFuZDtcblNlcXVlbGl6ZS5wcm90b3R5cGUub3IgPSBTZXF1ZWxpemUub3I7XG5TZXF1ZWxpemUucHJvdG90eXBlLmpzb24gPSBTZXF1ZWxpemUuanNvbjtcblNlcXVlbGl6ZS5wcm90b3R5cGUud2hlcmUgPSBTZXF1ZWxpemUud2hlcmU7XG5TZXF1ZWxpemUucHJvdG90eXBlLnZhbGlkYXRlID0gU2VxdWVsaXplLnByb3RvdHlwZS5hdXRoZW50aWNhdGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2VxdWVsaXplLCBcInZlcnNpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIikudmVyc2lvbjtcbiAgfVxufSk7XG5TZXF1ZWxpemUub3B0aW9ucyA9IHsgaG9va3M6IHt9IH07XG5TZXF1ZWxpemUuVXRpbHMgPSBVdGlscztcblNlcXVlbGl6ZS5PcCA9IE9wO1xuU2VxdWVsaXplLlRhYmxlSGludHMgPSBUYWJsZUhpbnRzO1xuU2VxdWVsaXplLkluZGV4SGludHMgPSBJbmRleEhpbnRzO1xuU2VxdWVsaXplLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5TZXF1ZWxpemUucHJvdG90eXBlLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcblNlcXVlbGl6ZS5wcm90b3R5cGUuUXVlcnlUeXBlcyA9IFNlcXVlbGl6ZS5RdWVyeVR5cGVzID0gUXVlcnlUeXBlcztcblNlcXVlbGl6ZS5wcm90b3R5cGUuVmFsaWRhdG9yID0gU2VxdWVsaXplLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcblNlcXVlbGl6ZS5Nb2RlbCA9IE1vZGVsO1xuU2VxdWVsaXplLlF1ZXJ5SW50ZXJmYWNlID0gUXVlcnlJbnRlcmZhY2U7XG5TZXF1ZWxpemUuQmVsb25nc1RvID0gQmVsb25nc1RvO1xuU2VxdWVsaXplLkhhc09uZSA9IEhhc09uZTtcblNlcXVlbGl6ZS5IYXNNYW55ID0gSGFzTWFueTtcblNlcXVlbGl6ZS5CZWxvbmdzVG9NYW55ID0gQmVsb25nc1RvTWFueTtcblNlcXVlbGl6ZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5mb3IgKGNvbnN0IGRhdGFUeXBlIGluIERhdGFUeXBlcykge1xuICBTZXF1ZWxpemVbZGF0YVR5cGVdID0gRGF0YVR5cGVzW2RhdGFUeXBlXTtcbn1cblNlcXVlbGl6ZS5EZWZlcnJhYmxlID0gRGVmZXJyYWJsZTtcblNlcXVlbGl6ZS5wcm90b3R5cGUuQXNzb2NpYXRpb24gPSBTZXF1ZWxpemUuQXNzb2NpYXRpb24gPSBBc3NvY2lhdGlvbjtcblNlcXVlbGl6ZS51c2VJbmZsZWN0aW9uID0gVXRpbHMudXNlSW5mbGVjdGlvbjtcbkhvb2tzLmFwcGx5VG8oU2VxdWVsaXplKTtcbkhvb2tzLmFwcGx5VG8oU2VxdWVsaXplLnByb3RvdHlwZSk7XG5TZXF1ZWxpemUuRXJyb3IgPSBzZXF1ZWxpemVFcnJvcnMuQmFzZUVycm9yO1xuZm9yIChjb25zdCBlcnJvciBvZiBPYmplY3Qua2V5cyhzZXF1ZWxpemVFcnJvcnMpKSB7XG4gIFNlcXVlbGl6ZVtlcnJvcl0gPSBzZXF1ZWxpemVFcnJvcnNbZXJyb3JdO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTZXF1ZWxpemU7XG5tb2R1bGUuZXhwb3J0cy5TZXF1ZWxpemUgPSBTZXF1ZWxpemU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gU2VxdWVsaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VxdWVsaXplLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/sequelize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/sql-string.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/sql-string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst dataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nfunction arrayToList(array, timeZone, dialect, format2) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += \", \";\n    }\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format2)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format2);\n    }\n    return sql;\n  }, \"\");\n}\nexports.arrayToList = arrayToList;\nfunction escape(val, timeZone, dialect, format2) {\n  let prependN = false;\n  if (val === void 0 || val === null) {\n    return \"NULL\";\n  }\n  switch (typeof val) {\n    case \"boolean\":\n      if ([\"sqlite\", \"mssql\", \"oracle\"].includes(dialect)) {\n        return +!!val;\n      }\n      return (!!val).toString();\n    case \"number\":\n    case \"bigint\":\n      return val.toString();\n    case \"string\":\n      prependN = dialect === \"mssql\";\n      break;\n  }\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n  if (Array.isArray(val)) {\n    const partialEscape = (escVal) => escape(escVal, timeZone, dialect, format2);\n    if (dialect === \"postgres\" && !format2) {\n      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });\n    }\n    return arrayToList(val, timeZone, dialect, format2);\n  }\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n  if ([\"postgres\", \"sqlite\", \"mssql\", \"snowflake\", \"db2\"].includes(dialect)) {\n    val = val.replace(/'/g, \"''\");\n    if (dialect === \"postgres\") {\n      val = val.replace(/\\0/g, \"\\\\0\");\n    }\n  } else if (dialect === \"oracle\" && typeof val === \"string\") {\n    if (val.startsWith(\"TO_TIMESTAMP_TZ\") || val.startsWith(\"TO_DATE\")) {\n      const splitVal = val.split(/\\(|\\)/);\n      if (splitVal.length !== 3 || splitVal[2] !== \"\") {\n        throw new Error(\"Invalid SQL function call.\");\n      }\n      const functionName = splitVal[0].trim();\n      const insideParens = splitVal[1].trim();\n      if (functionName !== \"TO_TIMESTAMP_TZ\" && functionName !== \"TO_DATE\") {\n        throw new Error(\"Invalid SQL function call. Expected TO_TIMESTAMP_TZ or TO_DATE.\");\n      }\n      const params = insideParens.split(\",\");\n      if (params.length !== 2) {\n        throw new Error(\"Unexpected input received.\\nSequelize supports TO_TIMESTAMP_TZ or TO_DATE exclusively with a combination of value and format.\");\n      }\n      const dateValue = params[0].trim().replace(/'/g, \"\");\n      const formatValue = params[1].trim();\n      if (functionName === \"TO_TIMESTAMP_TZ\") {\n        const expectedFormat = \"'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_TIMESTAMP_TZ. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_TIMESTAMP_TZ. Expected format: 'YYYY-MM-DD HH:mm:ss.SSS Z'\");\n        }\n      } else if (functionName === \"TO_DATE\") {\n        const expectedFormat = \"'YYYY/MM/DD'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_DATE. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_DATE. Expected format: 'YYYY-MM-DD'\");\n        }\n      }\n      return val;\n    }\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, (s) => {\n      switch (s) {\n        case \"\\0\":\n          return \"\\\\0\";\n        case \"\\n\":\n          return \"\\\\n\";\n        case \"\\r\":\n          return \"\\\\r\";\n        case \"\\b\":\n          return \"\\\\b\";\n        case \"\t\":\n          return \"\\\\t\";\n        case \"\u001a\":\n          return \"\\\\Z\";\n        default:\n          return `\\\\${s}`;\n      }\n    });\n  }\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\nexports.escape = escape;\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n  if (typeof sql !== \"string\") {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n  return sql.replace(/\\?/g, (match) => {\n    if (!values.length) {\n      return match;\n    }\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if (dialect === \"postgres\" && value.slice(0, 2) === \"::\") {\n      return value;\n    }\n    if (values[key] !== void 0) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n//# sourceMappingURL=sql-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zcWwtc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3hDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDLEdBQUc7QUFDSDtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3NxbC1zdHJpbmcuanM/MWJkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IG1vbWVudCA9IHJlcXVpcmUoXCJtb21lbnRcIik7XG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKFwiLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZ2dlclwiKTtcbmZ1bmN0aW9uIGFycmF5VG9MaXN0KGFycmF5LCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mikge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChzcWwsIHZhbCwgaSkgPT4ge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBzcWwgKz0gXCIsIFwiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBzcWwgKz0gYCgke2FycmF5VG9MaXN0KHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpfSlgO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcWwgKz0gZXNjYXBlKHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9LCBcIlwiKTtcbn1cbmV4cG9ydHMuYXJyYXlUb0xpc3QgPSBhcnJheVRvTGlzdDtcbmZ1bmN0aW9uIGVzY2FwZSh2YWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKSB7XG4gIGxldCBwcmVwZW5kTiA9IGZhbHNlO1xuICBpZiAodmFsID09PSB2b2lkIDAgfHwgdmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiTlVMTFwiO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbCkge1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICBpZiAoW1wic3FsaXRlXCIsIFwibXNzcWxcIiwgXCJvcmFjbGVcIl0uaW5jbHVkZXMoZGlhbGVjdCkpIHtcbiAgICAgICAgcmV0dXJuICshIXZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoISF2YWwpLnRvU3RyaW5nKCk7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBwcmVwZW5kTiA9IGRpYWxlY3QgPT09IFwibXNzcWxcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gZGF0YVR5cGVzW2RpYWxlY3RdLkRBVEUucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwsIHsgdGltZXpvbmU6IHRpbWVab25lIH0pO1xuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIGlmIChkYXRhVHlwZXNbZGlhbGVjdF0uQkxPQikge1xuICAgICAgcmV0dXJuIGRhdGFUeXBlc1tkaWFsZWN0XS5CTE9CLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFUeXBlcy5CTE9CLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgcGFydGlhbEVzY2FwZSA9IChlc2NWYWwpID0+IGVzY2FwZShlc2NWYWwsIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKTtcbiAgICBpZiAoZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc1wiICYmICFmb3JtYXQyKSB7XG4gICAgICByZXR1cm4gZGF0YVR5cGVzLkFSUkFZLnByb3RvdHlwZS5zdHJpbmdpZnkodmFsLCB7IGVzY2FwZTogcGFydGlhbEVzY2FwZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG9MaXN0KHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpO1xuICB9XG4gIGlmICghdmFsLnJlcGxhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgJHtsb2dnZXIuaW5zcGVjdCh2YWwpfWApO1xuICB9XG4gIGlmIChbXCJwb3N0Z3Jlc1wiLCBcInNxbGl0ZVwiLCBcIm1zc3FsXCIsIFwic25vd2ZsYWtlXCIsIFwiZGIyXCJdLmluY2x1ZGVzKGRpYWxlY3QpKSB7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgXCInJ1wiKTtcbiAgICBpZiAoZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc1wiKSB7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpYWxlY3QgPT09IFwib3JhY2xlXCIgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh2YWwuc3RhcnRzV2l0aChcIlRPX1RJTUVTVEFNUF9UWlwiKSB8fCB2YWwuc3RhcnRzV2l0aChcIlRPX0RBVEVcIikpIHtcbiAgICAgIGNvbnN0IHNwbGl0VmFsID0gdmFsLnNwbGl0KC9cXCh8XFwpLyk7XG4gICAgICBpZiAoc3BsaXRWYWwubGVuZ3RoICE9PSAzIHx8IHNwbGl0VmFsWzJdICE9PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1FMIGZ1bmN0aW9uIGNhbGwuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gc3BsaXRWYWxbMF0udHJpbSgpO1xuICAgICAgY29uc3QgaW5zaWRlUGFyZW5zID0gc3BsaXRWYWxbMV0udHJpbSgpO1xuICAgICAgaWYgKGZ1bmN0aW9uTmFtZSAhPT0gXCJUT19USU1FU1RBTVBfVFpcIiAmJiBmdW5jdGlvbk5hbWUgIT09IFwiVE9fREFURVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1FMIGZ1bmN0aW9uIGNhbGwuIEV4cGVjdGVkIFRPX1RJTUVTVEFNUF9UWiBvciBUT19EQVRFLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IGluc2lkZVBhcmVucy5zcGxpdChcIixcIik7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGlucHV0IHJlY2VpdmVkLlxcblNlcXVlbGl6ZSBzdXBwb3J0cyBUT19USU1FU1RBTVBfVFogb3IgVE9fREFURSBleGNsdXNpdmVseSB3aXRoIGEgY29tYmluYXRpb24gb2YgdmFsdWUgYW5kIGZvcm1hdC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlVmFsdWUgPSBwYXJhbXNbMF0udHJpbSgpLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICBjb25zdCBmb3JtYXRWYWx1ZSA9IHBhcmFtc1sxXS50cmltKCk7XG4gICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSBcIlRPX1RJTUVTVEFNUF9UWlwiKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRm9ybWF0ID0gXCInWVlZWS1NTS1ERCBISDI0Ok1JOlNTLkZGVFpIOlRaTSdcIjtcbiAgICAgICAgaWYgKGZvcm1hdFZhbHVlICE9PSBleHBlY3RlZEZvcm1hdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JtYXQgc3RyaW5nIGZvciBUT19USU1FU1RBTVBfVFouIEV4cGVjdGVkIGZvcm1hdDogJHtleHBlY3RlZEZvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gbW9tZW50KGRhdGVWYWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgWlwiKTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZERhdGUgIT09IGRhdGVWYWx1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSB2YWx1ZSBmb3IgVE9fVElNRVNUQU1QX1RaLiBFeHBlY3RlZCBmb3JtYXQ6ICdZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBaJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmdW5jdGlvbk5hbWUgPT09IFwiVE9fREFURVwiKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRm9ybWF0ID0gXCInWVlZWS9NTS9ERCdcIjtcbiAgICAgICAgaWYgKGZvcm1hdFZhbHVlICE9PSBleHBlY3RlZEZvcm1hdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JtYXQgc3RyaW5nIGZvciBUT19EQVRFLiBFeHBlY3RlZCBmb3JtYXQ6ICR7ZXhwZWN0ZWRGb3JtYXR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IG1vbWVudChkYXRlVmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgICAgIGlmIChmb3JtYXR0ZWREYXRlICE9PSBkYXRlVmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgdmFsdWUgZm9yIFRPX0RBVEUuIEV4cGVjdGVkIGZvcm1hdDogJ1lZWVktTU0tREQnXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvJy9nLCBcIicnXCIpO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9bXFwwXFxuXFxyXFxiXFx0XFxcXCdcIlxceDFhXS9nLCAocykgPT4ge1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgXCJcXDBcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcMFwiO1xuICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgIGNhc2UgXCJcXGJcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICBjYXNlIFwiXHRcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcdFwiO1xuICAgICAgICBjYXNlIFwiXHUwMDFhXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXFpcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYFxcXFwke3N9YDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYCR7KHByZXBlbmROID8gXCJOJ1wiIDogXCInXCIpICsgdmFsfSdgO1xufVxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG5mdW5jdGlvbiBmb3JtYXQoc3FsLCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0KSB7XG4gIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICBpZiAodHlwZW9mIHNxbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTUUwgc3RyaW5nIHByb3ZpZGVkOiAke3NxbH1gKTtcbiAgfVxuICByZXR1cm4gc3FsLnJlcGxhY2UoL1xcPy9nLCAobWF0Y2gpID0+IHtcbiAgICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZSh2YWx1ZXMuc2hpZnQoKSwgdGltZVpvbmUsIGRpYWxlY3QsIHRydWUpO1xuICB9KTtcbn1cbmV4cG9ydHMuZm9ybWF0ID0gZm9ybWF0O1xuZnVuY3Rpb24gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCkge1xuICByZXR1cm4gc3FsLnJlcGxhY2UoLzorKD8hXFxkKShcXHcrKS9nLCAodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmIChkaWFsZWN0ID09PSBcInBvc3RncmVzXCIgJiYgdmFsdWUuc2xpY2UoMCwgMikgPT09IFwiOjpcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWVzW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGVzY2FwZSh2YWx1ZXNba2V5XSwgdGltZVpvbmUsIGRpYWxlY3QsIHRydWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWVkIHBhcmFtZXRlciBcIiR7dmFsdWV9XCIgaGFzIG5vIHZhbHVlIGluIHRoZSBnaXZlbiBvYmplY3QuYCk7XG4gIH0pO1xufVxuZXhwb3J0cy5mb3JtYXROYW1lZFBhcmFtZXRlcnMgPSBmb3JtYXROYW1lZFBhcmFtZXRlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcWwtc3RyaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/sql-string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/table-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/table-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst TableHints = module.exports = {\n  NOLOCK: \"NOLOCK\",\n  READUNCOMMITTED: \"READUNCOMMITTED\",\n  UPDLOCK: \"UPDLOCK\",\n  REPEATABLEREAD: \"REPEATABLEREAD\",\n  SERIALIZABLE: \"SERIALIZABLE\",\n  READCOMMITTED: \"READCOMMITTED\",\n  TABLOCK: \"TABLOCK\",\n  TABLOCKX: \"TABLOCKX\",\n  PAGLOCK: \"PAGLOCK\",\n  ROWLOCK: \"ROWLOCK\",\n  NOWAIT: \"NOWAIT\",\n  READPAST: \"READPAST\",\n  XLOCK: \"XLOCK\",\n  SNAPSHOT: \"SNAPSHOT\",\n  NOEXPAND: \"NOEXPAND\"\n};\n//# sourceMappingURL=table-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90YWJsZS1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3RhYmxlLWhpbnRzLmpzP2E5NzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBUYWJsZUhpbnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIE5PTE9DSzogXCJOT0xPQ0tcIixcbiAgUkVBRFVOQ09NTUlUVEVEOiBcIlJFQURVTkNPTU1JVFRFRFwiLFxuICBVUERMT0NLOiBcIlVQRExPQ0tcIixcbiAgUkVQRUFUQUJMRVJFQUQ6IFwiUkVQRUFUQUJMRVJFQURcIixcbiAgU0VSSUFMSVpBQkxFOiBcIlNFUklBTElaQUJMRVwiLFxuICBSRUFEQ09NTUlUVEVEOiBcIlJFQURDT01NSVRURURcIixcbiAgVEFCTE9DSzogXCJUQUJMT0NLXCIsXG4gIFRBQkxPQ0tYOiBcIlRBQkxPQ0tYXCIsXG4gIFBBR0xPQ0s6IFwiUEFHTE9DS1wiLFxuICBST1dMT0NLOiBcIlJPV0xPQ0tcIixcbiAgTk9XQUlUOiBcIk5PV0FJVFwiLFxuICBSRUFEUEFTVDogXCJSRUFEUEFTVFwiLFxuICBYTE9DSzogXCJYTE9DS1wiLFxuICBTTkFQU0hPVDogXCJTTkFQU0hPVFwiLFxuICBOT0VYUEFORDogXCJOT0VYUEFORFwiXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFibGUtaGludHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/table-hints.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/transaction.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nclass Transaction {\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = __spreadValues({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options);\n    this.parent = this.options.transaction;\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n    delete this.options.transaction;\n  }\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Committing transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    } finally {\n      this.finished = \"commit\";\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n    if (!this.connection) {\n      throw new Error(\"Transaction cannot be rolled back because it never started\");\n    }\n    try {\n      await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Rolling back transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    }\n  }\n  async prepareEnvironment(useCLS = true) {\n    let connectionPromise;\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = \"SELECT\";\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr;\n      }\n    }\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set(\"transaction\", this);\n    }\n    return result;\n  }\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    return queryInterface.startTransaction(this, this.options);\n  }\n  cleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  async forceCleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n    if (cls) {\n      if (cls.get(\"transaction\") === this) {\n        cls.set(\"transaction\", null);\n      }\n    }\n  }\n  afterCommit(fn) {\n    if (!fn || typeof fn !== \"function\") {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n  static get TYPES() {\n    return {\n      DEFERRED: \"DEFERRED\",\n      IMMEDIATE: \"IMMEDIATE\",\n      EXCLUSIVE: \"EXCLUSIVE\"\n    };\n  }\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n      READ_COMMITTED: \"READ COMMITTED\",\n      REPEATABLE_READ: \"REPEATABLE READ\",\n      SERIALIZABLE: \"SERIALIZABLE\"\n    };\n  }\n  static get LOCK() {\n    return {\n      UPDATE: \"UPDATE\",\n      SHARE: \"SHARE\",\n      KEY_SHARE: \"KEY SHARE\",\n      NO_KEY_UPDATE: \"NO KEY UPDATE\"\n    };\n  }\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports[\"default\"] = Transaction;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLE1BQU0sOEJBQThCO0FBQ2pFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csY0FBYztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsU0FBUyxvQkFBb0IsMEJBQTBCO0FBQ3BHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxjQUFjO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxTQUFTLG9CQUFvQiwwQkFBMEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90cmFuc2FjdGlvbi5qcz85Y2ExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLnNhdmVwb2ludHMgPSBbXTtcbiAgICB0aGlzLl9hZnRlckNvbW1pdEhvb2tzID0gW107XG4gICAgY29uc3QgZ2VuZXJhdGVUcmFuc2FjdGlvbklkID0gdGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5nZW5lcmF0ZVRyYW5zYWN0aW9uSWQ7XG4gICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdHlwZTogc2VxdWVsaXplLm9wdGlvbnMudHJhbnNhY3Rpb25UeXBlLFxuICAgICAgaXNvbGF0aW9uTGV2ZWw6IHNlcXVlbGl6ZS5vcHRpb25zLmlzb2xhdGlvbkxldmVsLFxuICAgICAgcmVhZE9ubHk6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXJlbnQgPSB0aGlzLm9wdGlvbnMudHJhbnNhY3Rpb247XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5wYXJlbnQuaWQ7XG4gICAgICB0aGlzLnBhcmVudC5zYXZlcG9pbnRzLnB1c2godGhpcyk7XG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLmlkfS1zcC0ke3RoaXMucGFyZW50LnNhdmVwb2ludHMubGVuZ3RofWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLm5hbWUgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbjtcbiAgfVxuICBhc3luYyBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gY2Fubm90IGJlIGNvbW1pdHRlZCBiZWNhdXNlIGl0IGhhcyBiZWVuIGZpbmlzaGVkIHdpdGggc3RhdGU6ICR7dGhpcy5maW5pc2hlZH1gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkuY29tbWl0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ29tbWl0dGluZyB0cmFuc2FjdGlvbiAke3RoaXMuaWR9IGZhaWxlZCB3aXRoIGVycm9yICR7SlNPTi5zdHJpbmdpZnkoZS5tZXNzYWdlKX0uIFdlIGFyZSBraWxsaW5nIGl0cyBjb25uZWN0aW9uIGFzIGl0IGlzIG5vdyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGUuYCk7XG4gICAgICBhd2FpdCB0aGlzLmZvcmNlQ2xlYW51cCgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5maW5pc2hlZCA9IFwiY29tbWl0XCI7XG4gICAgICBmb3IgKGNvbnN0IGhvb2sgb2YgdGhpcy5fYWZ0ZXJDb21taXRIb29rcykge1xuICAgICAgICBhd2FpdCBob29rLmFwcGx5KHRoaXMsIFt0aGlzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHJvbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLmZpbmlzaGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGNhbm5vdCBiZSByb2xsZWQgYmFjayBiZWNhdXNlIGl0IGhhcyBiZWVuIGZpbmlzaGVkIHdpdGggc3RhdGU6ICR7dGhpcy5maW5pc2hlZH1gKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGNhbm5vdCBiZSByb2xsZWQgYmFjayBiZWNhdXNlIGl0IG5ldmVyIHN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpLnJvbGxiYWNrVHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgUm9sbGluZyBiYWNrIHRyYW5zYWN0aW9uICR7dGhpcy5pZH0gZmFpbGVkIHdpdGggZXJyb3IgJHtKU09OLnN0cmluZ2lmeShlLm1lc3NhZ2UpfS4gV2UgYXJlIGtpbGxpbmcgaXRzIGNvbm5lY3Rpb24gYXMgaXQgaXMgbm93IGluIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZS5gKTtcbiAgICAgIGF3YWl0IHRoaXMuZm9yY2VDbGVhbnVwKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcmVwYXJlRW52aXJvbm1lbnQodXNlQ0xTID0gdHJ1ZSkge1xuICAgIGxldCBjb25uZWN0aW9uUHJvbWlzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGNvbm5lY3Rpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMucGFyZW50LmNvbm5lY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhY3F1aXJlT3B0aW9ucyA9IHsgdXVpZDogdGhpcy5pZCB9O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICBhY3F1aXJlT3B0aW9ucy50eXBlID0gXCJTRUxFQ1RcIjtcbiAgICAgIH1cbiAgICAgIGNvbm5lY3Rpb25Qcm9taXNlID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbihhY3F1aXJlT3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5jb25uZWN0aW9uLnV1aWQgPSB0aGlzLmlkO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmJlZ2luKCk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNldERlZmVycmFibGUoKTtcbiAgICB9IGNhdGNoIChzZXR1cEVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5yb2xsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhyb3cgc2V0dXBFcnI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VDTFMgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5zZXQoXCJ0cmFuc2FjdGlvblwiLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBzZXREZWZlcnJhYmxlKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGVmZXJyYWJsZSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZGVmZXJDb25zdHJhaW50cyh0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBiZWdpbigpIHtcbiAgICBjb25zdCBxdWVyeUludGVyZmFjZSA9IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCk7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmRpYWxlY3Quc3VwcG9ydHMuc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgIGF3YWl0IHF1ZXJ5SW50ZXJmYWNlLnN0YXJ0VHJhbnNhY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHJldHVybiBxdWVyeUludGVyZmFjZS5zZXRJc29sYXRpb25MZXZlbCh0aGlzLCB0aGlzLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGF3YWl0IHF1ZXJ5SW50ZXJmYWNlLnNldElzb2xhdGlvbkxldmVsKHRoaXMsIHRoaXMub3B0aW9ucy5pc29sYXRpb25MZXZlbCwgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gcXVlcnlJbnRlcmZhY2Uuc3RhcnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMucGFyZW50IHx8IHRoaXMuY29ubmVjdGlvbi51dWlkID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xlYXJDbHMoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5yZWxlYXNlQ29ubmVjdGlvbih0aGlzLmNvbm5lY3Rpb24pO1xuICAgIHRoaXMuY29ubmVjdGlvbi51dWlkID0gdm9pZCAwO1xuICB9XG4gIGFzeW5jIGZvcmNlQ2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgfHwgdGhpcy5jb25uZWN0aW9uLnV1aWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNscygpO1xuICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmRlc3Ryb3lDb25uZWN0aW9uKHRoaXMuY29ubmVjdGlvbik7XG4gICAgdGhpcy5jb25uZWN0aW9uLnV1aWQgPSB2b2lkIDA7XG4gIH1cbiAgX2NsZWFyQ2xzKCkge1xuICAgIGNvbnN0IGNscyA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHM7XG4gICAgaWYgKGNscykge1xuICAgICAgaWYgKGNscy5nZXQoXCJ0cmFuc2FjdGlvblwiKSA9PT0gdGhpcykge1xuICAgICAgICBjbHMuc2V0KFwidHJhbnNhY3Rpb25cIiwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFmdGVyQ29tbWl0KGZuKSB7XG4gICAgaWYgKCFmbiB8fCB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImZuXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MucHVzaChmbik7XG4gIH1cbiAgc3RhdGljIGdldCBUWVBFUygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgREVGRVJSRUQ6IFwiREVGRVJSRURcIixcbiAgICAgIElNTUVESUFURTogXCJJTU1FRElBVEVcIixcbiAgICAgIEVYQ0xVU0lWRTogXCJFWENMVVNJVkVcIlxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldCBJU09MQVRJT05fTEVWRUxTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBSRUFEX1VOQ09NTUlUVEVEOiBcIlJFQUQgVU5DT01NSVRURURcIixcbiAgICAgIFJFQURfQ09NTUlUVEVEOiBcIlJFQUQgQ09NTUlUVEVEXCIsXG4gICAgICBSRVBFQVRBQkxFX1JFQUQ6IFwiUkVQRUFUQUJMRSBSRUFEXCIsXG4gICAgICBTRVJJQUxJWkFCTEU6IFwiU0VSSUFMSVpBQkxFXCJcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBnZXQgTE9DSygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgVVBEQVRFOiBcIlVQREFURVwiLFxuICAgICAgU0hBUkU6IFwiU0hBUkVcIixcbiAgICAgIEtFWV9TSEFSRTogXCJLRVkgU0hBUkVcIixcbiAgICAgIE5PX0tFWV9VUERBVEU6IFwiTk8gS0VZIFVQREFURVwiXG4gICAgfTtcbiAgfVxuICBnZXQgTE9DSygpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTE9DSztcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcbm1vZHVsZS5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNhY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2FjdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst SqlString = __webpack_require__(/*! ./sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ \"(rsc)/./node_modules/lodash/_baseIsNative.js\");\nconst uuidv1 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v1);\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst operators = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst operatorsSet = new Set(Object.values(operators));\nlet inflection = __webpack_require__(/*! inflection */ \"(rsc)/./node_modules/inflection/lib/inflection.js\");\nexports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ \"(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\").classToInvokable;\nexports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\").joinSQLFragments;\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\nfunction camelizeIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = camelize(str);\n  }\n  return result;\n}\nexports.camelizeIf = camelizeIf;\nfunction underscoredIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = underscore(str);\n  }\n  return result;\n}\nexports.underscoredIf = underscoredIf;\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return [\"string\", \"number\", \"boolean\"].includes(type);\n}\nexports.isPrimitive = isPrimitive;\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    if (!_.isPlainObject(objectValue) && objectValue !== void 0) {\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\nfunction merge() {\n  const result = {};\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== void 0) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.merge = merge;\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\nfunction format(arr, dialect) {\n  const timeZone = null;\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, (elem) => {\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return void 0;\n    }\n    if (onlyPlain || typeof elem === \"object\") {\n      return elem;\n    }\n    if (elem && typeof elem.clone === \"function\") {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter((v) => !Model._virtualAttributes.has(v));\n  }\n  mapOptionFieldNames(options, Model);\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map((attr) => {\n      if (typeof attr !== \"string\")\n        return attr;\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach((attribute) => {\n      const rawAttribute = Model.rawAttributes[attribute];\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n  for (const attr of fields) {\n    if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\nfunction isColString(value) {\n  return typeof value === \"string\" && value[0] === \"$\" && value[value.length - 1] === \"$\";\n}\nexports.isColString = isColString;\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some((arg) => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === \"function\") {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return __spreadValues({}, value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\nfunction defaultValueSchemable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n  return typeof value !== \"function\";\n}\nexports.defaultValueSchemable = defaultValueSchemable;\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n  if (omitNull) {\n    const _hash = {};\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith(\"Id\") || val !== null && val !== void 0) {\n        _hash[key] = val;\n      }\n    });\n    result = _hash;\n  }\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\nconst dialects = /* @__PURE__ */ new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\", \"db2\", \"oracle\"]);\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\nconst TICK_CHAR = \"`\";\nexports.TICK_CHAR = TICK_CHAR;\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, \"g\"), \"\");\n}\nexports.removeTicks = removeTicks;\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value))\n    return value;\n  const flattenedObj = {};\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach((key) => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === \"object\" && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n  return flattenObject(value, void 0);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\nclass SequelizeMethod {\n}\nexports.SequelizeMethod = SequelizeMethod;\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || \"\").trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === void 0) {\n      logic = comparator;\n      comparator = \"=\";\n    }\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter((s) => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach((key) => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\nfunction defaults(object, ...sources) {\n  object = Object(object);\n  sources.forEach((source) => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach((key) => {\n        const value = object[key];\n        if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\nexports.defaults = defaults;\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName)\n    tableName = tableName.tableName;\n  if (!Object.prototype.hasOwnProperty.call(index, \"name\")) {\n    const fields = index.fields.map((field) => typeof field === \"string\" ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join(\"_\")}`);\n  }\n  return index;\n}\nexports.nameIndex = nameIndex;\nfunction intersects(arr1, arr2) {\n  return arr1.some((v) => arr2.includes(v));\n}\nexports.intersects = intersects;\nfunction safeStringifyJson(value) {\n  return JSON.stringify(value, (key, value2) => {\n    if (typeof value2 === \"bigint\") {\n      return String(value2);\n    }\n    return value2;\n  });\n}\nexports.safeStringifyJson = safeStringifyJson;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIscUJBQXFCLG1CQUFPLENBQUMsMEVBQXNCO0FBQ25ELGVBQWUsd0ZBQWtCO0FBQ2pDLGVBQWUsd0ZBQWtCO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3ZDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscUVBQVk7QUFDckMsbUtBQWlGO0FBQ2pGLG1LQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsR0FBRyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsVUFBVSxHQUFHLFdBQVc7QUFDekM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSxHQUFHLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzLmpzPzA3ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgU3FsU3RyaW5nID0gcmVxdWlyZShcIi4vc3FsLXN0cmluZ1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgYmFzZUlzTmF0aXZlID0gcmVxdWlyZShcImxvZGFzaC9fYmFzZUlzTmF0aXZlXCIpO1xuY29uc3QgdXVpZHYxID0gcmVxdWlyZShcInV1aWRcIikudjE7XG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKFwidXVpZFwiKS52NDtcbmNvbnN0IG9wZXJhdG9ycyA9IHJlcXVpcmUoXCIuL29wZXJhdG9yc1wiKTtcbmNvbnN0IG9wZXJhdG9yc1NldCA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhvcGVyYXRvcnMpKTtcbmxldCBpbmZsZWN0aW9uID0gcmVxdWlyZShcImluZmxlY3Rpb25cIik7XG5leHBvcnRzLmNsYXNzVG9JbnZva2FibGUgPSByZXF1aXJlKFwiLi91dGlscy9jbGFzcy10by1pbnZva2FibGVcIikuY2xhc3NUb0ludm9rYWJsZTtcbmV4cG9ydHMuam9pblNRTEZyYWdtZW50cyA9IHJlcXVpcmUoXCIuL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50c1wiKS5qb2luU1FMRnJhZ21lbnRzO1xuZnVuY3Rpb24gdXNlSW5mbGVjdGlvbihfaW5mbGVjdGlvbikge1xuICBpbmZsZWN0aW9uID0gX2luZmxlY3Rpb247XG59XG5leHBvcnRzLnVzZUluZmxlY3Rpb24gPSB1c2VJbmZsZWN0aW9uO1xuZnVuY3Rpb24gY2FtZWxpemVJZihzdHIsIGNvbmRpdGlvbikge1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmVzdWx0ID0gY2FtZWxpemUoc3RyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5jYW1lbGl6ZUlmID0gY2FtZWxpemVJZjtcbmZ1bmN0aW9uIHVuZGVyc2NvcmVkSWYoc3RyLCBjb25kaXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IHN0cjtcbiAgaWYgKGNvbmRpdGlvbikge1xuICAgIHJlc3VsdCA9IHVuZGVyc2NvcmUoc3RyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51bmRlcnNjb3JlZElmID0gdW5kZXJzY29yZWRJZjtcbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJvb2xlYW5cIl0uaW5jbHVkZXModHlwZSk7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKGEsIGIpIHtcbiAgcmV0dXJuIF8ubWVyZ2VXaXRoKGEsIGIsIChvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpID0+IHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChvYmplY3RWYWx1ZSkgJiYgb2JqZWN0VmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmplY3RWYWx1ZSkgJiYgYmFzZUlzTmF0aXZlKG9iamVjdFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc291cmNlVmFsdWUgfHwgb2JqZWN0VmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VmFsdWU7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMubWVyZ2VEZWZhdWx0cyA9IG1lcmdlRGVmYXVsdHM7XG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3VtZW50cykge1xuICAgIF8uZm9yT3duKG9iaiwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghcmVzdWx0W2tleV0pIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgXy5pc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUuY29uY2F0KHJlc3VsdFtrZXldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmZ1bmN0aW9uIHNwbGljZVN0cihzdHIsIGluZGV4LCBjb3VudCwgYWRkKSB7XG4gIHJldHVybiBzdHIuc2xpY2UoMCwgaW5kZXgpICsgYWRkICsgc3RyLnNsaWNlKGluZGV4ICsgY291bnQpO1xufVxuZXhwb3J0cy5zcGxpY2VTdHIgPSBzcGxpY2VTdHI7XG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvWy1fXFxzXSsoLik/L2csIChtYXRjaCwgYykgPT4gYy50b1VwcGVyQ2FzZSgpKTtcbn1cbmV4cG9ydHMuY2FtZWxpemUgPSBjYW1lbGl6ZTtcbmZ1bmN0aW9uIHVuZGVyc2NvcmUoc3RyKSB7XG4gIHJldHVybiBpbmZsZWN0aW9uLnVuZGVyc2NvcmUoc3RyKTtcbn1cbmV4cG9ydHMudW5kZXJzY29yZSA9IHVuZGVyc2NvcmU7XG5mdW5jdGlvbiBzaW5ndWxhcml6ZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24uc2luZ3VsYXJpemUoc3RyKTtcbn1cbmV4cG9ydHMuc2luZ3VsYXJpemUgPSBzaW5ndWxhcml6ZTtcbmZ1bmN0aW9uIHBsdXJhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24ucGx1cmFsaXplKHN0cik7XG59XG5leHBvcnRzLnBsdXJhbGl6ZSA9IHBsdXJhbGl6ZTtcbmZ1bmN0aW9uIGZvcm1hdChhcnIsIGRpYWxlY3QpIHtcbiAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICByZXR1cm4gU3FsU3RyaW5nLmZvcm1hdChhcnJbMF0sIGFyci5zbGljZSgxKSwgdGltZVpvbmUsIGRpYWxlY3QpO1xufVxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5mdW5jdGlvbiBmb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCBwYXJhbWV0ZXJzLCBkaWFsZWN0KSB7XG4gIGNvbnN0IHRpbWVab25lID0gbnVsbDtcbiAgcmV0dXJuIFNxbFN0cmluZy5mb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCBwYXJhbWV0ZXJzLCB0aW1lWm9uZSwgZGlhbGVjdCk7XG59XG5leHBvcnRzLmZvcm1hdE5hbWVkUGFyYW1ldGVycyA9IGZvcm1hdE5hbWVkUGFyYW1ldGVycztcbmZ1bmN0aW9uIGNsb25lRGVlcChvYmosIG9ubHlQbGFpbikge1xuICBvYmogPSBvYmogfHwge307XG4gIHJldHVybiBfLmNsb25lRGVlcFdpdGgob2JqLCAoZWxlbSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW0pIHx8IF8uaXNQbGFpbk9iamVjdChlbGVtKSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKG9ubHlQbGFpbiB8fCB0eXBlb2YgZWxlbSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuICAgIGlmIChlbGVtICYmIHR5cGVvZiBlbGVtLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBlbGVtLmNsb25lKCk7XG4gICAgfVxuICB9KTtcbn1cbmV4cG9ydHMuY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuZnVuY3Rpb24gbWFwRmluZGVyT3B0aW9ucyhvcHRpb25zLCBNb2RlbCkge1xuICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IE1vZGVsLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5maWx0ZXIoKHYpID0+ICFNb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKHYpKTtcbiAgfVxuICBtYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIE1vZGVsKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLm1hcEZpbmRlck9wdGlvbnMgPSBtYXBGaW5kZXJPcHRpb25zO1xuZnVuY3Rpb24gbWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCBNb2RlbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgIGlmIChNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdICYmIGF0dHIgIT09IE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIFtNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkLCBhdHRyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLndoZXJlICYmIF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgIG9wdGlvbnMud2hlcmUgPSBtYXBXaGVyZUZpZWxkTmFtZXMob3B0aW9ucy53aGVyZSwgTW9kZWwpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5tYXBPcHRpb25GaWVsZE5hbWVzID0gbWFwT3B0aW9uRmllbGROYW1lcztcbmZ1bmN0aW9uIG1hcFdoZXJlRmllbGROYW1lcyhhdHRyaWJ1dGVzLCBNb2RlbCkge1xuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGF0dHJpYnV0ZXMgPSBjbG9uZURlZXAoYXR0cmlidXRlcyk7XG4gICAgZ2V0Q29tcGxleEtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgoYXR0cmlidXRlKSA9PiB7XG4gICAgICBjb25zdCByYXdBdHRyaWJ1dGUgPSBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICBpZiAocmF3QXR0cmlidXRlICYmIHJhd0F0dHJpYnV0ZS5maWVsZCAhPT0gcmF3QXR0cmlidXRlLmZpZWxkTmFtZSkge1xuICAgICAgICBhdHRyaWJ1dGVzW3Jhd0F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV07XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXNbYXR0cmlidXRlXSkgJiYgIShyYXdBdHRyaWJ1dGUgJiYgKHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkhTVE9SRSB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSkpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gbWFwT3B0aW9uRmllbGROYW1lcyh7XG4gICAgICAgICAgd2hlcmU6IGF0dHJpYnV0ZXNbYXR0cmlidXRlXVxuICAgICAgICB9LCBNb2RlbCkud2hlcmU7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlXS5mb3JFYWNoKCh3aGVyZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHdoZXJlKSkge1xuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdW2luZGV4XSA9IG1hcFdoZXJlRmllbGROYW1lcyh3aGVyZSwgTW9kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG5leHBvcnRzLm1hcFdoZXJlRmllbGROYW1lcyA9IG1hcFdoZXJlRmllbGROYW1lcztcbmZ1bmN0aW9uIG1hcFZhbHVlRmllbGROYW1lcyhkYXRhVmFsdWVzLCBmaWVsZHMsIE1vZGVsKSB7XG4gIGNvbnN0IHZhbHVlcyA9IHt9O1xuICBmb3IgKGNvbnN0IGF0dHIgb2YgZmllbGRzKSB7XG4gICAgaWYgKGRhdGFWYWx1ZXNbYXR0cl0gIT09IHZvaWQgMCAmJiAhTW9kZWwuX3ZpcnR1YWxBdHRyaWJ1dGVzLmhhcyhhdHRyKSkge1xuICAgICAgaWYgKE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCAmJiBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyKSB7XG4gICAgICAgIHZhbHVlc1tNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSA9IGRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNbYXR0cl0gPSBkYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0cy5tYXBWYWx1ZUZpZWxkTmFtZXMgPSBtYXBWYWx1ZUZpZWxkTmFtZXM7XG5mdW5jdGlvbiBpc0NvbFN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlWzBdID09PSBcIiRcIiAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gXCIkXCI7XG59XG5leHBvcnRzLmlzQ29sU3RyaW5nID0gaXNDb2xTdHJpbmc7XG5mdW5jdGlvbiBjYW5UcmVhdEFycmF5QXNBbmQoYXJyKSB7XG4gIHJldHVybiBhcnIuc29tZSgoYXJnKSA9PiBfLmlzUGxhaW5PYmplY3QoYXJnKSB8fCBhcmcgaW5zdGFuY2VvZiBXaGVyZSk7XG59XG5leHBvcnRzLmNhblRyZWF0QXJyYXlBc0FuZCA9IGNhblRyZWF0QXJyYXlBc0FuZDtcbmZ1bmN0aW9uIGNvbWJpbmVUYWJsZU5hbWVzKHRhYmxlTmFtZTEsIHRhYmxlTmFtZTIpIHtcbiAgcmV0dXJuIHRhYmxlTmFtZTEudG9Mb3dlckNhc2UoKSA8IHRhYmxlTmFtZTIudG9Mb3dlckNhc2UoKSA/IHRhYmxlTmFtZTEgKyB0YWJsZU5hbWUyIDogdGFibGVOYW1lMiArIHRhYmxlTmFtZTE7XG59XG5leHBvcnRzLmNvbWJpbmVUYWJsZU5hbWVzID0gY29tYmluZVRhYmxlTmFtZXM7XG5mdW5jdGlvbiB0b0RlZmF1bHRWYWx1ZSh2YWx1ZSwgZGlhbGVjdCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCB0bXAgPSB2YWx1ZSgpO1xuICAgIGlmICh0bXAgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQUJTVFJBQ1QpIHtcbiAgICAgIHJldHVybiB0bXAudG9TcWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRtcDtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFYxKSB7XG4gICAgcmV0dXJuIHV1aWR2MSgpO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjQpIHtcbiAgICByZXR1cm4gdXVpZHY0KCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLk5PVykge1xuICAgIHJldHVybiBub3coZGlhbGVjdCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbiAgaWYgKF8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoe30sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLnRvRGVmYXVsdFZhbHVlID0gdG9EZWZhdWx0VmFsdWU7XG5mdW5jdGlvbiBkZWZhdWx0VmFsdWVTY2hlbWFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLk5PVykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFYxIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnRzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZSA9IGRlZmF1bHRWYWx1ZVNjaGVtYWJsZTtcbmZ1bmN0aW9uIHJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaChoYXNoLCBvbWl0TnVsbCwgb3B0aW9ucykge1xuICBsZXQgcmVzdWx0ID0gaGFzaDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYWxsb3dOdWxsID0gb3B0aW9ucy5hbGxvd051bGwgfHwgW107XG4gIGlmIChvbWl0TnVsbCkge1xuICAgIGNvbnN0IF9oYXNoID0ge307XG4gICAgXy5mb3JJbihoYXNoLCAodmFsLCBrZXkpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmFsbG93TnVsbC5pbmNsdWRlcyhrZXkpIHx8IGtleS5lbmRzV2l0aChcIklkXCIpIHx8IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHZvaWQgMCkge1xuICAgICAgICBfaGFzaFtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdCA9IF9oYXNoO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaCA9IHJlbW92ZU51bGxWYWx1ZXNGcm9tSGFzaDtcbmNvbnN0IGRpYWxlY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wibWFyaWFkYlwiLCBcIm15c3FsXCIsIFwicG9zdGdyZXNcIiwgXCJzcWxpdGVcIiwgXCJtc3NxbFwiLCBcImRiMlwiLCBcIm9yYWNsZVwiXSk7XG5mdW5jdGlvbiBub3coZGlhbGVjdCkge1xuICBjb25zdCBkID0gbmV3IERhdGUoKTtcbiAgaWYgKCFkaWFsZWN0cy5oYXMoZGlhbGVjdCkpIHtcbiAgICBkLnNldE1pbGxpc2Vjb25kcygwKTtcbiAgfVxuICByZXR1cm4gZDtcbn1cbmV4cG9ydHMubm93ID0gbm93O1xuY29uc3QgVElDS19DSEFSID0gXCJgXCI7XG5leHBvcnRzLlRJQ0tfQ0hBUiA9IFRJQ0tfQ0hBUjtcbmZ1bmN0aW9uIGFkZFRpY2tzKHMsIHRpY2tDaGFyKSB7XG4gIHRpY2tDaGFyID0gdGlja0NoYXIgfHwgVElDS19DSEFSO1xuICByZXR1cm4gdGlja0NoYXIgKyByZW1vdmVUaWNrcyhzLCB0aWNrQ2hhcikgKyB0aWNrQ2hhcjtcbn1cbmV4cG9ydHMuYWRkVGlja3MgPSBhZGRUaWNrcztcbmZ1bmN0aW9uIHJlbW92ZVRpY2tzKHMsIHRpY2tDaGFyKSB7XG4gIHRpY2tDaGFyID0gdGlja0NoYXIgfHwgVElDS19DSEFSO1xuICByZXR1cm4gcy5yZXBsYWNlKG5ldyBSZWdFeHAodGlja0NoYXIsIFwiZ1wiKSwgXCJcIik7XG59XG5leHBvcnRzLnJlbW92ZVRpY2tzID0gcmVtb3ZlVGlja3M7XG5mdW5jdGlvbiBmbGF0dGVuT2JqZWN0RGVlcCh2YWx1ZSkge1xuICBpZiAoIV8uaXNQbGFpbk9iamVjdCh2YWx1ZSkpXG4gICAgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBmbGF0dGVuZWRPYmogPSB7fTtcbiAgZnVuY3Rpb24gZmxhdHRlbk9iamVjdChvYmosIHN1YlBhdGgpIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgcGF0aFRvUHJvcGVydHkgPSBzdWJQYXRoID8gYCR7c3ViUGF0aH0uJHtrZXl9YCA6IGtleTtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09IFwib2JqZWN0XCIgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgZmxhdHRlbk9iamVjdChvYmpba2V5XSwgcGF0aFRvUHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbmVkT2JqW3BhdGhUb1Byb3BlcnR5XSA9IF8uZ2V0KG9iaiwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmxhdHRlbmVkT2JqO1xuICB9XG4gIHJldHVybiBmbGF0dGVuT2JqZWN0KHZhbHVlLCB2b2lkIDApO1xufVxuZXhwb3J0cy5mbGF0dGVuT2JqZWN0RGVlcCA9IGZsYXR0ZW5PYmplY3REZWVwO1xuY2xhc3MgU2VxdWVsaXplTWV0aG9kIHtcbn1cbmV4cG9ydHMuU2VxdWVsaXplTWV0aG9kID0gU2VxdWVsaXplTWV0aG9kO1xuY2xhc3MgRm4gZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3RvcihmbiwgYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBGbih0aGlzLmZuLCB0aGlzLmFyZ3MpO1xuICB9XG59XG5leHBvcnRzLkZuID0gRm47XG5jbGFzcyBDb2wgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcihjb2wsIC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbCA9IGFyZ3M7XG4gICAgfVxuICAgIHRoaXMuY29sID0gY29sO1xuICB9XG59XG5leHBvcnRzLkNvbCA9IENvbDtcbmNsYXNzIENhc3QgZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcih2YWwsIHR5cGUsIGpzb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsID0gdmFsO1xuICAgIHRoaXMudHlwZSA9ICh0eXBlIHx8IFwiXCIpLnRyaW0oKTtcbiAgICB0aGlzLmpzb24gPSBqc29uIHx8IGZhbHNlO1xuICB9XG59XG5leHBvcnRzLkNhc3QgPSBDYXN0O1xuY2xhc3MgTGl0ZXJhbCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gIH1cbn1cbmV4cG9ydHMuTGl0ZXJhbCA9IExpdGVyYWw7XG5jbGFzcyBKc29uIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChfLmlzT2JqZWN0KGNvbmRpdGlvbnNPclBhdGgpKSB7XG4gICAgICB0aGlzLmNvbmRpdGlvbnMgPSBjb25kaXRpb25zT3JQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdGggPSBjb25kaXRpb25zT3JQYXRoO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuSnNvbiA9IEpzb247XG5jbGFzcyBXaGVyZSBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZSwgY29tcGFyYXRvciwgbG9naWMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChsb2dpYyA9PT0gdm9pZCAwKSB7XG4gICAgICBsb2dpYyA9IGNvbXBhcmF0b3I7XG4gICAgICBjb21wYXJhdG9yID0gXCI9XCI7XG4gICAgfVxuICAgIHRoaXMuYXR0cmlidXRlID0gYXR0cmlidXRlO1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gICAgdGhpcy5sb2dpYyA9IGxvZ2ljO1xuICB9XG59XG5leHBvcnRzLldoZXJlID0gV2hlcmU7XG5mdW5jdGlvbiBnZXRPcGVyYXRvcnMob2JqKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikuZmlsdGVyKChzKSA9PiBvcGVyYXRvcnNTZXQuaGFzKHMpKTtcbn1cbmV4cG9ydHMuZ2V0T3BlcmF0b3JzID0gZ2V0T3BlcmF0b3JzO1xuZnVuY3Rpb24gZ2V0Q29tcGxleEtleXMob2JqKSB7XG4gIHJldHVybiBnZXRPcGVyYXRvcnMob2JqKS5jb25jYXQoT2JqZWN0LmtleXMob2JqKSk7XG59XG5leHBvcnRzLmdldENvbXBsZXhLZXlzID0gZ2V0Q29tcGxleEtleXM7XG5mdW5jdGlvbiBnZXRDb21wbGV4U2l6ZShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBnZXRDb21wbGV4S2V5cyhvYmopLmxlbmd0aDtcbn1cbmV4cG9ydHMuZ2V0Q29tcGxleFNpemUgPSBnZXRDb21wbGV4U2l6ZTtcbmZ1bmN0aW9uIGlzV2hlcmVFbXB0eShvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmIF8uaXNFbXB0eShvYmopICYmIGdldE9wZXJhdG9ycyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNXaGVyZUVtcHR5ID0gaXNXaGVyZUVtcHR5O1xuZnVuY3Rpb24gZ2VuZXJhdGVFbnVtTmFtZSh0YWJsZU5hbWUsIGNvbHVtbk5hbWUpIHtcbiAgcmV0dXJuIGBlbnVtXyR7dGFibGVOYW1lfV8ke2NvbHVtbk5hbWV9YDtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVFbnVtTmFtZSA9IGdlbmVyYXRlRW51bU5hbWU7XG5mdW5jdGlvbiBjYW1lbGl6ZU9iamVjdEtleXMob2JqKSB7XG4gIGNvbnN0IG5ld09iaiA9IG5ldyBPYmplY3QoKTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBuZXdPYmpbY2FtZWxpemUoa2V5KV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiBuZXdPYmo7XG59XG5leHBvcnRzLmNhbWVsaXplT2JqZWN0S2V5cyA9IGNhbWVsaXplT2JqZWN0S2V5cztcbmZ1bmN0aW9uIGRlZmF1bHRzKG9iamVjdCwgLi4uc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBzb3VyY2UgPSBPYmplY3Qoc291cmNlKTtcbiAgICAgIGdldENvbXBsZXhLZXlzKHNvdXJjZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IF8uZXEodmFsdWUsIE9iamVjdC5wcm90b3R5cGVba2V5XSkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb2JqZWN0O1xufVxuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuZnVuY3Rpb24gbmFtZUluZGV4KGluZGV4LCB0YWJsZU5hbWUpIHtcbiAgaWYgKHRhYmxlTmFtZS50YWJsZU5hbWUpXG4gICAgdGFibGVOYW1lID0gdGFibGVOYW1lLnRhYmxlTmFtZTtcbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5kZXgsIFwibmFtZVwiKSkge1xuICAgIGNvbnN0IGZpZWxkcyA9IGluZGV4LmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIgPyBmaWVsZCA6IGZpZWxkLm5hbWUgfHwgZmllbGQuYXR0cmlidXRlKTtcbiAgICBpbmRleC5uYW1lID0gdW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7ZmllbGRzLmpvaW4oXCJfXCIpfWApO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cbmV4cG9ydHMubmFtZUluZGV4ID0gbmFtZUluZGV4O1xuZnVuY3Rpb24gaW50ZXJzZWN0cyhhcnIxLCBhcnIyKSB7XG4gIHJldHVybiBhcnIxLnNvbWUoKHYpID0+IGFycjIuaW5jbHVkZXModikpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3RzID0gaW50ZXJzZWN0cztcbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnlKc29uKHZhbHVlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlMjtcbiAgfSk7XG59XG5leHBvcnRzLnNhZmVTdHJpbmdpZnlKc29uID0gc2FmZVN0cmluZ2lmeUpzb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  classToInvokable: () => classToInvokable\n});\nfunction classToInvokable(Class) {\n  return new Proxy(Class, {\n    apply(_target, _thisArg, args) {\n      return new Class(...args);\n    },\n    construct(_target, args) {\n      return new Class(...args);\n    }\n  });\n}\n//# sourceMappingURL=class-to-invokable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9jbGFzcy10by1pbnZva2FibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZS5qcz8zZTFlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgY2xhc3NUb0ludm9rYWJsZTogKCkgPT4gY2xhc3NUb0ludm9rYWJsZVxufSk7XG5mdW5jdGlvbiBjbGFzc1RvSW52b2thYmxlKENsYXNzKSB7XG4gIHJldHVybiBuZXcgUHJveHkoQ2xhc3MsIHtcbiAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgYXJncykge1xuICAgICAgcmV0dXJuIG5ldyBDbGFzcyguLi5hcmdzKTtcbiAgICB9LFxuICAgIGNvbnN0cnVjdChfdGFyZ2V0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IENsYXNzKC4uLmFyZ3MpO1xuICAgIH1cbiAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGFzcy10by1pbnZva2FibGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/deprecations.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/deprecations.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  noBoolOperatorAliases: () => noBoolOperatorAliases,\n  noDoubleNestedGroup: () => noDoubleNestedGroup,\n  noStringOperators: () => noStringOperators,\n  noTrueLogging: () => noTrueLogging,\n  unsupportedEngine: () => unsupportedEngine\n});\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nconst noop = () => {\n};\nconst noTrueLogging = (0, import_util.deprecate)(noop, \"The logging-option should be either a function or false. Default: console.log\", \"SEQUELIZE0002\");\nconst noStringOperators = (0, import_util.deprecate)(noop, \"String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators\", \"SEQUELIZE0003\");\nconst noBoolOperatorAliases = (0, import_util.deprecate)(noop, \"A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.\", \"SEQUELIZE0004\");\nconst noDoubleNestedGroup = (0, import_util.deprecate)(noop, \"Passing a double nested nested array to `group` is unsupported and will be removed in v6.\", \"SEQUELIZE0005\");\nconst unsupportedEngine = (0, import_util.deprecate)(noop, \"This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md\", \"SEQUELIZE0006\");\n//# sourceMappingURL=deprecations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9kZXByZWNhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QixtQkFBTyxDQUFDLGtCQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9kZXByZWNhdGlvbnMuanM/M2MwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgbm9Cb29sT3BlcmF0b3JBbGlhc2VzOiAoKSA9PiBub0Jvb2xPcGVyYXRvckFsaWFzZXMsXG4gIG5vRG91YmxlTmVzdGVkR3JvdXA6ICgpID0+IG5vRG91YmxlTmVzdGVkR3JvdXAsXG4gIG5vU3RyaW5nT3BlcmF0b3JzOiAoKSA9PiBub1N0cmluZ09wZXJhdG9ycyxcbiAgbm9UcnVlTG9nZ2luZzogKCkgPT4gbm9UcnVlTG9nZ2luZyxcbiAgdW5zdXBwb3J0ZWRFbmdpbmU6ICgpID0+IHVuc3VwcG9ydGVkRW5naW5lXG59KTtcbnZhciBpbXBvcnRfdXRpbCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInV0aWxcIikpO1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5jb25zdCBub1RydWVMb2dnaW5nID0gKDAsIGltcG9ydF91dGlsLmRlcHJlY2F0ZSkobm9vcCwgXCJUaGUgbG9nZ2luZy1vcHRpb24gc2hvdWxkIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGZhbHNlLiBEZWZhdWx0OiBjb25zb2xlLmxvZ1wiLCBcIlNFUVVFTElaRTAwMDJcIik7XG5jb25zdCBub1N0cmluZ09wZXJhdG9ycyA9ICgwLCBpbXBvcnRfdXRpbC5kZXByZWNhdGUpKG5vb3AsIFwiU3RyaW5nIGJhc2VkIG9wZXJhdG9ycyBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBTeW1ib2wgYmFzZWQgb3BlcmF0b3JzIGZvciBiZXR0ZXIgc2VjdXJpdHksIHJlYWQgbW9yZSBhdCBodHRwczovL3NlcXVlbGl6ZS5vcmcvbWFzdGVyL21hbnVhbC9xdWVyeWluZy5odG1sI29wZXJhdG9yc1wiLCBcIlNFUVVFTElaRTAwMDNcIik7XG5jb25zdCBub0Jvb2xPcGVyYXRvckFsaWFzZXMgPSAoMCwgaW1wb3J0X3V0aWwuZGVwcmVjYXRlKShub29wLCBcIkEgYm9vbGVhbiB2YWx1ZSB3YXMgcGFzc2VkIHRvIG9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcy4gVGhpcyBpcyBhIG5vLW9wIHdpdGggdjUgYW5kIHNob3VsZCBiZSByZW1vdmVkLlwiLCBcIlNFUVVFTElaRTAwMDRcIik7XG5jb25zdCBub0RvdWJsZU5lc3RlZEdyb3VwID0gKDAsIGltcG9ydF91dGlsLmRlcHJlY2F0ZSkobm9vcCwgXCJQYXNzaW5nIGEgZG91YmxlIG5lc3RlZCBuZXN0ZWQgYXJyYXkgdG8gYGdyb3VwYCBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY2LlwiLCBcIlNFUVVFTElaRTAwMDVcIik7XG5jb25zdCB1bnN1cHBvcnRlZEVuZ2luZSA9ICgwLCBpbXBvcnRfdXRpbC5kZXByZWNhdGUpKG5vb3AsIFwiVGhpcyBkYXRhYmFzZSBlbmdpbmUgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgdXBkYXRlIHlvdXIgZGF0YWJhc2Ugc2VydmVyLiBNb3JlIGluZm9ybWF0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2Jsb2IvbWFpbi9FTkdJTkUubWRcIiwgXCJTRVFVRUxJWkUwMDA2XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRpb25zLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  JoinSQLFragmentsError: () => JoinSQLFragmentsError,\n  joinSQLFragments: () => joinSQLFragments\n});\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: \"\"\n  }).result;\n}\nfunction joinSQLFragments(array) {\n  if (array.length === 0)\n    return \"\";\n  const truthyArray = array.filter((x) => !!x);\n  const flattenedArray = truthyArray.map((fragment) => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n    return fragment;\n  });\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== \"string\") {\n      throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n    }\n  }\n  const trimmedArray = flattenedArray.map((x) => x.trim());\n  const nonEmptyStringArray = trimmedArray.filter((x) => x !== \"\");\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\nclass JoinSQLFragmentsError extends TypeError {\n  constructor(args, fragment, message) {\n    super(message);\n    __publicField(this, \"args\");\n    __publicField(this, \"fragment\");\n    this.args = args;\n    this.fragment = fragment;\n    this.name = \"JoinSQLFragmentsError\";\n  }\n}\n//# sourceMappingURL=join-sql-fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMElBQTBJLFNBQVM7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2pvaW4tc3FsLWZyYWdtZW50cy5qcz9jZDM2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBKb2luU1FMRnJhZ21lbnRzRXJyb3I6ICgpID0+IEpvaW5TUUxGcmFnbWVudHNFcnJvcixcbiAgam9pblNRTEZyYWdtZW50czogKCkgPT4gam9pblNRTEZyYWdtZW50c1xufSk7XG5mdW5jdGlvbiBkb2VzTm90V2FudExlYWRpbmdTcGFjZShzdHIpIHtcbiAgcmV0dXJuIC9eWzssKV0vLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGRvZXNOb3RXYW50VHJhaWxpbmdTcGFjZShzdHIpIHtcbiAgcmV0dXJuIC9cXCgkLy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBzaW5nbGVTcGFjZUpvaW5IZWxwZXIocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnJlZHVjZSgoeyBza2lwTmV4dExlYWRpbmdTcGFjZSwgcmVzdWx0IH0sIHBhcnQpID0+IHtcbiAgICBpZiAoc2tpcE5leHRMZWFkaW5nU3BhY2UgfHwgZG9lc05vdFdhbnRMZWFkaW5nU3BhY2UocGFydCkpIHtcbiAgICAgIHJlc3VsdCArPSBwYXJ0LnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IGAgJHtwYXJ0LnRyaW0oKX1gO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2tpcE5leHRMZWFkaW5nU3BhY2U6IGRvZXNOb3RXYW50VHJhaWxpbmdTcGFjZShwYXJ0KSxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH0sIHtcbiAgICBza2lwTmV4dExlYWRpbmdTcGFjZTogdHJ1ZSxcbiAgICByZXN1bHQ6IFwiXCJcbiAgfSkucmVzdWx0O1xufVxuZnVuY3Rpb24gam9pblNRTEZyYWdtZW50cyhhcnJheSkge1xuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCB0cnV0aHlBcnJheSA9IGFycmF5LmZpbHRlcigoeCkgPT4gISF4KTtcbiAgY29uc3QgZmxhdHRlbmVkQXJyYXkgPSB0cnV0aHlBcnJheS5tYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZnJhZ21lbnQpKSB7XG4gICAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhmcmFnbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSk7XG4gIGZvciAoY29uc3QgZnJhZ21lbnQgb2YgZmxhdHRlbmVkQXJyYXkpIHtcbiAgICBpZiAoZnJhZ21lbnQgJiYgdHlwZW9mIGZyYWdtZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgSm9pblNRTEZyYWdtZW50c0Vycm9yKGZsYXR0ZW5lZEFycmF5LCBmcmFnbWVudCwgYFRyaWVkIHRvIGNvbnN0cnVjdCBhIFNRTCBzdHJpbmcgd2l0aCBhIG5vbi1zdHJpbmcsIG5vbi1mYWxzeSBmcmFnbWVudCAoJHtmcmFnbWVudH0pLmApO1xuICAgIH1cbiAgfVxuICBjb25zdCB0cmltbWVkQXJyYXkgPSBmbGF0dGVuZWRBcnJheS5tYXAoKHgpID0+IHgudHJpbSgpKTtcbiAgY29uc3Qgbm9uRW1wdHlTdHJpbmdBcnJheSA9IHRyaW1tZWRBcnJheS5maWx0ZXIoKHgpID0+IHggIT09IFwiXCIpO1xuICByZXR1cm4gc2luZ2xlU3BhY2VKb2luSGVscGVyKG5vbkVtcHR5U3RyaW5nQXJyYXkpO1xufVxuY2xhc3MgSm9pblNRTEZyYWdtZW50c0Vycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoYXJncywgZnJhZ21lbnQsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXJnc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZnJhZ21lbnRcIik7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgdGhpcy5uYW1lID0gXCJKb2luU1FMRnJhZ21lbnRzRXJyb3JcIjtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9am9pbi1zcWwtZnJhZ21lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/logger.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  Logger: () => Logger,\n  logger: () => logger\n});\nvar import_debug = __toModule(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nclass Logger {\n  constructor(_a = {}) {\n    __publicField(this, \"config\");\n    var _b = _a, { context = \"sequelize\" } = _b, rest = __objRest(_b, [\"context\"]);\n    this.config = __spreadValues({\n      context\n    }, rest);\n  }\n  warn(message) {\n    console.warn(`(${this.config.context}) Warning: ${message}`);\n  }\n  inspect(value) {\n    return import_util.default.inspect(value, {\n      showHidden: false,\n      depth: 1\n    });\n  }\n  debugContext(name) {\n    return (0, import_debug.default)(`${this.config.context}:${name}`);\n  }\n}\nconst logger = new Logger();\n//# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLG1CQUFPLENBQUMsc0RBQU87QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsa0JBQU07QUFDM0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0IsYUFBYSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IsR0FBRyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemlxdWUtYXNzaXN0YW50LXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvbG9nZ2VyLmpzPzhiMzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fb2JqUmVzdCA9IChzb3VyY2UsIGV4Y2x1ZGUpID0+IHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoc291cmNlLCBwcm9wKSAmJiBleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICBpZiAoc291cmNlICE9IG51bGwgJiYgX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoc291cmNlKSkge1xuICAgICAgaWYgKGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDAgJiYgX19wcm9wSXNFbnVtLmNhbGwoc291cmNlLCBwcm9wKSlcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBMb2dnZXI6ICgpID0+IExvZ2dlcixcbiAgbG9nZ2VyOiAoKSA9PiBsb2dnZXJcbn0pO1xudmFyIGltcG9ydF9kZWJ1ZyA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImRlYnVnXCIpKTtcbnZhciBpbXBvcnRfdXRpbCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcInV0aWxcIikpO1xuY2xhc3MgTG9nZ2VyIHtcbiAgY29uc3RydWN0b3IoX2EgPSB7fSkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25maWdcIik7XG4gICAgdmFyIF9iID0gX2EsIHsgY29udGV4dCA9IFwic2VxdWVsaXplXCIgfSA9IF9iLCByZXN0ID0gX19vYmpSZXN0KF9iLCBbXCJjb250ZXh0XCJdKTtcbiAgICB0aGlzLmNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGNvbnRleHRcbiAgICB9LCByZXN0KTtcbiAgfVxuICB3YXJuKG1lc3NhZ2UpIHtcbiAgICBjb25zb2xlLndhcm4oYCgke3RoaXMuY29uZmlnLmNvbnRleHR9KSBXYXJuaW5nOiAke21lc3NhZ2V9YCk7XG4gIH1cbiAgaW5zcGVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbXBvcnRfdXRpbC5kZWZhdWx0Lmluc3BlY3QodmFsdWUsIHtcbiAgICAgIHNob3dIaWRkZW46IGZhbHNlLFxuICAgICAgZGVwdGg6IDFcbiAgICB9KTtcbiAgfVxuICBkZWJ1Z0NvbnRleHQobmFtZSkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X2RlYnVnLmRlZmF1bHQpKGAke3RoaXMuY29uZmlnLmNvbnRleHR9OiR7bmFtZX1gKTtcbiAgfVxufVxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/sql.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/sql.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  injectReplacements: () => injectReplacements\n});\nvar import_isPlainObject = __toModule(__webpack_require__(/*! lodash/isPlainObject */ \"(rsc)/./node_modules/lodash/isPlainObject.js\"));\nvar import_sql_string = __toModule(__webpack_require__(/*! ../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\"));\nfunction injectReplacements(sqlString, dialect, replacements) {\n  var _a, _b, _c, _d;\n  if (replacements == null) {\n    return sqlString;\n  }\n  if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n  const isNamedReplacements = (0, import_isPlainObject.default)(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n  let output = \"\";\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n      continue;\n    }\n    if (isString) {\n      if (char === \"'\" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n      continue;\n    }\n    if (currentDollarStringTagName !== null) {\n      if (char !== \"$\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      const tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || \"\";\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n      continue;\n    }\n    if (isSingleLineComment) {\n      if (char === \"\\n\") {\n        isSingleLineComment = false;\n      }\n      continue;\n    }\n    if (isCommentBlock) {\n      if (char === \"*\" && sqlString[i + 1] === \"/\") {\n        isCommentBlock = false;\n      }\n      continue;\n    }\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n    if (char === \"'\") {\n      isString = true;\n      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === \"E\" || sqlString[i - 1] === \"e\") && canPrecedeNewToken(sqlString[i - 2]);\n      continue;\n    }\n    if (char === \"-\" && sqlString.slice(i, i + 3) === \"-- \") {\n      isSingleLineComment = true;\n      continue;\n    }\n    if (char === \"/\" && sqlString.slice(i, i + 2) === \"/*\") {\n      isCommentBlock = true;\n      continue;\n    }\n    if (char === \"$\") {\n      const previousChar = sqlString[i - 1];\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = (_c = (_b = dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : \"\";\n        i += dollarStringStartMatch[0].length - 1;\n        continue;\n      }\n      continue;\n    }\n    if (isNamedReplacements && char === \":\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;\n      if (!replacementName) {\n        continue;\n      }\n      const replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + replacementName.length + 1;\n      output += escapedReplacement;\n      continue;\n    }\n    if (isPositionalReplacements && char === \"?\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const nextChar = sqlString[i + 1];\n      if (nextChar === \"|\" || nextChar === \"&\") {\n        continue;\n      }\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n      if (replacementValue === void 0) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + 1;\n      output += escapedReplacement;\n    }\n  }\n  if (isString) {\n    throw new Error(`The following SQL query includes an unterminated string literal:\n${sqlString}`);\n  }\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n  return output;\n}\nfunction canPrecedeNewToken(char) {\n  return char === void 0 || /[\\s(>,=]/.test(char);\n}\nfunction isBackslashEscaped(string, pos) {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== \"\\\\\") {\n      break;\n    }\n    escaped = !escaped;\n  }\n  return escaped;\n}\n//# sourceMappingURL=sql.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9zcWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsbUJBQU8sQ0FBQywwRUFBc0I7QUFDcEUsbUNBQW1DLG1CQUFPLENBQUMsdUVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLDhCQUE4QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQixvREFBb0QsaUJBQWlCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsVUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL3NxbC5qcz81NzlkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBpbmplY3RSZXBsYWNlbWVudHM6ICgpID0+IGluamVjdFJlcGxhY2VtZW50c1xufSk7XG52YXIgaW1wb3J0X2lzUGxhaW5PYmplY3QgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSk7XG52YXIgaW1wb3J0X3NxbF9zdHJpbmcgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi9zcWwtc3RyaW5nXCIpKTtcbmZ1bmN0aW9uIGluamVjdFJlcGxhY2VtZW50cyhzcWxTdHJpbmcsIGRpYWxlY3QsIHJlcGxhY2VtZW50cykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIGlmIChyZXBsYWNlbWVudHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBzcWxTdHJpbmc7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50cykgJiYgISgwLCBpbXBvcnRfaXNQbGFpbk9iamVjdC5kZWZhdWx0KShyZXBsYWNlbWVudHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJyZXBsYWNlbWVudHNcIiBtdXN0IGJlIGFuIGFycmF5IG9yIGEgcGxhaW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShyZXBsYWNlbWVudHMpfSBpbnN0ZWFkLmApO1xuICB9XG4gIGNvbnN0IGlzTmFtZWRSZXBsYWNlbWVudHMgPSAoMCwgaW1wb3J0X2lzUGxhaW5PYmplY3QuZGVmYXVsdCkocmVwbGFjZW1lbnRzKTtcbiAgY29uc3QgaXNQb3NpdGlvbmFsUmVwbGFjZW1lbnRzID0gQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudHMpO1xuICBsZXQgbGFzdENvbnN1bWVkUG9zaXRpb25hbFJlcGxhY2VtZW50SW5kZXggPSAtMTtcbiAgbGV0IG91dHB1dCA9IFwiXCI7XG4gIGxldCBjdXJyZW50RG9sbGFyU3RyaW5nVGFnTmFtZSA9IG51bGw7XG4gIGxldCBpc1N0cmluZyA9IGZhbHNlO1xuICBsZXQgaXNDb2x1bW4gPSBmYWxzZTtcbiAgbGV0IHByZXZpb3VzU2xpY2VFbmQgPSAwO1xuICBsZXQgaXNTaW5nbGVMaW5lQ29tbWVudCA9IGZhbHNlO1xuICBsZXQgaXNDb21tZW50QmxvY2sgPSBmYWxzZTtcbiAgbGV0IHN0cmluZ0lzQmFja3NsYXNoRXNjYXBhYmxlID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3FsU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHNxbFN0cmluZ1tpXTtcbiAgICBpZiAoaXNDb2x1bW4pIHtcbiAgICAgIGlmIChjaGFyID09PSBkaWFsZWN0LlRJQ0tfQ0hBUl9SSUdIVCkge1xuICAgICAgICBpc0NvbHVtbiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgaWYgKGNoYXIgPT09IFwiJ1wiICYmICghc3RyaW5nSXNCYWNrc2xhc2hFc2NhcGFibGUgfHwgIWlzQmFja3NsYXNoRXNjYXBlZChzcWxTdHJpbmcsIGkgLSAxKSkpIHtcbiAgICAgICAgaXNTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RyaW5nSXNCYWNrc2xhc2hFc2NhcGFibGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERvbGxhclN0cmluZ1RhZ05hbWUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGFyICE9PSBcIiRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbWFpbmluZ1N0cmluZyA9IHNxbFN0cmluZy5zbGljZShpLCBzcWxTdHJpbmcubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2ggPSByZW1haW5pbmdTdHJpbmcubWF0Y2goL15cXCQoPzxuYW1lPlthLXpfXVswLTlhLXpfXSopPyhcXCQpL2kpO1xuICAgICAgY29uc3QgdGFnTmFtZSA9ICgoX2EgPSBkb2xsYXJTdHJpbmdTdGFydE1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBkb2xsYXJTdHJpbmdTdGFydE1hdGNoLmdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWUpIHx8IFwiXCI7XG4gICAgICBpZiAoY3VycmVudERvbGxhclN0cmluZ1RhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgY3VycmVudERvbGxhclN0cmluZ1RhZ05hbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc1NpbmdsZUxpbmVDb21tZW50KSB7XG4gICAgICBpZiAoY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBpc1NpbmdsZUxpbmVDb21tZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzQ29tbWVudEJsb2NrKSB7XG4gICAgICBpZiAoY2hhciA9PT0gXCIqXCIgJiYgc3FsU3RyaW5nW2kgKyAxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaXNDb21tZW50QmxvY2sgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gZGlhbGVjdC5USUNLX0NIQVJfTEVGVCkge1xuICAgICAgaXNDb2x1bW4gPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIidcIikge1xuICAgICAgaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgc3RyaW5nSXNCYWNrc2xhc2hFc2NhcGFibGUgPSBkaWFsZWN0LmNhbkJhY2tzbGFzaEVzY2FwZSgpIHx8IGRpYWxlY3Quc3VwcG9ydHMuZXNjYXBlU3RyaW5nQ29uc3RhbnRzICYmIChzcWxTdHJpbmdbaSAtIDFdID09PSBcIkVcIiB8fCBzcWxTdHJpbmdbaSAtIDFdID09PSBcImVcIikgJiYgY2FuUHJlY2VkZU5ld1Rva2VuKHNxbFN0cmluZ1tpIC0gMl0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIi1cIiAmJiBzcWxTdHJpbmcuc2xpY2UoaSwgaSArIDMpID09PSBcIi0tIFwiKSB7XG4gICAgICBpc1NpbmdsZUxpbmVDb21tZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCIvXCIgJiYgc3FsU3RyaW5nLnNsaWNlKGksIGkgKyAyKSA9PT0gXCIvKlwiKSB7XG4gICAgICBpc0NvbW1lbnRCbG9jayA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NoYXIgPSBzcWxTdHJpbmdbaSAtIDFdO1xuICAgICAgaWYgKC9bMC05YS16X10vaS50ZXN0KHByZXZpb3VzQ2hhcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1haW5pbmdTdHJpbmcgPSBzcWxTdHJpbmcuc2xpY2UoaSwgc3FsU3RyaW5nLmxlbmd0aCk7XG4gICAgICBjb25zdCBkb2xsYXJTdHJpbmdTdGFydE1hdGNoID0gcmVtYWluaW5nU3RyaW5nLm1hdGNoKC9eXFwkKD88bmFtZT5bYS16X11bMC05YS16X10qKT8oXFwkKS9pKTtcbiAgICAgIGlmIChkb2xsYXJTdHJpbmdTdGFydE1hdGNoKSB7XG4gICAgICAgIGN1cnJlbnREb2xsYXJTdHJpbmdUYWdOYW1lID0gKF9jID0gKF9iID0gZG9sbGFyU3RyaW5nU3RhcnRNYXRjaC5ncm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSAhPSBudWxsID8gX2MgOiBcIlwiO1xuICAgICAgICBpICs9IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzTmFtZWRSZXBsYWNlbWVudHMgJiYgY2hhciA9PT0gXCI6XCIpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hhciA9IHNxbFN0cmluZ1tpIC0gMV07XG4gICAgICBpZiAoIWNhblByZWNlZGVOZXdUb2tlbihwcmV2aW91c0NoYXIpICYmIHByZXZpb3VzQ2hhciAhPT0gXCJbXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZW1haW5pbmdTdHJpbmcgPSBzcWxTdHJpbmcuc2xpY2UoaSwgc3FsU3RyaW5nLmxlbmd0aCk7XG4gICAgICBjb25zdCBtYXRjaCA9IHJlbWFpbmluZ1N0cmluZy5tYXRjaCgvXjooPzxuYW1lPlthLXpfXVswLTlhLXpfXSopKD86XFwpfCx8JHxcXHN8Ojp8O3xdKS9pKTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50TmFtZSA9IChfZCA9IG1hdGNoID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaC5ncm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5uYW1lO1xuICAgICAgaWYgKCFyZXBsYWNlbWVudE5hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXBsYWNlbWVudFZhbHVlID0gcmVwbGFjZW1lbnRzW3JlcGxhY2VtZW50TmFtZV07XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXBsYWNlbWVudHMsIHJlcGxhY2VtZW50TmFtZSkgfHwgcmVwbGFjZW1lbnRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZWQgcmVwbGFjZW1lbnQgXCI6JHtyZXBsYWNlbWVudE5hbWV9XCIgaGFzIG5vIGVudHJ5IGluIHRoZSByZXBsYWNlbWVudCBtYXAuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlc2NhcGVkUmVwbGFjZW1lbnQgPSAoMCwgaW1wb3J0X3NxbF9zdHJpbmcuZXNjYXBlKShyZXBsYWNlbWVudFZhbHVlLCB2b2lkIDAsIGRpYWxlY3QubmFtZSwgdHJ1ZSk7XG4gICAgICBvdXRwdXQgKz0gc3FsU3RyaW5nLnNsaWNlKHByZXZpb3VzU2xpY2VFbmQsIGkpO1xuICAgICAgcHJldmlvdXNTbGljZUVuZCA9IGkgKyByZXBsYWNlbWVudE5hbWUubGVuZ3RoICsgMTtcbiAgICAgIG91dHB1dCArPSBlc2NhcGVkUmVwbGFjZW1lbnQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzUG9zaXRpb25hbFJlcGxhY2VtZW50cyAmJiBjaGFyID09PSBcIj9cIikge1xuICAgICAgY29uc3QgcHJldmlvdXNDaGFyID0gc3FsU3RyaW5nW2kgLSAxXTtcbiAgICAgIGlmICghY2FuUHJlY2VkZU5ld1Rva2VuKHByZXZpb3VzQ2hhcikgJiYgcHJldmlvdXNDaGFyICE9PSBcIltcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRDaGFyID0gc3FsU3RyaW5nW2kgKyAxXTtcbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCJ8XCIgfHwgbmV4dENoYXIgPT09IFwiJlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVwbGFjZW1lbnRJbmRleCA9ICsrbGFzdENvbnN1bWVkUG9zaXRpb25hbFJlcGxhY2VtZW50SW5kZXg7XG4gICAgICBjb25zdCByZXBsYWNlbWVudFZhbHVlID0gcmVwbGFjZW1lbnRzW2xhc3RDb25zdW1lZFBvc2l0aW9uYWxSZXBsYWNlbWVudEluZGV4XTtcbiAgICAgIGlmIChyZXBsYWNlbWVudFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb3NpdGlvbmFsIHJlcGxhY2VtZW50ICg/KSAke3JlcGxhY2VtZW50SW5kZXh9IGhhcyBubyBlbnRyeSBpbiB0aGUgcmVwbGFjZW1lbnQgbWFwIChyZXBsYWNlbWVudHNbJHtyZXBsYWNlbWVudEluZGV4fV0gaXMgdW5kZWZpbmVkKS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzY2FwZWRSZXBsYWNlbWVudCA9ICgwLCBpbXBvcnRfc3FsX3N0cmluZy5lc2NhcGUpKHJlcGxhY2VtZW50VmFsdWUsIHZvaWQgMCwgZGlhbGVjdC5uYW1lLCB0cnVlKTtcbiAgICAgIG91dHB1dCArPSBzcWxTdHJpbmcuc2xpY2UocHJldmlvdXNTbGljZUVuZCwgaSk7XG4gICAgICBwcmV2aW91c1NsaWNlRW5kID0gaSArIDE7XG4gICAgICBvdXRwdXQgKz0gZXNjYXBlZFJlcGxhY2VtZW50O1xuICAgIH1cbiAgfVxuICBpZiAoaXNTdHJpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgU1FMIHF1ZXJ5IGluY2x1ZGVzIGFuIHVudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbDpcbiR7c3FsU3RyaW5nfWApO1xuICB9XG4gIG91dHB1dCArPSBzcWxTdHJpbmcuc2xpY2UocHJldmlvdXNTbGljZUVuZCwgc3FsU3RyaW5nLmxlbmd0aCk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjYW5QcmVjZWRlTmV3VG9rZW4oY2hhcikge1xuICByZXR1cm4gY2hhciA9PT0gdm9pZCAwIHx8IC9bXFxzKD4sPV0vLnRlc3QoY2hhcik7XG59XG5mdW5jdGlvbiBpc0JhY2tzbGFzaEVzY2FwZWQoc3RyaW5nLCBwb3MpIHtcbiAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IHBvczsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBjaGFyID0gc3RyaW5nW2ldO1xuICAgIGlmIChjaGFyICE9PSBcIlxcXFxcIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgfVxuICByZXR1cm4gZXNjYXBlZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNxbC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/sql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/validator-extras.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst validator = _.cloneDeep(__webpack_require__(/*! validator */ \"(rsc)/./node_modules/validator/index.js\"));\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += \"\";\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== \"RegExp\") {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== \"\" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\nvalidator.notNull = function(val) {\n  return val !== null && val !== void 0;\n};\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\nvalidator.isNull = validator.isEmpty;\nvalidator.isDate = function(dateString) {\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    return false;\n  }\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\nexports.validator = validator;\n//# sourceMappingURL=validator-extras.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy92YWxpZGF0b3ItZXh0cmFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLDhCQUE4QixtQkFBTyxDQUFDLDBEQUFXO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96aXF1ZS1hc3Npc3RhbnQtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy92YWxpZGF0b3ItZXh0cmFzLmpzP2NkODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHZhbGlkYXRvciA9IF8uY2xvbmVEZWVwKHJlcXVpcmUoXCJ2YWxpZGF0b3JcIikpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IGV4dGVuc2lvbnMgPSB7XG4gIGV4dGVuZChuYW1lLCBmbikge1xuICAgIHRoaXNbbmFtZV0gPSBmbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm90RW1wdHkoc3RyKSB7XG4gICAgcmV0dXJuICFzdHIubWF0Y2goL15bXFxzXFx0XFxyXFxuXSokLyk7XG4gIH0sXG4gIGxlbihzdHIsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZW5ndGgoc3RyLCBtaW4sIG1heCk7XG4gIH0sXG4gIGlzVXJsKHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzVVJMKHN0cik7XG4gIH0sXG4gIGlzSVB2NihzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0lQKHN0ciwgNik7XG4gIH0sXG4gIGlzSVB2NChzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0lQKHN0ciwgNCk7XG4gIH0sXG4gIG5vdEluKHN0ciwgdmFsdWVzKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzSW4oc3RyLCB2YWx1ZXMpO1xuICB9LFxuICByZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHN0ciArPSBcIlwiO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF0dGVybikuc2xpY2UoOCwgLTEpICE9PSBcIlJlZ0V4cFwiKSB7XG4gICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLm1hdGNoKHBhdHRlcm4pO1xuICB9LFxuICBub3RSZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiAhdGhpcy5yZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH0sXG4gIGlzRGVjaW1hbChzdHIpIHtcbiAgICByZXR1cm4gc3RyICE9PSBcIlwiICYmICEhc3RyLm1hdGNoKC9eKD86LT8oPzpbMC05XSspKT8oPzpcXC5bMC05XSopPyg/OltlRV1bKy1dPyg/OlswLTldKykpPyQvKTtcbiAgfSxcbiAgbWluKHN0ciwgdmFsKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiBpc05hTihudW1iZXIpIHx8IG51bWJlciA+PSB2YWw7XG4gIH0sXG4gIG1heChzdHIsIHZhbCkge1xuICAgIGNvbnN0IG51bWJlciA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gaXNOYU4obnVtYmVyKSB8fCBudW1iZXIgPD0gdmFsO1xuICB9LFxuICBub3Qoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RSZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH0sXG4gIGNvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAgIHJldHVybiAhIWVsZW0gJiYgc3RyLmluY2x1ZGVzKGVsZW0pO1xuICB9LFxuICBub3RDb250YWlucyhzdHIsIGVsZW0pIHtcbiAgICByZXR1cm4gIXRoaXMuY29udGFpbnMoc3RyLCBlbGVtKTtcbiAgfSxcbiAgaXMoc3RyLCBwYXR0ZXJuLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdleChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gIH1cbn07XG5leHBvcnRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xudmFsaWRhdG9yLmlzSW1tdXRhYmxlID0gZnVuY3Rpb24odmFsdWUsIHZhbGlkYXRvckFyZ3MsIGZpZWxkLCBtb2RlbEluc3RhbmNlKSB7XG4gIHJldHVybiBtb2RlbEluc3RhbmNlLmlzTmV3UmVjb3JkIHx8IG1vZGVsSW5zdGFuY2UuZGF0YVZhbHVlc1tmaWVsZF0gPT09IG1vZGVsSW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1tmaWVsZF07XG59O1xudmFsaWRhdG9yLm5vdE51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHZvaWQgMDtcbn07XG5fLmZvckVhY2goZXh0ZW5zaW9ucywgKGV4dGVuZCwga2V5KSA9PiB7XG4gIHZhbGlkYXRvcltrZXldID0gZXh0ZW5kO1xufSk7XG52YWxpZGF0b3IuaXNOdWxsID0gdmFsaWRhdG9yLmlzRW1wdHk7XG52YWxpZGF0b3IuaXNEYXRlID0gZnVuY3Rpb24oZGF0ZVN0cmluZykge1xuICBjb25zdCBwYXJzZWQgPSBEYXRlLnBhcnNlKGRhdGVTdHJpbmcpO1xuICBpZiAoaXNOYU4ocGFyc2VkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBkYXRlID0gbmV3IERhdGUocGFyc2VkKTtcbiAgcmV0dXJuIG1vbWVudChkYXRlLnRvSVNPU3RyaW5nKCkpLmlzVmFsaWQoKTtcbn07XG5leHBvcnRzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRvci1leHRyYXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/sequelize/lib/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ABSTRACT: () => (/* binding */ ABSTRACT),\n/* harmony export */   ARRAY: () => (/* binding */ ARRAY),\n/* harmony export */   AccessDeniedError: () => (/* binding */ AccessDeniedError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   Association: () => (/* binding */ Association),\n/* harmony export */   AssociationError: () => (/* binding */ AssociationError),\n/* harmony export */   AsyncQueueError: () => (/* binding */ AsyncQueueError),\n/* harmony export */   BIGINT: () => (/* binding */ BIGINT),\n/* harmony export */   BLOB: () => (/* binding */ BLOB),\n/* harmony export */   BOOLEAN: () => (/* binding */ BOOLEAN),\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   BelongsTo: () => (/* binding */ BelongsTo),\n/* harmony export */   BelongsToMany: () => (/* binding */ BelongsToMany),\n/* harmony export */   BulkRecordError: () => (/* binding */ BulkRecordError),\n/* harmony export */   CHAR: () => (/* binding */ CHAR),\n/* harmony export */   CIDR: () => (/* binding */ CIDR),\n/* harmony export */   CITEXT: () => (/* binding */ CITEXT),\n/* harmony export */   ConnectionAcquireTimeoutError: () => (/* binding */ ConnectionAcquireTimeoutError),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionRefusedError: () => (/* binding */ ConnectionRefusedError),\n/* harmony export */   ConnectionTimedOutError: () => (/* binding */ ConnectionTimedOutError),\n/* harmony export */   DATE: () => (/* binding */ DATE),\n/* harmony export */   DATEONLY: () => (/* binding */ DATEONLY),\n/* harmony export */   DECIMAL: () => (/* binding */ DECIMAL),\n/* harmony export */   DOUBLE: () => (/* binding */ DOUBLE),\n/* harmony export */   DataTypes: () => (/* binding */ DataTypes),\n/* harmony export */   DatabaseError: () => (/* binding */ DatabaseError),\n/* harmony export */   Deferrable: () => (/* binding */ Deferrable),\n/* harmony export */   ENUM: () => (/* binding */ ENUM),\n/* harmony export */   EagerLoadingError: () => (/* binding */ EagerLoadingError),\n/* harmony export */   EmptyResultError: () => (/* binding */ EmptyResultError),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   ExclusionConstraintError: () => (/* binding */ ExclusionConstraintError),\n/* harmony export */   FLOAT: () => (/* binding */ FLOAT),\n/* harmony export */   ForeignKeyConstraintError: () => (/* binding */ ForeignKeyConstraintError),\n/* harmony export */   GEOGRAPHY: () => (/* binding */ GEOGRAPHY),\n/* harmony export */   GEOMETRY: () => (/* binding */ GEOMETRY),\n/* harmony export */   HSTORE: () => (/* binding */ HSTORE),\n/* harmony export */   HasMany: () => (/* binding */ HasMany),\n/* harmony export */   HasOne: () => (/* binding */ HasOne),\n/* harmony export */   HostNotFoundError: () => (/* binding */ HostNotFoundError),\n/* harmony export */   HostNotReachableError: () => (/* binding */ HostNotReachableError),\n/* harmony export */   INET: () => (/* binding */ INET),\n/* harmony export */   INTEGER: () => (/* binding */ INTEGER),\n/* harmony export */   IndexHints: () => (/* binding */ IndexHints),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InvalidConnectionError: () => (/* binding */ InvalidConnectionError),\n/* harmony export */   JSON: () => (/* binding */ JSON),\n/* harmony export */   JSONB: () => (/* binding */ JSONB),\n/* harmony export */   MACADDR: () => (/* binding */ MACADDR),\n/* harmony export */   MEDIUMINT: () => (/* binding */ MEDIUMINT),\n/* harmony export */   Model: () => (/* binding */ Model),\n/* harmony export */   NOW: () => (/* binding */ NOW),\n/* harmony export */   NUMBER: () => (/* binding */ NUMBER),\n/* harmony export */   NUMERIC: () => (/* binding */ NUMERIC),\n/* harmony export */   Op: () => (/* binding */ Op),\n/* harmony export */   OptimisticLockError: () => (/* binding */ OptimisticLockError),\n/* harmony export */   QueryError: () => (/* binding */ QueryError),\n/* harmony export */   QueryInterface: () => (/* binding */ QueryInterface),\n/* harmony export */   QueryTypes: () => (/* binding */ QueryTypes),\n/* harmony export */   RANGE: () => (/* binding */ RANGE),\n/* harmony export */   REAL: () => (/* binding */ REAL),\n/* harmony export */   SMALLINT: () => (/* binding */ SMALLINT),\n/* harmony export */   STRING: () => (/* binding */ STRING),\n/* harmony export */   Sequelize: () => (/* binding */ Sequelize),\n/* harmony export */   SequelizeScopeError: () => (/* binding */ SequelizeScopeError),\n/* harmony export */   TEXT: () => (/* binding */ TEXT),\n/* harmony export */   TIME: () => (/* binding */ TIME),\n/* harmony export */   TINYINT: () => (/* binding */ TINYINT),\n/* harmony export */   TSVECTOR: () => (/* binding */ TSVECTOR),\n/* harmony export */   TableHints: () => (/* binding */ TableHints),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UUID: () => (/* binding */ UUID),\n/* harmony export */   UUIDV1: () => (/* binding */ UUIDV1),\n/* harmony export */   UUIDV4: () => (/* binding */ UUIDV4),\n/* harmony export */   UniqueConstraintError: () => (/* binding */ UniqueConstraintError),\n/* harmony export */   UnknownConstraintError: () => (/* binding */ UnknownConstraintError),\n/* harmony export */   Utils: () => (/* binding */ Utils),\n/* harmony export */   VIRTUAL: () => (/* binding */ VIRTUAL),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   ValidationErrorItem: () => (/* binding */ ValidationErrorItem),\n/* harmony export */   ValidationErrorItemOrigin: () => (/* binding */ ValidationErrorItemOrigin),\n/* harmony export */   ValidationErrorItemType: () => (/* binding */ ValidationErrorItemType),\n/* harmony export */   Validator: () => (/* binding */ Validator),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   cast: () => (/* binding */ cast),\n/* harmony export */   col: () => (/* binding */ col),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fn: () => (/* binding */ fn),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   useInflection: () => (/* binding */ useInflection),\n/* harmony export */   where: () => (/* binding */ where)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/sequelize/lib/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// export * from './lib/sequelize';\nconst Sequelize = _index_js__WEBPACK_IMPORTED_MODULE_0__.Sequelize;\nconst fn = _index_js__WEBPACK_IMPORTED_MODULE_0__.fn;\nconst col = _index_js__WEBPACK_IMPORTED_MODULE_0__.col;\nconst cast = _index_js__WEBPACK_IMPORTED_MODULE_0__.cast;\nconst literal = _index_js__WEBPACK_IMPORTED_MODULE_0__.literal;\nconst and = _index_js__WEBPACK_IMPORTED_MODULE_0__.and;\nconst or = _index_js__WEBPACK_IMPORTED_MODULE_0__.or;\nconst json = _index_js__WEBPACK_IMPORTED_MODULE_0__.json;\nconst where = _index_js__WEBPACK_IMPORTED_MODULE_0__.where;\n\n// export * from './lib/query-interface';\nconst QueryInterface = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryInterface;\n\n// export * from './lib/data-types';\n// 'DOUBLE PRECISION' is missing because its name is not a valid export identifier.\nconst ABSTRACT = _index_js__WEBPACK_IMPORTED_MODULE_0__.ABSTRACT;\nconst STRING = _index_js__WEBPACK_IMPORTED_MODULE_0__.STRING;\nconst CHAR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CHAR;\nconst TEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TEXT;\nconst NUMBER = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMBER;\nconst TINYINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TINYINT;\nconst SMALLINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.SMALLINT;\nconst MEDIUMINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.MEDIUMINT;\nconst INTEGER = _index_js__WEBPACK_IMPORTED_MODULE_0__.INTEGER;\nconst BIGINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.BIGINT;\nconst FLOAT = _index_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT;\nconst TIME = _index_js__WEBPACK_IMPORTED_MODULE_0__.TIME;\nconst DATE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATE;\nconst DATEONLY = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATEONLY;\nconst BOOLEAN = _index_js__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN;\nconst NOW = _index_js__WEBPACK_IMPORTED_MODULE_0__.NOW;\nconst BLOB = _index_js__WEBPACK_IMPORTED_MODULE_0__.BLOB;\nconst DECIMAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL;\nconst NUMERIC = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMERIC;\nconst UUID = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUID;\nconst UUIDV1 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV1;\nconst UUIDV4 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV4;\nconst HSTORE = _index_js__WEBPACK_IMPORTED_MODULE_0__.HSTORE;\nconst JSON = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSON;\nconst JSONB = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSONB;\nconst VIRTUAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.VIRTUAL;\nconst ARRAY = _index_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY;\nconst ENUM = _index_js__WEBPACK_IMPORTED_MODULE_0__.ENUM;\nconst RANGE = _index_js__WEBPACK_IMPORTED_MODULE_0__.RANGE;\nconst REAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.REAL;\nconst DOUBLE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DOUBLE;\nconst GEOMETRY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY;\nconst GEOGRAPHY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOGRAPHY;\nconst CIDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CIDR;\nconst INET = _index_js__WEBPACK_IMPORTED_MODULE_0__.INET;\nconst MACADDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.MACADDR;\nconst CITEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.CITEXT;\nconst TSVECTOR = _index_js__WEBPACK_IMPORTED_MODULE_0__.TSVECTOR;\n\n// export * from './lib/model';\nconst Model = _index_js__WEBPACK_IMPORTED_MODULE_0__.Model;\n\n// export * from './lib/transaction';\nconst Transaction = _index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction;\n\n// export * from './lib/associations/index';\nconst Association = _index_js__WEBPACK_IMPORTED_MODULE_0__.Association;\nconst BelongsTo = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsTo;\nconst HasOne = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasOne;\nconst HasMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasMany;\nconst BelongsToMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsToMany;\n\n// export * from './lib/errors';\nconst BaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BaseError;\n\nconst AggregateError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AggregateError;\nconst AsyncQueueError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncQueueError;\nconst AssociationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AssociationError;\nconst BulkRecordError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BulkRecordError;\nconst ConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionError;\nconst DatabaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.DatabaseError;\nconst EagerLoadingError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EagerLoadingError;\nconst EmptyResultError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EmptyResultError;\nconst InstanceError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InstanceError;\nconst OptimisticLockError = _index_js__WEBPACK_IMPORTED_MODULE_0__.OptimisticLockError;\nconst QueryError = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryError;\nconst SequelizeScopeError = _index_js__WEBPACK_IMPORTED_MODULE_0__.SequelizeScopeError;\nconst ValidationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationError;\nconst ValidationErrorItem = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItem;\n\nconst AccessDeniedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AccessDeniedError;\nconst ConnectionAcquireTimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionAcquireTimeoutError;\nconst ConnectionRefusedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionRefusedError;\nconst ConnectionTimedOutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionTimedOutError;\nconst HostNotFoundError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotFoundError;\nconst HostNotReachableError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotReachableError;\nconst InvalidConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InvalidConnectionError;\n\nconst ExclusionConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ExclusionConstraintError;\nconst ForeignKeyConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ForeignKeyConstraintError;\nconst TimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError;\nconst UnknownConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UnknownConstraintError;\n\nconst UniqueConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UniqueConstraintError;\n\n// export { BaseError as Error } from './lib/errors';\nconst Error = _index_js__WEBPACK_IMPORTED_MODULE_0__.Error;\n\n// export { useInflection } from './lib/utils';\nconst useInflection = _index_js__WEBPACK_IMPORTED_MODULE_0__.useInflection;\n\n// export { Utils, QueryTypes, Op, TableHints, IndexHints, DataTypes, Deferrable };\nconst Utils = _index_js__WEBPACK_IMPORTED_MODULE_0__.Utils;\nconst QueryTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryTypes;\nconst Op = _index_js__WEBPACK_IMPORTED_MODULE_0__.Op;\nconst TableHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.TableHints;\nconst IndexHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.IndexHints;\nconst DataTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.DataTypes;\nconst Deferrable = _index_js__WEBPACK_IMPORTED_MODULE_0__.Deferrable;\n\n// export { Validator as validator } from './lib/utils/validator-extras';\nconst Validator = _index_js__WEBPACK_IMPORTED_MODULE_0__.Validator;\n\nconst ValidationErrorItemOrigin = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemOrigin;\nconst ValidationErrorItemType = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCOztBQUU3QixpRUFBZSxzQ0FBRyxFQUFDOztBQUVuQjtBQUNPLGtCQUFrQixnREFBYTtBQUMvQixXQUFXLHlDQUFNO0FBQ2pCLFlBQVksMENBQU87QUFDbkIsYUFBYSwyQ0FBUTtBQUNyQixnQkFBZ0IsOENBQVc7QUFDM0IsWUFBWSwwQ0FBTztBQUNuQixXQUFXLHlDQUFNO0FBQ2pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUzs7QUFFOUI7QUFDTyx1QkFBdUIscURBQWtCOztBQUVoRDtBQUNBO0FBQ08saUJBQWlCLCtDQUFZO0FBQzdCLGVBQWUsNkNBQVU7QUFDekIsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsZ0JBQWdCLDhDQUFXO0FBQzNCLGVBQWUsNkNBQVU7QUFDekIsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGFBQWEsMkNBQVE7QUFDckIsaUJBQWlCLCtDQUFZO0FBQzdCLGdCQUFnQiw4Q0FBVztBQUMzQixZQUFZLDBDQUFPO0FBQ25CLGFBQWEsMkNBQVE7QUFDckIsZ0JBQWdCLDhDQUFXO0FBQzNCLGdCQUFnQiw4Q0FBVztBQUMzQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZUFBZSw2Q0FBVTtBQUN6QixlQUFlLDZDQUFVO0FBQ3pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUztBQUN2QixnQkFBZ0IsOENBQVc7QUFDM0IsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGNBQWMsNENBQVM7QUFDdkIsYUFBYSwyQ0FBUTtBQUNyQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGdCQUFnQiw4Q0FBVztBQUMzQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTs7QUFFcEM7QUFDTyxjQUFjLDRDQUFTOztBQUU5QjtBQUNPLG9CQUFvQixrREFBZTs7QUFFMUM7QUFDTyxvQkFBb0Isa0RBQWU7QUFDbkMsa0JBQWtCLGdEQUFhO0FBQy9CLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLHNCQUFzQixvREFBaUI7O0FBRTlDO0FBQ08sa0JBQWtCLGdEQUFhOztBQUUvQix1QkFBdUIscURBQWtCO0FBQ3pDLHdCQUF3QixzREFBbUI7QUFDM0MseUJBQXlCLHVEQUFvQjtBQUM3Qyx3QkFBd0Isc0RBQW1CO0FBQzNDLHdCQUF3QixzREFBbUI7QUFDM0Msc0JBQXNCLG9EQUFpQjtBQUN2QywwQkFBMEIsd0RBQXFCO0FBQy9DLHlCQUF5Qix1REFBb0I7QUFDN0Msc0JBQXNCLG9EQUFpQjtBQUN2Qyw0QkFBNEIsMERBQXVCO0FBQ25ELG1CQUFtQixpREFBYztBQUNqQyw0QkFBNEIsMERBQXVCO0FBQ25ELHdCQUF3QixzREFBbUI7QUFDM0MsNEJBQTRCLDBEQUF1Qjs7QUFFbkQsMEJBQTBCLHdEQUFxQjtBQUMvQyxzQ0FBc0Msb0VBQWlDO0FBQ3ZFLCtCQUErQiw2REFBMEI7QUFDekQsZ0NBQWdDLDhEQUEyQjtBQUMzRCwwQkFBMEIsd0RBQXFCO0FBQy9DLDhCQUE4Qiw0REFBeUI7QUFDdkQsK0JBQStCLDZEQUEwQjs7QUFFekQsaUNBQWlDLCtEQUE0QjtBQUM3RCxrQ0FBa0MsZ0VBQTZCO0FBQy9ELHFCQUFxQixtREFBZ0I7QUFDckMsK0JBQStCLDZEQUEwQjs7QUFFekQsOEJBQThCLDREQUF5Qjs7QUFFOUQsWUFBWSxxQkFBcUI7QUFDMUIsY0FBYyw0Q0FBUzs7QUFFOUIsWUFBWSxnQkFBZ0I7QUFDckIsc0JBQXNCLG9EQUFpQjs7QUFFOUMsWUFBWTtBQUNMLGNBQWMsNENBQVM7QUFDdkIsbUJBQW1CLGlEQUFjO0FBQ2pDLFdBQVcseUNBQU07QUFDakIsbUJBQW1CLGlEQUFjO0FBQ2pDLG1CQUFtQixpREFBYztBQUNqQyxrQkFBa0IsZ0RBQWE7QUFDL0IsbUJBQW1CLGlEQUFjOztBQUV4QyxZQUFZLHlCQUF5QjtBQUM5QixrQkFBa0IsZ0RBQWE7O0FBRS9CLGtDQUFrQyxnRUFBNkI7QUFDL0QsZ0NBQWdDLDhEQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ppcXVlLWFzc2lzdGFudC1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2luZGV4Lm1qcz81YTEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQa2cgZnJvbSAnLi9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IFBrZztcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvc2VxdWVsaXplJztcbmV4cG9ydCBjb25zdCBTZXF1ZWxpemUgPSBQa2cuU2VxdWVsaXplO1xuZXhwb3J0IGNvbnN0IGZuID0gUGtnLmZuO1xuZXhwb3J0IGNvbnN0IGNvbCA9IFBrZy5jb2w7XG5leHBvcnQgY29uc3QgY2FzdCA9IFBrZy5jYXN0O1xuZXhwb3J0IGNvbnN0IGxpdGVyYWwgPSBQa2cubGl0ZXJhbDtcbmV4cG9ydCBjb25zdCBhbmQgPSBQa2cuYW5kO1xuZXhwb3J0IGNvbnN0IG9yID0gUGtnLm9yO1xuZXhwb3J0IGNvbnN0IGpzb24gPSBQa2cuanNvbjtcbmV4cG9ydCBjb25zdCB3aGVyZSA9IFBrZy53aGVyZTtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvcXVlcnktaW50ZXJmYWNlJztcbmV4cG9ydCBjb25zdCBRdWVyeUludGVyZmFjZSA9IFBrZy5RdWVyeUludGVyZmFjZTtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvZGF0YS10eXBlcyc7XG4vLyAnRE9VQkxFIFBSRUNJU0lPTicgaXMgbWlzc2luZyBiZWNhdXNlIGl0cyBuYW1lIGlzIG5vdCBhIHZhbGlkIGV4cG9ydCBpZGVudGlmaWVyLlxuZXhwb3J0IGNvbnN0IEFCU1RSQUNUID0gUGtnLkFCU1RSQUNUO1xuZXhwb3J0IGNvbnN0IFNUUklORyA9IFBrZy5TVFJJTkc7XG5leHBvcnQgY29uc3QgQ0hBUiA9IFBrZy5DSEFSO1xuZXhwb3J0IGNvbnN0IFRFWFQgPSBQa2cuVEVYVDtcbmV4cG9ydCBjb25zdCBOVU1CRVIgPSBQa2cuTlVNQkVSO1xuZXhwb3J0IGNvbnN0IFRJTllJTlQgPSBQa2cuVElOWUlOVDtcbmV4cG9ydCBjb25zdCBTTUFMTElOVCA9IFBrZy5TTUFMTElOVDtcbmV4cG9ydCBjb25zdCBNRURJVU1JTlQgPSBQa2cuTUVESVVNSU5UO1xuZXhwb3J0IGNvbnN0IElOVEVHRVIgPSBQa2cuSU5URUdFUjtcbmV4cG9ydCBjb25zdCBCSUdJTlQgPSBQa2cuQklHSU5UO1xuZXhwb3J0IGNvbnN0IEZMT0FUID0gUGtnLkZMT0FUO1xuZXhwb3J0IGNvbnN0IFRJTUUgPSBQa2cuVElNRTtcbmV4cG9ydCBjb25zdCBEQVRFID0gUGtnLkRBVEU7XG5leHBvcnQgY29uc3QgREFURU9OTFkgPSBQa2cuREFURU9OTFk7XG5leHBvcnQgY29uc3QgQk9PTEVBTiA9IFBrZy5CT09MRUFOO1xuZXhwb3J0IGNvbnN0IE5PVyA9IFBrZy5OT1c7XG5leHBvcnQgY29uc3QgQkxPQiA9IFBrZy5CTE9CO1xuZXhwb3J0IGNvbnN0IERFQ0lNQUwgPSBQa2cuREVDSU1BTDtcbmV4cG9ydCBjb25zdCBOVU1FUklDID0gUGtnLk5VTUVSSUM7XG5leHBvcnQgY29uc3QgVVVJRCA9IFBrZy5VVUlEO1xuZXhwb3J0IGNvbnN0IFVVSURWMSA9IFBrZy5VVUlEVjE7XG5leHBvcnQgY29uc3QgVVVJRFY0ID0gUGtnLlVVSURWNDtcbmV4cG9ydCBjb25zdCBIU1RPUkUgPSBQa2cuSFNUT1JFO1xuZXhwb3J0IGNvbnN0IEpTT04gPSBQa2cuSlNPTjtcbmV4cG9ydCBjb25zdCBKU09OQiA9IFBrZy5KU09OQjtcbmV4cG9ydCBjb25zdCBWSVJUVUFMID0gUGtnLlZJUlRVQUw7XG5leHBvcnQgY29uc3QgQVJSQVkgPSBQa2cuQVJSQVk7XG5leHBvcnQgY29uc3QgRU5VTSA9IFBrZy5FTlVNO1xuZXhwb3J0IGNvbnN0IFJBTkdFID0gUGtnLlJBTkdFO1xuZXhwb3J0IGNvbnN0IFJFQUwgPSBQa2cuUkVBTDtcbmV4cG9ydCBjb25zdCBET1VCTEUgPSBQa2cuRE9VQkxFO1xuZXhwb3J0IGNvbnN0IEdFT01FVFJZID0gUGtnLkdFT01FVFJZO1xuZXhwb3J0IGNvbnN0IEdFT0dSQVBIWSA9IFBrZy5HRU9HUkFQSFk7XG5leHBvcnQgY29uc3QgQ0lEUiA9IFBrZy5DSURSO1xuZXhwb3J0IGNvbnN0IElORVQgPSBQa2cuSU5FVDtcbmV4cG9ydCBjb25zdCBNQUNBRERSID0gUGtnLk1BQ0FERFI7XG5leHBvcnQgY29uc3QgQ0lURVhUID0gUGtnLkNJVEVYVDtcbmV4cG9ydCBjb25zdCBUU1ZFQ1RPUiA9IFBrZy5UU1ZFQ1RPUjtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvbW9kZWwnO1xuZXhwb3J0IGNvbnN0IE1vZGVsID0gUGtnLk1vZGVsO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi90cmFuc2FjdGlvbic7XG5leHBvcnQgY29uc3QgVHJhbnNhY3Rpb24gPSBQa2cuVHJhbnNhY3Rpb247XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL2Fzc29jaWF0aW9ucy9pbmRleCc7XG5leHBvcnQgY29uc3QgQXNzb2NpYXRpb24gPSBQa2cuQXNzb2NpYXRpb247XG5leHBvcnQgY29uc3QgQmVsb25nc1RvID0gUGtnLkJlbG9uZ3NUbztcbmV4cG9ydCBjb25zdCBIYXNPbmUgPSBQa2cuSGFzT25lO1xuZXhwb3J0IGNvbnN0IEhhc01hbnkgPSBQa2cuSGFzTWFueTtcbmV4cG9ydCBjb25zdCBCZWxvbmdzVG9NYW55ID0gUGtnLkJlbG9uZ3NUb01hbnk7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgY29uc3QgQmFzZUVycm9yID0gUGtnLkJhc2VFcnJvcjtcblxuZXhwb3J0IGNvbnN0IEFnZ3JlZ2F0ZUVycm9yID0gUGtnLkFnZ3JlZ2F0ZUVycm9yO1xuZXhwb3J0IGNvbnN0IEFzeW5jUXVldWVFcnJvciA9IFBrZy5Bc3luY1F1ZXVlRXJyb3I7XG5leHBvcnQgY29uc3QgQXNzb2NpYXRpb25FcnJvciA9IFBrZy5Bc3NvY2lhdGlvbkVycm9yO1xuZXhwb3J0IGNvbnN0IEJ1bGtSZWNvcmRFcnJvciA9IFBrZy5CdWxrUmVjb3JkRXJyb3I7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvbkVycm9yID0gUGtnLkNvbm5lY3Rpb25FcnJvcjtcbmV4cG9ydCBjb25zdCBEYXRhYmFzZUVycm9yID0gUGtnLkRhdGFiYXNlRXJyb3I7XG5leHBvcnQgY29uc3QgRWFnZXJMb2FkaW5nRXJyb3IgPSBQa2cuRWFnZXJMb2FkaW5nRXJyb3I7XG5leHBvcnQgY29uc3QgRW1wdHlSZXN1bHRFcnJvciA9IFBrZy5FbXB0eVJlc3VsdEVycm9yO1xuZXhwb3J0IGNvbnN0IEluc3RhbmNlRXJyb3IgPSBQa2cuSW5zdGFuY2VFcnJvcjtcbmV4cG9ydCBjb25zdCBPcHRpbWlzdGljTG9ja0Vycm9yID0gUGtnLk9wdGltaXN0aWNMb2NrRXJyb3I7XG5leHBvcnQgY29uc3QgUXVlcnlFcnJvciA9IFBrZy5RdWVyeUVycm9yO1xuZXhwb3J0IGNvbnN0IFNlcXVlbGl6ZVNjb3BlRXJyb3IgPSBQa2cuU2VxdWVsaXplU2NvcGVFcnJvcjtcbmV4cG9ydCBjb25zdCBWYWxpZGF0aW9uRXJyb3IgPSBQa2cuVmFsaWRhdGlvbkVycm9yO1xuZXhwb3J0IGNvbnN0IFZhbGlkYXRpb25FcnJvckl0ZW0gPSBQa2cuVmFsaWRhdGlvbkVycm9ySXRlbTtcblxuZXhwb3J0IGNvbnN0IEFjY2Vzc0RlbmllZEVycm9yID0gUGtnLkFjY2Vzc0RlbmllZEVycm9yO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yID0gUGtnLkNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25SZWZ1c2VkRXJyb3IgPSBQa2cuQ29ubmVjdGlvblJlZnVzZWRFcnJvcjtcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uVGltZWRPdXRFcnJvciA9IFBrZy5Db25uZWN0aW9uVGltZWRPdXRFcnJvcjtcbmV4cG9ydCBjb25zdCBIb3N0Tm90Rm91bmRFcnJvciA9IFBrZy5Ib3N0Tm90Rm91bmRFcnJvcjtcbmV4cG9ydCBjb25zdCBIb3N0Tm90UmVhY2hhYmxlRXJyb3IgPSBQa2cuSG9zdE5vdFJlYWNoYWJsZUVycm9yO1xuZXhwb3J0IGNvbnN0IEludmFsaWRDb25uZWN0aW9uRXJyb3IgPSBQa2cuSW52YWxpZENvbm5lY3Rpb25FcnJvcjtcblxuZXhwb3J0IGNvbnN0IEV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvciA9IFBrZy5FeGNsdXNpb25Db25zdHJhaW50RXJyb3I7XG5leHBvcnQgY29uc3QgRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvciA9IFBrZy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yO1xuZXhwb3J0IGNvbnN0IFRpbWVvdXRFcnJvciA9IFBrZy5UaW1lb3V0RXJyb3I7XG5leHBvcnQgY29uc3QgVW5rbm93bkNvbnN0cmFpbnRFcnJvciA9IFBrZy5Vbmtub3duQ29uc3RyYWludEVycm9yO1xuXG5leHBvcnQgY29uc3QgVW5pcXVlQ29uc3RyYWludEVycm9yID0gUGtnLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcjtcblxuLy8gZXhwb3J0IHsgQmFzZUVycm9yIGFzIEVycm9yIH0gZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCBjb25zdCBFcnJvciA9IFBrZy5FcnJvcjtcblxuLy8gZXhwb3J0IHsgdXNlSW5mbGVjdGlvbiB9IGZyb20gJy4vbGliL3V0aWxzJztcbmV4cG9ydCBjb25zdCB1c2VJbmZsZWN0aW9uID0gUGtnLnVzZUluZmxlY3Rpb247XG5cbi8vIGV4cG9ydCB7IFV0aWxzLCBRdWVyeVR5cGVzLCBPcCwgVGFibGVIaW50cywgSW5kZXhIaW50cywgRGF0YVR5cGVzLCBEZWZlcnJhYmxlIH07XG5leHBvcnQgY29uc3QgVXRpbHMgPSBQa2cuVXRpbHM7XG5leHBvcnQgY29uc3QgUXVlcnlUeXBlcyA9IFBrZy5RdWVyeVR5cGVzO1xuZXhwb3J0IGNvbnN0IE9wID0gUGtnLk9wO1xuZXhwb3J0IGNvbnN0IFRhYmxlSGludHMgPSBQa2cuVGFibGVIaW50cztcbmV4cG9ydCBjb25zdCBJbmRleEhpbnRzID0gUGtnLkluZGV4SGludHM7XG5leHBvcnQgY29uc3QgRGF0YVR5cGVzID0gUGtnLkRhdGFUeXBlcztcbmV4cG9ydCBjb25zdCBEZWZlcnJhYmxlID0gUGtnLkRlZmVycmFibGU7XG5cbi8vIGV4cG9ydCB7IFZhbGlkYXRvciBhcyB2YWxpZGF0b3IgfSBmcm9tICcuL2xpYi91dGlscy92YWxpZGF0b3ItZXh0cmFzJztcbmV4cG9ydCBjb25zdCBWYWxpZGF0b3IgPSBQa2cuVmFsaWRhdG9yO1xuXG5leHBvcnQgY29uc3QgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbiA9IFBrZy5WYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luO1xuZXhwb3J0IGNvbnN0IFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlID0gUGtnLlZhbGlkYXRpb25FcnJvckl0ZW1UeXBlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/package.json":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"sequelize","description":"Sequelize is a promise-based Node.js ORM tool for Postgres, MySQL, MariaDB, SQLite, Microsoft SQL Server, Amazon Redshift and Snowflake’s Data Cloud. It features solid transaction support, relations, eager and lazy loading, read replication and more.","version":"6.37.7","funding":[{"type":"opencollective","url":"https://opencollective.com/sequelize"}],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"./lib/index.js","types":"./types/index.d.ts","type":"commonjs","exports":{".":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"./lib/*":{"types":"./types/*.d.ts","default":"./lib/*.js"},"./lib/errors":{"types":"./types/errors/index.d.ts","default":"./lib/errors/index.js"},"./package.json":"./package.json","./types/*":{"types":"./types/*.d.ts"}},"engines":{"node":">=10.0.0"},"files":["lib","types","index.js"],"license":"MIT","dependencies":{"@types/debug":"^4.1.8","@types/validator":"^13.7.17","debug":"^4.3.4","dottie":"^2.0.6","inflection":"^1.13.4","lodash":"^4.17.21","moment":"^2.29.4","moment-timezone":"^0.5.43","pg-connection-string":"^2.6.1","retry-as-promised":"^7.0.4","semver":"^7.5.4","sequelize-pool":"^7.1.0","toposort-class":"^1.0.1","uuid":"^8.3.2","validator":"^13.9.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^15.0.0","@commitlint/config-angular":"^15.0.0","@octokit/rest":"^18.12.0","@octokit/types":"^6.34.0","@types/chai":"^4.3.0","@types/lodash":"4.14.197","@types/mocha":"^9.0.0","@types/node":"^16.11.17","@types/sinon":"^10.0.6","@typescript-eslint/eslint-plugin":"^5.8.1","@typescript-eslint/parser":"^5.8.1","acorn":"^8.7.0","chai":"^4.3.7","chai-as-promised":"^7.1.1","chai-datetime":"^1.8.0","cheerio":"^1.0.0-rc.10","cls-hooked":"^4.2.2","copyfiles":"^2.4.1","cross-env":"^7.0.3","delay":"^5.0.0","esbuild":"0.14.3","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^8.5.0","eslint-plugin-jsdoc":"^37.4.0","eslint-plugin-mocha":"^9.0.0","expect-type":"^0.12.0","fast-glob":"^3.2.7","fs-jetpack":"^4.3.0","husky":"^7.0.4","ibm_db":"^2.8.1","js-combinatorics":"^0.6.1","lcov-result-merger":"^3.1.0","lint-staged":"^12.1.4","mariadb":"^2.5.5","markdownlint-cli":"^0.30.0","mocha":"^7.2.0","module-alias":"^2.2.2","mysql2":"^2.3.3","node-hook":"^1.0.0","nyc":"^15.1.0","oracledb":"^5.5.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.7.1","pg-hstore":"^2.3.4","rimraf":"^3.0.2","semantic-release":"^18.0.1","semantic-release-fail-on-major-bump":"^1.0.0","sinon":"^12.0.1","sinon-chai":"^3.7.0","snowflake-sdk":"^1.6.6","source-map-support":"^0.5.21","sqlite3":"^5.1.6","tedious":"8.3.0","typescript":"^4.5.4"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"ibm_db":{"optional":true},"snowflake-sdk":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true},"oracledb":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","pg","mssql","db2","ibm_db","sql","oracledb","sqlserver","snowflake","orm","nodejs","object relational mapper","database","db"],"commitlint":{"extends":["@commitlint/config-angular"],"rules":{"type-enum":[2,"always",["build","ci","docs","feat","fix","perf","refactor","revert","style","test","meta"]]}},"lint-staged":{"*!(d).[tj]s":"eslint"},"release":{"plugins":["@semantic-release/commit-analyzer","semantic-release-fail-on-major-bump","@semantic-release/release-notes-generator","@semantic-release/npm","@semantic-release/github"],"branches":["v6",{"name":"v6-beta","prerelease":"beta"}]},"publishConfig":{"tag":"latest"},"scripts":{"----------------------------------------- static analysis -----------------------------------------":"","lint":"eslint src test --quiet --fix","lint-docs":"markdownlint docs","test-typings":"tsc --noEmit --emitDeclarationOnly false && tsc -b test/tsconfig.json","----------------------------------------- documentation -------------------------------------------":"","docs":"sh docs.sh","----------------------------------------- tests ---------------------------------------------------":"","mocha":"mocha -r ./test/registerEsbuild","test-unit":"yarn mocha \\"test/unit/**/*.test.[tj]s\\"","test-integration":"yarn mocha \\"test/integration/**/*.test.[tj]s\\"","teaser":"node test/teaser.js","test":"npm run prepare && npm run test-typings && npm run teaser && npm run test-unit && npm run test-integration","----------------------------------------- coverage ------------------------------------------------":"","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/integration/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/unit/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","----------------------------------------- local test dbs ------------------------------------------":"","start-mariadb":"bash dev/mariadb/10.3/start.sh","start-mysql":"bash dev/mysql/5.7/start.sh","start-mysql-8":"bash dev/mysql/8.0/start.sh","start-postgres":"bash dev/postgres/10/start.sh","start-mssql":"bash dev/mssql/2019/start.sh","start-db2":"bash dev/db2/11.5/start.sh","start-oracle-oldest":"bash dev/oracle/18-slim/start.sh","start-oracle-latest":"bash dev/oracle/23-slim/start.sh","stop-mariadb":"bash dev/mariadb/10.3/stop.sh","stop-mysql":"bash dev/mysql/5.7/stop.sh","stop-mysql-8":"bash dev/mysql/8.0/stop.sh","stop-postgres":"bash dev/postgres/10/stop.sh","stop-mssql":"bash dev/mssql/2019/stop.sh","stop-db2":"bash dev/db2/11.5/stop.sh","stop-oracle-oldest":"bash dev/oracle/18-slim/stop.sh","stop-oracle-latest":"bash dev/oracle/23-slim/stop.sh","restart-mariadb":"npm run start-mariadb","restart-mysql":"npm run start-mysql","restart-postgres":"npm run start-postgres","restart-mssql":"npm run start-mssql","restart-db2":"npm run start-db2","restart-oracle-oldest":"npm run start-oracle-oldest","restart-oracle-latest":"npm run start-oracle-latest","----------------------------------------- local tests ---------------------------------------------":"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-db2":"cross-env DIALECT=db2 npm run test-unit","test-unit-snowflake":"cross-env DIALECT=snowflake npm run test-unit","test-unit-oracle":"cross-env DIALECT=oracle npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite && npm run test-unit-snowflake && npm run test-unit-db2 && npm run test-unit-oracle","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-db2":"cross-env DIALECT=db2 npm run test-integration","test-integration-snowflake":"cross-env DIALECT=snowflake npm run test-integration","test-integration-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm run test-integration","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-mssql":"cross-env DIALECT=mssql npm test","test-db2":"cross-env DIALECT=db2 npm test","test-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm test","----------------------------------------- development ---------------------------------------------":"","sscce":"node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb node sscce.js","sscce-mysql":"cross-env DIALECT=mysql node sscce.js","sscce-postgres":"cross-env DIALECT=postgres node sscce.js","sscce-postgres-native":"cross-env DIALECT=postgres-native node sscce.js","sscce-sqlite":"cross-env DIALECT=sqlite node sscce.js","sscce-mssql":"cross-env DIALECT=mssql node sscce.js","sscce-db2":"cross-env DIALECT=db2 node sscce.js","sscce-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 node sscce.js","prepare":"npm run build && husky install","build":"node ./build.js","---------------------------------------------------------------------------------------------------":""},"support":true}');

/***/ })

};
;